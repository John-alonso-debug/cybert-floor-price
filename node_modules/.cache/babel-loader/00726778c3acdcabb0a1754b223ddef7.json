{"ast":null,"code":"import { Subprovider } from '@bitski/provider-engine';\nimport { ProviderError } from '../errors/provider-error';\nimport { encodeNumber } from '../utils/parse-utils';\nexport class TypedDataSanitizerSubprovider extends Subprovider {\n  handleRequest(payload, next, end) {\n    if (payload.method === 'eth_signTypedData' || payload.method === 'eth_signTypedData_v3') {\n      try {\n        this.sanitizePayload(payload);\n      } catch (err) {\n        return end(err, undefined);\n      }\n    }\n\n    next();\n  }\n\n  sanitizePayload(payload) {\n    const typedData = this.extractTypedData(payload); // create map of types\n\n    const typeMapping = createTypeMapping(typedData); // sanitize domain\n\n    sanitizeDomain(typedData, typeMapping); // sanitize message\n\n    sanitizeMessage(typedData, typeMapping); // Re-assign typed data to params in case it has been parsed\n    // from a string.\n\n    payload.params[1] = typedData;\n  } // Given a JSON-RPC request, extract the typed data from the params\n\n\n  extractTypedData(payload) {\n    if (!payload.params || payload.params.length < 2) {\n      throw ProviderError.InvalidRequest('Missing params for typed data');\n    } // Some implementations pass typed data as a string\n\n\n    if (typeof payload.params[1] === 'string') {\n      return JSON.parse(payload.params[1]);\n    }\n\n    return payload.params[1];\n  }\n\n}\n/**\n * Sanitizes the `domain` values from the TypedData\n *\n * @param typedData TypedData payload\n * @param typeMapping a TypeMapping pre-generated from the TypedData\n */\n\nexport function sanitizeDomain(typedData, typeMapping) {\n  if (typeof typedData.domain === 'undefined') {\n    throw ProviderError.InvalidRequest('Missing domain for typed data');\n  }\n\n  if (typeof typedData.types.EIP712Domain === 'undefined') {\n    throw ProviderError.InvalidRequest('Missing type definition for domain');\n  }\n\n  sanitizeType('EIP712Domain', typedData.domain, typeMapping);\n}\n/**\n * Sanitizes the `message` values from the TypedData\n *\n * @param typedData TypedData payload\n * @param typeMapping a TypeMapping pre-generated from the TypedData\n */\n\nexport function sanitizeMessage(typedData, typeMapping) {\n  if (typeof typedData.message === 'undefined') {\n    throw ProviderError.InvalidRequest('Missing message in typed data');\n  }\n\n  if (typeof typedData.primaryType !== 'string') {\n    throw ProviderError.InvalidRequest('Missing primary type in typed data');\n  }\n\n  sanitizeType(typedData.primaryType, typedData.message, typeMapping);\n}\n/**\n * Recursively examines each value and determines type from the type mapping to\n * format and sanitize the value if needed.\n *\n * Currently this will only convert number values into a consistent hex format,\n * but in the future additional transformations may be necessary.\n *\n * @param typeName Name of the type we are starting from\n * @param values The root object containing the keys and values\n * @param typeMapping The type mapping that represents this data\n */\n\nexport function sanitizeType(typeName, values, typeMapping) {\n  // For each key in the 'values' object...\n  Object.keys(values).forEach(key => {\n    // Find the type name associated from the mapping\n    const type = typeMapping[typeName][key];\n\n    if (type === undefined) {// Do nothing if we don't have a type for this key\n    } else if (isArray(type)) {\n      // find the base type (left side of the brackets)\n      const baseType = type.split('[')[0];\n\n      if (typeof values[key].length === 'undefined') {\n        throw new TypeError(`Could not parse ${values[key]} for type ${type}. Expected array.`);\n      } // If base type is a struct, iterate through each instance of struct\n\n\n      if (typeMapping[baseType]) {\n        // values[key] is expected to be an array, where each element\n        // is an object that represents the struct named baseType.\n        values[key].forEach(itemValues => {\n          sanitizeType(baseType, itemValues, typeMapping);\n        });\n      } else if (baseType.startsWith('uint') || baseType.startsWith('int')) {\n        // If we have an array of primitive types that are numbers, we need to encode the numbers as hex\n        const numberValues = values[key].map(numberValue => {\n          return encodeNumber(numberValue, baseType, true);\n        });\n        values[key] = numberValues;\n      } else {// Do nothing with regular array values\n        // int8[], etc should already be strings\n      }\n    } else if (typeMapping[type]) {\n      // If type name is a custom struct, it should live in the type mapping\n      // We need to recursively check the custom types until we get to primitive values\n      sanitizeType(type, values[key], typeMapping);\n    } else if (type.startsWith('uint') || type.startsWith('int')) {\n      // Finally, if we have a primitive type that is a number, we need to encode the numbers as hex\n      values[key] = encodeNumber(values[key], type, true);\n    }\n  });\n}\n/**\n * Returns true if type name indicates that an array\n * @param typeName solidity type name\n */\n\nfunction isArray(typeName) {\n  if (typeName.includes('[') && typeName.includes(']')) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * Maps the type definitions from the typed data for easy look-up.\n * Top level keys represent the structs defined, while top-level values\n * are an object keyed by property with string values of the type name.\n *\n * For example:\n * {\n *    EIP712Domain: {\n *      name: 'string',\n *      version: 'string',\n *      chainId: 'uint256'\n *    }\n * }\n * @param typedData The TypedData to map\n * @returns {TypeMapping} the mapped data schema\n */\n\n\nexport function createTypeMapping(typedData) {\n  if (typeof typedData.types === 'undefined') {\n    throw ProviderError.InvalidRequest('Missing type definitions for typed data');\n  } // Go through each of the top level keys. These represent the custom types.\n\n\n  return Object.keys(typedData.types).reduce((acc, current) => {\n    // Reduce into a new single object\n    // Set a key for each type, reduce array of property names and types to an object\n    acc[current] = typedData.types[current].reduce((acc2, typeDef) => {\n      // For each type, set the key as the property name, and the value as the type name\n      acc2[typeDef.name] = typeDef.type;\n      return acc2;\n    }, {});\n    return acc;\n  }, {});\n}","map":{"version":3,"sources":["/Users/helen/fi/protocol-demo/frontend/node_modules/bitski-provider/dist/subproviders/typed-data.js"],"names":["Subprovider","ProviderError","encodeNumber","TypedDataSanitizerSubprovider","handleRequest","payload","next","end","method","sanitizePayload","err","undefined","typedData","extractTypedData","typeMapping","createTypeMapping","sanitizeDomain","sanitizeMessage","params","length","InvalidRequest","JSON","parse","domain","types","EIP712Domain","sanitizeType","message","primaryType","typeName","values","Object","keys","forEach","key","type","isArray","baseType","split","TypeError","itemValues","startsWith","numberValues","map","numberValue","includes","reduce","acc","current","acc2","typeDef","name"],"mappings":"AAAA,SAASA,WAAT,QAA4B,yBAA5B;AACA,SAASC,aAAT,QAA8B,0BAA9B;AACA,SAASC,YAAT,QAA6B,sBAA7B;AACA,OAAO,MAAMC,6BAAN,SAA4CH,WAA5C,CAAwD;AAC3DI,EAAAA,aAAa,CAACC,OAAD,EAAUC,IAAV,EAAgBC,GAAhB,EAAqB;AAC9B,QAAIF,OAAO,CAACG,MAAR,KAAmB,mBAAnB,IAA0CH,OAAO,CAACG,MAAR,KAAmB,sBAAjE,EAAyF;AACrF,UAAI;AACA,aAAKC,eAAL,CAAqBJ,OAArB;AACH,OAFD,CAGA,OAAOK,GAAP,EAAY;AACR,eAAOH,GAAG,CAACG,GAAD,EAAMC,SAAN,CAAV;AACH;AACJ;;AACDL,IAAAA,IAAI;AACP;;AACDG,EAAAA,eAAe,CAACJ,OAAD,EAAU;AACrB,UAAMO,SAAS,GAAG,KAAKC,gBAAL,CAAsBR,OAAtB,CAAlB,CADqB,CAErB;;AACA,UAAMS,WAAW,GAAGC,iBAAiB,CAACH,SAAD,CAArC,CAHqB,CAIrB;;AACAI,IAAAA,cAAc,CAACJ,SAAD,EAAYE,WAAZ,CAAd,CALqB,CAMrB;;AACAG,IAAAA,eAAe,CAACL,SAAD,EAAYE,WAAZ,CAAf,CAPqB,CAQrB;AACA;;AACAT,IAAAA,OAAO,CAACa,MAAR,CAAe,CAAf,IAAoBN,SAApB;AACH,GAvB0D,CAwB3D;;;AACAC,EAAAA,gBAAgB,CAACR,OAAD,EAAU;AACtB,QAAI,CAACA,OAAO,CAACa,MAAT,IAAmBb,OAAO,CAACa,MAAR,CAAeC,MAAf,GAAwB,CAA/C,EAAkD;AAC9C,YAAMlB,aAAa,CAACmB,cAAd,CAA6B,+BAA7B,CAAN;AACH,KAHqB,CAItB;;;AACA,QAAI,OAAOf,OAAO,CAACa,MAAR,CAAe,CAAf,CAAP,KAA6B,QAAjC,EAA2C;AACvC,aAAOG,IAAI,CAACC,KAAL,CAAWjB,OAAO,CAACa,MAAR,CAAe,CAAf,CAAX,CAAP;AACH;;AACD,WAAOb,OAAO,CAACa,MAAR,CAAe,CAAf,CAAP;AACH;;AAlC0D;AAoC/D;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASF,cAAT,CAAwBJ,SAAxB,EAAmCE,WAAnC,EAAgD;AACnD,MAAI,OAAOF,SAAS,CAACW,MAAjB,KAA4B,WAAhC,EAA6C;AACzC,UAAMtB,aAAa,CAACmB,cAAd,CAA6B,+BAA7B,CAAN;AACH;;AACD,MAAI,OAAOR,SAAS,CAACY,KAAV,CAAgBC,YAAvB,KAAwC,WAA5C,EAAyD;AACrD,UAAMxB,aAAa,CAACmB,cAAd,CAA6B,oCAA7B,CAAN;AACH;;AACDM,EAAAA,YAAY,CAAC,cAAD,EAAiBd,SAAS,CAACW,MAA3B,EAAmCT,WAAnC,CAAZ;AACH;AACD;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASG,eAAT,CAAyBL,SAAzB,EAAoCE,WAApC,EAAiD;AACpD,MAAI,OAAOF,SAAS,CAACe,OAAjB,KAA6B,WAAjC,EAA8C;AAC1C,UAAM1B,aAAa,CAACmB,cAAd,CAA6B,+BAA7B,CAAN;AACH;;AACD,MAAI,OAAOR,SAAS,CAACgB,WAAjB,KAAiC,QAArC,EAA+C;AAC3C,UAAM3B,aAAa,CAACmB,cAAd,CAA6B,oCAA7B,CAAN;AACH;;AACDM,EAAAA,YAAY,CAACd,SAAS,CAACgB,WAAX,EAAwBhB,SAAS,CAACe,OAAlC,EAA2Cb,WAA3C,CAAZ;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASY,YAAT,CAAsBG,QAAtB,EAAgCC,MAAhC,EAAwChB,WAAxC,EAAqD;AACxD;AACAiB,EAAAA,MAAM,CAACC,IAAP,CAAYF,MAAZ,EAAoBG,OAApB,CAA6BC,GAAD,IAAS;AACjC;AACA,UAAMC,IAAI,GAAGrB,WAAW,CAACe,QAAD,CAAX,CAAsBK,GAAtB,CAAb;;AACA,QAAIC,IAAI,KAAKxB,SAAb,EAAwB,CACpB;AACH,KAFD,MAGK,IAAIyB,OAAO,CAACD,IAAD,CAAX,EAAmB;AACpB;AACA,YAAME,QAAQ,GAAGF,IAAI,CAACG,KAAL,CAAW,GAAX,EAAgB,CAAhB,CAAjB;;AACA,UAAI,OAAOR,MAAM,CAACI,GAAD,CAAN,CAAYf,MAAnB,KAA8B,WAAlC,EAA+C;AAC3C,cAAM,IAAIoB,SAAJ,CAAe,mBAAkBT,MAAM,CAACI,GAAD,CAAM,aAAYC,IAAK,mBAA9D,CAAN;AACH,OALmB,CAMpB;;;AACA,UAAIrB,WAAW,CAACuB,QAAD,CAAf,EAA2B;AACvB;AACA;AACAP,QAAAA,MAAM,CAACI,GAAD,CAAN,CAAYD,OAAZ,CAAqBO,UAAD,IAAgB;AAChCd,UAAAA,YAAY,CAACW,QAAD,EAAWG,UAAX,EAAuB1B,WAAvB,CAAZ;AACH,SAFD;AAGH,OAND,MAOK,IAAIuB,QAAQ,CAACI,UAAT,CAAoB,MAApB,KAA+BJ,QAAQ,CAACI,UAAT,CAAoB,KAApB,CAAnC,EAA+D;AAChE;AACA,cAAMC,YAAY,GAAGZ,MAAM,CAACI,GAAD,CAAN,CAAYS,GAAZ,CAAiBC,WAAD,IAAiB;AAClD,iBAAO1C,YAAY,CAAC0C,WAAD,EAAcP,QAAd,EAAwB,IAAxB,CAAnB;AACH,SAFoB,CAArB;AAGAP,QAAAA,MAAM,CAACI,GAAD,CAAN,GAAcQ,YAAd;AACH,OANI,MAOA,CACD;AACA;AACH;AACJ,KAzBI,MA0BA,IAAI5B,WAAW,CAACqB,IAAD,CAAf,EAAuB;AACxB;AACA;AACAT,MAAAA,YAAY,CAACS,IAAD,EAAOL,MAAM,CAACI,GAAD,CAAb,EAAoBpB,WAApB,CAAZ;AACH,KAJI,MAKA,IAAIqB,IAAI,CAACM,UAAL,CAAgB,MAAhB,KAA2BN,IAAI,CAACM,UAAL,CAAgB,KAAhB,CAA/B,EAAuD;AACxD;AACAX,MAAAA,MAAM,CAACI,GAAD,CAAN,GAAchC,YAAY,CAAC4B,MAAM,CAACI,GAAD,CAAP,EAAcC,IAAd,EAAoB,IAApB,CAA1B;AACH;AACJ,GAzCD;AA0CH;AACD;AACA;AACA;AACA;;AACA,SAASC,OAAT,CAAiBP,QAAjB,EAA2B;AACvB,MAAIA,QAAQ,CAACgB,QAAT,CAAkB,GAAlB,KAA0BhB,QAAQ,CAACgB,QAAT,CAAkB,GAAlB,CAA9B,EAAsD;AAClD,WAAO,IAAP;AACH;;AACD,SAAO,KAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,SAAS9B,iBAAT,CAA2BH,SAA3B,EAAsC;AACzC,MAAI,OAAOA,SAAS,CAACY,KAAjB,KAA2B,WAA/B,EAA4C;AACxC,UAAMvB,aAAa,CAACmB,cAAd,CAA6B,yCAA7B,CAAN;AACH,GAHwC,CAIzC;;;AACA,SAAOW,MAAM,CAACC,IAAP,CAAYpB,SAAS,CAACY,KAAtB,EAA6BsB,MAA7B,CAAoC,CAACC,GAAD,EAAMC,OAAN,KAAkB;AACzD;AACA;AACAD,IAAAA,GAAG,CAACC,OAAD,CAAH,GAAepC,SAAS,CAACY,KAAV,CAAgBwB,OAAhB,EAAyBF,MAAzB,CAAgC,CAACG,IAAD,EAAOC,OAAP,KAAmB;AAC9D;AACAD,MAAAA,IAAI,CAACC,OAAO,CAACC,IAAT,CAAJ,GAAqBD,OAAO,CAACf,IAA7B;AACA,aAAOc,IAAP;AACH,KAJc,EAIZ,EAJY,CAAf;AAKA,WAAOF,GAAP;AACH,GATM,EASJ,EATI,CAAP;AAUH","sourcesContent":["import { Subprovider } from '@bitski/provider-engine';\nimport { ProviderError } from '../errors/provider-error';\nimport { encodeNumber } from '../utils/parse-utils';\nexport class TypedDataSanitizerSubprovider extends Subprovider {\n    handleRequest(payload, next, end) {\n        if (payload.method === 'eth_signTypedData' || payload.method === 'eth_signTypedData_v3') {\n            try {\n                this.sanitizePayload(payload);\n            }\n            catch (err) {\n                return end(err, undefined);\n            }\n        }\n        next();\n    }\n    sanitizePayload(payload) {\n        const typedData = this.extractTypedData(payload);\n        // create map of types\n        const typeMapping = createTypeMapping(typedData);\n        // sanitize domain\n        sanitizeDomain(typedData, typeMapping);\n        // sanitize message\n        sanitizeMessage(typedData, typeMapping);\n        // Re-assign typed data to params in case it has been parsed\n        // from a string.\n        payload.params[1] = typedData;\n    }\n    // Given a JSON-RPC request, extract the typed data from the params\n    extractTypedData(payload) {\n        if (!payload.params || payload.params.length < 2) {\n            throw ProviderError.InvalidRequest('Missing params for typed data');\n        }\n        // Some implementations pass typed data as a string\n        if (typeof payload.params[1] === 'string') {\n            return JSON.parse(payload.params[1]);\n        }\n        return payload.params[1];\n    }\n}\n/**\n * Sanitizes the `domain` values from the TypedData\n *\n * @param typedData TypedData payload\n * @param typeMapping a TypeMapping pre-generated from the TypedData\n */\nexport function sanitizeDomain(typedData, typeMapping) {\n    if (typeof typedData.domain === 'undefined') {\n        throw ProviderError.InvalidRequest('Missing domain for typed data');\n    }\n    if (typeof typedData.types.EIP712Domain === 'undefined') {\n        throw ProviderError.InvalidRequest('Missing type definition for domain');\n    }\n    sanitizeType('EIP712Domain', typedData.domain, typeMapping);\n}\n/**\n * Sanitizes the `message` values from the TypedData\n *\n * @param typedData TypedData payload\n * @param typeMapping a TypeMapping pre-generated from the TypedData\n */\nexport function sanitizeMessage(typedData, typeMapping) {\n    if (typeof typedData.message === 'undefined') {\n        throw ProviderError.InvalidRequest('Missing message in typed data');\n    }\n    if (typeof typedData.primaryType !== 'string') {\n        throw ProviderError.InvalidRequest('Missing primary type in typed data');\n    }\n    sanitizeType(typedData.primaryType, typedData.message, typeMapping);\n}\n/**\n * Recursively examines each value and determines type from the type mapping to\n * format and sanitize the value if needed.\n *\n * Currently this will only convert number values into a consistent hex format,\n * but in the future additional transformations may be necessary.\n *\n * @param typeName Name of the type we are starting from\n * @param values The root object containing the keys and values\n * @param typeMapping The type mapping that represents this data\n */\nexport function sanitizeType(typeName, values, typeMapping) {\n    // For each key in the 'values' object...\n    Object.keys(values).forEach((key) => {\n        // Find the type name associated from the mapping\n        const type = typeMapping[typeName][key];\n        if (type === undefined) {\n            // Do nothing if we don't have a type for this key\n        }\n        else if (isArray(type)) {\n            // find the base type (left side of the brackets)\n            const baseType = type.split('[')[0];\n            if (typeof values[key].length === 'undefined') {\n                throw new TypeError(`Could not parse ${values[key]} for type ${type}. Expected array.`);\n            }\n            // If base type is a struct, iterate through each instance of struct\n            if (typeMapping[baseType]) {\n                // values[key] is expected to be an array, where each element\n                // is an object that represents the struct named baseType.\n                values[key].forEach((itemValues) => {\n                    sanitizeType(baseType, itemValues, typeMapping);\n                });\n            }\n            else if (baseType.startsWith('uint') || baseType.startsWith('int')) {\n                // If we have an array of primitive types that are numbers, we need to encode the numbers as hex\n                const numberValues = values[key].map((numberValue) => {\n                    return encodeNumber(numberValue, baseType, true);\n                });\n                values[key] = numberValues;\n            }\n            else {\n                // Do nothing with regular array values\n                // int8[], etc should already be strings\n            }\n        }\n        else if (typeMapping[type]) {\n            // If type name is a custom struct, it should live in the type mapping\n            // We need to recursively check the custom types until we get to primitive values\n            sanitizeType(type, values[key], typeMapping);\n        }\n        else if (type.startsWith('uint') || type.startsWith('int')) {\n            // Finally, if we have a primitive type that is a number, we need to encode the numbers as hex\n            values[key] = encodeNumber(values[key], type, true);\n        }\n    });\n}\n/**\n * Returns true if type name indicates that an array\n * @param typeName solidity type name\n */\nfunction isArray(typeName) {\n    if (typeName.includes('[') && typeName.includes(']')) {\n        return true;\n    }\n    return false;\n}\n/**\n * Maps the type definitions from the typed data for easy look-up.\n * Top level keys represent the structs defined, while top-level values\n * are an object keyed by property with string values of the type name.\n *\n * For example:\n * {\n *    EIP712Domain: {\n *      name: 'string',\n *      version: 'string',\n *      chainId: 'uint256'\n *    }\n * }\n * @param typedData The TypedData to map\n * @returns {TypeMapping} the mapped data schema\n */\nexport function createTypeMapping(typedData) {\n    if (typeof typedData.types === 'undefined') {\n        throw ProviderError.InvalidRequest('Missing type definitions for typed data');\n    }\n    // Go through each of the top level keys. These represent the custom types.\n    return Object.keys(typedData.types).reduce((acc, current) => {\n        // Reduce into a new single object\n        // Set a key for each type, reduce array of property names and types to an object\n        acc[current] = typedData.types[current].reduce((acc2, typeDef) => {\n            // For each type, set the key as the property name, and the value as the type name\n            acc2[typeDef.name] = typeDef.type;\n            return acc2;\n        }, {});\n        return acc;\n    }, {});\n}\n"]},"metadata":{},"sourceType":"module"}