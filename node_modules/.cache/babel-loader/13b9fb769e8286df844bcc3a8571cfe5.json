{"ast":null,"code":"import { AuthenticationStatus, OAuthSignInMethod } from '../bitski';\nimport { AuthenticationError } from '../errors/authentication-error';\nimport { OAuthManager } from './oauth-manager';\nimport { TokenStore } from './token-store';\nimport { User } from './user';\nimport { UserStore } from './user-store';\nexport class OpenidAuthProvider {\n  constructor(clientId, redirectUri, additionalScopes, opts) {\n    opts = opts || {};\n    const settings = {\n      additionalScopes,\n      clientId,\n      redirectUri\n    };\n    Object.assign(settings, opts);\n    this.oauthManager = new OAuthManager(settings);\n    this.tokenStore = new TokenStore(clientId, opts.store);\n    this.userStore = new UserStore(clientId, opts.store);\n  }\n\n  get authStatus() {\n    if (this.tokenStore.currentToken) {\n      return AuthenticationStatus.Connected;\n    } else if (this.tokenStore.refreshToken) {\n      return AuthenticationStatus.Expired;\n    } else {\n      return AuthenticationStatus.NotConnected;\n    }\n  }\n\n  getAccessToken() {\n    if (this.tokenStore.currentToken) {\n      return Promise.resolve(this.tokenStore.currentToken);\n    }\n\n    if (this.tokenStore.refreshToken) {\n      return this.refreshAccessToken();\n    }\n\n    return Promise.reject(AuthenticationError.NotSignedIn());\n  }\n\n  getRefreshToken() {\n    if (this.tokenStore.refreshToken) {\n      return Promise.resolve(this.tokenStore.refreshToken);\n    } // Error: the user did not approve this app for offline access\n\n\n    if (this.tokenStore.currentToken) {\n      return Promise.reject(AuthenticationError.NoRefreshToken());\n    } // Error: the user is not signed in.\n\n\n    return Promise.reject(AuthenticationError.NotSignedIn());\n  }\n\n  invalidateToken() {\n    if (this.tokenStore.currentToken) {\n      this.tokenStore.invalidateCurrentToken();\n    }\n\n    if (this.signOutCallback) {\n      this.signOutCallback();\n    }\n\n    return Promise.resolve();\n  }\n\n  refreshAccessToken() {\n    if (this.tokenStore.refreshToken) {\n      return this.oauthManager.refreshAccessToken(this.tokenStore.refreshToken).then(tokenResponse => {\n        this.tokenStore.persistTokenResponse(tokenResponse);\n        return tokenResponse.accessToken;\n      }).catch(error => {\n        // If we can't renew, we likely have bad data\n        this.tokenStore.clear();\n        this.userStore.clear();\n        throw error;\n      });\n    }\n\n    return Promise.reject(AuthenticationError.NoRefreshToken());\n  }\n\n  signIn(method, opts) {\n    let promise;\n\n    switch (method) {\n      case OAuthSignInMethod.Redirect:\n        promise = this.oauthManager.signInRedirect(opts);\n        break;\n\n      case OAuthSignInMethod.Silent:\n        return Promise.reject(AuthenticationError.UnsupportedAuthenticationMethod());\n\n      default:\n        promise = this.oauthManager.signInPopup(opts);\n        break;\n    }\n\n    return promise.then(tokenResponse => {\n      this.tokenStore.persistTokenResponse(tokenResponse);\n      return this.loadUser();\n    });\n  }\n\n  connect() {\n    return this.refreshAccessToken().then(() => {\n      return this.loadUser();\n    });\n  }\n\n  getUser() {\n    return this.getOrFetchUser();\n  }\n\n  signInOrConnect(signInMethod = OAuthSignInMethod.Popup, opts) {\n    switch (this.authStatus) {\n      case AuthenticationStatus.Connected:\n        return this.loadUser();\n\n      case AuthenticationStatus.Expired:\n        return this.connect();\n\n      case AuthenticationStatus.NotConnected:\n        return this.signIn(signInMethod, opts);\n    }\n  }\n\n  redirectCallback() {\n    return this.oauthManager.redirectCallback().then(tokenResponse => {\n      this.tokenStore.persistTokenResponse(tokenResponse);\n      return this.loadUser();\n    });\n  }\n\n  signOut() {\n    this.tokenStore.clear();\n    this.userStore.clear(); // Call the sign out callback if one has been provided\n\n    if (this.signOutCallback) {\n      this.signOutCallback();\n    } // We don't currently have the ability to invalidate access tokens, so for now simply resolve.\n    // Down the road this may perform a network request to invalidate.\n\n\n    return Promise.resolve();\n  }\n\n  getOrFetchUser() {\n    const currentUser = this.userStore.currentUser;\n\n    if (currentUser) {\n      return Promise.resolve(currentUser);\n    }\n\n    return this.loadUser();\n  }\n\n  loadUser() {\n    return this.getAccessToken().then(accessToken => {\n      return this.oauthManager.requestUserInfo(accessToken);\n    }).then(json => {\n      return User.fromJson(json);\n    }).then(user => {\n      this.userStore.set(user);\n      return user;\n    });\n  }\n\n}","map":{"version":3,"sources":["/Users/helen/fi/protocol-demo/frontend/node_modules/bitski/dist/esm/auth/openid-auth-provider.js"],"names":["AuthenticationStatus","OAuthSignInMethod","AuthenticationError","OAuthManager","TokenStore","User","UserStore","OpenidAuthProvider","constructor","clientId","redirectUri","additionalScopes","opts","settings","Object","assign","oauthManager","tokenStore","store","userStore","authStatus","currentToken","Connected","refreshToken","Expired","NotConnected","getAccessToken","Promise","resolve","refreshAccessToken","reject","NotSignedIn","getRefreshToken","NoRefreshToken","invalidateToken","invalidateCurrentToken","signOutCallback","then","tokenResponse","persistTokenResponse","accessToken","catch","error","clear","signIn","method","promise","Redirect","signInRedirect","Silent","UnsupportedAuthenticationMethod","signInPopup","loadUser","connect","getUser","getOrFetchUser","signInOrConnect","signInMethod","Popup","redirectCallback","signOut","currentUser","requestUserInfo","json","fromJson","user","set"],"mappings":"AAAA,SAASA,oBAAT,EAA+BC,iBAA/B,QAAwD,WAAxD;AACA,SAASC,mBAAT,QAAoC,gCAApC;AACA,SAASC,YAAT,QAA6B,iBAA7B;AACA,SAASC,UAAT,QAA2B,eAA3B;AACA,SAASC,IAAT,QAAqB,QAArB;AACA,SAASC,SAAT,QAA0B,cAA1B;AACA,OAAO,MAAMC,kBAAN,CAAyB;AAC5BC,EAAAA,WAAW,CAACC,QAAD,EAAWC,WAAX,EAAwBC,gBAAxB,EAA0CC,IAA1C,EAAgD;AACvDA,IAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;AACA,UAAMC,QAAQ,GAAG;AACbF,MAAAA,gBADa;AAEbF,MAAAA,QAFa;AAGbC,MAAAA;AAHa,KAAjB;AAKAI,IAAAA,MAAM,CAACC,MAAP,CAAcF,QAAd,EAAwBD,IAAxB;AACA,SAAKI,YAAL,GAAoB,IAAIb,YAAJ,CAAiBU,QAAjB,CAApB;AACA,SAAKI,UAAL,GAAkB,IAAIb,UAAJ,CAAeK,QAAf,EAAyBG,IAAI,CAACM,KAA9B,CAAlB;AACA,SAAKC,SAAL,GAAiB,IAAIb,SAAJ,CAAcG,QAAd,EAAwBG,IAAI,CAACM,KAA7B,CAAjB;AACH;;AACa,MAAVE,UAAU,GAAG;AACb,QAAI,KAAKH,UAAL,CAAgBI,YAApB,EAAkC;AAC9B,aAAOrB,oBAAoB,CAACsB,SAA5B;AACH,KAFD,MAGK,IAAI,KAAKL,UAAL,CAAgBM,YAApB,EAAkC;AACnC,aAAOvB,oBAAoB,CAACwB,OAA5B;AACH,KAFI,MAGA;AACD,aAAOxB,oBAAoB,CAACyB,YAA5B;AACH;AACJ;;AACDC,EAAAA,cAAc,GAAG;AACb,QAAI,KAAKT,UAAL,CAAgBI,YAApB,EAAkC;AAC9B,aAAOM,OAAO,CAACC,OAAR,CAAgB,KAAKX,UAAL,CAAgBI,YAAhC,CAAP;AACH;;AACD,QAAI,KAAKJ,UAAL,CAAgBM,YAApB,EAAkC;AAC9B,aAAO,KAAKM,kBAAL,EAAP;AACH;;AACD,WAAOF,OAAO,CAACG,MAAR,CAAe5B,mBAAmB,CAAC6B,WAApB,EAAf,CAAP;AACH;;AACDC,EAAAA,eAAe,GAAG;AACd,QAAI,KAAKf,UAAL,CAAgBM,YAApB,EAAkC;AAC9B,aAAOI,OAAO,CAACC,OAAR,CAAgB,KAAKX,UAAL,CAAgBM,YAAhC,CAAP;AACH,KAHa,CAId;;;AACA,QAAI,KAAKN,UAAL,CAAgBI,YAApB,EAAkC;AAC9B,aAAOM,OAAO,CAACG,MAAR,CAAe5B,mBAAmB,CAAC+B,cAApB,EAAf,CAAP;AACH,KAPa,CAQd;;;AACA,WAAON,OAAO,CAACG,MAAR,CAAe5B,mBAAmB,CAAC6B,WAApB,EAAf,CAAP;AACH;;AACDG,EAAAA,eAAe,GAAG;AACd,QAAI,KAAKjB,UAAL,CAAgBI,YAApB,EAAkC;AAC9B,WAAKJ,UAAL,CAAgBkB,sBAAhB;AACH;;AACD,QAAI,KAAKC,eAAT,EAA0B;AACtB,WAAKA,eAAL;AACH;;AACD,WAAOT,OAAO,CAACC,OAAR,EAAP;AACH;;AACDC,EAAAA,kBAAkB,GAAG;AACjB,QAAI,KAAKZ,UAAL,CAAgBM,YAApB,EAAkC;AAC9B,aAAO,KAAKP,YAAL,CAAkBa,kBAAlB,CAAqC,KAAKZ,UAAL,CAAgBM,YAArD,EAAmEc,IAAnE,CAAyEC,aAAD,IAAmB;AAC9F,aAAKrB,UAAL,CAAgBsB,oBAAhB,CAAqCD,aAArC;AACA,eAAOA,aAAa,CAACE,WAArB;AACH,OAHM,EAGJC,KAHI,CAGGC,KAAD,IAAW;AAChB;AACA,aAAKzB,UAAL,CAAgB0B,KAAhB;AACA,aAAKxB,SAAL,CAAewB,KAAf;AACA,cAAMD,KAAN;AACH,OARM,CAAP;AASH;;AACD,WAAOf,OAAO,CAACG,MAAR,CAAe5B,mBAAmB,CAAC+B,cAApB,EAAf,CAAP;AACH;;AACDW,EAAAA,MAAM,CAACC,MAAD,EAASjC,IAAT,EAAe;AACjB,QAAIkC,OAAJ;;AACA,YAAQD,MAAR;AACI,WAAK5C,iBAAiB,CAAC8C,QAAvB;AACID,QAAAA,OAAO,GAAG,KAAK9B,YAAL,CAAkBgC,cAAlB,CAAiCpC,IAAjC,CAAV;AACA;;AACJ,WAAKX,iBAAiB,CAACgD,MAAvB;AACI,eAAOtB,OAAO,CAACG,MAAR,CAAe5B,mBAAmB,CAACgD,+BAApB,EAAf,CAAP;;AACJ;AACIJ,QAAAA,OAAO,GAAG,KAAK9B,YAAL,CAAkBmC,WAAlB,CAA8BvC,IAA9B,CAAV;AACA;AARR;;AAUA,WAAOkC,OAAO,CAACT,IAAR,CAAcC,aAAD,IAAmB;AACnC,WAAKrB,UAAL,CAAgBsB,oBAAhB,CAAqCD,aAArC;AACA,aAAO,KAAKc,QAAL,EAAP;AACH,KAHM,CAAP;AAIH;;AACDC,EAAAA,OAAO,GAAG;AACN,WAAO,KAAKxB,kBAAL,GAA0BQ,IAA1B,CAA+B,MAAM;AACxC,aAAO,KAAKe,QAAL,EAAP;AACH,KAFM,CAAP;AAGH;;AACDE,EAAAA,OAAO,GAAG;AACN,WAAO,KAAKC,cAAL,EAAP;AACH;;AACDC,EAAAA,eAAe,CAACC,YAAY,GAAGxD,iBAAiB,CAACyD,KAAlC,EAAyC9C,IAAzC,EAA+C;AAC1D,YAAQ,KAAKQ,UAAb;AACI,WAAKpB,oBAAoB,CAACsB,SAA1B;AACI,eAAO,KAAK8B,QAAL,EAAP;;AACJ,WAAKpD,oBAAoB,CAACwB,OAA1B;AACI,eAAO,KAAK6B,OAAL,EAAP;;AACJ,WAAKrD,oBAAoB,CAACyB,YAA1B;AACI,eAAO,KAAKmB,MAAL,CAAYa,YAAZ,EAA0B7C,IAA1B,CAAP;AANR;AAQH;;AACD+C,EAAAA,gBAAgB,GAAG;AACf,WAAO,KAAK3C,YAAL,CAAkB2C,gBAAlB,GAAqCtB,IAArC,CAA2CC,aAAD,IAAmB;AAChE,WAAKrB,UAAL,CAAgBsB,oBAAhB,CAAqCD,aAArC;AACA,aAAO,KAAKc,QAAL,EAAP;AACH,KAHM,CAAP;AAIH;;AACDQ,EAAAA,OAAO,GAAG;AACN,SAAK3C,UAAL,CAAgB0B,KAAhB;AACA,SAAKxB,SAAL,CAAewB,KAAf,GAFM,CAGN;;AACA,QAAI,KAAKP,eAAT,EAA0B;AACtB,WAAKA,eAAL;AACH,KANK,CAON;AACA;;;AACA,WAAOT,OAAO,CAACC,OAAR,EAAP;AACH;;AACD2B,EAAAA,cAAc,GAAG;AACb,UAAMM,WAAW,GAAG,KAAK1C,SAAL,CAAe0C,WAAnC;;AACA,QAAIA,WAAJ,EAAiB;AACb,aAAOlC,OAAO,CAACC,OAAR,CAAgBiC,WAAhB,CAAP;AACH;;AACD,WAAO,KAAKT,QAAL,EAAP;AACH;;AACDA,EAAAA,QAAQ,GAAG;AACP,WAAO,KAAK1B,cAAL,GAAsBW,IAAtB,CAA4BG,WAAD,IAAiB;AAC/C,aAAO,KAAKxB,YAAL,CAAkB8C,eAAlB,CAAkCtB,WAAlC,CAAP;AACH,KAFM,EAEJH,IAFI,CAEE0B,IAAD,IAAU;AACd,aAAO1D,IAAI,CAAC2D,QAAL,CAAcD,IAAd,CAAP;AACH,KAJM,EAIJ1B,IAJI,CAIE4B,IAAD,IAAU;AACd,WAAK9C,SAAL,CAAe+C,GAAf,CAAmBD,IAAnB;AACA,aAAOA,IAAP;AACH,KAPM,CAAP;AAQH;;AAvI2B","sourcesContent":["import { AuthenticationStatus, OAuthSignInMethod } from '../bitski';\nimport { AuthenticationError } from '../errors/authentication-error';\nimport { OAuthManager } from './oauth-manager';\nimport { TokenStore } from './token-store';\nimport { User } from './user';\nimport { UserStore } from './user-store';\nexport class OpenidAuthProvider {\n    constructor(clientId, redirectUri, additionalScopes, opts) {\n        opts = opts || {};\n        const settings = {\n            additionalScopes,\n            clientId,\n            redirectUri,\n        };\n        Object.assign(settings, opts);\n        this.oauthManager = new OAuthManager(settings);\n        this.tokenStore = new TokenStore(clientId, opts.store);\n        this.userStore = new UserStore(clientId, opts.store);\n    }\n    get authStatus() {\n        if (this.tokenStore.currentToken) {\n            return AuthenticationStatus.Connected;\n        }\n        else if (this.tokenStore.refreshToken) {\n            return AuthenticationStatus.Expired;\n        }\n        else {\n            return AuthenticationStatus.NotConnected;\n        }\n    }\n    getAccessToken() {\n        if (this.tokenStore.currentToken) {\n            return Promise.resolve(this.tokenStore.currentToken);\n        }\n        if (this.tokenStore.refreshToken) {\n            return this.refreshAccessToken();\n        }\n        return Promise.reject(AuthenticationError.NotSignedIn());\n    }\n    getRefreshToken() {\n        if (this.tokenStore.refreshToken) {\n            return Promise.resolve(this.tokenStore.refreshToken);\n        }\n        // Error: the user did not approve this app for offline access\n        if (this.tokenStore.currentToken) {\n            return Promise.reject(AuthenticationError.NoRefreshToken());\n        }\n        // Error: the user is not signed in.\n        return Promise.reject(AuthenticationError.NotSignedIn());\n    }\n    invalidateToken() {\n        if (this.tokenStore.currentToken) {\n            this.tokenStore.invalidateCurrentToken();\n        }\n        if (this.signOutCallback) {\n            this.signOutCallback();\n        }\n        return Promise.resolve();\n    }\n    refreshAccessToken() {\n        if (this.tokenStore.refreshToken) {\n            return this.oauthManager.refreshAccessToken(this.tokenStore.refreshToken).then((tokenResponse) => {\n                this.tokenStore.persistTokenResponse(tokenResponse);\n                return tokenResponse.accessToken;\n            }).catch((error) => {\n                // If we can't renew, we likely have bad data\n                this.tokenStore.clear();\n                this.userStore.clear();\n                throw error;\n            });\n        }\n        return Promise.reject(AuthenticationError.NoRefreshToken());\n    }\n    signIn(method, opts) {\n        let promise;\n        switch (method) {\n            case OAuthSignInMethod.Redirect:\n                promise = this.oauthManager.signInRedirect(opts);\n                break;\n            case OAuthSignInMethod.Silent:\n                return Promise.reject(AuthenticationError.UnsupportedAuthenticationMethod());\n            default:\n                promise = this.oauthManager.signInPopup(opts);\n                break;\n        }\n        return promise.then((tokenResponse) => {\n            this.tokenStore.persistTokenResponse(tokenResponse);\n            return this.loadUser();\n        });\n    }\n    connect() {\n        return this.refreshAccessToken().then(() => {\n            return this.loadUser();\n        });\n    }\n    getUser() {\n        return this.getOrFetchUser();\n    }\n    signInOrConnect(signInMethod = OAuthSignInMethod.Popup, opts) {\n        switch (this.authStatus) {\n            case AuthenticationStatus.Connected:\n                return this.loadUser();\n            case AuthenticationStatus.Expired:\n                return this.connect();\n            case AuthenticationStatus.NotConnected:\n                return this.signIn(signInMethod, opts);\n        }\n    }\n    redirectCallback() {\n        return this.oauthManager.redirectCallback().then((tokenResponse) => {\n            this.tokenStore.persistTokenResponse(tokenResponse);\n            return this.loadUser();\n        });\n    }\n    signOut() {\n        this.tokenStore.clear();\n        this.userStore.clear();\n        // Call the sign out callback if one has been provided\n        if (this.signOutCallback) {\n            this.signOutCallback();\n        }\n        // We don't currently have the ability to invalidate access tokens, so for now simply resolve.\n        // Down the road this may perform a network request to invalidate.\n        return Promise.resolve();\n    }\n    getOrFetchUser() {\n        const currentUser = this.userStore.currentUser;\n        if (currentUser) {\n            return Promise.resolve(currentUser);\n        }\n        return this.loadUser();\n    }\n    loadUser() {\n        return this.getAccessToken().then((accessToken) => {\n            return this.oauthManager.requestUserInfo(accessToken);\n        }).then((json) => {\n            return User.fromJson(json);\n        }).then((user) => {\n            this.userStore.set(user);\n            return user;\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"module"}