{"ast":null,"code":"import { Subprovider } from '@bitski/provider-engine';\nimport asyncify from 'async/asyncify';\nimport retry from 'async/retry';\nimport waterfall from 'async/waterfall';\nimport fetch from 'cross-fetch';\nimport JsonRpcError from 'json-rpc-error';\nimport promiseToCallback from 'promise-to-callback';\nconst RETRIABLE_ERRORS = [// ignore server overload errors\n'Gateway timeout', 'ETIMEDOUT', // ignore server sent html error pages\n// or truncated json responses\n'SyntaxError'];\nconst MATCHING_METHODS = ['eth_getBlockByNumber', 'eth_blockNumber', 'net_Version', 'eth_getLogs'];\nexport class RestFetchSubprovider extends Subprovider {\n  constructor(opts) {\n    super();\n    this.rpcUrl = opts.rpcUrl;\n    this.defaultHeaders = opts.defaultHeaders;\n    this.originHttpHeaderKey = opts.originHttpHeaderKey;\n  }\n\n  handleRequest(payload, next, end) {\n    if (MATCHING_METHODS.includes(payload.method)) {\n      this.handleRestRequest(payload, end);\n    } else {\n      next();\n    }\n  }\n\n  handleRestRequest(payload, end) {\n    const originDomain = payload.origin;\n    const query = payload.params.length > 0 ? `?params=${encodeURIComponent(JSON.stringify(payload.params))}` : '';\n    const url = `${this.rpcUrl}/${payload.method}${query}`;\n    const reqParams = {\n      method: 'GET',\n      headers: Object.assign({\n        'Accept': 'application/json',\n        'Content-Type': 'application/json'\n      }, this.defaultHeaders),\n      credentials: 'omit'\n    };\n\n    if (this.originHttpHeaderKey && originDomain) {\n      reqParams.headers[this.originHttpHeaderKey] = originDomain;\n    }\n\n    retry({\n      times: 5,\n      interval: 1000,\n      errorFilter: isErrorRetriable\n    }, cb => this._submitRequest(url, reqParams, cb), (err, result) => {\n      // ends on retriable error\n      if (err && isErrorRetriable(err)) {\n        const errMsg = `FetchSubprovider - cannot complete request. All retries exhausted.\\nOriginal Error:\\n${err.toString()}\\n\\n`;\n        const retriesExhaustedErr = new Error(errMsg);\n        return end(retriesExhaustedErr);\n      } // otherwise continue normally\n\n\n      return end(err, result);\n    });\n  }\n\n  _submitRequest(targetUrl, reqParams, done) {\n    promiseToCallback(fetch(targetUrl, reqParams))((err, res) => {\n      if (err) {\n        return done(err);\n      } // continue parsing result\n\n\n      waterfall([checkForHttpErrors, // buffer body\n      cb => promiseToCallback(res.text())(cb), // parse body\n      asyncify(rawBody => JSON.parse(rawBody)), parseResponse], done);\n\n      function checkForHttpErrors(cb) {\n        // check for errors\n        switch (res.status) {\n          case 405:\n            return cb(new JsonRpcError.MethodNotFound());\n\n          case 418:\n            return cb(createRatelimitError());\n\n          case 503:\n          case 504:\n            return cb(createTimeoutError());\n\n          default:\n            return cb();\n        }\n      }\n\n      function parseResponse(body, cb) {\n        // check for error code\n        if (res.status !== 200) {\n          return cb(new JsonRpcError.InternalError(body));\n        }\n\n        cb(null, body);\n      }\n    });\n  }\n\n}\n\nfunction isErrorRetriable(err) {\n  const errMsg = err.toString();\n  return RETRIABLE_ERRORS.some(phrase => errMsg.includes(phrase));\n}\n\nfunction createRatelimitError() {\n  const msg = 'Request is being rate limited.';\n  const err = new Error(msg);\n  return new JsonRpcError.InternalError(err);\n}\n\nfunction createTimeoutError() {\n  let msg = 'Gateway timeout. The request took too long to process. ';\n  msg += 'This can happen when querying logs over too wide a block range.';\n  const err = new Error(msg);\n  return new JsonRpcError.InternalError(err);\n}","map":{"version":3,"sources":["/Users/helen/fi/protocol-demo/frontend/node_modules/bitski/dist/esm/subproviders/rest-fetch.js"],"names":["Subprovider","asyncify","retry","waterfall","fetch","JsonRpcError","promiseToCallback","RETRIABLE_ERRORS","MATCHING_METHODS","RestFetchSubprovider","constructor","opts","rpcUrl","defaultHeaders","originHttpHeaderKey","handleRequest","payload","next","end","includes","method","handleRestRequest","originDomain","origin","query","params","length","encodeURIComponent","JSON","stringify","url","reqParams","headers","Object","assign","credentials","times","interval","errorFilter","isErrorRetriable","cb","_submitRequest","err","result","errMsg","toString","retriesExhaustedErr","Error","targetUrl","done","res","checkForHttpErrors","text","rawBody","parse","parseResponse","status","MethodNotFound","createRatelimitError","createTimeoutError","body","InternalError","some","phrase","msg"],"mappings":"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","sourcesContent":["import { Subprovider } from '@bitski/provider-engine';\nimport asyncify from 'async/asyncify';\nimport retry from 'async/retry';\nimport waterfall from 'async/waterfall';\nimport fetch from 'cross-fetch';\nimport JsonRpcError from 'json-rpc-error';\nimport promiseToCallback from 'promise-to-callback';\nconst RETRIABLE_ERRORS = [\n    // ignore server overload errors\n    'Gateway timeout',\n    'ETIMEDOUT',\n    // ignore server sent html error pages\n    // or truncated json responses\n    'SyntaxError',\n];\nconst MATCHING_METHODS = ['eth_getBlockByNumber', 'eth_blockNumber', 'net_Version', 'eth_getLogs'];\nexport class RestFetchSubprovider extends Subprovider {\n    constructor(opts) {\n        super();\n        this.rpcUrl = opts.rpcUrl;\n        this.defaultHeaders = opts.defaultHeaders;\n        this.originHttpHeaderKey = opts.originHttpHeaderKey;\n    }\n    handleRequest(payload, next, end) {\n        if (MATCHING_METHODS.includes(payload.method)) {\n            this.handleRestRequest(payload, end);\n        }\n        else {\n            next();\n        }\n    }\n    handleRestRequest(payload, end) {\n        const originDomain = payload.origin;\n        const query = payload.params.length > 0 ? `?params=${encodeURIComponent(JSON.stringify(payload.params))}` : '';\n        const url = `${this.rpcUrl}/${payload.method}${query}`;\n        const reqParams = {\n            method: 'GET',\n            headers: Object.assign({\n                'Accept': 'application/json',\n                'Content-Type': 'application/json',\n            }, this.defaultHeaders),\n            credentials: 'omit',\n        };\n        if (this.originHttpHeaderKey && originDomain) {\n            reqParams.headers[this.originHttpHeaderKey] = originDomain;\n        }\n        retry({\n            times: 5,\n            interval: 1000,\n            errorFilter: isErrorRetriable,\n        }, (cb) => this._submitRequest(url, reqParams, cb), (err, result) => {\n            // ends on retriable error\n            if (err && isErrorRetriable(err)) {\n                const errMsg = `FetchSubprovider - cannot complete request. All retries exhausted.\\nOriginal Error:\\n${err.toString()}\\n\\n`;\n                const retriesExhaustedErr = new Error(errMsg);\n                return end(retriesExhaustedErr);\n            }\n            // otherwise continue normally\n            return end(err, result);\n        });\n    }\n    _submitRequest(targetUrl, reqParams, done) {\n        promiseToCallback(fetch(targetUrl, reqParams))((err, res) => {\n            if (err) {\n                return done(err);\n            }\n            // continue parsing result\n            waterfall([\n                checkForHttpErrors,\n                // buffer body\n                (cb) => promiseToCallback(res.text())(cb),\n                // parse body\n                asyncify((rawBody) => JSON.parse(rawBody)),\n                parseResponse,\n            ], done);\n            function checkForHttpErrors(cb) {\n                // check for errors\n                switch (res.status) {\n                    case 405:\n                        return cb(new JsonRpcError.MethodNotFound());\n                    case 418:\n                        return cb(createRatelimitError());\n                    case 503:\n                    case 504:\n                        return cb(createTimeoutError());\n                    default:\n                        return cb();\n                }\n            }\n            function parseResponse(body, cb) {\n                // check for error code\n                if (res.status !== 200) {\n                    return cb(new JsonRpcError.InternalError(body));\n                }\n                cb(null, body);\n            }\n        });\n    }\n}\nfunction isErrorRetriable(err) {\n    const errMsg = err.toString();\n    return RETRIABLE_ERRORS.some((phrase) => errMsg.includes(phrase));\n}\nfunction createRatelimitError() {\n    const msg = 'Request is being rate limited.';\n    const err = new Error(msg);\n    return new JsonRpcError.InternalError(err);\n}\nfunction createTimeoutError() {\n    let msg = 'Gateway timeout. The request took too long to process. ';\n    msg += 'This can happen when querying logs over too wide a block range.';\n    const err = new Error(msg);\n    return new JsonRpcError.InternalError(err);\n}\n"]},"metadata":{},"sourceType":"module"}