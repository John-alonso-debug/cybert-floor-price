{"ast":null,"code":"import BN from 'bn.js';\n/**\n * parseNumber\n * Converts a value that represents a number into a hex value.\n * @param arg {string | number | BN} A number value to convert to hex.\n * Can be a regular number, base-10 string, base-16 string, or BN instance.\n * @returns {BN} BN instance representing the number\n *\n * (Adapted from ethereumjs-abi)\n */\n\nfunction parseNumber(arg) {\n  const type = typeof arg;\n\n  if (type === 'string') {\n    if (arg.substr(0, 2) === '0x') {\n      return new BN(arg.substr(2), 16);\n    } else {\n      return new BN(arg, 10);\n    }\n  } else if (type === 'number') {\n    return new BN(arg);\n  } else if (arg.toArray) {\n    // assume this is a BN for the moment, replace with BN.isBN soon\n    return arg;\n  } else {\n    throw new Error('Argument is not a number');\n  }\n}\n\nfunction parseBitWidth(type, offset) {\n  // default to 256 bit if not specified\n  let size = 256; // If type string is longer than offset, parse bits from the type string\n\n  if (type.length > offset) {\n    size = parseInt(type.substr(offset), 10);\n  } // bit width must be a multiple of 8, and in the range 8-256.\n\n\n  if (size % 8 || size < 8 || size > 256) {\n    throw new Error(`Invalid bit width ${type}`);\n  }\n\n  return size;\n}\n/**\n * encodeNumber\n * Takes a decimal string, hex string, regular number, or BN instance and returns a hex string in the specified format.\n * Typically these conversions are done in web3, but until web3 adds direct support, this is necessary for normalizing\n * numbers eth_signTypedData payloads.\n * @param num The value to convert\n * @param type The solidity ABI type to format the data as (eg. uint256, int8, etc). Only supports int and uint variants.\n * @param compact boolean (default false). Whether to use compact encoding for uints, or pad with zeroes.\n * @returns {string} A hex string formatted as the specified type.\n */\n\n\nexport function encodeNumber(num, type, compact = false) {\n  if (type.startsWith('uint')) {\n    const size = parseBitWidth(type, 4); // start after 'uint'\n\n    const length = size / 4; // length in characters for the string. hex is 1 character for 4 bits.\n\n    const parsed = parseNumber(num); // uint can never be negative\n\n    if (parsed.isNeg()) {\n      throw new Error('Supplied uint is negative');\n    } // Convert to hex, and prepend 0x\n\n\n    if (compact) {\n      return '0x' + parsed.toString(16);\n    }\n\n    return '0x' + parsed.toString(16, length);\n  } else if (type.startsWith('int')) {\n    // bit width must be a multiple of 8, and in the range 8-256.\n    const size = parseBitWidth(type, 3);\n    const length = size / 4; // length in characters for the string. hex is 1 character for 4 bits.\n\n    const parsed = parseNumber(num); // Convert to twos complement at the bit size from the type, then convert value to hex\n\n    return '0x' + parsed.toTwos(size).toString(16, length);\n  } else {\n    throw new Error('Invalid type passed');\n  }\n}","map":{"version":3,"sources":["/Users/helen/fi/protocol-demo/frontend/node_modules/bitski-provider/dist/utils/parse-utils.js"],"names":["BN","parseNumber","arg","type","substr","toArray","Error","parseBitWidth","offset","size","length","parseInt","encodeNumber","num","compact","startsWith","parsed","isNeg","toString","toTwos"],"mappings":"AAAA,OAAOA,EAAP,MAAe,OAAf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,WAAT,CAAqBC,GAArB,EAA0B;AACtB,QAAMC,IAAI,GAAG,OAAOD,GAApB;;AACA,MAAIC,IAAI,KAAK,QAAb,EAAuB;AACnB,QAAID,GAAG,CAACE,MAAJ,CAAW,CAAX,EAAc,CAAd,MAAqB,IAAzB,EAA+B;AAC3B,aAAO,IAAIJ,EAAJ,CAAOE,GAAG,CAACE,MAAJ,CAAW,CAAX,CAAP,EAAsB,EAAtB,CAAP;AACH,KAFD,MAGK;AACD,aAAO,IAAIJ,EAAJ,CAAOE,GAAP,EAAY,EAAZ,CAAP;AACH;AACJ,GAPD,MAQK,IAAIC,IAAI,KAAK,QAAb,EAAuB;AACxB,WAAO,IAAIH,EAAJ,CAAOE,GAAP,CAAP;AACH,GAFI,MAGA,IAAIA,GAAG,CAACG,OAAR,EAAiB;AAClB;AACA,WAAOH,GAAP;AACH,GAHI,MAIA;AACD,UAAM,IAAII,KAAJ,CAAU,0BAAV,CAAN;AACH;AACJ;;AACD,SAASC,aAAT,CAAuBJ,IAAvB,EAA6BK,MAA7B,EAAqC;AACjC;AACA,MAAIC,IAAI,GAAG,GAAX,CAFiC,CAGjC;;AACA,MAAIN,IAAI,CAACO,MAAL,GAAcF,MAAlB,EAA0B;AACtBC,IAAAA,IAAI,GAAGE,QAAQ,CAACR,IAAI,CAACC,MAAL,CAAYI,MAAZ,CAAD,EAAsB,EAAtB,CAAf;AACH,GANgC,CAOjC;;;AACA,MAAIC,IAAI,GAAG,CAAP,IAAYA,IAAI,GAAG,CAAnB,IAAwBA,IAAI,GAAG,GAAnC,EAAwC;AACpC,UAAM,IAAIH,KAAJ,CAAW,qBAAoBH,IAAK,EAApC,CAAN;AACH;;AACD,SAAOM,IAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,SAASG,YAAT,CAAsBC,GAAtB,EAA2BV,IAA3B,EAAiCW,OAAO,GAAG,KAA3C,EAAkD;AACrD,MAAIX,IAAI,CAACY,UAAL,CAAgB,MAAhB,CAAJ,EAA6B;AACzB,UAAMN,IAAI,GAAGF,aAAa,CAACJ,IAAD,EAAO,CAAP,CAA1B,CADyB,CACY;;AACrC,UAAMO,MAAM,GAAGD,IAAI,GAAG,CAAtB,CAFyB,CAEA;;AACzB,UAAMO,MAAM,GAAGf,WAAW,CAACY,GAAD,CAA1B,CAHyB,CAIzB;;AACA,QAAIG,MAAM,CAACC,KAAP,EAAJ,EAAoB;AAChB,YAAM,IAAIX,KAAJ,CAAU,2BAAV,CAAN;AACH,KAPwB,CAQzB;;;AACA,QAAIQ,OAAJ,EAAa;AACT,aAAO,OAAOE,MAAM,CAACE,QAAP,CAAgB,EAAhB,CAAd;AACH;;AACD,WAAO,OAAOF,MAAM,CAACE,QAAP,CAAgB,EAAhB,EAAoBR,MAApB,CAAd;AACH,GAbD,MAcK,IAAIP,IAAI,CAACY,UAAL,CAAgB,KAAhB,CAAJ,EAA4B;AAC7B;AACA,UAAMN,IAAI,GAAGF,aAAa,CAACJ,IAAD,EAAO,CAAP,CAA1B;AACA,UAAMO,MAAM,GAAGD,IAAI,GAAG,CAAtB,CAH6B,CAGJ;;AACzB,UAAMO,MAAM,GAAGf,WAAW,CAACY,GAAD,CAA1B,CAJ6B,CAK7B;;AACA,WAAO,OAAOG,MAAM,CAACG,MAAP,CAAcV,IAAd,EAAoBS,QAApB,CAA6B,EAA7B,EAAiCR,MAAjC,CAAd;AACH,GAPI,MAQA;AACD,UAAM,IAAIJ,KAAJ,CAAU,qBAAV,CAAN;AACH;AACJ","sourcesContent":["import BN from 'bn.js';\n/**\n * parseNumber\n * Converts a value that represents a number into a hex value.\n * @param arg {string | number | BN} A number value to convert to hex.\n * Can be a regular number, base-10 string, base-16 string, or BN instance.\n * @returns {BN} BN instance representing the number\n *\n * (Adapted from ethereumjs-abi)\n */\nfunction parseNumber(arg) {\n    const type = typeof arg;\n    if (type === 'string') {\n        if (arg.substr(0, 2) === '0x') {\n            return new BN(arg.substr(2), 16);\n        }\n        else {\n            return new BN(arg, 10);\n        }\n    }\n    else if (type === 'number') {\n        return new BN(arg);\n    }\n    else if (arg.toArray) {\n        // assume this is a BN for the moment, replace with BN.isBN soon\n        return arg;\n    }\n    else {\n        throw new Error('Argument is not a number');\n    }\n}\nfunction parseBitWidth(type, offset) {\n    // default to 256 bit if not specified\n    let size = 256;\n    // If type string is longer than offset, parse bits from the type string\n    if (type.length > offset) {\n        size = parseInt(type.substr(offset), 10);\n    }\n    // bit width must be a multiple of 8, and in the range 8-256.\n    if (size % 8 || size < 8 || size > 256) {\n        throw new Error(`Invalid bit width ${type}`);\n    }\n    return size;\n}\n/**\n * encodeNumber\n * Takes a decimal string, hex string, regular number, or BN instance and returns a hex string in the specified format.\n * Typically these conversions are done in web3, but until web3 adds direct support, this is necessary for normalizing\n * numbers eth_signTypedData payloads.\n * @param num The value to convert\n * @param type The solidity ABI type to format the data as (eg. uint256, int8, etc). Only supports int and uint variants.\n * @param compact boolean (default false). Whether to use compact encoding for uints, or pad with zeroes.\n * @returns {string} A hex string formatted as the specified type.\n */\nexport function encodeNumber(num, type, compact = false) {\n    if (type.startsWith('uint')) {\n        const size = parseBitWidth(type, 4); // start after 'uint'\n        const length = size / 4; // length in characters for the string. hex is 1 character for 4 bits.\n        const parsed = parseNumber(num);\n        // uint can never be negative\n        if (parsed.isNeg()) {\n            throw new Error('Supplied uint is negative');\n        }\n        // Convert to hex, and prepend 0x\n        if (compact) {\n            return '0x' + parsed.toString(16);\n        }\n        return '0x' + parsed.toString(16, length);\n    }\n    else if (type.startsWith('int')) {\n        // bit width must be a multiple of 8, and in the range 8-256.\n        const size = parseBitWidth(type, 3);\n        const length = size / 4; // length in characters for the string. hex is 1 character for 4 bits.\n        const parsed = parseNumber(num);\n        // Convert to twos complement at the bit size from the type, then convert value to hex\n        return '0x' + parsed.toTwos(size).toString(16, length);\n    }\n    else {\n        throw new Error('Invalid type passed');\n    }\n}\n"]},"metadata":{},"sourceType":"module"}