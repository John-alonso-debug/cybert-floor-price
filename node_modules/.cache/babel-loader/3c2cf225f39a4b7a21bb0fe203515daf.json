{"ast":null,"code":"import { AuthorizationNotifier, AuthorizationRequest, AuthorizationServiceConfiguration, BaseTokenRequestHandler, FetchRequestor, GRANT_TYPE_AUTHORIZATION_CODE, GRANT_TYPE_REFRESH_TOKEN, RedirectRequestHandler, TokenRequest } from '@openid/appauth';\nimport { BITSKI_USER_API_HOST, DEFAULT_OAUTH_CONFIGURATION, DEFAULT_OPTIONAL_SCOPES, DEFAULT_SCOPES } from '../constants';\nimport { AuthenticationError } from '../errors/authentication-error';\nimport { NoHashQueryStringUtils } from '../utils/no-hash-query-string-utils';\nimport { parseResponse } from '../utils/request-utils';\nimport { PopupBlockedError, PopupClosedError, PopupRequestHandler } from './popup-handler'; // Use this constant in login_hint to indicate that the sign up UI should be displayed\n\nexport const LOGIN_HINT_SIGNUP = 'signup';\n/**\n * Responsible for submitting requests to our OAuth server.\n */\n\nexport class OAuthManager {\n  /**\n   * Create a new OAuth Manager\n   * @param options Settings object\n   * @param options.clientId string: The client id to use for various requests\n   * @param options.redirectUri string: The redirect URI to use for responding to auth requests\n   * @param options.configuration AuthorizationServiceConfiguration (optional): The configuration for the OAuth server\n   * @param options.additionalScopes string[] (optional): Additional scopes to request outside of openid.\n   * Default is offline. Pass an empty array to only request openid.\n   */\n  constructor(options) {\n    this.clientId = options.clientId;\n    this.redirectUri = options.redirectUri;\n    this.configuration = options.configuration || new AuthorizationServiceConfiguration(DEFAULT_OAUTH_CONFIGURATION);\n    const additionalScopes = options.additionalScopes || DEFAULT_OPTIONAL_SCOPES;\n    this.scopes = DEFAULT_SCOPES.concat(additionalScopes);\n    this.tokenHandler = new BaseTokenRequestHandler(new FetchRequestor());\n    this.notifier = new AuthorizationNotifier();\n    this.notifier.setAuthorizationListener(this.didCompleteAuthorizationFlow.bind(this));\n  }\n  /**\n   * Trigger a popup sign in flow (the default)\n   */\n\n\n  signInPopup(opts) {\n    opts = opts || {};\n    const promise = new Promise((fulfill, reject) => {\n      this.pendingResolver = {\n        fulfill,\n        reject\n      };\n    });\n    this.authHandler = new PopupRequestHandler();\n    this.authHandler.setAuthorizationNotifier(this.notifier);\n    const request = this.createAuthRequest(opts);\n    this.authHandler.performAuthorizationRequest(this.configuration, request);\n    return promise.then(response => {\n      return this.requestAccessToken(response.code);\n    });\n  }\n  /**\n   * Trigger a redirect sign in flow. Promise should never fulfill, as you will be redirected.\n   */\n\n\n  signInRedirect(opts) {\n    opts = opts || {};\n    const promise = new Promise((fulfill, reject) => {\n      this.pendingResolver = {\n        fulfill,\n        reject\n      };\n    });\n    this.authHandler = new RedirectRequestHandler(undefined, new NoHashQueryStringUtils());\n    this.authHandler.setAuthorizationNotifier(this.notifier);\n    const request = this.createAuthRequest(opts);\n    this.authHandler.performAuthorizationRequest(this.configuration, request); // Since this method redirects the whole window, the promise will\n    // likely never complete unless we encounter an error.\n\n    return promise;\n  }\n  /**\n   * Attempt to finalize auth request from a redirect flow. Called from your redirect url once you've been\n   * redirected back.\n   */\n\n\n  redirectCallback() {\n    const promise = new Promise((fulfill, reject) => {\n      this.pendingResolver = {\n        fulfill,\n        reject\n      };\n    });\n    this.authHandler = new RedirectRequestHandler(undefined, new NoHashQueryStringUtils());\n    this.authHandler.setAuthorizationNotifier(this.notifier);\n    this.authHandler.completeAuthorizationRequestIfPossible();\n    return promise.then(response => {\n      return this.requestAccessToken(response.code);\n    });\n  }\n  /**\n   * Exchange an authorization code for an access token\n   * @param code The authorization code to exchange\n   */\n\n\n  requestAccessToken(code) {\n    const request = this.createTokenRequest(code);\n    return this.tokenHandler.performTokenRequest(this.configuration, request);\n  }\n  /**\n   * Request a new access token from a previous refresh token\n   * @param refreshToken The refresh token to use for authorization\n   */\n\n\n  refreshAccessToken(refreshToken) {\n    const request = this.createRefreshTokenRequest(refreshToken);\n    return this.tokenHandler.performTokenRequest(this.configuration, request);\n  }\n  /**\n   * Submit a sign out request on the oauth endpoint\n   * @param accessToken The access token to sign out with\n   */\n\n\n  requestSignOut(accessToken) {\n    return fetch(`${BITSKI_USER_API_HOST}/logout`, {\n      headers: {\n        'Accept': 'application/json',\n        'Authorization': `Bearer ${accessToken}`,\n        'Content-Type': 'application/json'\n      },\n      method: 'POST'\n    }).then(response => {\n      return parseResponse(response);\n    });\n  }\n  /**\n   * Request a user's profile from the oauth server\n   * @param accessToken The access token for the user\n   */\n\n\n  requestUserInfo(accessToken) {\n    const userInfoEndpoint = this.configuration.userInfoEndpoint;\n\n    if (!userInfoEndpoint) {\n      return Promise.reject(AuthenticationError.InvalidConfiguration('Could not find user info endpoint'));\n    }\n\n    return fetch(userInfoEndpoint, {\n      headers: {\n        Accept: 'application/json',\n        Authorization: `Bearer ${accessToken}`\n      }\n    }).then(response => {\n      return parseResponse(response);\n    });\n  }\n  /**\n   * Internal callback from our Auth Request handler. Passes the response through to a cached promise if it exists.\n   * @param request The original auth request\n   * @param response The auth response if it was successful\n   * @param errorResponse The error response if it failed\n   */\n\n\n  didCompleteAuthorizationFlow(request, response, errorResponse) {\n    if (this.pendingResolver) {\n      if (response) {\n        this.pendingResolver.fulfill(response);\n        this.pendingResolver = undefined;\n      } else if (errorResponse) {\n        if (errorResponse instanceof PopupClosedError) {\n          this.pendingResolver.reject(AuthenticationError.UserCancelled());\n        } else if (errorResponse instanceof PopupBlockedError) {\n          // Parse domain of the authority, to log better context for error.\n          const urlMatch = /^(http?s:\\/\\/[\\w.]*)\\/[\\w\\/]*$/; // Check for matches against the authority\n\n          const matches = this.configuration.authorizationEndpoint.match(urlMatch);\n          const baseUrl = matches && matches.length > 1 ? matches[1] : '';\n          this.pendingResolver.reject(AuthenticationError.PopupBlocked(baseUrl));\n        } else {\n          this.pendingResolver.reject(AuthenticationError.ServerError(errorResponse.error, errorResponse.errorDescription));\n        }\n\n        this.pendingResolver = undefined;\n      }\n    }\n  }\n  /**\n   * Factory method to create an auth request\n   */\n\n\n  createAuthRequest(opts) {\n    // Create base request\n    const request = new AuthorizationRequest({\n      client_id: this.clientId,\n      redirect_uri: this.redirectUri,\n      response_type: AuthorizationRequest.RESPONSE_TYPE_CODE,\n      scope: this.scopes.join(' ')\n    }, undefined, false); // Pass options through\n\n    if (opts.login_hint) {\n      // Only assign extras if login_hint is included in the options\n      request.extras = {\n        login_hint: opts.login_hint\n      };\n    }\n\n    return request;\n  }\n  /**\n   * Factory method to create a token request with a refresh token\n   * @param refreshToken Refresh token to use\n   */\n\n\n  createRefreshTokenRequest(refreshToken) {\n    return new TokenRequest({\n      client_id: this.clientId,\n      grant_type: GRANT_TYPE_REFRESH_TOKEN,\n      redirect_uri: this.redirectUri,\n      refresh_token: refreshToken\n    });\n  }\n  /**\n   * Factory method to create a token request with an auth code\n   * @param code The auth code to use\n   */\n\n\n  createTokenRequest(code) {\n    return new TokenRequest({\n      client_id: this.clientId,\n      code,\n      grant_type: GRANT_TYPE_AUTHORIZATION_CODE,\n      redirect_uri: this.redirectUri\n    });\n  }\n\n}","map":{"version":3,"sources":["/Users/helen/fi/protocol-demo/frontend/node_modules/bitski/dist/esm/auth/oauth-manager.js"],"names":["AuthorizationNotifier","AuthorizationRequest","AuthorizationServiceConfiguration","BaseTokenRequestHandler","FetchRequestor","GRANT_TYPE_AUTHORIZATION_CODE","GRANT_TYPE_REFRESH_TOKEN","RedirectRequestHandler","TokenRequest","BITSKI_USER_API_HOST","DEFAULT_OAUTH_CONFIGURATION","DEFAULT_OPTIONAL_SCOPES","DEFAULT_SCOPES","AuthenticationError","NoHashQueryStringUtils","parseResponse","PopupBlockedError","PopupClosedError","PopupRequestHandler","LOGIN_HINT_SIGNUP","OAuthManager","constructor","options","clientId","redirectUri","configuration","additionalScopes","scopes","concat","tokenHandler","notifier","setAuthorizationListener","didCompleteAuthorizationFlow","bind","signInPopup","opts","promise","Promise","fulfill","reject","pendingResolver","authHandler","setAuthorizationNotifier","request","createAuthRequest","performAuthorizationRequest","then","response","requestAccessToken","code","signInRedirect","undefined","redirectCallback","completeAuthorizationRequestIfPossible","createTokenRequest","performTokenRequest","refreshAccessToken","refreshToken","createRefreshTokenRequest","requestSignOut","accessToken","fetch","headers","method","requestUserInfo","userInfoEndpoint","InvalidConfiguration","Accept","Authorization","errorResponse","UserCancelled","urlMatch","matches","authorizationEndpoint","match","baseUrl","length","PopupBlocked","ServerError","error","errorDescription","client_id","redirect_uri","response_type","RESPONSE_TYPE_CODE","scope","join","login_hint","extras","grant_type","refresh_token"],"mappings":"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","sourcesContent":["import { AuthorizationNotifier, AuthorizationRequest, AuthorizationServiceConfiguration, BaseTokenRequestHandler, FetchRequestor, GRANT_TYPE_AUTHORIZATION_CODE, GRANT_TYPE_REFRESH_TOKEN, RedirectRequestHandler, TokenRequest, } from '@openid/appauth';\nimport { BITSKI_USER_API_HOST, DEFAULT_OAUTH_CONFIGURATION, DEFAULT_OPTIONAL_SCOPES, DEFAULT_SCOPES } from '../constants';\nimport { AuthenticationError } from '../errors/authentication-error';\nimport { NoHashQueryStringUtils } from '../utils/no-hash-query-string-utils';\nimport { parseResponse } from '../utils/request-utils';\nimport { PopupBlockedError, PopupClosedError, PopupRequestHandler } from './popup-handler';\n// Use this constant in login_hint to indicate that the sign up UI should be displayed\nexport const LOGIN_HINT_SIGNUP = 'signup';\n/**\n * Responsible for submitting requests to our OAuth server.\n */\nexport class OAuthManager {\n    /**\n     * Create a new OAuth Manager\n     * @param options Settings object\n     * @param options.clientId string: The client id to use for various requests\n     * @param options.redirectUri string: The redirect URI to use for responding to auth requests\n     * @param options.configuration AuthorizationServiceConfiguration (optional): The configuration for the OAuth server\n     * @param options.additionalScopes string[] (optional): Additional scopes to request outside of openid.\n     * Default is offline. Pass an empty array to only request openid.\n     */\n    constructor(options) {\n        this.clientId = options.clientId;\n        this.redirectUri = options.redirectUri;\n        this.configuration = options.configuration || new AuthorizationServiceConfiguration(DEFAULT_OAUTH_CONFIGURATION);\n        const additionalScopes = options.additionalScopes || DEFAULT_OPTIONAL_SCOPES;\n        this.scopes = DEFAULT_SCOPES.concat(additionalScopes);\n        this.tokenHandler = new BaseTokenRequestHandler(new FetchRequestor());\n        this.notifier = new AuthorizationNotifier();\n        this.notifier.setAuthorizationListener(this.didCompleteAuthorizationFlow.bind(this));\n    }\n    /**\n     * Trigger a popup sign in flow (the default)\n     */\n    signInPopup(opts) {\n        opts = opts || {};\n        const promise = new Promise((fulfill, reject) => {\n            this.pendingResolver = { fulfill, reject };\n        });\n        this.authHandler = new PopupRequestHandler();\n        this.authHandler.setAuthorizationNotifier(this.notifier);\n        const request = this.createAuthRequest(opts);\n        this.authHandler.performAuthorizationRequest(this.configuration, request);\n        return promise.then((response) => {\n            return this.requestAccessToken(response.code);\n        });\n    }\n    /**\n     * Trigger a redirect sign in flow. Promise should never fulfill, as you will be redirected.\n     */\n    signInRedirect(opts) {\n        opts = opts || {};\n        const promise = new Promise((fulfill, reject) => {\n            this.pendingResolver = { fulfill, reject };\n        });\n        this.authHandler = new RedirectRequestHandler(undefined, new NoHashQueryStringUtils());\n        this.authHandler.setAuthorizationNotifier(this.notifier);\n        const request = this.createAuthRequest(opts);\n        this.authHandler.performAuthorizationRequest(this.configuration, request);\n        // Since this method redirects the whole window, the promise will\n        // likely never complete unless we encounter an error.\n        return promise;\n    }\n    /**\n     * Attempt to finalize auth request from a redirect flow. Called from your redirect url once you've been\n     * redirected back.\n     */\n    redirectCallback() {\n        const promise = new Promise((fulfill, reject) => {\n            this.pendingResolver = { fulfill, reject };\n        });\n        this.authHandler = new RedirectRequestHandler(undefined, new NoHashQueryStringUtils());\n        this.authHandler.setAuthorizationNotifier(this.notifier);\n        this.authHandler.completeAuthorizationRequestIfPossible();\n        return promise.then((response) => {\n            return this.requestAccessToken(response.code);\n        });\n    }\n    /**\n     * Exchange an authorization code for an access token\n     * @param code The authorization code to exchange\n     */\n    requestAccessToken(code) {\n        const request = this.createTokenRequest(code);\n        return this.tokenHandler.performTokenRequest(this.configuration, request);\n    }\n    /**\n     * Request a new access token from a previous refresh token\n     * @param refreshToken The refresh token to use for authorization\n     */\n    refreshAccessToken(refreshToken) {\n        const request = this.createRefreshTokenRequest(refreshToken);\n        return this.tokenHandler.performTokenRequest(this.configuration, request);\n    }\n    /**\n     * Submit a sign out request on the oauth endpoint\n     * @param accessToken The access token to sign out with\n     */\n    requestSignOut(accessToken) {\n        return fetch(`${BITSKI_USER_API_HOST}/logout`, {\n            headers: {\n                'Accept': 'application/json',\n                'Authorization': `Bearer ${accessToken}`,\n                'Content-Type': 'application/json',\n            },\n            method: 'POST',\n        }).then((response) => {\n            return parseResponse(response);\n        });\n    }\n    /**\n     * Request a user's profile from the oauth server\n     * @param accessToken The access token for the user\n     */\n    requestUserInfo(accessToken) {\n        const userInfoEndpoint = this.configuration.userInfoEndpoint;\n        if (!userInfoEndpoint) {\n            return Promise.reject(AuthenticationError.InvalidConfiguration('Could not find user info endpoint'));\n        }\n        return fetch(userInfoEndpoint, {\n            headers: {\n                Accept: 'application/json',\n                Authorization: `Bearer ${accessToken}`,\n            },\n        }).then((response) => {\n            return parseResponse(response);\n        });\n    }\n    /**\n     * Internal callback from our Auth Request handler. Passes the response through to a cached promise if it exists.\n     * @param request The original auth request\n     * @param response The auth response if it was successful\n     * @param errorResponse The error response if it failed\n     */\n    didCompleteAuthorizationFlow(request, response, errorResponse) {\n        if (this.pendingResolver) {\n            if (response) {\n                this.pendingResolver.fulfill(response);\n                this.pendingResolver = undefined;\n            }\n            else if (errorResponse) {\n                if (errorResponse instanceof PopupClosedError) {\n                    this.pendingResolver.reject(AuthenticationError.UserCancelled());\n                }\n                else if (errorResponse instanceof PopupBlockedError) {\n                    // Parse domain of the authority, to log better context for error.\n                    const urlMatch = /^(http?s:\\/\\/[\\w.]*)\\/[\\w\\/]*$/;\n                    // Check for matches against the authority\n                    const matches = this.configuration.authorizationEndpoint.match(urlMatch);\n                    const baseUrl = matches && matches.length > 1 ? matches[1] : '';\n                    this.pendingResolver.reject(AuthenticationError.PopupBlocked(baseUrl));\n                }\n                else {\n                    this.pendingResolver.reject(AuthenticationError.ServerError(errorResponse.error, errorResponse.errorDescription));\n                }\n                this.pendingResolver = undefined;\n            }\n        }\n    }\n    /**\n     * Factory method to create an auth request\n     */\n    createAuthRequest(opts) {\n        // Create base request\n        const request = new AuthorizationRequest({\n            client_id: this.clientId,\n            redirect_uri: this.redirectUri,\n            response_type: AuthorizationRequest.RESPONSE_TYPE_CODE,\n            scope: this.scopes.join(' '),\n        }, undefined, false);\n        // Pass options through\n        if (opts.login_hint) {\n            // Only assign extras if login_hint is included in the options\n            request.extras = { login_hint: opts.login_hint };\n        }\n        return request;\n    }\n    /**\n     * Factory method to create a token request with a refresh token\n     * @param refreshToken Refresh token to use\n     */\n    createRefreshTokenRequest(refreshToken) {\n        return new TokenRequest({\n            client_id: this.clientId,\n            grant_type: GRANT_TYPE_REFRESH_TOKEN,\n            redirect_uri: this.redirectUri,\n            refresh_token: refreshToken,\n        });\n    }\n    /**\n     * Factory method to create a token request with an auth code\n     * @param code The auth code to use\n     */\n    createTokenRequest(code) {\n        return new TokenRequest({\n            client_id: this.clientId,\n            code,\n            grant_type: GRANT_TYPE_AUTHORIZATION_CODE,\n            redirect_uri: this.redirectUri,\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"module"}