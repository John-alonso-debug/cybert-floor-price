{"ast":null,"code":"import { FetchSubprovider } from '@bitski/provider-engine';\nimport retry from 'async/retry';\nimport { AUTHENTICATED_METHODS, RETRIABLE_ERRORS, UNAUTHORIZED_ERRORS } from '../constants';\nimport { ServerError } from '../errors/server-error';\n/*\n * Subprovider that fetches over HTTP and manages authentication headers\n */\n\nexport class AuthenticatedFetchSubprovider extends FetchSubprovider {\n  constructor(rpcUrl, debug, accessTokenProvider, defaultHeaders = {}) {\n    super({\n      rpcUrl\n    });\n    this.authenticatedMethods = AUTHENTICATED_METHODS;\n    this.accessTokenProvider = accessTokenProvider;\n    this.defaultHeaders = defaultHeaders;\n  }\n\n  handleRequest(payload, next, end) {\n    if (this.requiresAuthentication(payload)) {\n      return this.handleAuthenticatedRequest(payload, next, end);\n    } else {\n      return this.handleUnauthenticatedRequest(payload, next, end);\n    }\n  }\n\n  handleAuthenticatedRequest(payload, next, end) {\n    this.accessTokenProvider.getAccessToken().then(accessToken => {\n      const parameters = this.generateParameters(payload, accessToken);\n      return this.sendRequest(parameters, next, end);\n    }).catch(error => {\n      end(error);\n    });\n  }\n\n  handleUnauthenticatedRequest(payload, next, end) {\n    const parameters = this.generateParameters(payload);\n    return this.sendRequest(parameters, next, end);\n  }\n\n  requiresAuthentication(payload) {\n    return this.authenticatedMethods.some(method => method === payload.method);\n  }\n\n  generateParameters(payload, accessToken) {\n    // overwrite id to not conflict with other concurrent users\n    const newPayload = this.createPayload(payload); // remove extra parameter from request\n\n    delete newPayload.origin;\n    let headers = {\n      'Accept': 'application/json',\n      'Content-Type': 'application/json'\n    };\n    headers = Object.assign({}, headers, this.defaultHeaders);\n    const originDomain = payload.origin;\n\n    if (this.originHttpHeaderKey && originDomain) {\n      headers[this.originHttpHeaderKey] = originDomain;\n    }\n\n    if (accessToken) {\n      headers.Authorization = `Bearer ${accessToken}`;\n    }\n\n    const requestParameters = {\n      body: JSON.stringify(newPayload),\n      headers,\n      method: 'POST'\n    };\n    return requestParameters;\n  }\n\n  sendRequest(parameters, next, end) {\n    retry({\n      errorFilter: this.isErrorRetriable,\n      interval: 1000,\n      times: 5\n    }, cb => this._submitRequest(parameters, cb), (err, result) => {\n      // ends on retriable error\n      if (err && this.isErrorRetriable(err)) {\n        const retriesExhaustedErr = new ServerError(err.message, 200, this.rpcUrl, true);\n        return end(retriesExhaustedErr);\n      }\n\n      if (err && this.isUnauthorizedError(err)) {\n        return this.accessTokenProvider.invalidateToken().then(() => {\n          return end(err);\n        });\n      } // otherwise continue normally\n\n\n      return end(err, result);\n    });\n  }\n\n  isErrorRetriable(err) {\n    const errMsg = err.toString();\n    return RETRIABLE_ERRORS.some(phrase => errMsg.includes(phrase));\n  }\n\n  isUnauthorizedError(err) {\n    return UNAUTHORIZED_ERRORS.some(phrase => err.message.includes(phrase));\n  }\n\n}","map":{"version":3,"sources":["/Users/helen/fi/protocol-demo/frontend/node_modules/bitski-provider/dist/subproviders/authenticated-fetch.js"],"names":["FetchSubprovider","retry","AUTHENTICATED_METHODS","RETRIABLE_ERRORS","UNAUTHORIZED_ERRORS","ServerError","AuthenticatedFetchSubprovider","constructor","rpcUrl","debug","accessTokenProvider","defaultHeaders","authenticatedMethods","handleRequest","payload","next","end","requiresAuthentication","handleAuthenticatedRequest","handleUnauthenticatedRequest","getAccessToken","then","accessToken","parameters","generateParameters","sendRequest","catch","error","some","method","newPayload","createPayload","origin","headers","Object","assign","originDomain","originHttpHeaderKey","Authorization","requestParameters","body","JSON","stringify","errorFilter","isErrorRetriable","interval","times","cb","_submitRequest","err","result","retriesExhaustedErr","message","isUnauthorizedError","invalidateToken","errMsg","toString","phrase","includes"],"mappings":"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","sourcesContent":["import { FetchSubprovider } from '@bitski/provider-engine';\nimport retry from 'async/retry';\nimport { AUTHENTICATED_METHODS, RETRIABLE_ERRORS, UNAUTHORIZED_ERRORS } from '../constants';\nimport { ServerError } from '../errors/server-error';\n/*\n * Subprovider that fetches over HTTP and manages authentication headers\n */\nexport class AuthenticatedFetchSubprovider extends FetchSubprovider {\n    constructor(rpcUrl, debug, accessTokenProvider, defaultHeaders = {}) {\n        super({ rpcUrl });\n        this.authenticatedMethods = AUTHENTICATED_METHODS;\n        this.accessTokenProvider = accessTokenProvider;\n        this.defaultHeaders = defaultHeaders;\n    }\n    handleRequest(payload, next, end) {\n        if (this.requiresAuthentication(payload)) {\n            return this.handleAuthenticatedRequest(payload, next, end);\n        }\n        else {\n            return this.handleUnauthenticatedRequest(payload, next, end);\n        }\n    }\n    handleAuthenticatedRequest(payload, next, end) {\n        this.accessTokenProvider.getAccessToken().then((accessToken) => {\n            const parameters = this.generateParameters(payload, accessToken);\n            return this.sendRequest(parameters, next, end);\n        }).catch((error) => {\n            end(error);\n        });\n    }\n    handleUnauthenticatedRequest(payload, next, end) {\n        const parameters = this.generateParameters(payload);\n        return this.sendRequest(parameters, next, end);\n    }\n    requiresAuthentication(payload) {\n        return this.authenticatedMethods.some((method) => method === payload.method);\n    }\n    generateParameters(payload, accessToken) {\n        // overwrite id to not conflict with other concurrent users\n        const newPayload = this.createPayload(payload);\n        // remove extra parameter from request\n        delete newPayload.origin;\n        let headers = {\n            'Accept': 'application/json',\n            'Content-Type': 'application/json',\n        };\n        headers = Object.assign({}, headers, this.defaultHeaders);\n        const originDomain = payload.origin;\n        if (this.originHttpHeaderKey && originDomain) {\n            headers[this.originHttpHeaderKey] = originDomain;\n        }\n        if (accessToken) {\n            headers.Authorization = `Bearer ${accessToken}`;\n        }\n        const requestParameters = {\n            body: JSON.stringify(newPayload),\n            headers,\n            method: 'POST',\n        };\n        return requestParameters;\n    }\n    sendRequest(parameters, next, end) {\n        retry({\n            errorFilter: this.isErrorRetriable,\n            interval: 1000,\n            times: 5,\n        }, (cb) => this._submitRequest(parameters, cb), (err, result) => {\n            // ends on retriable error\n            if (err && this.isErrorRetriable(err)) {\n                const retriesExhaustedErr = new ServerError(err.message, 200, this.rpcUrl, true);\n                return end(retriesExhaustedErr);\n            }\n            if (err && this.isUnauthorizedError(err)) {\n                return this.accessTokenProvider.invalidateToken().then(() => {\n                    return end(err);\n                });\n            }\n            // otherwise continue normally\n            return end(err, result);\n        });\n    }\n    isErrorRetriable(err) {\n        const errMsg = err.toString();\n        return RETRIABLE_ERRORS.some((phrase) => errMsg.includes(phrase));\n    }\n    isUnauthorizedError(err) {\n        return UNAUTHORIZED_ERRORS.some((phrase) => err.message.includes(phrase));\n    }\n}\n"]},"metadata":{},"sourceType":"module"}