{"ast":null,"code":"import { Subprovider } from '@bitski/provider-engine';\nimport { CACHED_METHODS } from '../constants';\n/*\n * Subprovider that caches values related to the user.\n */\n\nexport class AuthenticatedCacheSubprovider extends Subprovider {\n  constructor(authProvider, engine) {\n    super();\n    this.authProvider = authProvider;\n    this.cachedValues = new Map();\n\n    if (engine) {\n      engine.on('signOut', () => this.cachedValues.clear());\n    }\n  }\n\n  handleRequest(payload, next, end) {\n    // Only evaluate matching methods\n    if (this.supportsCache(payload.method) === false) {\n      return next();\n    } // Allow overriding the cache\n\n\n    if (payload.skipCache) {\n      return next();\n    } // Load from cache\n\n\n    this.checkCachedValues(payload.method).then(value => {\n      if (value !== undefined) {\n        // Value for method is cached, return value\n        end(undefined, value);\n      } else {\n        // Value for method is not cached, fallback to fetch\n        next();\n      }\n    }).catch(() => {\n      // If method is not supported, or we encounter an error, fallback to fetch provider\n      return next();\n    });\n  }\n\n  supportsCache(methodName) {\n    return CACHED_METHODS.includes(methodName);\n  }\n\n  checkCachedValues(methodName) {\n    // First, check in-memory cache\n    if (this.cachedValues.has(methodName)) {\n      return Promise.resolve(this.cachedValues.get(methodName));\n    } // Fallback to local-storage cache\n\n\n    switch (methodName) {\n      case 'eth_accounts':\n        return this.getAccounts();\n\n      default:\n        return Promise.reject(new Error('Method not supported'));\n    }\n  }\n\n  getAccounts() {\n    // TODO: Move this to a subscription model and load into memory automatically\n    return this.authProvider.getUser().then(user => {\n      if (user.accounts) {\n        this.cachedValues.set('eth_accounts', user.accounts);\n        return user.accounts;\n      }\n\n      throw new Error('Accounts not found on user');\n    });\n  }\n\n}","map":{"version":3,"sources":["/Users/helen/fi/protocol-demo/frontend/node_modules/bitski/dist/esm/subproviders/authenticated-cache.js"],"names":["Subprovider","CACHED_METHODS","AuthenticatedCacheSubprovider","constructor","authProvider","engine","cachedValues","Map","on","clear","handleRequest","payload","next","end","supportsCache","method","skipCache","checkCachedValues","then","value","undefined","catch","methodName","includes","has","Promise","resolve","get","getAccounts","reject","Error","getUser","user","accounts","set"],"mappings":"AAAA,SAASA,WAAT,QAA4B,yBAA5B;AACA,SAASC,cAAT,QAA+B,cAA/B;AACA;AACA;AACA;;AACA,OAAO,MAAMC,6BAAN,SAA4CF,WAA5C,CAAwD;AAC3DG,EAAAA,WAAW,CAACC,YAAD,EAAeC,MAAf,EAAuB;AAC9B;AACA,SAAKD,YAAL,GAAoBA,YAApB;AACA,SAAKE,YAAL,GAAoB,IAAIC,GAAJ,EAApB;;AACA,QAAIF,MAAJ,EAAY;AACRA,MAAAA,MAAM,CAACG,EAAP,CAAU,SAAV,EAAqB,MAAM,KAAKF,YAAL,CAAkBG,KAAlB,EAA3B;AACH;AACJ;;AACDC,EAAAA,aAAa,CAACC,OAAD,EAAUC,IAAV,EAAgBC,GAAhB,EAAqB;AAC9B;AACA,QAAI,KAAKC,aAAL,CAAmBH,OAAO,CAACI,MAA3B,MAAuC,KAA3C,EAAkD;AAC9C,aAAOH,IAAI,EAAX;AACH,KAJ6B,CAK9B;;;AACA,QAAID,OAAO,CAACK,SAAZ,EAAuB;AACnB,aAAOJ,IAAI,EAAX;AACH,KAR6B,CAS9B;;;AACA,SAAKK,iBAAL,CAAuBN,OAAO,CAACI,MAA/B,EAAuCG,IAAvC,CAA6CC,KAAD,IAAW;AACnD,UAAIA,KAAK,KAAKC,SAAd,EAAyB;AACrB;AACAP,QAAAA,GAAG,CAACO,SAAD,EAAYD,KAAZ,CAAH;AACH,OAHD,MAIK;AACD;AACAP,QAAAA,IAAI;AACP;AACJ,KATD,EASGS,KATH,CASS,MAAM;AACX;AACA,aAAOT,IAAI,EAAX;AACH,KAZD;AAaH;;AACDE,EAAAA,aAAa,CAACQ,UAAD,EAAa;AACtB,WAAOrB,cAAc,CAACsB,QAAf,CAAwBD,UAAxB,CAAP;AACH;;AACDL,EAAAA,iBAAiB,CAACK,UAAD,EAAa;AAC1B;AACA,QAAI,KAAKhB,YAAL,CAAkBkB,GAAlB,CAAsBF,UAAtB,CAAJ,EAAuC;AACnC,aAAOG,OAAO,CAACC,OAAR,CAAgB,KAAKpB,YAAL,CAAkBqB,GAAlB,CAAsBL,UAAtB,CAAhB,CAAP;AACH,KAJyB,CAK1B;;;AACA,YAAQA,UAAR;AACI,WAAK,cAAL;AACI,eAAO,KAAKM,WAAL,EAAP;;AACJ;AACI,eAAOH,OAAO,CAACI,MAAR,CAAe,IAAIC,KAAJ,CAAU,sBAAV,CAAf,CAAP;AAJR;AAMH;;AACDF,EAAAA,WAAW,GAAG;AACV;AACA,WAAO,KAAKxB,YAAL,CAAkB2B,OAAlB,GAA4Bb,IAA5B,CAAkCc,IAAD,IAAU;AAC9C,UAAIA,IAAI,CAACC,QAAT,EAAmB;AACf,aAAK3B,YAAL,CAAkB4B,GAAlB,CAAsB,cAAtB,EAAsCF,IAAI,CAACC,QAA3C;AACA,eAAOD,IAAI,CAACC,QAAZ;AACH;;AACD,YAAM,IAAIH,KAAJ,CAAU,4BAAV,CAAN;AACH,KANM,CAAP;AAOH;;AA1D0D","sourcesContent":["import { Subprovider } from '@bitski/provider-engine';\nimport { CACHED_METHODS } from '../constants';\n/*\n * Subprovider that caches values related to the user.\n */\nexport class AuthenticatedCacheSubprovider extends Subprovider {\n    constructor(authProvider, engine) {\n        super();\n        this.authProvider = authProvider;\n        this.cachedValues = new Map();\n        if (engine) {\n            engine.on('signOut', () => this.cachedValues.clear());\n        }\n    }\n    handleRequest(payload, next, end) {\n        // Only evaluate matching methods\n        if (this.supportsCache(payload.method) === false) {\n            return next();\n        }\n        // Allow overriding the cache\n        if (payload.skipCache) {\n            return next();\n        }\n        // Load from cache\n        this.checkCachedValues(payload.method).then((value) => {\n            if (value !== undefined) {\n                // Value for method is cached, return value\n                end(undefined, value);\n            }\n            else {\n                // Value for method is not cached, fallback to fetch\n                next();\n            }\n        }).catch(() => {\n            // If method is not supported, or we encounter an error, fallback to fetch provider\n            return next();\n        });\n    }\n    supportsCache(methodName) {\n        return CACHED_METHODS.includes(methodName);\n    }\n    checkCachedValues(methodName) {\n        // First, check in-memory cache\n        if (this.cachedValues.has(methodName)) {\n            return Promise.resolve(this.cachedValues.get(methodName));\n        }\n        // Fallback to local-storage cache\n        switch (methodName) {\n            case 'eth_accounts':\n                return this.getAccounts();\n            default:\n                return Promise.reject(new Error('Method not supported'));\n        }\n    }\n    getAccounts() {\n        // TODO: Move this to a subscription model and load into memory automatically\n        return this.authProvider.getUser().then((user) => {\n            if (user.accounts) {\n                this.cachedValues.set('eth_accounts', user.accounts);\n                return user.accounts;\n            }\n            throw new Error('Accounts not found on user');\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"module"}