{"ast":null,"code":"import { Subprovider } from '@bitski/provider-engine';\nimport { v4 as uuidv4 } from 'uuid';\nimport { DEFAULT_AUTHORIZED_METHODS as DEFAULT_SIGNATURE_METHODS } from '../constants';\nimport { SignerError } from '../errors/signer-error';\nexport var TransactionKind;\n\n(function (TransactionKind) {\n  TransactionKind[\"SendTransaction\"] = \"ETH_SEND_TRANSACTION\";\n  TransactionKind[\"SignTransaction\"] = \"ETH_SIGN_TRANSACTION\";\n  TransactionKind[\"Sign\"] = \"ETH_SIGN\";\n  TransactionKind[\"SignTypedData\"] = \"ETH_SIGN_TYPED_DATA\";\n})(TransactionKind || (TransactionKind = {}));\n/**\n * A Subprovider that manages the interface between JSON-RPC and Bitski's proprietary transaction signing flow.\n * This class is responsible for transforming the JSON-RPC request into a Transaction object that the Bitski signer understands.\n * Also responsible for submitting the transaction to the network, and converting the response back into an RPC response.\n *\n * Important: this class assumes the transaction has all the necessary fields populated. The TransactionValidatorSubprovider\n * should be placed in front of this subprovider.\n */\n\n\nexport class SignatureSubprovider extends Subprovider {\n  constructor(network, signer, tokenProvider, signatureMethods) {\n    super();\n    this.network = network;\n    this.tokenProvider = tokenProvider;\n    this.signer = signer;\n    this.signatureMethods = signatureMethods || DEFAULT_SIGNATURE_METHODS;\n  }\n  /**\n   * Handle RPC request from engine (called by)\n   * @param payload RPC request payload\n   * @param next Callback to skip handling this request\n   * @param end Completion handler\n   */\n\n\n  handleRequest(payload, next, end) {\n    if (this.requiresSignature(payload.method)) {\n      this.handleSignatureRequest(payload, end);\n      return;\n    }\n\n    next();\n  }\n  /**\n   * Called when a payload is received that needs a signature\n   * @param payload The JSON-RPC request\n   * @param callback The callback to call when the request has been handled\n   */\n\n\n  async handleSignatureRequest(payload, callback) {\n    try {\n      // Get access token\n      const accessToken = await this.tokenProvider.getAccessToken(); // Prepare a transaction object\n\n      const transaction = await this.createBitskiTransaction(payload); // Sign the transaction object\n\n      const signedResponse = await this.signer.sign(transaction, accessToken); // Send the transaction if needed\n\n      const result = await this.sendIfNeeded(payload, signedResponse); // Call the callback with the result\n\n      callback(undefined, result);\n    } catch (error) {\n      // Call with the error if any of the steps fail\n      callback(error, undefined);\n    }\n  }\n  /** Should this subprovider handle the request?\n   * @param method The RPC method of the request\n   */\n\n\n  requiresSignature(method) {\n    return this.signatureMethods.includes(method);\n  }\n  /**\n   * This will forward transactions that should be automatically submitted to the network, otherwise\n   * resolve with the original value.\n   * @param payload The original request payload\n   * @param signedData signed data for the transaction\n   */\n\n\n  sendIfNeeded(payload, signedData) {\n    if (payload.method === 'eth_sendTransaction') {\n      // Create a send raw transaction payload\n      const sendPayload = {\n        id: 0,\n        jsonrpc: '2.0',\n        method: 'eth_sendRawTransaction',\n        params: [signedData]\n      };\n      return this.performRequest(sendPayload);\n    }\n\n    return Promise.resolve(signedData);\n  }\n  /**\n   * Load the balance so the web approval dialog can give the user better context\n   * @param payload Payload for the request\n   */\n\n\n  loadBalanceIfNeeded(payload) {\n    // Only necessary if this is a transaction\n    const isTransaction = payload.method === 'eth_sendTransaction' || payload.method === 'eth_signTransaction';\n    const isCustomRPC = !this.network.rpcUrl.includes('api.bitski.com');\n\n    if (isTransaction && isCustomRPC) {\n      const transaction = payload.params[0];\n      const balancePayload = {\n        id: 0,\n        jsonrpc: '2.0',\n        method: 'eth_getBalance',\n        params: [transaction.from, 'latest']\n      };\n      return this.performRequest(balancePayload);\n    }\n\n    return Promise.resolve();\n  }\n  /**\n   * Responsible for creating the Transaction object from a given RPC payload\n   * @param payload JSON-RPC payload to extract the values from\n   */\n\n\n  async createBitskiTransaction(payload) {\n    const context = await this.createContext(payload);\n    const kind = this.kindForMethod(payload.method);\n    const extractedPayload = this.createPayload(payload);\n    const transaction = {\n      id: uuidv4(),\n      kind,\n      payload: extractedPayload,\n      context\n    };\n    return transaction;\n  }\n\n  async createContext(request) {\n    switch (request.method) {\n      case 'eth_sendTransaction':\n      case 'eth_signTransaction':\n        const balance = await this.loadBalanceIfNeeded(request);\n        return {\n          chainId: this.network.chainId,\n          currentBalance: balance\n        };\n\n      case 'eth_signTypedData':\n      case 'eth_signTypedData_v3':\n        // The from address should be the first parameter as a 20 byte hex string\n        if (request.params && request.params.length > 0) {\n          return {\n            from: request.params[0]\n          };\n        }\n\n        throw SignerError.MissingFrom();\n\n      default:\n        // Other transaction types do not need context\n        return {};\n    }\n  }\n  /**\n   * Responsible for creating the payload from a given RPC request\n   * @param request JSON-RPC request to extract params from\n   */\n\n\n  createPayload(request) {\n    switch (request.method) {\n      case 'eth_sendTransaction':\n      case 'eth_signTransaction':\n        if (request.params && request.params.length > 0) {\n          return request.params[0];\n        } else {\n          throw SignerError.MissingTransaction();\n        }\n\n      case 'eth_sign':\n        if (request.params && request.params.length > 1) {\n          return {\n            from: request.params[0],\n            message: request.params[1]\n          };\n        } else {\n          throw SignerError.MissingMessage();\n        }\n\n      case 'personal_sign':\n        if (request.params && request.params.length > 1) {\n          return {\n            from: request.params[1],\n            message: request.params[0]\n          };\n        } else {\n          throw SignerError.MissingMessage();\n        }\n\n      case 'eth_signTypedData':\n      case 'eth_signTypedData_v3':\n        if (request.params && request.params.length > 1) {\n          return request.params[1];\n        } else {\n          throw SignerError.MissingTypedData();\n        }\n\n      default:\n        throw SignerError.UnsupportedMethod();\n    }\n  }\n  /**\n   * Determines a BitskiTransaction.Kind value from a given RPC method name\n   * @param method The JSON-RPC method being requested\n   */\n\n\n  kindForMethod(method) {\n    switch (method) {\n      case 'eth_sendTransaction':\n      case 'eth_signTransaction':\n        // Convert both *sign* and *send* methods into a sign transaction.\n        // (we will forward the transaction locally if needed)\n        return TransactionKind.SignTransaction;\n\n      case 'eth_sign':\n      case 'personal_sign':\n        return TransactionKind.Sign;\n\n      case 'eth_signTypedData':\n      case 'eth_signTypedData_v3':\n        return TransactionKind.SignTypedData;\n\n      default:\n        throw SignerError.UnsupportedMethod();\n    }\n  } // Wraps emitPayload in a promise\n\n\n  performRequest(payload) {\n    return new Promise((fulfill, reject) => {\n      this.emitPayload(payload, (err, result) => {\n        if (err) {\n          reject(err);\n        } else {\n          fulfill(result.result);\n        }\n      });\n    });\n  }\n\n}","map":{"version":3,"sources":["/Users/helen/fi/protocol-demo/frontend/node_modules/bitski/dist/esm/subproviders/signature.js"],"names":["Subprovider","v4","uuidv4","DEFAULT_AUTHORIZED_METHODS","DEFAULT_SIGNATURE_METHODS","SignerError","TransactionKind","SignatureSubprovider","constructor","network","signer","tokenProvider","signatureMethods","handleRequest","payload","next","end","requiresSignature","method","handleSignatureRequest","callback","accessToken","getAccessToken","transaction","createBitskiTransaction","signedResponse","sign","result","sendIfNeeded","undefined","error","includes","signedData","sendPayload","id","jsonrpc","params","performRequest","Promise","resolve","loadBalanceIfNeeded","isTransaction","isCustomRPC","rpcUrl","balancePayload","from","context","createContext","kind","kindForMethod","extractedPayload","createPayload","request","balance","chainId","currentBalance","length","MissingFrom","MissingTransaction","message","MissingMessage","MissingTypedData","UnsupportedMethod","SignTransaction","Sign","SignTypedData","fulfill","reject","emitPayload","err"],"mappings":"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","sourcesContent":["import { Subprovider } from '@bitski/provider-engine';\nimport { v4 as uuidv4 } from 'uuid';\nimport { DEFAULT_AUTHORIZED_METHODS as DEFAULT_SIGNATURE_METHODS } from '../constants';\nimport { SignerError } from '../errors/signer-error';\nexport var TransactionKind;\n(function (TransactionKind) {\n    TransactionKind[\"SendTransaction\"] = \"ETH_SEND_TRANSACTION\";\n    TransactionKind[\"SignTransaction\"] = \"ETH_SIGN_TRANSACTION\";\n    TransactionKind[\"Sign\"] = \"ETH_SIGN\";\n    TransactionKind[\"SignTypedData\"] = \"ETH_SIGN_TYPED_DATA\";\n})(TransactionKind || (TransactionKind = {}));\n/**\n * A Subprovider that manages the interface between JSON-RPC and Bitski's proprietary transaction signing flow.\n * This class is responsible for transforming the JSON-RPC request into a Transaction object that the Bitski signer understands.\n * Also responsible for submitting the transaction to the network, and converting the response back into an RPC response.\n *\n * Important: this class assumes the transaction has all the necessary fields populated. The TransactionValidatorSubprovider\n * should be placed in front of this subprovider.\n */\nexport class SignatureSubprovider extends Subprovider {\n    constructor(network, signer, tokenProvider, signatureMethods) {\n        super();\n        this.network = network;\n        this.tokenProvider = tokenProvider;\n        this.signer = signer;\n        this.signatureMethods = signatureMethods || DEFAULT_SIGNATURE_METHODS;\n    }\n    /**\n     * Handle RPC request from engine (called by)\n     * @param payload RPC request payload\n     * @param next Callback to skip handling this request\n     * @param end Completion handler\n     */\n    handleRequest(payload, next, end) {\n        if (this.requiresSignature(payload.method)) {\n            this.handleSignatureRequest(payload, end);\n            return;\n        }\n        next();\n    }\n    /**\n     * Called when a payload is received that needs a signature\n     * @param payload The JSON-RPC request\n     * @param callback The callback to call when the request has been handled\n     */\n    async handleSignatureRequest(payload, callback) {\n        try {\n            // Get access token\n            const accessToken = await this.tokenProvider.getAccessToken();\n            // Prepare a transaction object\n            const transaction = await this.createBitskiTransaction(payload);\n            // Sign the transaction object\n            const signedResponse = await this.signer.sign(transaction, accessToken);\n            // Send the transaction if needed\n            const result = await this.sendIfNeeded(payload, signedResponse);\n            // Call the callback with the result\n            callback(undefined, result);\n        }\n        catch (error) {\n            // Call with the error if any of the steps fail\n            callback(error, undefined);\n        }\n    }\n    /** Should this subprovider handle the request?\n     * @param method The RPC method of the request\n     */\n    requiresSignature(method) {\n        return this.signatureMethods.includes(method);\n    }\n    /**\n     * This will forward transactions that should be automatically submitted to the network, otherwise\n     * resolve with the original value.\n     * @param payload The original request payload\n     * @param signedData signed data for the transaction\n     */\n    sendIfNeeded(payload, signedData) {\n        if (payload.method === 'eth_sendTransaction') {\n            // Create a send raw transaction payload\n            const sendPayload = {\n                id: 0,\n                jsonrpc: '2.0',\n                method: 'eth_sendRawTransaction',\n                params: [signedData],\n            };\n            return this.performRequest(sendPayload);\n        }\n        return Promise.resolve(signedData);\n    }\n    /**\n     * Load the balance so the web approval dialog can give the user better context\n     * @param payload Payload for the request\n     */\n    loadBalanceIfNeeded(payload) {\n        // Only necessary if this is a transaction\n        const isTransaction = payload.method === 'eth_sendTransaction' || payload.method === 'eth_signTransaction';\n        const isCustomRPC = !this.network.rpcUrl.includes('api.bitski.com');\n        if (isTransaction && isCustomRPC) {\n            const transaction = payload.params[0];\n            const balancePayload = {\n                id: 0,\n                jsonrpc: '2.0',\n                method: 'eth_getBalance',\n                params: [transaction.from, 'latest'],\n            };\n            return this.performRequest(balancePayload);\n        }\n        return Promise.resolve();\n    }\n    /**\n     * Responsible for creating the Transaction object from a given RPC payload\n     * @param payload JSON-RPC payload to extract the values from\n     */\n    async createBitskiTransaction(payload) {\n        const context = await this.createContext(payload);\n        const kind = this.kindForMethod(payload.method);\n        const extractedPayload = this.createPayload(payload);\n        const transaction = {\n            id: uuidv4(),\n            kind,\n            payload: extractedPayload,\n            context,\n        };\n        return transaction;\n    }\n    async createContext(request) {\n        switch (request.method) {\n            case 'eth_sendTransaction':\n            case 'eth_signTransaction':\n                const balance = await this.loadBalanceIfNeeded(request);\n                return { chainId: this.network.chainId, currentBalance: balance };\n            case 'eth_signTypedData':\n            case 'eth_signTypedData_v3':\n                // The from address should be the first parameter as a 20 byte hex string\n                if (request.params && request.params.length > 0) {\n                    return { from: request.params[0] };\n                }\n                throw SignerError.MissingFrom();\n            default:\n                // Other transaction types do not need context\n                return {};\n        }\n    }\n    /**\n     * Responsible for creating the payload from a given RPC request\n     * @param request JSON-RPC request to extract params from\n     */\n    createPayload(request) {\n        switch (request.method) {\n            case 'eth_sendTransaction':\n            case 'eth_signTransaction':\n                if (request.params && request.params.length > 0) {\n                    return request.params[0];\n                }\n                else {\n                    throw SignerError.MissingTransaction();\n                }\n            case 'eth_sign':\n                if (request.params && request.params.length > 1) {\n                    return { from: request.params[0], message: request.params[1] };\n                }\n                else {\n                    throw SignerError.MissingMessage();\n                }\n            case 'personal_sign':\n                if (request.params && request.params.length > 1) {\n                    return { from: request.params[1], message: request.params[0] };\n                }\n                else {\n                    throw SignerError.MissingMessage();\n                }\n            case 'eth_signTypedData':\n            case 'eth_signTypedData_v3':\n                if (request.params && request.params.length > 1) {\n                    return request.params[1];\n                }\n                else {\n                    throw SignerError.MissingTypedData();\n                }\n            default:\n                throw SignerError.UnsupportedMethod();\n        }\n    }\n    /**\n     * Determines a BitskiTransaction.Kind value from a given RPC method name\n     * @param method The JSON-RPC method being requested\n     */\n    kindForMethod(method) {\n        switch (method) {\n            case 'eth_sendTransaction':\n            case 'eth_signTransaction':\n                // Convert both *sign* and *send* methods into a sign transaction.\n                // (we will forward the transaction locally if needed)\n                return TransactionKind.SignTransaction;\n            case 'eth_sign':\n            case 'personal_sign':\n                return TransactionKind.Sign;\n            case 'eth_signTypedData':\n            case 'eth_signTypedData_v3':\n                return TransactionKind.SignTypedData;\n            default:\n                throw SignerError.UnsupportedMethod();\n        }\n    }\n    // Wraps emitPayload in a promise\n    performRequest(payload) {\n        return new Promise((fulfill, reject) => {\n            this.emitPayload(payload, (err, result) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    fulfill(result.result);\n                }\n            });\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"module"}