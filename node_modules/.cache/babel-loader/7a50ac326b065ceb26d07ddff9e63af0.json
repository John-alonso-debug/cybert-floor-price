{"ast":null,"code":"/**\n * Represents a Bitski access token\n */\nexport class AccessToken {\n  /**\n   *\n   * @param token the access token\n   * @param expiresAt the token expiration date (in seconds) (optional)\n   * @param scope the scopes this token represents (optional)\n   */\n  constructor(token, expiresAt, scope) {\n    this.token = token;\n    this.scope = scope;\n    this.expiresAt = expiresAt;\n  }\n  /**\n   * Creates a token from a TokenResponse object\n   * @param tokenResponse The token response object to build a token from\n   */\n\n\n  static fromTokenResponse(tokenResponse) {\n    let expiresAt;\n\n    if (tokenResponse.expiresIn) {\n      expiresAt = Math.floor(Date.now() / 1000) + tokenResponse.expiresIn;\n    }\n\n    return new AccessToken(tokenResponse.accessToken, expiresAt, tokenResponse.scope);\n  }\n  /**\n   * Creates a token from a storage string\n   * @param s JSON string representing the token\n   */\n\n\n  static fromString(s) {\n    let parsed;\n\n    try {\n      parsed = JSON.parse(s);\n    } catch (error) {\n      return;\n    }\n\n    if (!parsed.token) {\n      return;\n    }\n\n    return new AccessToken(parsed.token, parsed.expiresAt, parsed.scope);\n  }\n  /**\n   * Calculates if the token is still active\n   */\n\n\n  get expired() {\n    if (this.expiresAt) {\n      const now = Math.floor(Date.now() / 1000);\n      const expiresIn = this.expiresAt - now;\n      return expiresIn <= 0;\n    }\n\n    return false;\n  }\n  /**\n   * Returns a JSON string suitable for writing in local storage\n   */\n\n\n  toStorageString() {\n    return JSON.stringify({\n      expiresAt: this.expiresAt,\n      scope: this.scope,\n      token: this.token\n    });\n  }\n\n}","map":{"version":3,"sources":["/Users/helen/fi/protocol-demo/frontend/node_modules/bitski/dist/esm/auth/access-token.js"],"names":["AccessToken","constructor","token","expiresAt","scope","fromTokenResponse","tokenResponse","expiresIn","Math","floor","Date","now","accessToken","fromString","s","parsed","JSON","parse","error","expired","toStorageString","stringify"],"mappings":"AAAA;AACA;AACA;AACA,OAAO,MAAMA,WAAN,CAAkB;AACrB;AACJ;AACA;AACA;AACA;AACA;AACIC,EAAAA,WAAW,CAACC,KAAD,EAAQC,SAAR,EAAmBC,KAAnB,EAA0B;AACjC,SAAKF,KAAL,GAAaA,KAAb;AACA,SAAKE,KAAL,GAAaA,KAAb;AACA,SAAKD,SAAL,GAAiBA,SAAjB;AACH;AACD;AACJ;AACA;AACA;;;AAC4B,SAAjBE,iBAAiB,CAACC,aAAD,EAAgB;AACpC,QAAIH,SAAJ;;AACA,QAAIG,aAAa,CAACC,SAAlB,EAA6B;AACzBJ,MAAAA,SAAS,GAAGK,IAAI,CAACC,KAAL,CAAWC,IAAI,CAACC,GAAL,KAAa,IAAxB,IAAgCL,aAAa,CAACC,SAA1D;AACH;;AACD,WAAO,IAAIP,WAAJ,CAAgBM,aAAa,CAACM,WAA9B,EAA2CT,SAA3C,EAAsDG,aAAa,CAACF,KAApE,CAAP;AACH;AACD;AACJ;AACA;AACA;;;AACqB,SAAVS,UAAU,CAACC,CAAD,EAAI;AACjB,QAAIC,MAAJ;;AACA,QAAI;AACAA,MAAAA,MAAM,GAAGC,IAAI,CAACC,KAAL,CAAWH,CAAX,CAAT;AACH,KAFD,CAGA,OAAOI,KAAP,EAAc;AACV;AACH;;AACD,QAAI,CAACH,MAAM,CAACb,KAAZ,EAAmB;AACf;AACH;;AACD,WAAO,IAAIF,WAAJ,CAAgBe,MAAM,CAACb,KAAvB,EAA8Ba,MAAM,CAACZ,SAArC,EAAgDY,MAAM,CAACX,KAAvD,CAAP;AACH;AACD;AACJ;AACA;;;AACe,MAAPe,OAAO,GAAG;AACV,QAAI,KAAKhB,SAAT,EAAoB;AAChB,YAAMQ,GAAG,GAAGH,IAAI,CAACC,KAAL,CAAWC,IAAI,CAACC,GAAL,KAAa,IAAxB,CAAZ;AACA,YAAMJ,SAAS,GAAG,KAAKJ,SAAL,GAAiBQ,GAAnC;AACA,aAAOJ,SAAS,IAAI,CAApB;AACH;;AACD,WAAO,KAAP;AACH;AACD;AACJ;AACA;;;AACIa,EAAAA,eAAe,GAAG;AACd,WAAOJ,IAAI,CAACK,SAAL,CAAe;AAClBlB,MAAAA,SAAS,EAAE,KAAKA,SADE;AAElBC,MAAAA,KAAK,EAAE,KAAKA,KAFM;AAGlBF,MAAAA,KAAK,EAAE,KAAKA;AAHM,KAAf,CAAP;AAKH;;AA5DoB","sourcesContent":["/**\n * Represents a Bitski access token\n */\nexport class AccessToken {\n    /**\n     *\n     * @param token the access token\n     * @param expiresAt the token expiration date (in seconds) (optional)\n     * @param scope the scopes this token represents (optional)\n     */\n    constructor(token, expiresAt, scope) {\n        this.token = token;\n        this.scope = scope;\n        this.expiresAt = expiresAt;\n    }\n    /**\n     * Creates a token from a TokenResponse object\n     * @param tokenResponse The token response object to build a token from\n     */\n    static fromTokenResponse(tokenResponse) {\n        let expiresAt;\n        if (tokenResponse.expiresIn) {\n            expiresAt = Math.floor(Date.now() / 1000) + tokenResponse.expiresIn;\n        }\n        return new AccessToken(tokenResponse.accessToken, expiresAt, tokenResponse.scope);\n    }\n    /**\n     * Creates a token from a storage string\n     * @param s JSON string representing the token\n     */\n    static fromString(s) {\n        let parsed;\n        try {\n            parsed = JSON.parse(s);\n        }\n        catch (error) {\n            return;\n        }\n        if (!parsed.token) {\n            return;\n        }\n        return new AccessToken(parsed.token, parsed.expiresAt, parsed.scope);\n    }\n    /**\n     * Calculates if the token is still active\n     */\n    get expired() {\n        if (this.expiresAt) {\n            const now = Math.floor(Date.now() / 1000);\n            const expiresIn = this.expiresAt - now;\n            return expiresIn <= 0;\n        }\n        return false;\n    }\n    /**\n     * Returns a JSON string suitable for writing in local storage\n     */\n    toStorageString() {\n        return JSON.stringify({\n            expiresAt: this.expiresAt,\n            scope: this.scope,\n            token: this.token,\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"module"}