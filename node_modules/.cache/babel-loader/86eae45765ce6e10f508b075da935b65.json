{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = retry;\n\nvar _wrapAsync = require('./internal/wrapAsync');\n\nvar _wrapAsync2 = _interopRequireDefault(_wrapAsync);\n\nvar _promiseCallback = require('./internal/promiseCallback');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction constant(value) {\n  return function () {\n    return value;\n  };\n}\n/**\n * Attempts to get a successful response from `task` no more than `times` times\n * before returning an error. If the task is successful, the `callback` will be\n * passed the result of the successful task. If all attempts fail, the callback\n * will be passed the error and result (if any) of the final attempt.\n *\n * @name retry\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @see [async.retryable]{@link module:ControlFlow.retryable}\n * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an\n * object with `times` and `interval` or a number.\n * * `times` - The number of attempts to make before giving up.  The default\n *   is `5`.\n * * `interval` - The time to wait between retries, in milliseconds.  The\n *   default is `0`. The interval may also be specified as a function of the\n *   retry count (see example).\n * * `errorFilter` - An optional synchronous function that is invoked on\n *   erroneous result. If it returns `true` the retry attempts will continue;\n *   if the function returns `false` the retry flow is aborted with the current\n *   attempt's error and result being returned to the final callback.\n *   Invoked with (err).\n * * If `opts` is a number, the number specifies the number of times to retry,\n *   with the default interval of `0`.\n * @param {AsyncFunction} task - An async function to retry.\n * Invoked with (callback).\n * @param {Function} [callback] - An optional callback which is called when the\n * task has succeeded, or after the final failed attempt. It receives the `err`\n * and `result` arguments of the last attempt at completing the `task`. Invoked\n * with (err, results).\n * @returns {Promise} a promise if no callback provided\n *\n * @example\n *\n * // The `retry` function can be used as a stand-alone control flow by passing\n * // a callback, as shown below:\n *\n * // try calling apiMethod 3 times\n * async.retry(3, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 3 times, waiting 200 ms between each retry\n * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 10 times with exponential backoff\n * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)\n * async.retry({\n *   times: 10,\n *   interval: function(retryCount) {\n *     return 50 * Math.pow(2, retryCount);\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod the default 5 times no delay between each retry\n * async.retry(apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod only when error condition satisfies, all other\n * // errors will abort the retry control flow and return to final callback\n * async.retry({\n *   errorFilter: function(err) {\n *     return err.message === 'Temporary error'; // only retry on a specific error\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // to retry individual methods that are not as reliable within other\n * // control flow functions, use the `retryable` wrapper:\n * async.auto({\n *     users: api.getUsers.bind(api),\n *     payments: async.retryable(3, api.getPayments.bind(api))\n * }, function(err, results) {\n *     // do something with the results\n * });\n *\n */\n\n\nconst DEFAULT_TIMES = 5;\nconst DEFAULT_INTERVAL = 0;\n\nfunction retry(opts, task, callback) {\n  var options = {\n    times: DEFAULT_TIMES,\n    intervalFunc: constant(DEFAULT_INTERVAL)\n  };\n\n  if (arguments.length < 3 && typeof opts === 'function') {\n    callback = task || (0, _promiseCallback.promiseCallback)();\n    task = opts;\n  } else {\n    parseTimes(options, opts);\n    callback = callback || (0, _promiseCallback.promiseCallback)();\n  }\n\n  if (typeof task !== 'function') {\n    throw new Error(\"Invalid arguments for async.retry\");\n  }\n\n  var _task = (0, _wrapAsync2.default)(task);\n\n  var attempt = 1;\n\n  function retryAttempt() {\n    _task((err, ...args) => {\n      if (err === false) return;\n\n      if (err && attempt++ < options.times && (typeof options.errorFilter != 'function' || options.errorFilter(err))) {\n        setTimeout(retryAttempt, options.intervalFunc(attempt - 1));\n      } else {\n        callback(err, ...args);\n      }\n    });\n  }\n\n  retryAttempt();\n  return callback[_promiseCallback.PROMISE_SYMBOL];\n}\n\nfunction parseTimes(acc, t) {\n  if (typeof t === 'object') {\n    acc.times = +t.times || DEFAULT_TIMES;\n    acc.intervalFunc = typeof t.interval === 'function' ? t.interval : constant(+t.interval || DEFAULT_INTERVAL);\n    acc.errorFilter = t.errorFilter;\n  } else if (typeof t === 'number' || typeof t === 'string') {\n    acc.times = +t || DEFAULT_TIMES;\n  } else {\n    throw new Error(\"Invalid arguments for async.retry\");\n  }\n}\n\nmodule.exports = exports['default'];","map":{"version":3,"sources":["/Users/helen/fi/protocol-demo/frontend/node_modules/@bitski/provider-engine/node_modules/async/retry.js"],"names":["Object","defineProperty","exports","value","default","retry","_wrapAsync","require","_wrapAsync2","_interopRequireDefault","_promiseCallback","obj","__esModule","constant","DEFAULT_TIMES","DEFAULT_INTERVAL","opts","task","callback","options","times","intervalFunc","arguments","length","promiseCallback","parseTimes","Error","_task","attempt","retryAttempt","err","args","errorFilter","setTimeout","PROMISE_SYMBOL","acc","t","interval","module"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = retry;\n\nvar _wrapAsync = require('./internal/wrapAsync');\n\nvar _wrapAsync2 = _interopRequireDefault(_wrapAsync);\n\nvar _promiseCallback = require('./internal/promiseCallback');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction constant(value) {\n    return function () {\n        return value;\n    };\n}\n\n/**\n * Attempts to get a successful response from `task` no more than `times` times\n * before returning an error. If the task is successful, the `callback` will be\n * passed the result of the successful task. If all attempts fail, the callback\n * will be passed the error and result (if any) of the final attempt.\n *\n * @name retry\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @see [async.retryable]{@link module:ControlFlow.retryable}\n * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an\n * object with `times` and `interval` or a number.\n * * `times` - The number of attempts to make before giving up.  The default\n *   is `5`.\n * * `interval` - The time to wait between retries, in milliseconds.  The\n *   default is `0`. The interval may also be specified as a function of the\n *   retry count (see example).\n * * `errorFilter` - An optional synchronous function that is invoked on\n *   erroneous result. If it returns `true` the retry attempts will continue;\n *   if the function returns `false` the retry flow is aborted with the current\n *   attempt's error and result being returned to the final callback.\n *   Invoked with (err).\n * * If `opts` is a number, the number specifies the number of times to retry,\n *   with the default interval of `0`.\n * @param {AsyncFunction} task - An async function to retry.\n * Invoked with (callback).\n * @param {Function} [callback] - An optional callback which is called when the\n * task has succeeded, or after the final failed attempt. It receives the `err`\n * and `result` arguments of the last attempt at completing the `task`. Invoked\n * with (err, results).\n * @returns {Promise} a promise if no callback provided\n *\n * @example\n *\n * // The `retry` function can be used as a stand-alone control flow by passing\n * // a callback, as shown below:\n *\n * // try calling apiMethod 3 times\n * async.retry(3, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 3 times, waiting 200 ms between each retry\n * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 10 times with exponential backoff\n * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)\n * async.retry({\n *   times: 10,\n *   interval: function(retryCount) {\n *     return 50 * Math.pow(2, retryCount);\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod the default 5 times no delay between each retry\n * async.retry(apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod only when error condition satisfies, all other\n * // errors will abort the retry control flow and return to final callback\n * async.retry({\n *   errorFilter: function(err) {\n *     return err.message === 'Temporary error'; // only retry on a specific error\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // to retry individual methods that are not as reliable within other\n * // control flow functions, use the `retryable` wrapper:\n * async.auto({\n *     users: api.getUsers.bind(api),\n *     payments: async.retryable(3, api.getPayments.bind(api))\n * }, function(err, results) {\n *     // do something with the results\n * });\n *\n */\nconst DEFAULT_TIMES = 5;\nconst DEFAULT_INTERVAL = 0;\n\nfunction retry(opts, task, callback) {\n    var options = {\n        times: DEFAULT_TIMES,\n        intervalFunc: constant(DEFAULT_INTERVAL)\n    };\n\n    if (arguments.length < 3 && typeof opts === 'function') {\n        callback = task || (0, _promiseCallback.promiseCallback)();\n        task = opts;\n    } else {\n        parseTimes(options, opts);\n        callback = callback || (0, _promiseCallback.promiseCallback)();\n    }\n\n    if (typeof task !== 'function') {\n        throw new Error(\"Invalid arguments for async.retry\");\n    }\n\n    var _task = (0, _wrapAsync2.default)(task);\n\n    var attempt = 1;\n    function retryAttempt() {\n        _task((err, ...args) => {\n            if (err === false) return;\n            if (err && attempt++ < options.times && (typeof options.errorFilter != 'function' || options.errorFilter(err))) {\n                setTimeout(retryAttempt, options.intervalFunc(attempt - 1));\n            } else {\n                callback(err, ...args);\n            }\n        });\n    }\n\n    retryAttempt();\n    return callback[_promiseCallback.PROMISE_SYMBOL];\n}\n\nfunction parseTimes(acc, t) {\n    if (typeof t === 'object') {\n        acc.times = +t.times || DEFAULT_TIMES;\n\n        acc.intervalFunc = typeof t.interval === 'function' ? t.interval : constant(+t.interval || DEFAULT_INTERVAL);\n\n        acc.errorFilter = t.errorFilter;\n    } else if (typeof t === 'number' || typeof t === 'string') {\n        acc.times = +t || DEFAULT_TIMES;\n    } else {\n        throw new Error(\"Invalid arguments for async.retry\");\n    }\n}\nmodule.exports = exports['default'];"]},"metadata":{},"sourceType":"script"}