{"ast":null,"code":"import { Subprovider } from '@bitski/provider-engine';\n/**\n * A subprovider that tracks and automatically increments the nonce on the client.\n * Heavily based on the provider-engine NonceTrackerSubprovider, but modified for\n * Bitski's transaction flow.\n */\n\nexport class NonceTrackerSubprovider extends Subprovider {\n  constructor() {\n    super();\n    this.nonceCache = new Map();\n  }\n\n  handleRequest(payload, next, end) {\n    switch (payload.method) {\n      case 'eth_getTransactionCount':\n        this.handleTransactionCountRequest(payload, next, end);\n        return;\n\n      case 'eth_sendTransaction':\n        this.handleSendTransactionRequest(payload, next);\n        return;\n\n      default:\n        next();\n        return;\n    }\n  } // Return cached result if present\n\n\n  handleTransactionCountRequest(payload, next, end) {\n    const blockTag = payload.params.length > 1 ? payload.params[1] : null; // Only handle pending tag\n\n    if (blockTag !== 'pending') {\n      next();\n      return;\n    }\n\n    const address = payload.params[0].toLowerCase();\n    const cachedResult = this.nonceCache.get(address); // Return cached result it we have it\n\n    if (cachedResult) {\n      end(null, cachedResult);\n      return;\n    } // Fallthrough and populate cache\n\n\n    next((err, result, cb) => {\n      if (!err) {\n        this.nonceCache.set(address, result);\n      }\n\n      cb();\n    });\n  }\n\n  toHex(num) {\n    const base16 = num.toString(16);\n    let hex = base16;\n\n    if (base16.length % 2 !== 0) {\n      hex = '0' + base16;\n    }\n\n    return '0x' + hex;\n  }\n\n  fromHex(str) {\n    return parseInt(str, 16);\n  }\n\n  nextNonce(nonce) {\n    const submittedNonce = this.fromHex(nonce);\n    const nextNonce = submittedNonce + 1;\n    return this.toHex(nextNonce);\n  } // Increment next nonce for address\n\n\n  handleSendTransactionRequest(payload, next) {\n    // Submit the request, then monitor the result\n    next((err, result, cb) => {\n      const transaction = payload.params.length > 0 ? payload.params[0] : {};\n      const submittedNonce = transaction.nonce;\n      const address = transaction.from;\n\n      if (!err) {\n        if (submittedNonce && address) {\n          // Increment nonce\n          const nextNonce = this.nextNonce(submittedNonce);\n          this.nonceCache.set(address, nextNonce);\n        }\n      } else {\n        // Remove cached value if we encounter an error\n        this.nonceCache.delete(address);\n      }\n\n      cb();\n    });\n  }\n\n}","map":{"version":3,"sources":["/Users/helen/fi/protocol-demo/frontend/node_modules/bitski-provider/dist/subproviders/nonce-tracker.js"],"names":["Subprovider","NonceTrackerSubprovider","constructor","nonceCache","Map","handleRequest","payload","next","end","method","handleTransactionCountRequest","handleSendTransactionRequest","blockTag","params","length","address","toLowerCase","cachedResult","get","err","result","cb","set","toHex","num","base16","toString","hex","fromHex","str","parseInt","nextNonce","nonce","submittedNonce","transaction","from","delete"],"mappings":"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","sourcesContent":["import { Subprovider } from '@bitski/provider-engine';\n/**\n * A subprovider that tracks and automatically increments the nonce on the client.\n * Heavily based on the provider-engine NonceTrackerSubprovider, but modified for\n * Bitski's transaction flow.\n */\nexport class NonceTrackerSubprovider extends Subprovider {\n    constructor() {\n        super();\n        this.nonceCache = new Map();\n    }\n    handleRequest(payload, next, end) {\n        switch (payload.method) {\n            case 'eth_getTransactionCount':\n                this.handleTransactionCountRequest(payload, next, end);\n                return;\n            case 'eth_sendTransaction':\n                this.handleSendTransactionRequest(payload, next);\n                return;\n            default:\n                next();\n                return;\n        }\n    }\n    // Return cached result if present\n    handleTransactionCountRequest(payload, next, end) {\n        const blockTag = payload.params.length > 1 ? payload.params[1] : null;\n        // Only handle pending tag\n        if (blockTag !== 'pending') {\n            next();\n            return;\n        }\n        const address = payload.params[0].toLowerCase();\n        const cachedResult = this.nonceCache.get(address);\n        // Return cached result it we have it\n        if (cachedResult) {\n            end(null, cachedResult);\n            return;\n        }\n        // Fallthrough and populate cache\n        next((err, result, cb) => {\n            if (!err) {\n                this.nonceCache.set(address, result);\n            }\n            cb();\n        });\n    }\n    toHex(num) {\n        const base16 = num.toString(16);\n        let hex = base16;\n        if (base16.length % 2 !== 0) {\n            hex = '0' + base16;\n        }\n        return '0x' + hex;\n    }\n    fromHex(str) {\n        return parseInt(str, 16);\n    }\n    nextNonce(nonce) {\n        const submittedNonce = this.fromHex(nonce);\n        const nextNonce = submittedNonce + 1;\n        return this.toHex(nextNonce);\n    }\n    // Increment next nonce for address\n    handleSendTransactionRequest(payload, next) {\n        // Submit the request, then monitor the result\n        next((err, result, cb) => {\n            const transaction = payload.params.length > 0 ? payload.params[0] : {};\n            const submittedNonce = transaction.nonce;\n            const address = transaction.from;\n            if (!err) {\n                if (submittedNonce && address) {\n                    // Increment nonce\n                    const nextNonce = this.nextNonce(submittedNonce);\n                    this.nonceCache.set(address, nextNonce);\n                }\n            }\n            else {\n                // Remove cached value if we encounter an error\n                this.nonceCache.delete(address);\n            }\n            cb();\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"module"}