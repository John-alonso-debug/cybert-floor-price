{"ast":null,"code":"import { Kovan, Mainnet, Rinkeby } from 'bitski-provider';\nimport { LOGIN_HINT_SIGNUP } from './auth/oauth-manager';\nimport { OpenidAuthProvider } from './auth/openid-auth-provider';\nimport { ConnectButton, ConnectButtonSize } from './components/connect-button';\nimport { SDK_VERSION } from './constants';\nimport { BitskiBrowserEngine } from './providers/bitski-browser-engine';\nimport css from './styles/index';\nimport { processCallback } from './utils/callback';\nimport { LocalStorageStore } from './utils/localstorage-store';\nexport var OAuthSignInMethod;\n\n(function (OAuthSignInMethod) {\n  OAuthSignInMethod[\"Redirect\"] = \"REDIRECT\";\n  OAuthSignInMethod[\"Popup\"] = \"POPUP\";\n  OAuthSignInMethod[\"Silent\"] = \"SILENT\";\n})(OAuthSignInMethod || (OAuthSignInMethod = {}));\n\nexport var AuthenticationStatus;\n\n(function (AuthenticationStatus) {\n  AuthenticationStatus[\"Connected\"] = \"CONNECTED\";\n  AuthenticationStatus[\"Expired\"] = \"EXPIRED\";\n  AuthenticationStatus[\"NotConnected\"] = \"NOT_CONNECTED\";\n})(AuthenticationStatus || (AuthenticationStatus = {})); // Customize token and user caching\n\n\nexport { LocalStorageStore }; // Sign-in Options\n\nexport { LOGIN_HINT_SIGNUP }; // Networks\n\nexport { Mainnet, Rinkeby, Kovan }; // Connect Button\n\nexport { ConnectButtonSize }; // Errors\n\nexport { AuthenticationError, AuthenticationErrorCode } from './errors/authentication-error';\nexport { ParseError, ParseErrorCode } from './errors/parse-error';\nexport { SignerError, SignerErrorCode } from './errors/signer-error';\n/**\n * Bitski SDK\n */\n\nexport class Bitski {\n  /**\n   * @param clientId OAuth Client ID\n   * @param redirectUri Redirect uri, defaults to the current url. This should be the location of your callback html file.\n   * @param additionalScopes To use custom scopes, add them here. The default value is ['offline'].\n   * Note: Make sure your app is approved for the scopes you are requesting first.\n   * @param options Other OAuth settings. Don't change these unless you know what you are doing.\n   */\n  constructor(clientId, redirectUri, additionalScopes, options) {\n    this.engines = new Map();\n    this.signoutHandlers = [];\n    this.clientId = clientId;\n    this.sdkVersion = SDK_VERSION;\n    this.authProvider = new OpenidAuthProvider(clientId, redirectUri || window.location.href, additionalScopes, options);\n\n    if (document && document.body) {\n      this.injectStyles();\n    } else {\n      window.addEventListener('load', () => {\n        this.injectStyles();\n      });\n    }\n\n    this.authProvider.signOutCallback = this.onSignOut.bind(this);\n  }\n  /**\n   * Alternative to using our static callback.html file. Call this from your own redirect page.\n   */\n\n\n  static callback() {\n    processCallback();\n  }\n  /**\n   * Returns a new web3 provider for a given network.\n   * @param options options for the provider, or a network name\n   */\n\n\n  getProvider(options) {\n    // Check cache for existing provider\n    const existingProvider = this.engines.get(JSON.stringify(options));\n\n    if (existingProvider) {\n      existingProvider.start();\n      return existingProvider;\n    } // Create a new provider if one does not exist\n\n\n    let normalizedOptions = {};\n\n    if (options && typeof options !== 'string') {\n      normalizedOptions = options;\n    }\n\n    const network = this.networkFromProviderOptions(options);\n\n    if (network === Kovan && normalizedOptions.minGasPrice == null) {\n      normalizedOptions.minGasPrice = 1;\n    }\n\n    const newProvider = this.createProvider(network, normalizedOptions);\n    newProvider.start();\n    this.engines.set(JSON.stringify(options), newProvider);\n    return newProvider;\n  }\n  /**\n   * Creates a sign in with bitski button to add to your app. If an HTML element is passed in as the\n   * first parameter, it will automatically add it to the DOM inside that element. Make sure to add\n   * a callback to get notified of login events.\n   * @param options {ConnectButtonOptions} Optional configuration for the button\n   * @param callback Post-login callback. Called when sign in is complete. Not applicable for redirect login method.\n   */\n\n\n  getConnectButton(options, callback) {\n    return new ConnectButton(this.authProvider, options, callback);\n  }\n  /**\n   * Signs in or connects to bitski depending on the user's auth state.\n   * Since it may open a popup, this method must be called from user interaction handler,\n   * such as a click or tap handler.\n   * @param options Provide SignInOptions for the sign in request. See signIn() for more info.\n   */\n\n\n  start(options) {\n    return this.authProvider.signInOrConnect(undefined, options);\n  }\n  /**\n   * Check the logged in state of the user\n   */\n\n\n  get authStatus() {\n    return this.authProvider.authStatus;\n  }\n  /**\n   * Starts the sign in flow. Will trigger a popup window over your app, so it must be called within a user interaction handler such as a click.\n   * @param options Optionally provide additional options for the sign in request.\n   *\n   * You can use the options parameter to request that we show the sign up form instead of the sign in form:\n   * ```javascript\n   * import { LOGIN_HINT_SIGNUP } from 'bitski';\n   *\n   * await bitski.signIn({ login_hint: LOGIN_HINT_SIGNUP });\n   * ```\n   */\n\n\n  signIn(options) {\n    return this.authProvider.signIn(OAuthSignInMethod.Popup, options);\n  }\n  /**\n   * Gets the current signed in user. Will reject if we are not signed in.\n   */\n\n\n  getUser() {\n    return this.authProvider.getUser();\n  }\n  /**\n   * Connects to bitski to get a valid access token if possible.\n   */\n\n\n  connect() {\n    return this.authProvider.connect();\n  }\n  /**\n   * Starts redirect sign in flow. This is an alternative flow to the popup that all takes place in the same browser window.\n   * @param options Optionally provide additional options for the sign in request. See signIn() for more info.\n   */\n\n\n  signInRedirect(options) {\n    this.authProvider.signIn(OAuthSignInMethod.Redirect, options);\n  }\n  /**\n   * Call from your oauth redirect page.\n   */\n\n\n  redirectCallback() {\n    return this.authProvider.redirectCallback();\n  }\n  /**\n   * Retrieves the current access token for the user, if logged in.\n   */\n\n\n  getCurrentAccessToken() {\n    return this.authProvider.getAccessToken();\n  }\n  /**\n   * Retrieves the current refresh token for the user, if logged in.\n   * Requires that the user has approved your application for offline access.\n   */\n\n\n  getCurrentRefreshToken() {\n    return this.authProvider.getRefreshToken();\n  }\n  /**\n   * Register a callback to be called on sign out. This is a good practice,\n   * since there may be situations where you are signed out unexpectedly.\n   * @param fn Your callback function\n   */\n\n\n  addSignOutHandler(fn) {\n    this.signoutHandlers.push(fn);\n  }\n  /**\n   * Remove a registered signout callback\n   * @param fn Your callback function\n   */\n\n\n  removeSignOutHandler(fn) {\n    const index = this.signoutHandlers.findIndex(item => item === fn);\n\n    if (index >= 0) {\n      this.signoutHandlers.splice(index, 1);\n    }\n  }\n  /**\n   * Sign the current user out of your application.\n   */\n\n\n  signOut() {\n    this.engines.forEach(engine => engine.emit('signOut'));\n    return this.authProvider.signOut();\n  }\n\n  createProvider(network, options = {}) {\n    return new BitskiBrowserEngine(this.clientId, this.authProvider, this.sdkVersion, network, options);\n  }\n\n  networkFromName(networkName) {\n    switch (networkName) {\n      case '':\n      case 'mainnet':\n        return Mainnet;\n\n      case 'rinkeby':\n        return Rinkeby;\n\n      case 'kovan':\n        return Kovan;\n\n      default:\n        throw new Error(`Unsupported network name ${networkName}. Try passing a \\`network\\` in the options instead.`);\n    }\n  }\n\n  networkFromProviderOptions(options) {\n    if (!options) {\n      return Mainnet;\n    }\n\n    if (typeof options === 'string') {\n      return this.networkFromName(options);\n    }\n\n    if (options.network) {\n      return options.network;\n    }\n\n    if (options.networkName) {\n      return this.networkFromName(options.networkName);\n    }\n\n    return Mainnet;\n  }\n\n  onSignOut() {\n    this.signoutHandlers.forEach(cb => {\n      cb();\n    });\n  }\n  /**\n   * Embeds Bitski's UI styles\n   */\n\n\n  injectStyles() {\n    if (document.getElementById('BitskiEmbeddedStyles')) {\n      return;\n    }\n\n    const style = document.createElement('style');\n    style.setAttribute('type', 'text/css');\n    style.setAttribute('id', 'BitskiEmbeddedStyles');\n    style.appendChild(document.createTextNode(css));\n    const head = document.head || document.getElementsByTagName('head')[0];\n    head.appendChild(style);\n  }\n\n}","map":{"version":3,"sources":["/Users/helen/fi/protocol-demo/frontend/node_modules/bitski/dist/esm/bitski.js"],"names":["Kovan","Mainnet","Rinkeby","LOGIN_HINT_SIGNUP","OpenidAuthProvider","ConnectButton","ConnectButtonSize","SDK_VERSION","BitskiBrowserEngine","css","processCallback","LocalStorageStore","OAuthSignInMethod","AuthenticationStatus","AuthenticationError","AuthenticationErrorCode","ParseError","ParseErrorCode","SignerError","SignerErrorCode","Bitski","constructor","clientId","redirectUri","additionalScopes","options","engines","Map","signoutHandlers","sdkVersion","authProvider","window","location","href","document","body","injectStyles","addEventListener","signOutCallback","onSignOut","bind","callback","getProvider","existingProvider","get","JSON","stringify","start","normalizedOptions","network","networkFromProviderOptions","minGasPrice","newProvider","createProvider","set","getConnectButton","signInOrConnect","undefined","authStatus","signIn","Popup","getUser","connect","signInRedirect","Redirect","redirectCallback","getCurrentAccessToken","getAccessToken","getCurrentRefreshToken","getRefreshToken","addSignOutHandler","fn","push","removeSignOutHandler","index","findIndex","item","splice","signOut","forEach","engine","emit","networkFromName","networkName","Error","cb","getElementById","style","createElement","setAttribute","appendChild","createTextNode","head","getElementsByTagName"],"mappings":"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","sourcesContent":["import { Kovan, Mainnet, Rinkeby } from 'bitski-provider';\nimport { LOGIN_HINT_SIGNUP } from './auth/oauth-manager';\nimport { OpenidAuthProvider } from './auth/openid-auth-provider';\nimport { ConnectButton, ConnectButtonSize } from './components/connect-button';\nimport { SDK_VERSION } from './constants';\nimport { BitskiBrowserEngine } from './providers/bitski-browser-engine';\nimport css from './styles/index';\nimport { processCallback } from './utils/callback';\nimport { LocalStorageStore } from './utils/localstorage-store';\nexport var OAuthSignInMethod;\n(function (OAuthSignInMethod) {\n    OAuthSignInMethod[\"Redirect\"] = \"REDIRECT\";\n    OAuthSignInMethod[\"Popup\"] = \"POPUP\";\n    OAuthSignInMethod[\"Silent\"] = \"SILENT\";\n})(OAuthSignInMethod || (OAuthSignInMethod = {}));\nexport var AuthenticationStatus;\n(function (AuthenticationStatus) {\n    AuthenticationStatus[\"Connected\"] = \"CONNECTED\";\n    AuthenticationStatus[\"Expired\"] = \"EXPIRED\";\n    AuthenticationStatus[\"NotConnected\"] = \"NOT_CONNECTED\";\n})(AuthenticationStatus || (AuthenticationStatus = {}));\n// Customize token and user caching\nexport { LocalStorageStore };\n// Sign-in Options\nexport { LOGIN_HINT_SIGNUP };\n// Networks\nexport { Mainnet, Rinkeby, Kovan };\n// Connect Button\nexport { ConnectButtonSize };\n// Errors\nexport { AuthenticationError, AuthenticationErrorCode } from './errors/authentication-error';\nexport { ParseError, ParseErrorCode } from './errors/parse-error';\nexport { SignerError, SignerErrorCode } from './errors/signer-error';\n/**\n * Bitski SDK\n */\nexport class Bitski {\n    /**\n     * @param clientId OAuth Client ID\n     * @param redirectUri Redirect uri, defaults to the current url. This should be the location of your callback html file.\n     * @param additionalScopes To use custom scopes, add them here. The default value is ['offline'].\n     * Note: Make sure your app is approved for the scopes you are requesting first.\n     * @param options Other OAuth settings. Don't change these unless you know what you are doing.\n     */\n    constructor(clientId, redirectUri, additionalScopes, options) {\n        this.engines = new Map();\n        this.signoutHandlers = [];\n        this.clientId = clientId;\n        this.sdkVersion = SDK_VERSION;\n        this.authProvider = new OpenidAuthProvider(clientId, redirectUri || window.location.href, additionalScopes, options);\n        if (document && document.body) {\n            this.injectStyles();\n        }\n        else {\n            window.addEventListener('load', () => {\n                this.injectStyles();\n            });\n        }\n        this.authProvider.signOutCallback = this.onSignOut.bind(this);\n    }\n    /**\n     * Alternative to using our static callback.html file. Call this from your own redirect page.\n     */\n    static callback() {\n        processCallback();\n    }\n    /**\n     * Returns a new web3 provider for a given network.\n     * @param options options for the provider, or a network name\n     */\n    getProvider(options) {\n        // Check cache for existing provider\n        const existingProvider = this.engines.get(JSON.stringify(options));\n        if (existingProvider) {\n            existingProvider.start();\n            return existingProvider;\n        }\n        // Create a new provider if one does not exist\n        let normalizedOptions = {};\n        if (options && typeof options !== 'string') {\n            normalizedOptions = options;\n        }\n        const network = this.networkFromProviderOptions(options);\n        if (network === Kovan && normalizedOptions.minGasPrice == null) {\n            normalizedOptions.minGasPrice = 1;\n        }\n        const newProvider = this.createProvider(network, normalizedOptions);\n        newProvider.start();\n        this.engines.set(JSON.stringify(options), newProvider);\n        return newProvider;\n    }\n    /**\n     * Creates a sign in with bitski button to add to your app. If an HTML element is passed in as the\n     * first parameter, it will automatically add it to the DOM inside that element. Make sure to add\n     * a callback to get notified of login events.\n     * @param options {ConnectButtonOptions} Optional configuration for the button\n     * @param callback Post-login callback. Called when sign in is complete. Not applicable for redirect login method.\n     */\n    getConnectButton(options, callback) {\n        return new ConnectButton(this.authProvider, options, callback);\n    }\n    /**\n     * Signs in or connects to bitski depending on the user's auth state.\n     * Since it may open a popup, this method must be called from user interaction handler,\n     * such as a click or tap handler.\n     * @param options Provide SignInOptions for the sign in request. See signIn() for more info.\n     */\n    start(options) {\n        return this.authProvider.signInOrConnect(undefined, options);\n    }\n    /**\n     * Check the logged in state of the user\n     */\n    get authStatus() {\n        return this.authProvider.authStatus;\n    }\n    /**\n     * Starts the sign in flow. Will trigger a popup window over your app, so it must be called within a user interaction handler such as a click.\n     * @param options Optionally provide additional options for the sign in request.\n     *\n     * You can use the options parameter to request that we show the sign up form instead of the sign in form:\n     * ```javascript\n     * import { LOGIN_HINT_SIGNUP } from 'bitski';\n     *\n     * await bitski.signIn({ login_hint: LOGIN_HINT_SIGNUP });\n     * ```\n     */\n    signIn(options) {\n        return this.authProvider.signIn(OAuthSignInMethod.Popup, options);\n    }\n    /**\n     * Gets the current signed in user. Will reject if we are not signed in.\n     */\n    getUser() {\n        return this.authProvider.getUser();\n    }\n    /**\n     * Connects to bitski to get a valid access token if possible.\n     */\n    connect() {\n        return this.authProvider.connect();\n    }\n    /**\n     * Starts redirect sign in flow. This is an alternative flow to the popup that all takes place in the same browser window.\n     * @param options Optionally provide additional options for the sign in request. See signIn() for more info.\n     */\n    signInRedirect(options) {\n        this.authProvider.signIn(OAuthSignInMethod.Redirect, options);\n    }\n    /**\n     * Call from your oauth redirect page.\n     */\n    redirectCallback() {\n        return this.authProvider.redirectCallback();\n    }\n    /**\n     * Retrieves the current access token for the user, if logged in.\n     */\n    getCurrentAccessToken() {\n        return this.authProvider.getAccessToken();\n    }\n    /**\n     * Retrieves the current refresh token for the user, if logged in.\n     * Requires that the user has approved your application for offline access.\n     */\n    getCurrentRefreshToken() {\n        return this.authProvider.getRefreshToken();\n    }\n    /**\n     * Register a callback to be called on sign out. This is a good practice,\n     * since there may be situations where you are signed out unexpectedly.\n     * @param fn Your callback function\n     */\n    addSignOutHandler(fn) {\n        this.signoutHandlers.push(fn);\n    }\n    /**\n     * Remove a registered signout callback\n     * @param fn Your callback function\n     */\n    removeSignOutHandler(fn) {\n        const index = this.signoutHandlers.findIndex((item) => item === fn);\n        if (index >= 0) {\n            this.signoutHandlers.splice(index, 1);\n        }\n    }\n    /**\n     * Sign the current user out of your application.\n     */\n    signOut() {\n        this.engines.forEach((engine) => engine.emit('signOut'));\n        return this.authProvider.signOut();\n    }\n    createProvider(network, options = {}) {\n        return new BitskiBrowserEngine(this.clientId, this.authProvider, this.sdkVersion, network, options);\n    }\n    networkFromName(networkName) {\n        switch (networkName) {\n            case '':\n            case 'mainnet':\n                return Mainnet;\n            case 'rinkeby':\n                return Rinkeby;\n            case 'kovan':\n                return Kovan;\n            default:\n                throw new Error(`Unsupported network name ${networkName}. Try passing a \\`network\\` in the options instead.`);\n        }\n    }\n    networkFromProviderOptions(options) {\n        if (!options) {\n            return Mainnet;\n        }\n        if (typeof options === 'string') {\n            return this.networkFromName(options);\n        }\n        if (options.network) {\n            return options.network;\n        }\n        if (options.networkName) {\n            return this.networkFromName(options.networkName);\n        }\n        return Mainnet;\n    }\n    onSignOut() {\n        this.signoutHandlers.forEach((cb) => {\n            cb();\n        });\n    }\n    /**\n     * Embeds Bitski's UI styles\n     */\n    injectStyles() {\n        if (document.getElementById('BitskiEmbeddedStyles')) {\n            return;\n        }\n        const style = document.createElement('style');\n        style.setAttribute('type', 'text/css');\n        style.setAttribute('id', 'BitskiEmbeddedStyles');\n        style.appendChild(document.createTextNode(css));\n        const head = document.head || document.getElementsByTagName('head')[0];\n        head.appendChild(style);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}