{"ast":null,"code":"import { Subprovider } from '@bitski/provider-engine';\n/**\n * A subprovider that automatically populates missing transaction details.\n * This is needed because it has become common to submit transactions with\n * only some of the parameters and rely on the provider or node to fill in the rest.\n */\n\nexport class TransactionValidatorSubprovider extends Subprovider {\n  constructor(minGasPrice = 0) {\n    super();\n    this.minGasPrice = minGasPrice;\n  }\n\n  handleRequest(payload, next, _) {\n    // Only handle transactions\n    if (payload.method === 'eth_sendTransaction' || payload.method === 'eth_signTransaction') {\n      this.populateTransactionFields(payload).then(() => {\n        // Payload was modified. Continue.\n        next();\n      }).catch(() => {\n        // Fall through if we cannot populate fields\n        next();\n      });\n    } else {\n      next();\n    }\n  } // Examine transaction and populate missing params\n\n\n  async populateTransactionFields(payload) {\n    const params = payload.params || [];\n    let transaction = {};\n\n    if (params.length > 0) {\n      transaction = params[0];\n    }\n\n    const promises = []; // Populate missing from with default account\n\n    if (transaction.from === undefined) {\n      const accounts = await this.getAccounts();\n      transaction.from = accounts[0];\n    } // Populate missing gasPrice\n\n\n    if (transaction.gasPrice === undefined) {\n      promises.push(this.estimateGasPrice());\n    } else {\n      promises.push(transaction.gasPrice);\n    } // Populate missing nonce\n\n\n    if (transaction.nonce === undefined) {\n      promises.push(this.getNonce(transaction.from));\n    } else {\n      promises.push(transaction.nonce);\n    } // Populate missing gas\n\n\n    if (transaction.gas === undefined) {\n      promises.push(this.estimateGas(transaction));\n    } else {\n      promises.push(transaction.gas);\n    } // Execute promises\n\n\n    const values = await Promise.all(promises); // Update parameters with loaded values. Must be very careful with the indexes here.\n\n    transaction.gasPrice = values[0];\n    transaction.nonce = values[1];\n    transaction.gas = values[2]; // Set the params on the payload\n\n    payload.params[0] = transaction;\n    return payload;\n  }\n\n  async getNonce(address) {\n    const request = {\n      id: 0,\n      jsonrpc: '2.0',\n      method: 'eth_getTransactionCount',\n      params: [address, 'latest']\n    };\n    return this.performRequest(request);\n  }\n\n  async getAccounts() {\n    const request = {\n      id: 0,\n      jsonrpc: '2.0',\n      method: 'eth_accounts',\n      params: []\n    };\n    return this.performRequest(request);\n  }\n\n  async estimateGas(transaction) {\n    const request = {\n      id: 0,\n      jsonrpc: '2.0',\n      method: 'eth_estimateGas',\n      params: [transaction]\n    };\n    return this.performRequest(request);\n  }\n\n  async estimateGasPrice() {\n    const request = {\n      id: 0,\n      jsonrpc: '2.0',\n      method: 'eth_gasPrice',\n      params: []\n    };\n    return this.performRequest(request).then(gasPrice => {\n      if (gasPrice === '0x0') {\n        return `0x${this.minGasPrice.toString(16)}`;\n      }\n\n      return gasPrice;\n    });\n  } // Wraps emitPayload in a promise\n\n\n  performRequest(payload) {\n    return new Promise((fulfill, reject) => {\n      this.emitPayload(payload, (err, result) => {\n        if (err) {\n          reject(err);\n        } else {\n          fulfill(result.result);\n        }\n      });\n    });\n  }\n\n}","map":{"version":3,"sources":["/Users/helen/fi/protocol-demo/frontend/node_modules/bitski-provider/dist/subproviders/transaction-validator.js"],"names":["Subprovider","TransactionValidatorSubprovider","constructor","minGasPrice","handleRequest","payload","next","_","method","populateTransactionFields","then","catch","params","transaction","length","promises","from","undefined","accounts","getAccounts","gasPrice","push","estimateGasPrice","nonce","getNonce","gas","estimateGas","values","Promise","all","address","request","id","jsonrpc","performRequest","toString","fulfill","reject","emitPayload","err","result"],"mappings":"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","sourcesContent":["import { Subprovider } from '@bitski/provider-engine';\n/**\n * A subprovider that automatically populates missing transaction details.\n * This is needed because it has become common to submit transactions with\n * only some of the parameters and rely on the provider or node to fill in the rest.\n */\nexport class TransactionValidatorSubprovider extends Subprovider {\n    constructor(minGasPrice = 0) {\n        super();\n        this.minGasPrice = minGasPrice;\n    }\n    handleRequest(payload, next, _) {\n        // Only handle transactions\n        if (payload.method === 'eth_sendTransaction' || payload.method === 'eth_signTransaction') {\n            this.populateTransactionFields(payload).then(() => {\n                // Payload was modified. Continue.\n                next();\n            }).catch(() => {\n                // Fall through if we cannot populate fields\n                next();\n            });\n        }\n        else {\n            next();\n        }\n    }\n    // Examine transaction and populate missing params\n    async populateTransactionFields(payload) {\n        const params = payload.params || [];\n        let transaction = {};\n        if (params.length > 0) {\n            transaction = params[0];\n        }\n        const promises = [];\n        // Populate missing from with default account\n        if (transaction.from === undefined) {\n            const accounts = await this.getAccounts();\n            transaction.from = accounts[0];\n        }\n        // Populate missing gasPrice\n        if (transaction.gasPrice === undefined) {\n            promises.push(this.estimateGasPrice());\n        }\n        else {\n            promises.push(transaction.gasPrice);\n        }\n        // Populate missing nonce\n        if (transaction.nonce === undefined) {\n            promises.push(this.getNonce(transaction.from));\n        }\n        else {\n            promises.push(transaction.nonce);\n        }\n        // Populate missing gas\n        if (transaction.gas === undefined) {\n            promises.push(this.estimateGas(transaction));\n        }\n        else {\n            promises.push(transaction.gas);\n        }\n        // Execute promises\n        const values = await Promise.all(promises);\n        // Update parameters with loaded values. Must be very careful with the indexes here.\n        transaction.gasPrice = values[0];\n        transaction.nonce = values[1];\n        transaction.gas = values[2];\n        // Set the params on the payload\n        payload.params[0] = transaction;\n        return payload;\n    }\n    async getNonce(address) {\n        const request = {\n            id: 0,\n            jsonrpc: '2.0',\n            method: 'eth_getTransactionCount',\n            params: [address, 'latest'],\n        };\n        return this.performRequest(request);\n    }\n    async getAccounts() {\n        const request = {\n            id: 0,\n            jsonrpc: '2.0',\n            method: 'eth_accounts',\n            params: [],\n        };\n        return this.performRequest(request);\n    }\n    async estimateGas(transaction) {\n        const request = {\n            id: 0,\n            jsonrpc: '2.0',\n            method: 'eth_estimateGas',\n            params: [transaction],\n        };\n        return this.performRequest(request);\n    }\n    async estimateGasPrice() {\n        const request = {\n            id: 0,\n            jsonrpc: '2.0',\n            method: 'eth_gasPrice',\n            params: [],\n        };\n        return this.performRequest(request).then((gasPrice) => {\n            if (gasPrice === '0x0') {\n                return `0x${this.minGasPrice.toString(16)}`;\n            }\n            return gasPrice;\n        });\n    }\n    // Wraps emitPayload in a promise\n    performRequest(payload) {\n        return new Promise((fulfill, reject) => {\n            this.emitPayload(payload, (err, result) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    fulfill(result.result);\n                }\n            });\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"module"}