{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MerkleTree = void 0;\n\nconst buffer_reverse_1 = __importDefault(require(\"buffer-reverse\"));\n\nconst sha256_1 = __importDefault(require(\"crypto-js/sha256\"));\n\nconst Base_1 = __importDefault(require(\"./Base\"));\n\nconst treeify_1 = __importDefault(require(\"treeify\"));\n/**\n * Class reprensenting a Merkle Tree\n * @namespace MerkleTree\n */\n\n\nclass MerkleTree extends Base_1.default {\n  /**\n   * @desc Constructs a Merkle Tree.\n   * All nodes and leaves are stored as Buffers.\n   * Lonely leaf nodes are promoted to the next level up without being hashed again.\n   * @param {Buffer[]} leaves - Array of hashed leaves. Each leaf must be a Buffer.\n   * @param {Function} hashFunction - Hash function to use for hashing leaves and nodes\n   * @param {Object} options - Additional options\n   * @example\n   *```js\n   *const MerkleTree = require('merkletreejs')\n   *const crypto = require('crypto')\n   *\n   *function sha256(data) {\n   *  // returns Buffer\n   *  return crypto.createHash('sha256').update(data).digest()\n   *}\n   *\n   *const leaves = ['a', 'b', 'c'].map(x => keccak(x))\n   *\n   *const tree = new MerkleTree(leaves, sha256)\n   *```\n   */\n  constructor(leaves, hashFn = sha256_1.default, options = {}) {\n    super();\n    this.duplicateOdd = false;\n    this.hashLeaves = false;\n    this.isBitcoinTree = false;\n    this.leaves = [];\n    this.layers = [];\n    this.sortLeaves = false;\n    this.sortPairs = false;\n    this.sort = false;\n    this.fillDefaultHash = null;\n    this.isBitcoinTree = !!options.isBitcoinTree;\n    this.hashLeaves = !!options.hashLeaves;\n    this.sortLeaves = !!options.sortLeaves;\n    this.sortPairs = !!options.sortPairs;\n\n    if (options.fillDefaultHash) {\n      if (typeof options.fillDefaultHash === 'function') {\n        this.fillDefaultHash = options.fillDefaultHash;\n      } else if (Buffer.isBuffer(options.fillDefaultHash) || typeof options.fillDefaultHash === 'string') {\n        this.fillDefaultHash = (idx, hashFn) => options.fillDefaultHash;\n      } else {\n        throw new Error('method \"fillDefaultHash\" must be a function, Buffer, or string');\n      }\n    }\n\n    this.sort = !!options.sort;\n\n    if (this.sort) {\n      this.sortLeaves = true;\n      this.sortPairs = true;\n    }\n\n    this.duplicateOdd = !!options.duplicateOdd;\n    this.hashFn = this._bufferifyFn(hashFn);\n\n    if (this.hashLeaves) {\n      leaves = leaves.map(x => this.hashFn(x));\n    }\n\n    this.leaves = leaves.map(x => this.bufferify(x));\n\n    if (this.sortLeaves) {\n      this.leaves = this.leaves.sort(Buffer.compare);\n    }\n\n    if (this.fillDefaultHash) {\n      for (let i = 0; i < Math.pow(2, Math.ceil(Math.log2(this.leaves.length))); i++) {\n        if (i >= this.leaves.length) {\n          this.leaves.push(this.bufferify(this.fillDefaultHash(i, this.hashFn)));\n        }\n      }\n    }\n\n    this.layers = [this.leaves];\n\n    this._createHashes(this.leaves);\n  }\n\n  _createHashes(nodes) {\n    while (nodes.length > 1) {\n      const layerIndex = this.layers.length;\n      this.layers.push([]);\n\n      for (let i = 0; i < nodes.length; i += 2) {\n        if (i + 1 === nodes.length) {\n          if (nodes.length % 2 === 1) {\n            let data = nodes[nodes.length - 1];\n            let hash = data; // is bitcoin tree\n\n            if (this.isBitcoinTree) {\n              // Bitcoin method of duplicating the odd ending nodes\n              data = Buffer.concat([buffer_reverse_1.default(data), buffer_reverse_1.default(data)]);\n              hash = this.hashFn(data);\n              hash = buffer_reverse_1.default(this.hashFn(hash));\n              this.layers[layerIndex].push(hash);\n              continue;\n            } else {\n              if (this.duplicateOdd) {// continue with creating layer\n              } else {\n                // push copy of hash and continue iteration\n                this.layers[layerIndex].push(nodes[i]);\n                continue;\n              }\n            }\n          }\n        }\n\n        const left = nodes[i];\n        const right = i + 1 === nodes.length ? left : nodes[i + 1];\n        let data = null;\n        let combined = null;\n\n        if (this.isBitcoinTree) {\n          combined = [buffer_reverse_1.default(left), buffer_reverse_1.default(right)];\n        } else {\n          combined = [left, right];\n        }\n\n        if (this.sortPairs) {\n          combined.sort(Buffer.compare);\n        }\n\n        data = Buffer.concat(combined);\n        let hash = this.hashFn(data); // double hash if bitcoin tree\n\n        if (this.isBitcoinTree) {\n          hash = buffer_reverse_1.default(this.hashFn(hash));\n        }\n\n        this.layers[layerIndex].push(hash);\n      }\n\n      nodes = this.layers[layerIndex];\n    }\n  }\n  /**\n   * getLeaves\n   * @desc Returns array of leaves of Merkle Tree.\n   * @return {Buffer[]}\n   * @example\n   *```js\n   *const leaves = tree.getLeaves()\n   *```\n   */\n\n\n  getLeaves(values) {\n    if (Array.isArray(values)) {\n      if (this.hashLeaves) {\n        values = values.map(x => this.hashFn(x));\n\n        if (this.sortLeaves) {\n          values = values.sort(Buffer.compare);\n        }\n      }\n\n      return this.leaves.filter(x => this._bufferIndexOf(values, x) !== -1);\n    }\n\n    return this.leaves;\n  }\n  /**\n   * getHexLeaves\n   * @desc Returns array of leaves of Merkle Tree as hex strings.\n   * @return {String[]}\n   * @example\n   *```js\n   *const leaves = tree.getHexLeaves()\n   *```\n   */\n\n\n  getHexLeaves() {\n    return this.leaves.map(x => this.bufferToHex(x));\n  }\n  /**\n   * marshalLeaves\n   * @desc Returns array of leaves of Merkle Tree as a JSON string.\n   * @param {String[]|Buffer[]} - Merkle tree leaves\n   * @return {String} - List of leaves as JSON string\n   * @example\n   *```js\n   *const jsonStr = MerkleTree.marshalLeaves(leaves)\n   *```\n   */\n\n\n  static marshalLeaves(leaves) {\n    return JSON.stringify(leaves.map(x => MerkleTree.bufferToHex(x)), null, 2);\n  }\n  /**\n   * unmarshalLeaves\n   * @desc Returns array of leaves of Merkle Tree as a Buffers.\n   * @param {String|Object} - JSON stringified leaves\n   * @return {Buffer[]} - Unmarshalled list of leaves\n   * @example\n   *```js\n   *const leaves = MerkleTree.unmarshalLeaves(jsonStr)\n   *```\n   */\n\n\n  static unmarshalLeaves(jsonStr) {\n    let parsed = null;\n\n    if (typeof jsonStr === 'string') {\n      parsed = JSON.parse(jsonStr);\n    } else if (jsonStr instanceof Object) {\n      parsed = jsonStr;\n    } else {\n      throw new Error('Expected type of string or object');\n    }\n\n    if (!parsed) {\n      return [];\n    }\n\n    if (!Array.isArray(parsed)) {\n      throw new Error('Expected JSON string to be array');\n    }\n\n    return parsed.map(x => MerkleTree.bufferify(x));\n  }\n  /**\n   * getLayers\n   * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root.\n   * @return {Buffer[]}\n   * @example\n   *```js\n   *const layers = tree.getLayers()\n   *```\n   */\n\n\n  getLayers() {\n    return this.layers;\n  }\n  /**\n   * getHexLayers\n   * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root as hex strings.\n   * @return {String[]}\n   * @example\n   *```js\n   *const layers = tree.getHexLayers()\n   *```\n   */\n\n\n  getHexLayers() {\n    return this.layers.reduce((acc, item) => {\n      if (Array.isArray(item)) {\n        acc.push(item.map(x => this.bufferToHex(x)));\n      } else {\n        acc.push(item);\n      }\n\n      return acc;\n    }, []);\n  }\n  /**\n   * getLayersFlat\n   * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root.\n   * @return {Buffer[]}\n   * @example\n   *```js\n   *const layers = tree.getLayersFlat()\n   *```\n   */\n\n\n  getLayersFlat() {\n    const layers = this.layers.reduce((acc, item) => {\n      if (Array.isArray(item)) {\n        acc.unshift(...item);\n      } else {\n        acc.unshift(item);\n      }\n\n      return acc;\n    }, []);\n    layers.unshift(Buffer.from([0]));\n    return layers;\n  }\n  /**\n   * getHexLayersFlat\n   * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root as hex string.\n   * @return {String[]}\n   * @example\n   *```js\n   *const layers = tree.getHexLayersFlat()\n   *```\n   */\n\n\n  getHexLayersFlat() {\n    return this.getLayersFlat().map(x => this.bufferToHex(x));\n  }\n  /**\n   * getRoot\n   * @desc Returns the Merkle root hash as a Buffer.\n   * @return {Buffer}\n   * @example\n   *```js\n   *const root = tree.getRoot()\n   *```\n   */\n\n\n  getRoot() {\n    return this.layers[this.layers.length - 1][0] || Buffer.from([]);\n  }\n  /**\n   * getHexRoot\n   * @desc Returns the Merkle root hash as a hex string.\n   * @return {String}\n   * @example\n   *```js\n   *const root = tree.getHexRoot()\n   *```\n   */\n\n\n  getHexRoot() {\n    return this.bufferToHex(this.getRoot());\n  }\n  /**\n   * getProof\n   * @desc Returns the proof for a target leaf.\n   * @param {Buffer} leaf - Target leaf\n   * @param {Number} [index] - Target leaf index in leaves array.\n   * Use if there are leaves containing duplicate data in order to distinguish it.\n   * @return {Object[]} - Array of objects containing a position property of type string\n   * with values of 'left' or 'right' and a data property of type Buffer.\n   * @example\n   * ```js\n   *const proof = tree.getProof(leaves[2])\n   *```\n   *\n   * @example\n   *```js\n   *const leaves = ['a', 'b', 'a'].map(x => keccak(x))\n   *const tree = new MerkleTree(leaves, keccak)\n   *const proof = tree.getProof(leaves[2], 2)\n   *```\n   */\n\n\n  getProof(leaf, index) {\n    if (typeof leaf === 'undefined') {\n      throw new Error('leaf is required');\n    }\n\n    leaf = this.bufferify(leaf);\n    const proof = [];\n\n    if (!Number.isInteger(index)) {\n      index = -1;\n\n      for (let i = 0; i < this.leaves.length; i++) {\n        if (Buffer.compare(leaf, this.leaves[i]) === 0) {\n          index = i;\n        }\n      }\n    }\n\n    if (index <= -1) {\n      return [];\n    }\n\n    for (let i = 0; i < this.layers.length; i++) {\n      const layer = this.layers[i];\n      const isRightNode = index % 2;\n      const pairIndex = isRightNode ? index - 1 : this.isBitcoinTree && index === layer.length - 1 && i < this.layers.length - 1 // Proof Generation for Bitcoin Trees\n      ? index // Proof Generation for Non-Bitcoin Trees\n      : index + 1;\n\n      if (pairIndex < layer.length) {\n        proof.push({\n          position: isRightNode ? 'left' : 'right',\n          data: layer[pairIndex]\n        });\n      } // set index to parent index\n\n\n      index = index / 2 | 0;\n    }\n\n    return proof;\n  }\n  /**\n   * getHexProof\n   * @desc Returns the proof for a target leaf as hex strings.\n   * @param {Buffer} leaf - Target leaf\n   * @param {Number} [index] - Target leaf index in leaves array.\n   * Use if there are leaves containing duplicate data in order to distinguish it.\n   * @return {String[]} - Proof array as hex strings.\n   * @example\n   * ```js\n   *const proof = tree.getHexProof(leaves[2])\n   *```\n   */\n\n\n  getHexProof(leaf, index) {\n    return this.getProof(leaf, index).map(x => this.bufferToHex(x.data));\n  }\n  /**\n  * getPositionalHexProof\n  * @desc Returns the proof for a target leaf as hex strings and the position in binary (left == 0).\n  * @param {Buffer} leaf - Target leaf\n  * @param {Number} [index] - Target leaf index in leaves array.\n  * Use if there are leaves containing duplicate data in order to distinguish it.\n  * @return {(string | number)[][]} - Proof array as hex strings. position at index 0\n  * @example\n  * ```js\n  *const proof = tree.getPositionalHexProof(leaves[2])\n  *```\n  */\n\n\n  getPositionalHexProof(leaf, index) {\n    return this.getProof(leaf, index).map(x => {\n      return [x.position === 'left' ? 0 : 1, this.bufferToHex(x.data)];\n    });\n  }\n  /**\n   * marshalProof\n   * @desc Returns proof array as JSON string.\n   * @param {String[]|Object[]} proof - Merkle tree proof array\n   * @return {String} - Proof array as JSON string.\n   * @example\n   * ```js\n   *const jsonStr = MerkleTree.marshalProof(proof)\n   *```\n   */\n\n\n  static marshalProof(proof) {\n    const json = proof.map(x => {\n      if (typeof x === 'string') {\n        return x;\n      }\n\n      if (Buffer.isBuffer(x)) {\n        return MerkleTree.bufferToHex(x);\n      }\n\n      return {\n        position: x.position,\n        data: MerkleTree.bufferToHex(x.data)\n      };\n    });\n    return JSON.stringify(json, null, 2);\n  }\n  /**\n   * unmarshalProof\n   * @desc Returns the proof for a target leaf as a list of Buffers.\n   * @param {String|Object} - Merkle tree leaves\n   * @return {String|Object} - Marshalled proof\n   * @example\n   * ```js\n   *const proof = MerkleTree.unmarshalProof(jsonStr)\n   *```\n   */\n\n\n  static unmarshalProof(jsonStr) {\n    let parsed = null;\n\n    if (typeof jsonStr === 'string') {\n      parsed = JSON.parse(jsonStr);\n    } else if (jsonStr instanceof Object) {\n      parsed = jsonStr;\n    } else {\n      throw new Error('Expected type of string or object');\n    }\n\n    if (!parsed) {\n      return [];\n    }\n\n    if (!Array.isArray(parsed)) {\n      throw new Error('Expected JSON string to be array');\n    }\n\n    return parsed.map(x => {\n      if (typeof x === 'string') {\n        return MerkleTree.bufferify(x);\n      } else if (x instanceof Object) {\n        return {\n          position: x.position,\n          data: MerkleTree.bufferify(x.data)\n        };\n      } else {\n        throw new Error('Expected item to be of type string or object');\n      }\n    });\n  }\n  /**\n   * getProofIndices\n   * @desc Returns the proof indices for given tree indices.\n   * @param {Number[]} treeIndices - Tree indices\n   * @param {Number} depth - Tree depth; number of layers.\n   * @return {Number[]} - Proof indices\n   * @example\n   * ```js\n   *const proofIndices = tree.getProofIndices([2,5,6], 4)\n   *console.log(proofIndices) // [ 23, 20, 19, 8, 3 ]\n   *```\n   */\n\n\n  getProofIndices(treeIndices, depth) {\n    const leafCount = Math.pow(2, depth);\n    let maximalIndices = new Set();\n\n    for (const index of treeIndices) {\n      let x = leafCount + index;\n\n      while (x > 1) {\n        maximalIndices.add(x ^ 1);\n        x = x / 2 | 0;\n      }\n    }\n\n    const a = treeIndices.map(index => leafCount + index);\n    const b = Array.from(maximalIndices).sort((a, b) => a - b).reverse();\n    maximalIndices = a.concat(b);\n    const redundantIndices = new Set();\n    const proof = [];\n\n    for (let index of maximalIndices) {\n      if (!redundantIndices.has(index)) {\n        proof.push(index);\n\n        while (index > 1) {\n          redundantIndices.add(index);\n          if (!redundantIndices.has(index ^ 1)) break;\n          index = index / 2 | 0;\n        }\n      }\n    }\n\n    return proof.filter(index => {\n      return !treeIndices.includes(index - leafCount);\n    });\n  }\n  /**\n   * getMultiProof\n   * @desc Returns the multiproof for given tree indices.\n   * @param {Number[]} indices - Tree indices.\n   * @return {Buffer[]} - Multiproofs\n   * @example\n   * ```js\n   *const indices = [2, 5, 6]\n   *const proof = tree.getMultiProof(indices)\n   *```\n   */\n\n\n  getMultiProof(tree, indices) {\n    if (!indices) {\n      indices = tree;\n      tree = this.getLayersFlat();\n\n      if (!indices.every(Number.isInteger)) {\n        let els = indices;\n\n        if (this.sortPairs) {\n          els = els.sort(Buffer.compare);\n        }\n\n        let ids = els.map(el => this._bufferIndexOf(this.leaves, el)).sort((a, b) => a === b ? 0 : a > b ? 1 : -1);\n\n        if (!ids.every(idx => idx !== -1)) {\n          throw new Error('Element does not exist in Merkle tree');\n        }\n\n        const hashes = [];\n        const proof = [];\n        let nextIds = [];\n\n        for (let i = 0; i < this.layers.length; i++) {\n          const layer = this.layers[i];\n\n          for (let j = 0; j < ids.length; j++) {\n            const idx = ids[j];\n\n            const pairElement = this._getPairNode(layer, idx);\n\n            hashes.push(layer[idx]);\n\n            if (pairElement) {\n              proof.push(pairElement);\n            }\n\n            nextIds.push(idx / 2 | 0);\n          }\n\n          ids = nextIds.filter((value, i, self) => self.indexOf(value) === i);\n          nextIds = [];\n        }\n\n        return proof.filter(value => !hashes.includes(value));\n      }\n    }\n\n    return this.getProofIndices(indices, this._log2(tree.length / 2 | 0)).map(index => tree[index]);\n  }\n  /**\n   * getHexMultiProof\n   * @desc Returns the multiproof for given tree indices as hex strings.\n   * @param {Number[]} indices - Tree indices.\n   * @return {String[]} - Multiproofs as hex strings.\n   * @example\n   * ```js\n   *const indices = [2, 5, 6]\n   *const proof = tree.getHexMultiProof(indices)\n   *```\n   */\n\n\n  getHexMultiProof(tree, indices) {\n    return this.getMultiProof(tree, indices).map(x => this.bufferToHex(x));\n  }\n  /**\n   * getProofFlags\n   * @desc Returns list of booleans where proofs should be used instead of hashing.\n   * Proof flags are used in the Solidity multiproof verifiers.\n   * @param {Number[]|Buffer[]} leaves\n   * @param {Buffer[]} proofs\n   * @return {Boolean[]} - Boolean flags\n   * @example\n   * ```js\n   *const indices = [2, 5, 6]\n   *const proof = tree.getMultiProof(indices)\n   *const proofFlags = tree.getProofFlags(leaves, proof)\n   *```\n   */\n\n\n  getProofFlags(leaves, proofs) {\n    if (!Array.isArray(leaves) || leaves.length <= 0) {\n      throw new Error('Invalid Inputs!');\n    }\n\n    let ids;\n\n    if (leaves.every(Number.isInteger)) {\n      ids = leaves.sort((a, b) => a === b ? 0 : a > b ? 1 : -1); // Indices where passed\n    } else {\n      ids = leaves.map(el => this._bufferIndexOf(this.leaves, el)).sort((a, b) => a === b ? 0 : a > b ? 1 : -1);\n    }\n\n    if (!ids.every(idx => idx !== -1)) {\n      throw new Error('Element does not exist in Merkle tree');\n    }\n\n    const _proofs = proofs.map(x => this.bufferify(x));\n\n    const tested = [];\n    const flags = [];\n\n    for (let index = 0; index < this.layers.length; index++) {\n      const layer = this.layers[index];\n      ids = ids.reduce((ids, idx) => {\n        const skipped = tested.includes(layer[idx]);\n\n        if (!skipped) {\n          const pairElement = this._getPairNode(layer, idx);\n\n          const proofUsed = _proofs.includes(layer[idx]) || _proofs.includes(pairElement);\n\n          pairElement && flags.push(!proofUsed);\n          tested.push(layer[idx]);\n          tested.push(pairElement);\n        }\n\n        ids.push(idx / 2 | 0);\n        return ids;\n      }, []);\n    }\n\n    return flags;\n  }\n  /**\n   * verify\n   * @desc Returns true if the proof path (array of hashes) can connect the target node\n   * to the Merkle root.\n   * @param {Object[]} proof - Array of proof objects that should connect\n   * target node to Merkle root.\n   * @param {Buffer} targetNode - Target node Buffer\n   * @param {Buffer} root - Merkle root Buffer\n   * @return {Boolean}\n   * @example\n   *```js\n   *const root = tree.getRoot()\n   *const proof = tree.getProof(leaves[2])\n   *const verified = tree.verify(proof, leaves[2], root)\n   *```\n   */\n\n\n  verify(proof, targetNode, root) {\n    let hash = this.bufferify(targetNode);\n    root = this.bufferify(root);\n\n    if (!Array.isArray(proof) || !targetNode || !root) {\n      return false;\n    }\n\n    for (let i = 0; i < proof.length; i++) {\n      const node = proof[i];\n      let data = null;\n      let isLeftNode = null; // case for when proof is hex values only\n\n      if (typeof node === 'string') {\n        data = this.bufferify(node);\n        isLeftNode = true;\n      } else if (Array.isArray(node)) {\n        isLeftNode = node[0] === 0;\n        data = this.bufferify(node[1]);\n      } else if (Buffer.isBuffer(node)) {\n        data = node;\n        isLeftNode = true;\n      } else if (node instanceof Object) {\n        data = this.bufferify(node.data);\n        isLeftNode = node.position === 'left';\n      } else {\n        throw new Error('Expected node to be of type string or object');\n      }\n\n      const buffers = [];\n\n      if (this.isBitcoinTree) {\n        buffers.push(buffer_reverse_1.default(hash));\n        buffers[isLeftNode ? 'unshift' : 'push'](buffer_reverse_1.default(data));\n        hash = this.hashFn(Buffer.concat(buffers));\n        hash = buffer_reverse_1.default(this.hashFn(hash));\n      } else {\n        if (this.sortPairs) {\n          if (Buffer.compare(hash, data) === -1) {\n            buffers.push(hash, data);\n            hash = this.hashFn(Buffer.concat(buffers));\n          } else {\n            buffers.push(data, hash);\n            hash = this.hashFn(Buffer.concat(buffers));\n          }\n        } else {\n          buffers.push(hash);\n          buffers[isLeftNode ? 'unshift' : 'push'](data);\n          hash = this.hashFn(Buffer.concat(buffers));\n        }\n      }\n    }\n\n    return Buffer.compare(hash, root) === 0;\n  }\n  /**\n   * verifyMultiProof\n   * @desc Returns true if the multiproofs can connect the leaves to the Merkle root.\n   * @param {Buffer} root - Merkle tree root\n   * @param {Number[]} indices - Leave indices\n   * @param {Buffer[]} leaves - Leaf values at indices.\n   * @param {Number} depth - Tree depth\n   * @param {Buffer[]} proof - Multiproofs given indices\n   * @return {Boolean}\n   * @example\n   *```js\n   *const root = tree.getRoot()\n   *const treeFlat = tree.getLayersFlat()\n   *const depth = tree.getDepth()\n   *const indices = [2, 5, 6]\n   *const proofLeaves = indices.map(i => leaves[i])\n   *const proof = tree.getMultiProof(treeFlat, indices)\n   *const verified = tree.verifyMultiProof(root, indices, proofLeaves, depth, proof)\n   *```\n   */\n\n\n  verifyMultiProof(root, indices, leaves, depth, proof) {\n    root = this.bufferify(root);\n    leaves = leaves.map(x => this.bufferify(x));\n    proof = proof.map(x => this.bufferify(x));\n    const tree = {};\n\n    for (const [index, leaf] of this._zip(indices, leaves)) {\n      tree[Math.pow(2, depth) + index] = leaf;\n    }\n\n    for (const [index, proofitem] of this._zip(this.getProofIndices(indices, depth), proof)) {\n      tree[index] = proofitem;\n    }\n\n    let indexqueue = Object.keys(tree).map(x => +x).sort((a, b) => a - b);\n    indexqueue = indexqueue.slice(0, indexqueue.length - 1);\n    let i = 0;\n\n    while (i < indexqueue.length) {\n      const index = indexqueue[i];\n\n      if (index >= 2 && {}.hasOwnProperty.call(tree, index ^ 1)) {\n        let pair = [tree[index - index % 2], tree[index - index % 2 + 1]];\n\n        if (this.sortPairs) {\n          pair = pair.sort(Buffer.compare);\n        }\n\n        tree[index / 2 | 0] = this.hashFn(Buffer.concat(pair));\n        indexqueue.push(index / 2 | 0);\n      }\n\n      i += 1;\n    }\n\n    return !indices.length || {}.hasOwnProperty.call(tree, 1) && tree[1].equals(root);\n  }\n  /**\n   * getDepth\n   * @desc Returns the tree depth (number of layers)\n   * @return {Number}\n   * @example\n   *```js\n   *const depth = tree.getDepth()\n   *```\n   */\n\n\n  getDepth() {\n    return this.getLayers().length - 1;\n  }\n  /**\n   * getLayersAsObject\n   * @desc Returns the layers as nested objects instead of an array.\n   * @example\n   *```js\n   *const layersObj = tree.getLayersAsObject()\n   *```\n   */\n\n\n  getLayersAsObject() {\n    const layers = this.getLayers().map(layer => layer.map(value => this.bufferToHex(value, false)));\n    const objs = [];\n\n    for (let i = 0; i < layers.length; i++) {\n      const arr = [];\n\n      for (let j = 0; j < layers[i].length; j++) {\n        const obj = {\n          [layers[i][j]]: null\n        };\n\n        if (objs.length) {\n          obj[layers[i][j]] = {};\n          const a = objs.shift();\n          const akey = Object.keys(a)[0];\n          obj[layers[i][j]][akey] = a[akey];\n\n          if (objs.length) {\n            const b = objs.shift();\n            const bkey = Object.keys(b)[0];\n            obj[layers[i][j]][bkey] = b[bkey];\n          }\n        }\n\n        arr.push(obj);\n      }\n\n      objs.push(...arr);\n    }\n\n    return objs[0];\n  }\n  /**\n   * verify\n   * @desc Returns true if the proof path (array of hashes) can connect the target node\n   * to the Merkle root.\n   * @param {Object[]} proof - Array of proof objects that should connect\n   * target node to Merkle root.\n   * @param {Buffer} targetNode - Target node Buffer\n   * @param {Buffer} root - Merkle root Buffer\n   * @param {Function} hashFunction - Hash function for hashing leaves and nodes\n   * @param {Object} options - Additional options\n   * @return {Boolean}\n   * @example\n   *```js\n   *const verified = MerkleTree.verify(proof, leaf, root, sha256, options)\n   *```\n   */\n\n\n  static verify(proof, targetNode, root, hashFn = sha256_1.default, options = {}) {\n    const tree = new MerkleTree([], hashFn, options);\n    return tree.verify(proof, targetNode, root);\n  }\n  /**\n   * getMultiProof\n   * @desc Returns the multiproof for given tree indices.\n   * @param {Buffer[]} tree - Tree as a flat array.\n   * @param {Number[]} indices - Tree indices.\n   * @return {Buffer[]} - Multiproofs\n   *\n   *@example\n   * ```js\n   *const flatTree = tree.getLayersFlat()\n   *const indices = [2, 5, 6]\n   *const proof = MerkleTree.getMultiProof(flatTree, indices)\n   *```\n   */\n\n\n  static getMultiProof(tree, indices) {\n    const t = new MerkleTree([]);\n    return t.getMultiProof(tree, indices);\n  }\n  /**\n   * getPairNode\n   * @desc Returns the node at the index for given layer.\n   * @param {Buffer[]} layer - Tree layer\n   * @param {Number} index - Index at layer.\n   * @return {Buffer} - Node\n   *\n   *@example\n   * ```js\n   *const node = tree.getPairNode(layer, index)\n   *```\n   */\n\n\n  _getPairNode(layer, idx) {\n    const pairIdx = idx % 2 === 0 ? idx + 1 : idx - 1;\n\n    if (pairIdx < layer.length) {\n      return layer[pairIdx];\n    } else {\n      return null;\n    }\n  }\n  /**\n   * toTreeString\n   * @desc Returns a visual representation of the merkle tree as a string.\n   * @return {String}\n   * @example\n   *```js\n   *console.log(tree.toTreeString())\n   *```\n   */\n\n\n  _toTreeString() {\n    const obj = this.getLayersAsObject();\n    return treeify_1.default.asTree(obj, true);\n  }\n  /**\n   * toString\n   * @desc Returns a visual representation of the merkle tree as a string.\n   * @example\n   *```js\n   *console.log(tree.toString())\n   *```\n   */\n\n\n  toString() {\n    return this._toTreeString();\n  }\n\n}\n\nexports.MerkleTree = MerkleTree;\n\nif (typeof window !== 'undefined') {\n  ;\n  window.MerkleTree = MerkleTree;\n}\n\nexports.default = MerkleTree;","map":{"version":3,"sources":["/Users/helen/fi/protocol-demo/frontend/node_modules/merkletreejs/dist/MerkleTree.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","MerkleTree","buffer_reverse_1","require","sha256_1","Base_1","treeify_1","default","constructor","leaves","hashFn","options","duplicateOdd","hashLeaves","isBitcoinTree","layers","sortLeaves","sortPairs","sort","fillDefaultHash","Buffer","isBuffer","idx","Error","_bufferifyFn","map","x","bufferify","compare","i","Math","pow","ceil","log2","length","push","_createHashes","nodes","layerIndex","data","hash","concat","left","right","combined","getLeaves","values","Array","isArray","filter","_bufferIndexOf","getHexLeaves","bufferToHex","marshalLeaves","JSON","stringify","unmarshalLeaves","jsonStr","parsed","parse","getLayers","getHexLayers","reduce","acc","item","getLayersFlat","unshift","from","getHexLayersFlat","getRoot","getHexRoot","getProof","leaf","index","proof","Number","isInteger","layer","isRightNode","pairIndex","position","getHexProof","getPositionalHexProof","marshalProof","json","unmarshalProof","getProofIndices","treeIndices","depth","leafCount","maximalIndices","Set","add","a","b","reverse","redundantIndices","has","includes","getMultiProof","tree","indices","every","els","ids","el","hashes","nextIds","j","pairElement","_getPairNode","self","indexOf","_log2","getHexMultiProof","getProofFlags","proofs","_proofs","tested","flags","skipped","proofUsed","verify","targetNode","root","node","isLeftNode","buffers","verifyMultiProof","_zip","proofitem","indexqueue","keys","slice","hasOwnProperty","call","pair","equals","getDepth","getLayersAsObject","objs","arr","obj","shift","akey","bkey","t","pairIdx","_toTreeString","asTree","toString","window"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MerkleTree = void 0;\nconst buffer_reverse_1 = __importDefault(require(\"buffer-reverse\"));\nconst sha256_1 = __importDefault(require(\"crypto-js/sha256\"));\nconst Base_1 = __importDefault(require(\"./Base\"));\nconst treeify_1 = __importDefault(require(\"treeify\"));\n/**\n * Class reprensenting a Merkle Tree\n * @namespace MerkleTree\n */\nclass MerkleTree extends Base_1.default {\n    /**\n     * @desc Constructs a Merkle Tree.\n     * All nodes and leaves are stored as Buffers.\n     * Lonely leaf nodes are promoted to the next level up without being hashed again.\n     * @param {Buffer[]} leaves - Array of hashed leaves. Each leaf must be a Buffer.\n     * @param {Function} hashFunction - Hash function to use for hashing leaves and nodes\n     * @param {Object} options - Additional options\n     * @example\n     *```js\n     *const MerkleTree = require('merkletreejs')\n     *const crypto = require('crypto')\n     *\n     *function sha256(data) {\n     *  // returns Buffer\n     *  return crypto.createHash('sha256').update(data).digest()\n     *}\n     *\n     *const leaves = ['a', 'b', 'c'].map(x => keccak(x))\n     *\n     *const tree = new MerkleTree(leaves, sha256)\n     *```\n     */\n    constructor(leaves, hashFn = sha256_1.default, options = {}) {\n        super();\n        this.duplicateOdd = false;\n        this.hashLeaves = false;\n        this.isBitcoinTree = false;\n        this.leaves = [];\n        this.layers = [];\n        this.sortLeaves = false;\n        this.sortPairs = false;\n        this.sort = false;\n        this.fillDefaultHash = null;\n        this.isBitcoinTree = !!options.isBitcoinTree;\n        this.hashLeaves = !!options.hashLeaves;\n        this.sortLeaves = !!options.sortLeaves;\n        this.sortPairs = !!options.sortPairs;\n        if (options.fillDefaultHash) {\n            if (typeof options.fillDefaultHash === 'function') {\n                this.fillDefaultHash = options.fillDefaultHash;\n            }\n            else if (Buffer.isBuffer(options.fillDefaultHash) || typeof options.fillDefaultHash === 'string') {\n                this.fillDefaultHash = (idx, hashFn) => options.fillDefaultHash;\n            }\n            else {\n                throw new Error('method \"fillDefaultHash\" must be a function, Buffer, or string');\n            }\n        }\n        this.sort = !!options.sort;\n        if (this.sort) {\n            this.sortLeaves = true;\n            this.sortPairs = true;\n        }\n        this.duplicateOdd = !!options.duplicateOdd;\n        this.hashFn = this._bufferifyFn(hashFn);\n        if (this.hashLeaves) {\n            leaves = leaves.map(x => this.hashFn(x));\n        }\n        this.leaves = leaves.map(x => this.bufferify(x));\n        if (this.sortLeaves) {\n            this.leaves = this.leaves.sort(Buffer.compare);\n        }\n        if (this.fillDefaultHash) {\n            for (let i = 0; i < Math.pow(2, Math.ceil(Math.log2(this.leaves.length))); i++) {\n                if (i >= this.leaves.length) {\n                    this.leaves.push(this.bufferify(this.fillDefaultHash(i, this.hashFn)));\n                }\n            }\n        }\n        this.layers = [this.leaves];\n        this._createHashes(this.leaves);\n    }\n    _createHashes(nodes) {\n        while (nodes.length > 1) {\n            const layerIndex = this.layers.length;\n            this.layers.push([]);\n            for (let i = 0; i < nodes.length; i += 2) {\n                if (i + 1 === nodes.length) {\n                    if (nodes.length % 2 === 1) {\n                        let data = nodes[nodes.length - 1];\n                        let hash = data;\n                        // is bitcoin tree\n                        if (this.isBitcoinTree) {\n                            // Bitcoin method of duplicating the odd ending nodes\n                            data = Buffer.concat([buffer_reverse_1.default(data), buffer_reverse_1.default(data)]);\n                            hash = this.hashFn(data);\n                            hash = buffer_reverse_1.default(this.hashFn(hash));\n                            this.layers[layerIndex].push(hash);\n                            continue;\n                        }\n                        else {\n                            if (this.duplicateOdd) {\n                                // continue with creating layer\n                            }\n                            else {\n                                // push copy of hash and continue iteration\n                                this.layers[layerIndex].push(nodes[i]);\n                                continue;\n                            }\n                        }\n                    }\n                }\n                const left = nodes[i];\n                const right = i + 1 === nodes.length ? left : nodes[i + 1];\n                let data = null;\n                let combined = null;\n                if (this.isBitcoinTree) {\n                    combined = [buffer_reverse_1.default(left), buffer_reverse_1.default(right)];\n                }\n                else {\n                    combined = [left, right];\n                }\n                if (this.sortPairs) {\n                    combined.sort(Buffer.compare);\n                }\n                data = Buffer.concat(combined);\n                let hash = this.hashFn(data);\n                // double hash if bitcoin tree\n                if (this.isBitcoinTree) {\n                    hash = buffer_reverse_1.default(this.hashFn(hash));\n                }\n                this.layers[layerIndex].push(hash);\n            }\n            nodes = this.layers[layerIndex];\n        }\n    }\n    /**\n     * getLeaves\n     * @desc Returns array of leaves of Merkle Tree.\n     * @return {Buffer[]}\n     * @example\n     *```js\n     *const leaves = tree.getLeaves()\n     *```\n     */\n    getLeaves(values) {\n        if (Array.isArray(values)) {\n            if (this.hashLeaves) {\n                values = values.map(x => this.hashFn(x));\n                if (this.sortLeaves) {\n                    values = values.sort(Buffer.compare);\n                }\n            }\n            return this.leaves.filter(x => this._bufferIndexOf(values, x) !== -1);\n        }\n        return this.leaves;\n    }\n    /**\n     * getHexLeaves\n     * @desc Returns array of leaves of Merkle Tree as hex strings.\n     * @return {String[]}\n     * @example\n     *```js\n     *const leaves = tree.getHexLeaves()\n     *```\n     */\n    getHexLeaves() {\n        return this.leaves.map(x => this.bufferToHex(x));\n    }\n    /**\n     * marshalLeaves\n     * @desc Returns array of leaves of Merkle Tree as a JSON string.\n     * @param {String[]|Buffer[]} - Merkle tree leaves\n     * @return {String} - List of leaves as JSON string\n     * @example\n     *```js\n     *const jsonStr = MerkleTree.marshalLeaves(leaves)\n     *```\n     */\n    static marshalLeaves(leaves) {\n        return JSON.stringify(leaves.map(x => MerkleTree.bufferToHex(x)), null, 2);\n    }\n    /**\n     * unmarshalLeaves\n     * @desc Returns array of leaves of Merkle Tree as a Buffers.\n     * @param {String|Object} - JSON stringified leaves\n     * @return {Buffer[]} - Unmarshalled list of leaves\n     * @example\n     *```js\n     *const leaves = MerkleTree.unmarshalLeaves(jsonStr)\n     *```\n     */\n    static unmarshalLeaves(jsonStr) {\n        let parsed = null;\n        if (typeof jsonStr === 'string') {\n            parsed = JSON.parse(jsonStr);\n        }\n        else if (jsonStr instanceof Object) {\n            parsed = jsonStr;\n        }\n        else {\n            throw new Error('Expected type of string or object');\n        }\n        if (!parsed) {\n            return [];\n        }\n        if (!Array.isArray(parsed)) {\n            throw new Error('Expected JSON string to be array');\n        }\n        return parsed.map(x => MerkleTree.bufferify(x));\n    }\n    /**\n     * getLayers\n     * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root.\n     * @return {Buffer[]}\n     * @example\n     *```js\n     *const layers = tree.getLayers()\n     *```\n     */\n    getLayers() {\n        return this.layers;\n    }\n    /**\n     * getHexLayers\n     * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root as hex strings.\n     * @return {String[]}\n     * @example\n     *```js\n     *const layers = tree.getHexLayers()\n     *```\n     */\n    getHexLayers() {\n        return this.layers.reduce((acc, item) => {\n            if (Array.isArray(item)) {\n                acc.push(item.map(x => this.bufferToHex(x)));\n            }\n            else {\n                acc.push(item);\n            }\n            return acc;\n        }, []);\n    }\n    /**\n     * getLayersFlat\n     * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root.\n     * @return {Buffer[]}\n     * @example\n     *```js\n     *const layers = tree.getLayersFlat()\n     *```\n     */\n    getLayersFlat() {\n        const layers = this.layers.reduce((acc, item) => {\n            if (Array.isArray(item)) {\n                acc.unshift(...item);\n            }\n            else {\n                acc.unshift(item);\n            }\n            return acc;\n        }, []);\n        layers.unshift(Buffer.from([0]));\n        return layers;\n    }\n    /**\n     * getHexLayersFlat\n     * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root as hex string.\n     * @return {String[]}\n     * @example\n     *```js\n     *const layers = tree.getHexLayersFlat()\n     *```\n     */\n    getHexLayersFlat() {\n        return this.getLayersFlat().map(x => this.bufferToHex(x));\n    }\n    /**\n     * getRoot\n     * @desc Returns the Merkle root hash as a Buffer.\n     * @return {Buffer}\n     * @example\n     *```js\n     *const root = tree.getRoot()\n     *```\n     */\n    getRoot() {\n        return this.layers[this.layers.length - 1][0] || Buffer.from([]);\n    }\n    /**\n     * getHexRoot\n     * @desc Returns the Merkle root hash as a hex string.\n     * @return {String}\n     * @example\n     *```js\n     *const root = tree.getHexRoot()\n     *```\n     */\n    getHexRoot() {\n        return this.bufferToHex(this.getRoot());\n    }\n    /**\n     * getProof\n     * @desc Returns the proof for a target leaf.\n     * @param {Buffer} leaf - Target leaf\n     * @param {Number} [index] - Target leaf index in leaves array.\n     * Use if there are leaves containing duplicate data in order to distinguish it.\n     * @return {Object[]} - Array of objects containing a position property of type string\n     * with values of 'left' or 'right' and a data property of type Buffer.\n     * @example\n     * ```js\n     *const proof = tree.getProof(leaves[2])\n     *```\n     *\n     * @example\n     *```js\n     *const leaves = ['a', 'b', 'a'].map(x => keccak(x))\n     *const tree = new MerkleTree(leaves, keccak)\n     *const proof = tree.getProof(leaves[2], 2)\n     *```\n     */\n    getProof(leaf, index) {\n        if (typeof leaf === 'undefined') {\n            throw new Error('leaf is required');\n        }\n        leaf = this.bufferify(leaf);\n        const proof = [];\n        if (!Number.isInteger(index)) {\n            index = -1;\n            for (let i = 0; i < this.leaves.length; i++) {\n                if (Buffer.compare(leaf, this.leaves[i]) === 0) {\n                    index = i;\n                }\n            }\n        }\n        if (index <= -1) {\n            return [];\n        }\n        for (let i = 0; i < this.layers.length; i++) {\n            const layer = this.layers[i];\n            const isRightNode = index % 2;\n            const pairIndex = (isRightNode ? index - 1\n                : this.isBitcoinTree && index === layer.length - 1 && i < this.layers.length - 1\n                    // Proof Generation for Bitcoin Trees\n                    ? index\n                    // Proof Generation for Non-Bitcoin Trees\n                    : index + 1);\n            if (pairIndex < layer.length) {\n                proof.push({\n                    position: isRightNode ? 'left' : 'right',\n                    data: layer[pairIndex]\n                });\n            }\n            // set index to parent index\n            index = (index / 2) | 0;\n        }\n        return proof;\n    }\n    /**\n     * getHexProof\n     * @desc Returns the proof for a target leaf as hex strings.\n     * @param {Buffer} leaf - Target leaf\n     * @param {Number} [index] - Target leaf index in leaves array.\n     * Use if there are leaves containing duplicate data in order to distinguish it.\n     * @return {String[]} - Proof array as hex strings.\n     * @example\n     * ```js\n     *const proof = tree.getHexProof(leaves[2])\n     *```\n     */\n    getHexProof(leaf, index) {\n        return this.getProof(leaf, index).map(x => this.bufferToHex(x.data));\n    }\n    /**\n    * getPositionalHexProof\n    * @desc Returns the proof for a target leaf as hex strings and the position in binary (left == 0).\n    * @param {Buffer} leaf - Target leaf\n    * @param {Number} [index] - Target leaf index in leaves array.\n    * Use if there are leaves containing duplicate data in order to distinguish it.\n    * @return {(string | number)[][]} - Proof array as hex strings. position at index 0\n    * @example\n    * ```js\n    *const proof = tree.getPositionalHexProof(leaves[2])\n    *```\n    */\n    getPositionalHexProof(leaf, index) {\n        return this.getProof(leaf, index).map(x => {\n            return [\n                x.position === 'left' ? 0 : 1,\n                this.bufferToHex(x.data)\n            ];\n        });\n    }\n    /**\n     * marshalProof\n     * @desc Returns proof array as JSON string.\n     * @param {String[]|Object[]} proof - Merkle tree proof array\n     * @return {String} - Proof array as JSON string.\n     * @example\n     * ```js\n     *const jsonStr = MerkleTree.marshalProof(proof)\n     *```\n     */\n    static marshalProof(proof) {\n        const json = proof.map(x => {\n            if (typeof x === 'string') {\n                return x;\n            }\n            if (Buffer.isBuffer(x)) {\n                return MerkleTree.bufferToHex(x);\n            }\n            return {\n                position: x.position,\n                data: MerkleTree.bufferToHex(x.data)\n            };\n        });\n        return JSON.stringify(json, null, 2);\n    }\n    /**\n     * unmarshalProof\n     * @desc Returns the proof for a target leaf as a list of Buffers.\n     * @param {String|Object} - Merkle tree leaves\n     * @return {String|Object} - Marshalled proof\n     * @example\n     * ```js\n     *const proof = MerkleTree.unmarshalProof(jsonStr)\n     *```\n     */\n    static unmarshalProof(jsonStr) {\n        let parsed = null;\n        if (typeof jsonStr === 'string') {\n            parsed = JSON.parse(jsonStr);\n        }\n        else if (jsonStr instanceof Object) {\n            parsed = jsonStr;\n        }\n        else {\n            throw new Error('Expected type of string or object');\n        }\n        if (!parsed) {\n            return [];\n        }\n        if (!Array.isArray(parsed)) {\n            throw new Error('Expected JSON string to be array');\n        }\n        return parsed.map(x => {\n            if (typeof x === 'string') {\n                return MerkleTree.bufferify(x);\n            }\n            else if (x instanceof Object) {\n                return {\n                    position: x.position,\n                    data: MerkleTree.bufferify(x.data)\n                };\n            }\n            else {\n                throw new Error('Expected item to be of type string or object');\n            }\n        });\n    }\n    /**\n     * getProofIndices\n     * @desc Returns the proof indices for given tree indices.\n     * @param {Number[]} treeIndices - Tree indices\n     * @param {Number} depth - Tree depth; number of layers.\n     * @return {Number[]} - Proof indices\n     * @example\n     * ```js\n     *const proofIndices = tree.getProofIndices([2,5,6], 4)\n     *console.log(proofIndices) // [ 23, 20, 19, 8, 3 ]\n     *```\n     */\n    getProofIndices(treeIndices, depth) {\n        const leafCount = Math.pow(2, depth);\n        let maximalIndices = new Set();\n        for (const index of treeIndices) {\n            let x = leafCount + index;\n            while (x > 1) {\n                maximalIndices.add(x ^ 1);\n                x = (x / 2) | 0;\n            }\n        }\n        const a = treeIndices.map(index => leafCount + index);\n        const b = Array.from(maximalIndices).sort((a, b) => a - b).reverse();\n        maximalIndices = a.concat(b);\n        const redundantIndices = new Set();\n        const proof = [];\n        for (let index of maximalIndices) {\n            if (!redundantIndices.has(index)) {\n                proof.push(index);\n                while (index > 1) {\n                    redundantIndices.add(index);\n                    if (!redundantIndices.has(index ^ 1))\n                        break;\n                    index = (index / 2) | 0;\n                }\n            }\n        }\n        return proof.filter(index => {\n            return !treeIndices.includes(index - leafCount);\n        });\n    }\n    /**\n     * getMultiProof\n     * @desc Returns the multiproof for given tree indices.\n     * @param {Number[]} indices - Tree indices.\n     * @return {Buffer[]} - Multiproofs\n     * @example\n     * ```js\n     *const indices = [2, 5, 6]\n     *const proof = tree.getMultiProof(indices)\n     *```\n     */\n    getMultiProof(tree, indices) {\n        if (!indices) {\n            indices = tree;\n            tree = this.getLayersFlat();\n            if (!indices.every(Number.isInteger)) {\n                let els = indices;\n                if (this.sortPairs) {\n                    els = els.sort(Buffer.compare);\n                }\n                let ids = els.map((el) => this._bufferIndexOf(this.leaves, el)).sort((a, b) => a === b ? 0 : a > b ? 1 : -1);\n                if (!ids.every((idx) => idx !== -1)) {\n                    throw new Error('Element does not exist in Merkle tree');\n                }\n                const hashes = [];\n                const proof = [];\n                let nextIds = [];\n                for (let i = 0; i < this.layers.length; i++) {\n                    const layer = this.layers[i];\n                    for (let j = 0; j < ids.length; j++) {\n                        const idx = ids[j];\n                        const pairElement = this._getPairNode(layer, idx);\n                        hashes.push(layer[idx]);\n                        if (pairElement) {\n                            proof.push(pairElement);\n                        }\n                        nextIds.push((idx / 2) | 0);\n                    }\n                    ids = nextIds.filter((value, i, self) => self.indexOf(value) === i);\n                    nextIds = [];\n                }\n                return proof.filter((value) => !hashes.includes(value));\n            }\n        }\n        return this.getProofIndices(indices, this._log2((tree.length / 2) | 0)).map(index => tree[index]);\n    }\n    /**\n     * getHexMultiProof\n     * @desc Returns the multiproof for given tree indices as hex strings.\n     * @param {Number[]} indices - Tree indices.\n     * @return {String[]} - Multiproofs as hex strings.\n     * @example\n     * ```js\n     *const indices = [2, 5, 6]\n     *const proof = tree.getHexMultiProof(indices)\n     *```\n     */\n    getHexMultiProof(tree, indices) {\n        return this.getMultiProof(tree, indices).map((x) => this.bufferToHex(x));\n    }\n    /**\n     * getProofFlags\n     * @desc Returns list of booleans where proofs should be used instead of hashing.\n     * Proof flags are used in the Solidity multiproof verifiers.\n     * @param {Number[]|Buffer[]} leaves\n     * @param {Buffer[]} proofs\n     * @return {Boolean[]} - Boolean flags\n     * @example\n     * ```js\n     *const indices = [2, 5, 6]\n     *const proof = tree.getMultiProof(indices)\n     *const proofFlags = tree.getProofFlags(leaves, proof)\n     *```\n     */\n    getProofFlags(leaves, proofs) {\n        if (!Array.isArray(leaves) || leaves.length <= 0) {\n            throw new Error('Invalid Inputs!');\n        }\n        let ids;\n        if (leaves.every(Number.isInteger)) {\n            ids = leaves.sort((a, b) => a === b ? 0 : a > b ? 1 : -1); // Indices where passed\n        }\n        else {\n            ids = leaves.map((el) => this._bufferIndexOf(this.leaves, el)).sort((a, b) => a === b ? 0 : a > b ? 1 : -1);\n        }\n        if (!ids.every((idx) => idx !== -1)) {\n            throw new Error('Element does not exist in Merkle tree');\n        }\n        const _proofs = proofs.map(x => this.bufferify(x));\n        const tested = [];\n        const flags = [];\n        for (let index = 0; index < this.layers.length; index++) {\n            const layer = this.layers[index];\n            ids = ids.reduce((ids, idx) => {\n                const skipped = tested.includes(layer[idx]);\n                if (!skipped) {\n                    const pairElement = this._getPairNode(layer, idx);\n                    const proofUsed = _proofs.includes(layer[idx]) || _proofs.includes(pairElement);\n                    pairElement && flags.push(!proofUsed);\n                    tested.push(layer[idx]);\n                    tested.push(pairElement);\n                }\n                ids.push((idx / 2) | 0);\n                return ids;\n            }, []);\n        }\n        return flags;\n    }\n    /**\n     * verify\n     * @desc Returns true if the proof path (array of hashes) can connect the target node\n     * to the Merkle root.\n     * @param {Object[]} proof - Array of proof objects that should connect\n     * target node to Merkle root.\n     * @param {Buffer} targetNode - Target node Buffer\n     * @param {Buffer} root - Merkle root Buffer\n     * @return {Boolean}\n     * @example\n     *```js\n     *const root = tree.getRoot()\n     *const proof = tree.getProof(leaves[2])\n     *const verified = tree.verify(proof, leaves[2], root)\n     *```\n     */\n    verify(proof, targetNode, root) {\n        let hash = this.bufferify(targetNode);\n        root = this.bufferify(root);\n        if (!Array.isArray(proof) ||\n            !targetNode ||\n            !root) {\n            return false;\n        }\n        for (let i = 0; i < proof.length; i++) {\n            const node = proof[i];\n            let data = null;\n            let isLeftNode = null;\n            // case for when proof is hex values only\n            if (typeof node === 'string') {\n                data = this.bufferify(node);\n                isLeftNode = true;\n            }\n            else if (Array.isArray(node)) {\n                isLeftNode = (node[0] === 0);\n                data = this.bufferify(node[1]);\n            }\n            else if (Buffer.isBuffer(node)) {\n                data = node;\n                isLeftNode = true;\n            }\n            else if (node instanceof Object) {\n                data = this.bufferify(node.data);\n                isLeftNode = (node.position === 'left');\n            }\n            else {\n                throw new Error('Expected node to be of type string or object');\n            }\n            const buffers = [];\n            if (this.isBitcoinTree) {\n                buffers.push(buffer_reverse_1.default(hash));\n                buffers[isLeftNode ? 'unshift' : 'push'](buffer_reverse_1.default(data));\n                hash = this.hashFn(Buffer.concat(buffers));\n                hash = buffer_reverse_1.default(this.hashFn(hash));\n            }\n            else {\n                if (this.sortPairs) {\n                    if (Buffer.compare(hash, data) === -1) {\n                        buffers.push(hash, data);\n                        hash = this.hashFn(Buffer.concat(buffers));\n                    }\n                    else {\n                        buffers.push(data, hash);\n                        hash = this.hashFn(Buffer.concat(buffers));\n                    }\n                }\n                else {\n                    buffers.push(hash);\n                    buffers[isLeftNode ? 'unshift' : 'push'](data);\n                    hash = this.hashFn(Buffer.concat(buffers));\n                }\n            }\n        }\n        return Buffer.compare(hash, root) === 0;\n    }\n    /**\n     * verifyMultiProof\n     * @desc Returns true if the multiproofs can connect the leaves to the Merkle root.\n     * @param {Buffer} root - Merkle tree root\n     * @param {Number[]} indices - Leave indices\n     * @param {Buffer[]} leaves - Leaf values at indices.\n     * @param {Number} depth - Tree depth\n     * @param {Buffer[]} proof - Multiproofs given indices\n     * @return {Boolean}\n     * @example\n     *```js\n     *const root = tree.getRoot()\n     *const treeFlat = tree.getLayersFlat()\n     *const depth = tree.getDepth()\n     *const indices = [2, 5, 6]\n     *const proofLeaves = indices.map(i => leaves[i])\n     *const proof = tree.getMultiProof(treeFlat, indices)\n     *const verified = tree.verifyMultiProof(root, indices, proofLeaves, depth, proof)\n     *```\n     */\n    verifyMultiProof(root, indices, leaves, depth, proof) {\n        root = this.bufferify(root);\n        leaves = leaves.map(x => this.bufferify(x));\n        proof = proof.map(x => this.bufferify(x));\n        const tree = {};\n        for (const [index, leaf] of this._zip(indices, leaves)) {\n            tree[(Math.pow(2, depth)) + index] = leaf;\n        }\n        for (const [index, proofitem] of this._zip(this.getProofIndices(indices, depth), proof)) {\n            tree[index] = proofitem;\n        }\n        let indexqueue = Object.keys(tree).map(x => +x).sort((a, b) => a - b);\n        indexqueue = indexqueue.slice(0, indexqueue.length - 1);\n        let i = 0;\n        while (i < indexqueue.length) {\n            const index = indexqueue[i];\n            if (index >= 2 && ({}).hasOwnProperty.call(tree, index ^ 1)) {\n                let pair = [tree[index - (index % 2)], tree[index - (index % 2) + 1]];\n                if (this.sortPairs) {\n                    pair = pair.sort(Buffer.compare);\n                }\n                tree[(index / 2) | 0] = this.hashFn(Buffer.concat(pair));\n                indexqueue.push((index / 2) | 0);\n            }\n            i += 1;\n        }\n        return !indices.length || (({}).hasOwnProperty.call(tree, 1) && tree[1].equals(root));\n    }\n    /**\n     * getDepth\n     * @desc Returns the tree depth (number of layers)\n     * @return {Number}\n     * @example\n     *```js\n     *const depth = tree.getDepth()\n     *```\n     */\n    getDepth() {\n        return this.getLayers().length - 1;\n    }\n    /**\n     * getLayersAsObject\n     * @desc Returns the layers as nested objects instead of an array.\n     * @example\n     *```js\n     *const layersObj = tree.getLayersAsObject()\n     *```\n     */\n    getLayersAsObject() {\n        const layers = this.getLayers().map((layer) => layer.map((value) => this.bufferToHex(value, false)));\n        const objs = [];\n        for (let i = 0; i < layers.length; i++) {\n            const arr = [];\n            for (let j = 0; j < layers[i].length; j++) {\n                const obj = { [layers[i][j]]: null };\n                if (objs.length) {\n                    obj[layers[i][j]] = {};\n                    const a = objs.shift();\n                    const akey = Object.keys(a)[0];\n                    obj[layers[i][j]][akey] = a[akey];\n                    if (objs.length) {\n                        const b = objs.shift();\n                        const bkey = Object.keys(b)[0];\n                        obj[layers[i][j]][bkey] = b[bkey];\n                    }\n                }\n                arr.push(obj);\n            }\n            objs.push(...arr);\n        }\n        return objs[0];\n    }\n    /**\n     * verify\n     * @desc Returns true if the proof path (array of hashes) can connect the target node\n     * to the Merkle root.\n     * @param {Object[]} proof - Array of proof objects that should connect\n     * target node to Merkle root.\n     * @param {Buffer} targetNode - Target node Buffer\n     * @param {Buffer} root - Merkle root Buffer\n     * @param {Function} hashFunction - Hash function for hashing leaves and nodes\n     * @param {Object} options - Additional options\n     * @return {Boolean}\n     * @example\n     *```js\n     *const verified = MerkleTree.verify(proof, leaf, root, sha256, options)\n     *```\n     */\n    static verify(proof, targetNode, root, hashFn = sha256_1.default, options = {}) {\n        const tree = new MerkleTree([], hashFn, options);\n        return tree.verify(proof, targetNode, root);\n    }\n    /**\n     * getMultiProof\n     * @desc Returns the multiproof for given tree indices.\n     * @param {Buffer[]} tree - Tree as a flat array.\n     * @param {Number[]} indices - Tree indices.\n     * @return {Buffer[]} - Multiproofs\n     *\n     *@example\n     * ```js\n     *const flatTree = tree.getLayersFlat()\n     *const indices = [2, 5, 6]\n     *const proof = MerkleTree.getMultiProof(flatTree, indices)\n     *```\n     */\n    static getMultiProof(tree, indices) {\n        const t = new MerkleTree([]);\n        return t.getMultiProof(tree, indices);\n    }\n    /**\n     * getPairNode\n     * @desc Returns the node at the index for given layer.\n     * @param {Buffer[]} layer - Tree layer\n     * @param {Number} index - Index at layer.\n     * @return {Buffer} - Node\n     *\n     *@example\n     * ```js\n     *const node = tree.getPairNode(layer, index)\n     *```\n     */\n    _getPairNode(layer, idx) {\n        const pairIdx = idx % 2 === 0 ? idx + 1 : idx - 1;\n        if (pairIdx < layer.length) {\n            return layer[pairIdx];\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * toTreeString\n     * @desc Returns a visual representation of the merkle tree as a string.\n     * @return {String}\n     * @example\n     *```js\n     *console.log(tree.toTreeString())\n     *```\n     */\n    _toTreeString() {\n        const obj = this.getLayersAsObject();\n        return treeify_1.default.asTree(obj, true);\n    }\n    /**\n     * toString\n     * @desc Returns a visual representation of the merkle tree as a string.\n     * @example\n     *```js\n     *console.log(tree.toString())\n     *```\n     */\n    toString() {\n        return this._toTreeString();\n    }\n}\nexports.MerkleTree = MerkleTree;\nif (typeof window !== 'undefined') {\n    ;\n    window.MerkleTree = MerkleTree;\n}\nexports.default = MerkleTree;\n"]},"metadata":{},"sourceType":"script"}