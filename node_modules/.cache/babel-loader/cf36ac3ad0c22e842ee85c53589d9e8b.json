{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar assert_1 = require(\"./assert\");\n\nvar eth_util_1 = require(\"./eth-util\");\n/*\n * As per https://github.com/ethereum/wiki/wiki/JSON-RPC#hex-value-encoding\n * Quantities should be represented by the most compact hex representation possible\n * This means that no leading zeroes are allowed. There helpers make it easy\n * to convert to and from integers and their compact hex representation\n */\n\n\nfunction bufferToQuantityHex(buffer) {\n  buffer = eth_util_1.toBuffer(buffer);\n  var hex = buffer.toString('hex');\n  var trimmed = eth_util_1.unpad(hex);\n  return eth_util_1.addHexPrefix(trimmed);\n}\n\nexports.bufferToQuantityHex = bufferToQuantityHex;\n\nfunction intToQuantityHex(n) {\n  assert_1.assert(typeof n === 'number' && n === Math.floor(n), 'intToQuantityHex arg must be an integer');\n  var nHex = eth_util_1.toBuffer(n).toString('hex');\n\n  if (nHex[0] === '0') {\n    nHex = nHex.substring(1);\n  }\n\n  return eth_util_1.addHexPrefix(nHex);\n}\n\nexports.intToQuantityHex = intToQuantityHex;\n\nfunction quantityHexToInt(prefixedQuantityHex) {\n  assert_1.assert(typeof prefixedQuantityHex === 'string', 'arg to quantityHexToInt must be a string');\n  var quantityHex = eth_util_1.stripHexPrefix(prefixedQuantityHex);\n  var isEven = quantityHex.length % 2 === 0;\n\n  if (!isEven) {\n    quantityHex = '0' + quantityHex;\n  }\n\n  var buf = new Buffer(quantityHex, 'hex');\n  return eth_util_1.bufferToInt(buf);\n}\n\nexports.quantityHexToInt = quantityHexToInt;","map":{"version":3,"sources":["/Users/helen/fi/protocol-demo/frontend/node_modules/@bitski/provider-engine/dist/util/rpc-hex-encoding.js"],"names":["Object","defineProperty","exports","value","assert_1","require","eth_util_1","bufferToQuantityHex","buffer","toBuffer","hex","toString","trimmed","unpad","addHexPrefix","intToQuantityHex","n","assert","Math","floor","nHex","substring","quantityHexToInt","prefixedQuantityHex","quantityHex","stripHexPrefix","isEven","length","buf","Buffer","bufferToInt"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,IAAIC,QAAQ,GAAGC,OAAO,CAAC,UAAD,CAAtB;;AACA,IAAIC,UAAU,GAAGD,OAAO,CAAC,YAAD,CAAxB;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASE,mBAAT,CAA6BC,MAA7B,EAAqC;AACjCA,EAAAA,MAAM,GAAGF,UAAU,CAACG,QAAX,CAAoBD,MAApB,CAAT;AACA,MAAIE,GAAG,GAAGF,MAAM,CAACG,QAAP,CAAgB,KAAhB,CAAV;AACA,MAAIC,OAAO,GAAGN,UAAU,CAACO,KAAX,CAAiBH,GAAjB,CAAd;AACA,SAAOJ,UAAU,CAACQ,YAAX,CAAwBF,OAAxB,CAAP;AACH;;AACDV,OAAO,CAACK,mBAAR,GAA8BA,mBAA9B;;AACA,SAASQ,gBAAT,CAA0BC,CAA1B,EAA6B;AACzBZ,EAAAA,QAAQ,CAACa,MAAT,CAAgB,OAAOD,CAAP,KAAa,QAAb,IAAyBA,CAAC,KAAKE,IAAI,CAACC,KAAL,CAAWH,CAAX,CAA/C,EAA8D,yCAA9D;AACA,MAAII,IAAI,GAAGd,UAAU,CAACG,QAAX,CAAoBO,CAApB,EAAuBL,QAAvB,CAAgC,KAAhC,CAAX;;AACA,MAAIS,IAAI,CAAC,CAAD,CAAJ,KAAY,GAAhB,EAAqB;AACjBA,IAAAA,IAAI,GAAGA,IAAI,CAACC,SAAL,CAAe,CAAf,CAAP;AACH;;AACD,SAAOf,UAAU,CAACQ,YAAX,CAAwBM,IAAxB,CAAP;AACH;;AACDlB,OAAO,CAACa,gBAAR,GAA2BA,gBAA3B;;AACA,SAASO,gBAAT,CAA0BC,mBAA1B,EAA+C;AAC3CnB,EAAAA,QAAQ,CAACa,MAAT,CAAgB,OAAOM,mBAAP,KAA+B,QAA/C,EAAyD,0CAAzD;AACA,MAAIC,WAAW,GAAGlB,UAAU,CAACmB,cAAX,CAA0BF,mBAA1B,CAAlB;AACA,MAAIG,MAAM,GAAGF,WAAW,CAACG,MAAZ,GAAqB,CAArB,KAA2B,CAAxC;;AACA,MAAI,CAACD,MAAL,EAAa;AACTF,IAAAA,WAAW,GAAG,MAAMA,WAApB;AACH;;AACD,MAAII,GAAG,GAAG,IAAIC,MAAJ,CAAWL,WAAX,EAAwB,KAAxB,CAAV;AACA,SAAOlB,UAAU,CAACwB,WAAX,CAAuBF,GAAvB,CAAP;AACH;;AACD1B,OAAO,CAACoB,gBAAR,GAA2BA,gBAA3B","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar assert_1 = require(\"./assert\");\nvar eth_util_1 = require(\"./eth-util\");\n/*\n * As per https://github.com/ethereum/wiki/wiki/JSON-RPC#hex-value-encoding\n * Quantities should be represented by the most compact hex representation possible\n * This means that no leading zeroes are allowed. There helpers make it easy\n * to convert to and from integers and their compact hex representation\n */\nfunction bufferToQuantityHex(buffer) {\n    buffer = eth_util_1.toBuffer(buffer);\n    var hex = buffer.toString('hex');\n    var trimmed = eth_util_1.unpad(hex);\n    return eth_util_1.addHexPrefix(trimmed);\n}\nexports.bufferToQuantityHex = bufferToQuantityHex;\nfunction intToQuantityHex(n) {\n    assert_1.assert(typeof n === 'number' && n === Math.floor(n), 'intToQuantityHex arg must be an integer');\n    var nHex = eth_util_1.toBuffer(n).toString('hex');\n    if (nHex[0] === '0') {\n        nHex = nHex.substring(1);\n    }\n    return eth_util_1.addHexPrefix(nHex);\n}\nexports.intToQuantityHex = intToQuantityHex;\nfunction quantityHexToInt(prefixedQuantityHex) {\n    assert_1.assert(typeof prefixedQuantityHex === 'string', 'arg to quantityHexToInt must be a string');\n    var quantityHex = eth_util_1.stripHexPrefix(prefixedQuantityHex);\n    var isEven = quantityHex.length % 2 === 0;\n    if (!isEven) {\n        quantityHex = '0' + quantityHex;\n    }\n    var buf = new Buffer(quantityHex, 'hex');\n    return eth_util_1.bufferToInt(buf);\n}\nexports.quantityHexToInt = quantityHexToInt;\n"]},"metadata":{},"sourceType":"script"}