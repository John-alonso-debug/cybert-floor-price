{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the\n * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n * express or implied. See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AuthorizationRequest = void 0;\n\nvar crypto_utils_1 = require(\"./crypto_utils\");\n\nvar logger_1 = require(\"./logger\");\n/**\n * Generates a cryptographically random new state. Useful for CSRF protection.\n */\n\n\nvar SIZE = 10; // 10 bytes\n\nvar newState = function (crypto) {\n  return crypto.generateRandom(SIZE);\n};\n/**\n * Represents the AuthorizationRequest.\n * For more information look at\n * https://tools.ietf.org/html/rfc6749#section-4.1.1\n */\n\n\nvar AuthorizationRequest =\n/** @class */\nfunction () {\n  /**\n   * Constructs a new AuthorizationRequest.\n   * Use a `undefined` value for the `state` parameter, to generate a random\n   * state for CSRF protection.\n   */\n  function AuthorizationRequest(request, crypto, usePkce) {\n    if (crypto === void 0) {\n      crypto = new crypto_utils_1.DefaultCrypto();\n    }\n\n    if (usePkce === void 0) {\n      usePkce = true;\n    }\n\n    this.crypto = crypto;\n    this.usePkce = usePkce;\n    this.clientId = request.client_id;\n    this.redirectUri = request.redirect_uri;\n    this.scope = request.scope;\n    this.responseType = request.response_type || AuthorizationRequest.RESPONSE_TYPE_CODE;\n    this.state = request.state || newState(crypto);\n    this.extras = request.extras; // read internal properties if available\n\n    this.internal = request.internal;\n  }\n\n  AuthorizationRequest.prototype.setupCodeVerifier = function () {\n    var _this = this;\n\n    if (!this.usePkce) {\n      return Promise.resolve();\n    } else {\n      var codeVerifier_1 = this.crypto.generateRandom(128);\n      var challenge = this.crypto.deriveChallenge(codeVerifier_1).catch(function (error) {\n        logger_1.log('Unable to generate PKCE challenge. Not using PKCE', error);\n        return undefined;\n      });\n      return challenge.then(function (result) {\n        if (result) {\n          // keep track of the code used.\n          _this.internal = _this.internal || {};\n          _this.internal['code_verifier'] = codeVerifier_1;\n          _this.extras = _this.extras || {};\n          _this.extras['code_challenge'] = result; // We always use S256. Plain is not good enough.\n\n          _this.extras['code_challenge_method'] = 'S256';\n        }\n      });\n    }\n  };\n  /**\n   * Serializes the AuthorizationRequest to a JavaScript Object.\n   */\n\n\n  AuthorizationRequest.prototype.toJson = function () {\n    var _this = this; // Always make sure that the code verifier is setup when toJson() is called.\n\n\n    return this.setupCodeVerifier().then(function () {\n      return {\n        response_type: _this.responseType,\n        client_id: _this.clientId,\n        redirect_uri: _this.redirectUri,\n        scope: _this.scope,\n        state: _this.state,\n        extras: _this.extras,\n        internal: _this.internal\n      };\n    });\n  };\n\n  AuthorizationRequest.RESPONSE_TYPE_TOKEN = 'token';\n  AuthorizationRequest.RESPONSE_TYPE_CODE = 'code';\n  return AuthorizationRequest;\n}();\n\nexports.AuthorizationRequest = AuthorizationRequest;","map":{"version":3,"sources":["../src/authorization_request.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the\n * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n * express or implied. See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Crypto, DefaultCrypto} from './crypto_utils';\nimport {log} from './logger';\nimport {StringMap} from './types';\n\n/**\n * Represents an AuthorizationRequest as JSON.\n */\nexport interface AuthorizationRequestJson {\n  response_type: string;\n  client_id: string;\n  redirect_uri: string;\n  scope: string;\n  state?: string;\n  extras?: StringMap;\n  internal?: StringMap;\n}\n\n/**\n * Generates a cryptographically random new state. Useful for CSRF protection.\n */\nconst SIZE = 10;  // 10 bytes\nconst newState = function(crypto: Crypto): string {\n  return crypto.generateRandom(SIZE);\n};\n\n/**\n * Represents the AuthorizationRequest.\n * For more information look at\n * https://tools.ietf.org/html/rfc6749#section-4.1.1\n */\nexport class AuthorizationRequest {\n  static RESPONSE_TYPE_TOKEN = 'token';\n  static RESPONSE_TYPE_CODE = 'code';\n\n  // NOTE:\n  // Both redirect_uri and state are actually optional.\n  // However AppAuth is more opionionated, and requires you to use both.\n\n  clientId: string;\n  redirectUri: string;\n  scope: string;\n  responseType: string;\n  state: string;\n  extras?: StringMap;\n  internal?: StringMap;\n  /**\n   * Constructs a new AuthorizationRequest.\n   * Use a `undefined` value for the `state` parameter, to generate a random\n   * state for CSRF protection.\n   */\n  constructor(\n      request: AuthorizationRequestJson,\n      private crypto: Crypto = new DefaultCrypto(),\n      private usePkce: boolean = true) {\n    this.clientId = request.client_id;\n    this.redirectUri = request.redirect_uri;\n    this.scope = request.scope;\n    this.responseType = request.response_type || AuthorizationRequest.RESPONSE_TYPE_CODE;\n    this.state = request.state || newState(crypto);\n    this.extras = request.extras;\n    // read internal properties if available\n    this.internal = request.internal;\n  }\n\n  setupCodeVerifier(): Promise<void> {\n    if (!this.usePkce) {\n      return Promise.resolve();\n    } else {\n      const codeVerifier = this.crypto.generateRandom(128);\n      const challenge: Promise<string|undefined> =\n          this.crypto.deriveChallenge(codeVerifier).catch(error => {\n            log('Unable to generate PKCE challenge. Not using PKCE', error);\n            return undefined;\n          });\n      return challenge.then(result => {\n        if (result) {\n          // keep track of the code used.\n          this.internal = this.internal || {};\n          this.internal['code_verifier'] = codeVerifier;\n          this.extras = this.extras || {};\n          this.extras['code_challenge'] = result;\n          // We always use S256. Plain is not good enough.\n          this.extras['code_challenge_method'] = 'S256';\n        }\n      });\n    }\n  }\n\n  /**\n   * Serializes the AuthorizationRequest to a JavaScript Object.\n   */\n  toJson(): Promise<AuthorizationRequestJson> {\n    // Always make sure that the code verifier is setup when toJson() is called.\n    return this.setupCodeVerifier().then(() => {\n      return {\n        response_type: this.responseType,\n        client_id: this.clientId,\n        redirect_uri: this.redirectUri,\n        scope: this.scope,\n        state: this.state,\n        extras: this.extras,\n        internal: this.internal\n      };\n    });\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}