(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Bitski = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AccessToken = void 0;

/**
 * Represents a Bitski access token
 */
class AccessToken {
  /**
   *
   * @param token the access token
   * @param expiresAt the token expiration date (in seconds) (optional)
   * @param scope the scopes this token represents (optional)
   */
  constructor(token, expiresAt, scope) {
    this.token = token;
    this.scope = scope;
    this.expiresAt = expiresAt;
  }
  /**
   * Creates a token from a TokenResponse object
   * @param tokenResponse The token response object to build a token from
   */


  static fromTokenResponse(tokenResponse) {
    let expiresAt;

    if (tokenResponse.expiresIn) {
      expiresAt = Math.floor(Date.now() / 1000) + tokenResponse.expiresIn;
    }

    return new AccessToken(tokenResponse.accessToken, expiresAt, tokenResponse.scope);
  }
  /**
   * Creates a token from a storage string
   * @param s JSON string representing the token
   */


  static fromString(s) {
    let parsed;

    try {
      parsed = JSON.parse(s);
    } catch (error) {
      return;
    }

    if (!parsed.token) {
      return;
    }

    return new AccessToken(parsed.token, parsed.expiresAt, parsed.scope);
  }
  /**
   * Calculates if the token is still active
   */


  get expired() {
    if (this.expiresAt) {
      const now = Math.floor(Date.now() / 1000);
      const expiresIn = this.expiresAt - now;
      return expiresIn <= 0;
    }

    return false;
  }
  /**
   * Returns a JSON string suitable for writing in local storage
   */


  toStorageString() {
    return JSON.stringify({
      expiresAt: this.expiresAt,
      scope: this.scope,
      token: this.token
    });
  }

}

exports.AccessToken = AccessToken;

},{}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OAuthManager = exports.LOGIN_HINT_SIGNUP = void 0;

var _appauth = require("@openid/appauth");

var _constants = require("../constants");

var _authenticationError = require("../errors/authentication-error");

var _noHashQueryStringUtils = require("../utils/no-hash-query-string-utils");

var _requestUtils = require("../utils/request-utils");

var _popupHandler = require("./popup-handler");

// Use this constant in login_hint to indicate that the sign up UI should be displayed
const LOGIN_HINT_SIGNUP = 'signup';
/**
 * Responsible for submitting requests to our OAuth server.
 */

exports.LOGIN_HINT_SIGNUP = LOGIN_HINT_SIGNUP;

class OAuthManager {
  /**
   * Create a new OAuth Manager
   * @param options Settings object
   * @param options.clientId string: The client id to use for various requests
   * @param options.redirectUri string: The redirect URI to use for responding to auth requests
   * @param options.configuration AuthorizationServiceConfiguration (optional): The configuration for the OAuth server
   * @param options.additionalScopes string[] (optional): Additional scopes to request outside of openid.
   * Default is offline. Pass an empty array to only request openid.
   */
  constructor(options) {
    this.clientId = options.clientId;
    this.redirectUri = options.redirectUri;
    this.configuration = options.configuration || new _appauth.AuthorizationServiceConfiguration(_constants.DEFAULT_OAUTH_CONFIGURATION);
    const additionalScopes = options.additionalScopes || _constants.DEFAULT_OPTIONAL_SCOPES;
    this.scopes = _constants.DEFAULT_SCOPES.concat(additionalScopes);
    this.tokenHandler = new _appauth.BaseTokenRequestHandler(new _appauth.FetchRequestor());
    this.notifier = new _appauth.AuthorizationNotifier();
    this.notifier.setAuthorizationListener(this.didCompleteAuthorizationFlow.bind(this));
  }
  /**
   * Trigger a popup sign in flow (the default)
   */


  signInPopup(opts) {
    opts = opts || {};
    const promise = new Promise((fulfill, reject) => {
      this.pendingResolver = {
        fulfill,
        reject
      };
    });
    this.authHandler = new _popupHandler.PopupRequestHandler();
    this.authHandler.setAuthorizationNotifier(this.notifier);
    const request = this.createAuthRequest(opts);
    this.authHandler.performAuthorizationRequest(this.configuration, request);
    return promise.then(response => {
      return this.requestAccessToken(response.code);
    });
  }
  /**
   * Trigger a redirect sign in flow. Promise should never fulfill, as you will be redirected.
   */


  signInRedirect(opts) {
    opts = opts || {};
    const promise = new Promise((fulfill, reject) => {
      this.pendingResolver = {
        fulfill,
        reject
      };
    });
    this.authHandler = new _appauth.RedirectRequestHandler(undefined, new _noHashQueryStringUtils.NoHashQueryStringUtils());
    this.authHandler.setAuthorizationNotifier(this.notifier);
    const request = this.createAuthRequest(opts);
    this.authHandler.performAuthorizationRequest(this.configuration, request); // Since this method redirects the whole window, the promise will
    // likely never complete unless we encounter an error.

    return promise;
  }
  /**
   * Attempt to finalize auth request from a redirect flow. Called from your redirect url once you've been
   * redirected back.
   */


  redirectCallback() {
    const promise = new Promise((fulfill, reject) => {
      this.pendingResolver = {
        fulfill,
        reject
      };
    });
    this.authHandler = new _appauth.RedirectRequestHandler(undefined, new _noHashQueryStringUtils.NoHashQueryStringUtils());
    this.authHandler.setAuthorizationNotifier(this.notifier);
    this.authHandler.completeAuthorizationRequestIfPossible();
    return promise.then(response => {
      return this.requestAccessToken(response.code);
    });
  }
  /**
   * Exchange an authorization code for an access token
   * @param code The authorization code to exchange
   */


  requestAccessToken(code) {
    const request = this.createTokenRequest(code);
    return this.tokenHandler.performTokenRequest(this.configuration, request);
  }
  /**
   * Request a new access token from a previous refresh token
   * @param refreshToken The refresh token to use for authorization
   */


  refreshAccessToken(refreshToken) {
    const request = this.createRefreshTokenRequest(refreshToken);
    return this.tokenHandler.performTokenRequest(this.configuration, request);
  }
  /**
   * Submit a sign out request on the oauth endpoint
   * @param accessToken The access token to sign out with
   */


  requestSignOut(accessToken) {
    return fetch("".concat(_constants.BITSKI_USER_API_HOST, "/logout"), {
      headers: {
        'Accept': 'application/json',
        'Authorization': "Bearer ".concat(accessToken),
        'Content-Type': 'application/json'
      },
      method: 'POST'
    }).then(response => {
      return (0, _requestUtils.parseResponse)(response);
    });
  }
  /**
   * Request a user's profile from the oauth server
   * @param accessToken The access token for the user
   */


  requestUserInfo(accessToken) {
    const userInfoEndpoint = this.configuration.userInfoEndpoint;

    if (!userInfoEndpoint) {
      return Promise.reject(_authenticationError.AuthenticationError.InvalidConfiguration('Could not find user info endpoint'));
    }

    return fetch(userInfoEndpoint, {
      headers: {
        Accept: 'application/json',
        Authorization: "Bearer ".concat(accessToken)
      }
    }).then(response => {
      return (0, _requestUtils.parseResponse)(response);
    });
  }
  /**
   * Internal callback from our Auth Request handler. Passes the response through to a cached promise if it exists.
   * @param request The original auth request
   * @param response The auth response if it was successful
   * @param errorResponse The error response if it failed
   */


  didCompleteAuthorizationFlow(request, response, errorResponse) {
    if (this.pendingResolver) {
      if (response) {
        this.pendingResolver.fulfill(response);
        this.pendingResolver = undefined;
      } else if (errorResponse) {
        if (errorResponse instanceof _popupHandler.PopupClosedError) {
          this.pendingResolver.reject(_authenticationError.AuthenticationError.UserCancelled());
        } else if (errorResponse instanceof _popupHandler.PopupBlockedError) {
          // Parse domain of the authority, to log better context for error.
          const urlMatch = /^(http?s:\/\/[\w.]*)\/[\w\/]*$/; // Check for matches against the authority

          const matches = this.configuration.authorizationEndpoint.match(urlMatch);
          const baseUrl = matches && matches.length > 1 ? matches[1] : '';
          this.pendingResolver.reject(_authenticationError.AuthenticationError.PopupBlocked(baseUrl));
        } else {
          this.pendingResolver.reject(_authenticationError.AuthenticationError.ServerError(errorResponse.error, errorResponse.errorDescription));
        }

        this.pendingResolver = undefined;
      }
    }
  }
  /**
   * Factory method to create an auth request
   */


  createAuthRequest(opts) {
    // Create base request
    const request = new _appauth.AuthorizationRequest({
      client_id: this.clientId,
      redirect_uri: this.redirectUri,
      response_type: _appauth.AuthorizationRequest.RESPONSE_TYPE_CODE,
      scope: this.scopes.join(' ')
    }, undefined, false); // Pass options through

    if (opts.login_hint) {
      // Only assign extras if login_hint is included in the options
      request.extras = {
        login_hint: opts.login_hint
      };
    }

    return request;
  }
  /**
   * Factory method to create a token request with a refresh token
   * @param refreshToken Refresh token to use
   */


  createRefreshTokenRequest(refreshToken) {
    return new _appauth.TokenRequest({
      client_id: this.clientId,
      grant_type: _appauth.GRANT_TYPE_REFRESH_TOKEN,
      redirect_uri: this.redirectUri,
      refresh_token: refreshToken
    });
  }
  /**
   * Factory method to create a token request with an auth code
   * @param code The auth code to use
   */


  createTokenRequest(code) {
    return new _appauth.TokenRequest({
      client_id: this.clientId,
      code,
      grant_type: _appauth.GRANT_TYPE_AUTHORIZATION_CODE,
      redirect_uri: this.redirectUri
    });
  }

}

exports.OAuthManager = OAuthManager;

},{"../constants":11,"../errors/authentication-error":12,"../utils/no-hash-query-string-utils":26,"../utils/request-utils":28,"./popup-handler":4,"@openid/appauth":97}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OpenidAuthProvider = void 0;

var _bitski = require("../bitski");

var _authenticationError = require("../errors/authentication-error");

var _oauthManager = require("./oauth-manager");

var _tokenStore = require("./token-store");

var _user = require("./user");

var _userStore = require("./user-store");

class OpenidAuthProvider {
  constructor(clientId, redirectUri, additionalScopes, opts) {
    opts = opts || {};
    const settings = {
      additionalScopes,
      clientId,
      redirectUri
    };
    Object.assign(settings, opts);
    this.oauthManager = new _oauthManager.OAuthManager(settings);
    this.tokenStore = new _tokenStore.TokenStore(clientId, opts.store);
    this.userStore = new _userStore.UserStore(clientId, opts.store);
  }

  get authStatus() {
    if (this.tokenStore.currentToken) {
      return _bitski.AuthenticationStatus.Connected;
    } else if (this.tokenStore.refreshToken) {
      return _bitski.AuthenticationStatus.Expired;
    } else {
      return _bitski.AuthenticationStatus.NotConnected;
    }
  }

  getAccessToken() {
    if (this.tokenStore.currentToken) {
      return Promise.resolve(this.tokenStore.currentToken);
    }

    if (this.tokenStore.refreshToken) {
      return this.refreshAccessToken();
    }

    return Promise.reject(_authenticationError.AuthenticationError.NotSignedIn());
  }

  getRefreshToken() {
    if (this.tokenStore.refreshToken) {
      return Promise.resolve(this.tokenStore.refreshToken);
    } // Error: the user did not approve this app for offline access


    if (this.tokenStore.currentToken) {
      return Promise.reject(_authenticationError.AuthenticationError.NoRefreshToken());
    } // Error: the user is not signed in.


    return Promise.reject(_authenticationError.AuthenticationError.NotSignedIn());
  }

  invalidateToken() {
    if (this.tokenStore.currentToken) {
      this.tokenStore.invalidateCurrentToken();
    }

    if (this.signOutCallback) {
      this.signOutCallback();
    }

    return Promise.resolve();
  }

  refreshAccessToken() {
    if (this.tokenStore.refreshToken) {
      return this.oauthManager.refreshAccessToken(this.tokenStore.refreshToken).then(tokenResponse => {
        this.tokenStore.persistTokenResponse(tokenResponse);
        return tokenResponse.accessToken;
      }).catch(error => {
        // If we can't renew, we likely have bad data
        this.tokenStore.clear();
        this.userStore.clear();
        throw error;
      });
    }

    return Promise.reject(_authenticationError.AuthenticationError.NoRefreshToken());
  }

  signIn(method, opts) {
    let promise;

    switch (method) {
      case _bitski.OAuthSignInMethod.Redirect:
        promise = this.oauthManager.signInRedirect(opts);
        break;

      case _bitski.OAuthSignInMethod.Silent:
        return Promise.reject(_authenticationError.AuthenticationError.UnsupportedAuthenticationMethod());

      default:
        promise = this.oauthManager.signInPopup(opts);
        break;
    }

    return promise.then(tokenResponse => {
      this.tokenStore.persistTokenResponse(tokenResponse);
      return this.loadUser();
    });
  }

  connect() {
    return this.refreshAccessToken().then(() => {
      return this.loadUser();
    });
  }

  getUser() {
    return this.getOrFetchUser();
  }

  signInOrConnect() {
    let signInMethod = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _bitski.OAuthSignInMethod.Popup;
    let opts = arguments.length > 1 ? arguments[1] : undefined;

    switch (this.authStatus) {
      case _bitski.AuthenticationStatus.Connected:
        return this.loadUser();

      case _bitski.AuthenticationStatus.Expired:
        return this.connect();

      case _bitski.AuthenticationStatus.NotConnected:
        return this.signIn(signInMethod, opts);
    }
  }

  redirectCallback() {
    return this.oauthManager.redirectCallback().then(tokenResponse => {
      this.tokenStore.persistTokenResponse(tokenResponse);
      return this.loadUser();
    });
  }

  signOut() {
    this.tokenStore.clear();
    this.userStore.clear(); // Call the sign out callback if one has been provided

    if (this.signOutCallback) {
      this.signOutCallback();
    } // We don't currently have the ability to invalidate access tokens, so for now simply resolve.
    // Down the road this may perform a network request to invalidate.


    return Promise.resolve();
  }

  getOrFetchUser() {
    const currentUser = this.userStore.currentUser;

    if (currentUser) {
      return Promise.resolve(currentUser);
    }

    return this.loadUser();
  }

  loadUser() {
    return this.getAccessToken().then(accessToken => {
      return this.oauthManager.requestUserInfo(accessToken);
    }).then(json => {
      return _user.User.fromJson(json);
    }).then(user => {
      this.userStore.set(user);
      return user;
    });
  }

}

exports.OpenidAuthProvider = OpenidAuthProvider;

},{"../bitski":8,"../errors/authentication-error":12,"./oauth-manager":2,"./token-store":5,"./user":7,"./user-store":6}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PopupRequestHandler = exports.PopupBlockedError = exports.PopupClosedError = void 0;

var _appauth = require("@openid/appauth");

var _constants = require("../constants");

var _callback = require("../utils/callback");

var _popupValidator = require("../utils/popup-validator");

// tslint:disable max-classes-per-file
// Intermediate errors, since AuthorizationRequestHandler must return an AuthorizationError instance.
// These should not be user visible.
class PopupClosedError extends _appauth.AuthorizationError {
  constructor() {
    super({
      error: 'The popup was dismissed.'
    });
  }

}

exports.PopupClosedError = PopupClosedError;

class PopupBlockedError extends _appauth.AuthorizationError {
  constructor() {
    super({
      error: 'The popup was blocked.'
    });
  }

} // Create a popup feature string from an object with keys and values


exports.PopupBlockedError = PopupBlockedError;

function createPopupFeatureString(features) {
  // Convert to array of strings
  const featuresArray = Object.keys(features).reduce((arr, key) => {
    const value = features[key]; // convert to feature string format: top=100

    arr.push("".concat(key, "=").concat(value));
    return arr;
  }, Array()); // Join strings with ',' and finish with ';'

  return featuresArray.join(',') + ';';
} // Returns a set of attributes for a centered popup based on
// the default values from constants.ts


function createCenteredPopupFeatures() {
  const windowFeatures = _constants.DEFAULT_POPUP_FEATURES;
  const w = windowFeatures.width;
  const h = windowFeatures.height; // Fixes dual-screen position

  const dualScreenLeft = window.screenLeft || window.screenX;
  const dualScreenTop = window.screenTop || window.screenY;
  const windowWidth = window.innerWidth || document.documentElement.clientWidth || screen.width;
  const windowHeight = window.innerHeight || document.documentElement.clientHeight || screen.height;
  const left = windowWidth / 2 - w / 2;
  const top = windowHeight / 2 - h / 2;
  windowFeatures.left = left + dualScreenLeft;
  windowFeatures.top = top + dualScreenTop;
  return windowFeatures;
}

class PopupRequestHandler extends _appauth.AuthorizationRequestHandler {
  constructor() {
    let utils = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _appauth.BasicQueryStringUtils();
    let crypto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _appauth.DefaultCrypto();
    super(utils, crypto);
    this.popupWindow = null;
    this.isCancelled = false;
    this.isBlocked = false; // Watch for the popup being blocked

    this.validator = new _popupValidator.PopupValidator(() => {
      // Return a specific error if blocked, so that we can handle it appropriately.
      this.isBlocked = true;
      this.completeAuthorizationRequestIfPossible();
    });
  }

  performAuthorizationRequest(configuration, request) {
    const url = this.buildRequestUrl(configuration, request);
    this.pendingRequest = request;
    this.id = request.state; // Set a unique handler on the main window

    window["popupCallback_".concat(request.state)] = this.callback.bind(this); // Start monitoring to see if the popup has been closed

    this.closedTimer = window.setInterval(this.checkPopup.bind(this), _constants.CHECK_FOR_POPUP_CLOSE_INTERVAL); // Create features for popup

    const windowFeatures = createCenteredPopupFeatures(); // Create popup window

    this.popupWindow = window.open(url, '_blank', createPopupFeatureString(windowFeatures)); // Check if the popup we just created was blocked.

    this.validator.check(this.popupWindow); // Focus the popup to bring it to the front

    if (this.popupWindow) {
      this.popupWindow.focus();
    }
  }

  callback(url) {
    this.responseUrl = url;
    this.completeAuthorizationRequestIfPossible();
  } // Custom implementation to remove excess log spam


  completeAuthorizationRequestIfPossible() {
    return this.completeAuthorizationRequest().then(result => {
      if (result && this.notifier) {
        this.notifier.onAuthorizationComplete(result.request, result.response, result.error);
      }
    });
  }

  completeAuthorizationRequest() {
    const request = this.pendingRequest; // Assert there is a pending request

    if (!request) {
      return Promise.resolve(null);
    } // Assert the request wasn't cancelled


    if (this.isCancelled === true) {
      return this.respondWithCancelled(request);
    }

    if (this.isBlocked === true) {
      return this.respondWithBlocked(request);
    } // Assert there is no error


    if (this.error) {
      return this.respondWithError(request, this.error.message);
    } // Assert there is a response url to parse


    if (!this.responseUrl) {
      return Promise.resolve(null);
    } // Parse the url into data


    const data = (0, _callback.parseUrlParams)(this.responseUrl); // Extra the state

    const state = data.state; // Validate state is same as request

    if (request.state !== state) {
      return Promise.resolve(null);
    } // Check for an error response


    const error = data.error;

    if (error) {
      // get additional optional info.
      const errorUri = data.error_uri;
      const errorDescription = data.error_description;
      return this.respondWithError(request, error, errorDescription, errorUri);
    } // Respond with a code


    const code = data.code;
    return this.respondWithCode(request, code);
  }

  respondWithBlocked(request) {
    const error = new PopupBlockedError();
    const response = {
      request,
      error,
      response: null
    };
    this.cleanup();
    return Promise.resolve(response);
  }

  respondWithCancelled(request) {
    const error = new PopupClosedError();
    const response = {
      request,
      error,
      response: null
    };
    this.cleanup();
    return Promise.resolve(response);
  }

  respondWithError(request, errorMessage, errorDescription, errorUri) {
    const error = new _appauth.AuthorizationError({
      error: errorMessage,
      error_description: errorDescription,
      error_uri: errorUri,
      state: request.state
    });
    const response = {
      request,
      error,
      response: null
    };
    this.cleanup();
    return Promise.resolve(response);
  }

  respondWithCode(request, code) {
    let authorizationResponse = null;

    if (code) {
      authorizationResponse = new _appauth.AuthorizationResponse({
        code,
        state: request.state
      });
    }

    const response = {
      request,
      response: authorizationResponse,
      error: null
    };
    this.cleanup();
    return Promise.resolve(response);
  }

  cleanup() {
    window.clearInterval(this.closedTimer);
    delete window["popupCallback_".concat(this.id)];

    if (this.popupWindow) {
      this.popupWindow.close();
    }

    this.popupWindow = null;
    this.pendingRequest = undefined;
    this.error = undefined;
    this.id = undefined;
    this.responseUrl = undefined;
  }

  checkPopup() {
    if (this.popupWindow && this.popupWindow.closed) {
      // Stop checking
      window.clearInterval(this.closedTimer);
      this.isCancelled = true;
      this.completeAuthorizationRequestIfPossible();
    }
  }

}

exports.PopupRequestHandler = PopupRequestHandler;

},{"../constants":11,"../utils/callback":24,"../utils/popup-validator":27,"@openid/appauth":97}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TokenStore = void 0;

var _constants = require("../constants");

var _localstorageStore = require("../utils/localstorage-store");

var _accessToken = require("./access-token");

class TokenStore {
  constructor(clientId, store) {
    this.clientId = clientId;
    this.store = store || new _localstorageStore.LocalStorageStore();
    const accessTokenString = this.store.getItem(this.accessTokenKey);

    if (accessTokenString) {
      let parsedToken;

      try {
        parsedToken = _accessToken.AccessToken.fromString(accessTokenString);
      } finally {
        this.accessToken = parsedToken;
      }
    }
  }

  get currentToken() {
    if (this.accessToken && !this.accessToken.expired) {
      return this.accessToken.token;
    }
  }

  get refreshToken() {
    const token = this.store.getItem(this.refreshTokenKey);

    if (token) {
      return token;
    }
  }

  get accessTokenKey() {
    return "".concat(_constants.ACCESS_TOKEN_KEY, ".").concat(this.clientId);
  }

  get refreshTokenKey() {
    return "".concat(_constants.REFRESH_TOKEN_KEY, ".").concat(this.clientId);
  }

  persistTokenResponse(response) {
    if (response.refreshToken) {
      this.store.setItem(this.refreshTokenKey, response.refreshToken);
    }

    const parsedToken = _accessToken.AccessToken.fromTokenResponse(response);

    this.store.setItem(this.accessTokenKey, parsedToken.toStorageString());
    this.accessToken = parsedToken;
  }

  invalidateCurrentToken() {
    this.accessToken = undefined;
    this.store.clearItem(this.accessTokenKey);
  }

  clear() {
    this.accessToken = undefined;
    this.store.clearItem(this.refreshTokenKey);
    this.store.clearItem(this.accessTokenKey);
  }

}

exports.TokenStore = TokenStore;

},{"../constants":11,"../utils/localstorage-store":25,"./access-token":1}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UserStore = void 0;

var _constants = require("../constants");

var _localstorageStore = require("../utils/localstorage-store");

var _user = require("./user");

class UserStore {
  constructor(clientId, store) {
    this.clientId = clientId;
    this.store = store || new _localstorageStore.LocalStorageStore();
    this.user = this.fetchUser();
  }

  get currentUser() {
    return this.user || this.fetchUser();
  }

  get storageKey() {
    return "".concat(_constants.USER_KEY, ".").concat(this.clientId);
  }

  set(user) {
    this.user = user;
    this.cacheUser(user);
  }

  clear() {
    this.user = undefined;
    this.cacheUser(undefined);
  }

  fetchUser() {
    const userData = this.store.getItem(this.storageKey);

    if (userData) {
      return _user.User.fromString(userData);
    }
  }

  cacheUser(user) {
    if (user) {
      this.store.setItem(this.storageKey, user.toStorageString());
    } else {
      this.store.clearItem(this.storageKey);
    }
  }

}

exports.UserStore = UserStore;

},{"../constants":11,"../utils/localstorage-store":25,"./user":7}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.User = void 0;

class User {
  constructor(id, accounts, email, emailVerified, phone, phoneNumberVerified) {
    this.id = id;
    this.accounts = accounts;
    this.email = email;
    this.emailVerified = emailVerified;
    this.phoneNumber = phone;
    this.phoneNumberVerified = phoneNumberVerified;
  }

  static fromJson(json) {
    return new User(json.sub, json.accounts, json.email, json.email_verified, json.phone_number, json.phone_number_verified);
  }

  static fromString(s) {
    let parsed;

    try {
      parsed = JSON.parse(s);
    } catch (e) {
      return;
    }

    if (parsed.id) {
      return new User(parsed.id, parsed.accounts, parsed.email, parsed.emailVerified, parsed.phoneNumber, parsed.phoneNumberVerified);
    }

    return;
  }

  toStorageString() {
    return JSON.stringify({
      accounts: this.accounts,
      email: this.email,
      emailVerified: this.emailVerified,
      id: this.id,
      phoneNumber: this.phoneNumber,
      phoneNumberVerified: this.phoneNumberVerified
    });
  }

}

exports.User = User;

},{}],8:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Kovan", {
  enumerable: true,
  get: function get() {
    return _bitskiProvider.Kovan;
  }
});
Object.defineProperty(exports, "Mainnet", {
  enumerable: true,
  get: function get() {
    return _bitskiProvider.Mainnet;
  }
});
Object.defineProperty(exports, "Rinkeby", {
  enumerable: true,
  get: function get() {
    return _bitskiProvider.Rinkeby;
  }
});
Object.defineProperty(exports, "LOGIN_HINT_SIGNUP", {
  enumerable: true,
  get: function get() {
    return _oauthManager.LOGIN_HINT_SIGNUP;
  }
});
Object.defineProperty(exports, "ConnectButtonSize", {
  enumerable: true,
  get: function get() {
    return _connectButton.ConnectButtonSize;
  }
});
Object.defineProperty(exports, "LocalStorageStore", {
  enumerable: true,
  get: function get() {
    return _localstorageStore.LocalStorageStore;
  }
});
Object.defineProperty(exports, "AuthenticationError", {
  enumerable: true,
  get: function get() {
    return _authenticationError.AuthenticationError;
  }
});
Object.defineProperty(exports, "AuthenticationErrorCode", {
  enumerable: true,
  get: function get() {
    return _authenticationError.AuthenticationErrorCode;
  }
});
Object.defineProperty(exports, "ParseError", {
  enumerable: true,
  get: function get() {
    return _parseError.ParseError;
  }
});
Object.defineProperty(exports, "ParseErrorCode", {
  enumerable: true,
  get: function get() {
    return _parseError.ParseErrorCode;
  }
});
Object.defineProperty(exports, "SignerError", {
  enumerable: true,
  get: function get() {
    return _signerError.SignerError;
  }
});
Object.defineProperty(exports, "SignerErrorCode", {
  enumerable: true,
  get: function get() {
    return _signerError.SignerErrorCode;
  }
});
exports.Bitski = exports.AuthenticationStatus = exports.OAuthSignInMethod = void 0;

var _bitskiProvider = require("bitski-provider");

var _oauthManager = require("./auth/oauth-manager");

var _openidAuthProvider = require("./auth/openid-auth-provider");

var _connectButton = require("./components/connect-button");

var _constants = require("./constants");

var _bitskiBrowserEngine = require("./providers/bitski-browser-engine");

var _index = _interopRequireDefault(require("./styles/index"));

var _callback = require("./utils/callback");

var _localstorageStore = require("./utils/localstorage-store");

var _authenticationError = require("./errors/authentication-error");

var _parseError = require("./errors/parse-error");

var _signerError = require("./errors/signer-error");

var OAuthSignInMethod;
exports.OAuthSignInMethod = OAuthSignInMethod;

(function (OAuthSignInMethod) {
  OAuthSignInMethod["Redirect"] = "REDIRECT";
  OAuthSignInMethod["Popup"] = "POPUP";
  OAuthSignInMethod["Silent"] = "SILENT";
})(OAuthSignInMethod || (exports.OAuthSignInMethod = OAuthSignInMethod = {}));

var AuthenticationStatus;
exports.AuthenticationStatus = AuthenticationStatus;

(function (AuthenticationStatus) {
  AuthenticationStatus["Connected"] = "CONNECTED";
  AuthenticationStatus["Expired"] = "EXPIRED";
  AuthenticationStatus["NotConnected"] = "NOT_CONNECTED";
})(AuthenticationStatus || (exports.AuthenticationStatus = AuthenticationStatus = {})); // Customize token and user caching


/**
 * Bitski SDK
 */
class Bitski {
  /**
   * @param clientId OAuth Client ID
   * @param redirectUri Redirect uri, defaults to the current url. This should be the location of your callback html file.
   * @param additionalScopes To use custom scopes, add them here. The default value is ['offline'].
   * Note: Make sure your app is approved for the scopes you are requesting first.
   * @param options Other OAuth settings. Don't change these unless you know what you are doing.
   */
  constructor(clientId, redirectUri, additionalScopes, options) {
    this.engines = new Map();
    this.signoutHandlers = [];
    this.clientId = clientId;
    this.sdkVersion = _constants.SDK_VERSION;
    this.authProvider = new _openidAuthProvider.OpenidAuthProvider(clientId, redirectUri || window.location.href, additionalScopes, options);

    if (document && document.body) {
      this.injectStyles();
    } else {
      window.addEventListener('load', () => {
        this.injectStyles();
      });
    }

    this.authProvider.signOutCallback = this.onSignOut.bind(this);
  }
  /**
   * Alternative to using our static callback.html file. Call this from your own redirect page.
   */


  static callback() {
    (0, _callback.processCallback)();
  }
  /**
   * Returns a new web3 provider for a given network.
   * @param options options for the provider, or a network name
   */


  getProvider(options) {
    // Check cache for existing provider
    const existingProvider = this.engines.get(JSON.stringify(options));

    if (existingProvider) {
      existingProvider.start();
      return existingProvider;
    } // Create a new provider if one does not exist


    let normalizedOptions = {};

    if (options && typeof options !== 'string') {
      normalizedOptions = options;
    }

    const network = this.networkFromProviderOptions(options);

    if (network === _bitskiProvider.Kovan && normalizedOptions.minGasPrice == null) {
      normalizedOptions.minGasPrice = 1;
    }

    const newProvider = this.createProvider(network, normalizedOptions);
    newProvider.start();
    this.engines.set(JSON.stringify(options), newProvider);
    return newProvider;
  }
  /**
   * Creates a sign in with bitski button to add to your app. If an HTML element is passed in as the
   * first parameter, it will automatically add it to the DOM inside that element. Make sure to add
   * a callback to get notified of login events.
   * @param options {ConnectButtonOptions} Optional configuration for the button
   * @param callback Post-login callback. Called when sign in is complete. Not applicable for redirect login method.
   */


  getConnectButton(options, callback) {
    return new _connectButton.ConnectButton(this.authProvider, options, callback);
  }
  /**
   * Signs in or connects to bitski depending on the user's auth state.
   * Since it may open a popup, this method must be called from user interaction handler,
   * such as a click or tap handler.
   * @param options Provide SignInOptions for the sign in request. See signIn() for more info.
   */


  start(options) {
    return this.authProvider.signInOrConnect(undefined, options);
  }
  /**
   * Check the logged in state of the user
   */


  get authStatus() {
    return this.authProvider.authStatus;
  }
  /**
   * Starts the sign in flow. Will trigger a popup window over your app, so it must be called within a user interaction handler such as a click.
   * @param options Optionally provide additional options for the sign in request.
   *
   * You can use the options parameter to request that we show the sign up form instead of the sign in form:
   * ```javascript
   * import { LOGIN_HINT_SIGNUP } from 'bitski';
   *
   * await bitski.signIn({ login_hint: LOGIN_HINT_SIGNUP });
   * ```
   */


  signIn(options) {
    return this.authProvider.signIn(OAuthSignInMethod.Popup, options);
  }
  /**
   * Gets the current signed in user. Will reject if we are not signed in.
   */


  getUser() {
    return this.authProvider.getUser();
  }
  /**
   * Connects to bitski to get a valid access token if possible.
   */


  connect() {
    return this.authProvider.connect();
  }
  /**
   * Starts redirect sign in flow. This is an alternative flow to the popup that all takes place in the same browser window.
   * @param options Optionally provide additional options for the sign in request. See signIn() for more info.
   */


  signInRedirect(options) {
    this.authProvider.signIn(OAuthSignInMethod.Redirect, options);
  }
  /**
   * Call from your oauth redirect page.
   */


  redirectCallback() {
    return this.authProvider.redirectCallback();
  }
  /**
   * Retrieves the current access token for the user, if logged in.
   */


  getCurrentAccessToken() {
    return this.authProvider.getAccessToken();
  }
  /**
   * Retrieves the current refresh token for the user, if logged in.
   * Requires that the user has approved your application for offline access.
   */


  getCurrentRefreshToken() {
    return this.authProvider.getRefreshToken();
  }
  /**
   * Register a callback to be called on sign out. This is a good practice,
   * since there may be situations where you are signed out unexpectedly.
   * @param fn Your callback function
   */


  addSignOutHandler(fn) {
    this.signoutHandlers.push(fn);
  }
  /**
   * Remove a registered signout callback
   * @param fn Your callback function
   */


  removeSignOutHandler(fn) {
    const index = this.signoutHandlers.findIndex(item => item === fn);

    if (index >= 0) {
      this.signoutHandlers.splice(index, 1);
    }
  }
  /**
   * Sign the current user out of your application.
   */


  signOut() {
    this.engines.forEach(engine => engine.emit('signOut'));
    return this.authProvider.signOut();
  }

  createProvider(network) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return new _bitskiBrowserEngine.BitskiBrowserEngine(this.clientId, this.authProvider, this.sdkVersion, network, options);
  }

  networkFromName(networkName) {
    switch (networkName) {
      case '':
      case 'mainnet':
        return _bitskiProvider.Mainnet;

      case 'rinkeby':
        return _bitskiProvider.Rinkeby;

      case 'kovan':
        return _bitskiProvider.Kovan;

      default:
        throw new Error("Unsupported network name ".concat(networkName, ". Try passing a `network` in the options instead."));
    }
  }

  networkFromProviderOptions(options) {
    if (!options) {
      return _bitskiProvider.Mainnet;
    }

    if (typeof options === 'string') {
      return this.networkFromName(options);
    }

    if (options.network) {
      return options.network;
    }

    if (options.networkName) {
      return this.networkFromName(options.networkName);
    }

    return _bitskiProvider.Mainnet;
  }

  onSignOut() {
    this.signoutHandlers.forEach(cb => {
      cb();
    });
  }
  /**
   * Embeds Bitski's UI styles
   */


  injectStyles() {
    if (document.getElementById('BitskiEmbeddedStyles')) {
      return;
    }

    const style = document.createElement('style');
    style.setAttribute('type', 'text/css');
    style.setAttribute('id', 'BitskiEmbeddedStyles');
    style.appendChild(document.createTextNode(_index.default));
    const head = document.head || document.getElementsByTagName('head')[0];
    head.appendChild(style);
  }

}

exports.Bitski = Bitski;

},{"./auth/oauth-manager":2,"./auth/openid-auth-provider":3,"./components/connect-button":9,"./constants":11,"./errors/authentication-error":12,"./errors/parse-error":13,"./errors/signer-error":14,"./providers/bitski-browser-engine":15,"./styles/index":19,"./utils/callback":24,"./utils/localstorage-store":25,"@babel/runtime/helpers/interopRequireDefault":29,"bitski-provider":123}],9:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ConnectButton = exports.ConnectButtonSize = void 0;

var _bitski = require("../bitski");

var _authenticationError = require("../errors/authentication-error");

/**
 * Sizing options for the Bitski connect button.
 */
var ConnectButtonSize;
exports.ConnectButtonSize = ConnectButtonSize;

(function (ConnectButtonSize) {
  ConnectButtonSize["Small"] = "SMALL";
  ConnectButtonSize["Medium"] = "MEDIUM";
  ConnectButtonSize["Large"] = "LARGE";
})(ConnectButtonSize || (exports.ConnectButtonSize = ConnectButtonSize = {}));
/**
 * A button used to connect to Bitski.
 */


class ConnectButton {
  /**
   * @param authProvider An instance of an AuthProvider to process sign in requests.
   * @param options Optional ConnectButtonOptions to configure your button.
   * @param callback Optional callback to be called after successful or failed log in attempt.
   * You can also set this directly later with the `callback` property.
   */
  constructor(authProvider, options, callback) {
    // Set options to object if undefined
    options = options || {}; // Configure instance

    this.authProvider = authProvider;
    this.size = options.size || ConnectButtonSize.Medium;
    this.authIntegrationType = options.authMethod || _bitski.OAuthSignInMethod.Popup;
    this.callback = callback;
    this.signInOptions = options.signInOptions || {}; // Create the element

    this.element = document.createElement('button');
    this.configureElement();
    this.element.addEventListener('click', this.signin.bind(this)); // Embed if needed

    if (options.container) {
      options.container.appendChild(this.element);
    }
  }
  /**
   * Removes the button from the page
   */


  remove() {
    if (this.element.parentNode) {
      this.element.parentNode.removeChild(this.element);
    }
  }

  signin() {
    this.authProvider.signInOrConnect(this.authIntegrationType, this.signInOptions).then(user => {
      if (this.callback) {
        this.callback(undefined, user);
      }
    }).catch(error => {
      // Check for cancellation
      if (error instanceof _authenticationError.AuthenticationError && error.code === _authenticationError.AuthenticationErrorCode.UserCancelled) {
        // Not a real error, the user just cancelled. Trigger cancellation callback.
        if (this.onCancel) {
          this.onCancel();
        }
      } else if (this.callback) {
        // Real error. Forward to main callback.
        this.callback(error, undefined);
      }
    });
  }

  configureElement() {
    this.element.title = 'Continue with Bitski';
    this.element.innerText = 'Continue with Bitski';
    this.element.className = 'bitski-connect-button';
    let sizeClass = '';

    switch (this.size) {
      case ConnectButtonSize.Small:
        sizeClass = 'size-small';
        break;

      case ConnectButtonSize.Medium:
        sizeClass = 'size-medium';
        break;

      case ConnectButtonSize.Large:
        sizeClass = 'size-large';
        break;
    }

    this.element.classList.add(sizeClass);
  }

}

exports.ConnectButton = ConnectButton;

},{"../bitski":8,"../errors/authentication-error":12}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Dialog = void 0;
const TEMPLATE = "\n  <div class='bitski-dialog'>\n      <button class='bitski-close-button'>Close</button>\n      <div class='bitski-dialog-body'></div>\n  </div>\n";
/**
 * Basic modal dialog
 */

class Dialog {
  /**
   * Creates and displays a new dialog
   * @param content The content (HTMLElement, selector, or text) to embed in the dialog
   * @param dynamicContent Set to true to show loading state
   */
  constructor(content) {
    let dynamicContent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    // check for an element passed as content or a selector corresponding to an element
    this.content = this.parseContent(content); // Find or create dialog container

    this.container = this.createContainer(); // Inject dialog content

    this.injectTemplate(this.container, this.content); // Show a spinner if content is dynamic

    if (dynamicContent) {
      this.setLoading(true);
    } // Add close handlers


    this.addCloseHandlers(); // A short delay is required before triggering animations

    setTimeout(() => {
      this.show();
    }, 10);
  }
  /**
   * Show the dialog
   */


  show() {
    this.container.classList.add('bitski-visible', 'bitski-loaded');
  }
  /**
   * Hides the dialog, but does not remove
   */


  hide() {
    this.container.classList.remove('bitski-visible', 'bitski-loaded');
  }
  /**
   * Dismisses the dialog without triggering the close handler.
   */


  dismiss() {
    // Allow 500ms for the animations to finish before removing elements from DOM
    setTimeout(() => {
      this.container.remove();
    }, 500);
    this.hide();
  }
  /**
   * Cancels the dialog by dismissing and triggering the close handler.
   */


  close() {
    this.dismiss();

    if (this.onClose) {
      this.onClose();
    }
  }
  /**
   * Show or hide the loading indicator
   * @param loading Whether or not to display the spinner
   */


  setLoading(loading) {
    const body = document.querySelector('.bitski-dialog-body');

    if (body) {
      if (loading) {
        body.classList.add('bitski-loading');
      } else {
        body.classList.remove('bitski-loading');
      }
    }
  }
  /**
   * Determines what content to embed
   * @param content Content to parse
   */


  parseContent(content) {
    // check for an element passed as content
    if (content instanceof HTMLElement) {
      return content;
    } // determine if content is a selector


    if (document.querySelector(content)) {
      return document.querySelector(content);
    } // otherwise content is text to be appended to the dialog body


    const div = document.createElement('div');
    div.innerText = content;
    return div;
  }
  /**
   * Creates and injects the container element at the end of the body,
   * responsible for housing all the dialog-related content.
   */


  createContainer() {
    const existingContainer = document.querySelector('#bitski-dialog-container');

    if (existingContainer) {
      return existingContainer;
    }

    const container = document.createElement('div');
    container.id = 'bitski-dialog-container';
    document.body.appendChild(container);
    return container;
  }
  /**
   * Injects the provided content into the template provided
   * @param container The container element
   * @param content The content to inject in the template
   */


  injectTemplate(container, content) {
    container.innerHTML = TEMPLATE;
    const body = container.querySelector('.bitski-dialog-body');

    if (body) {
      body.appendChild(content);
    }
  }
  /**
   * Adds event listeners for events that should trigger closing the dialog
   */


  addCloseHandlers() {
    // Close on click outside of the dialog
    this.container.addEventListener('click', event => {
      if (event.target === this.container) {
        this.close();
      }
    }); // Close on escape press

    document.addEventListener('keyup', e => {
      if (e.key === 'Escape') {
        this.close();
      }
    }); // Close on close button click

    const closeButton = this.container.querySelector('.bitski-close-button');

    if (closeButton) {
      closeButton.addEventListener('click', this.close.bind(this));
    }
  }

}

exports.Dialog = Dialog;

},{}],11:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_AUTHORIZED_METHODS = exports.CACHED_METHODS = exports.USER_KEY = exports.ACCESS_TOKEN_KEY = exports.REFRESH_TOKEN_KEY = exports.DEFAULT_POPUP_FEATURES = exports.CHECK_FOR_POPUP_CLOSE_INTERVAL = exports.DEFAULT_OPTIONAL_SCOPES = exports.DEFAULT_SCOPES = exports.DEFAULT_OAUTH_CONFIGURATION = exports.IFRAME_MESSAGE_ORIGIN_INCLUDES = exports.BITSKI_WEB_BASE_URL = exports.BITSKI_RPC_BASE_URL = exports.BITSKI_TRANSACTION_API_BASE_URL = exports.BITSKI_USER_API_HOST = exports.SDK_VERSION = void 0;
// SDK
const SDK_VERSION = '0.10.9'; // URLs

exports.SDK_VERSION = SDK_VERSION;
const BITSKI_USER_API_HOST = 'https://www.bitski.com/v1';
exports.BITSKI_USER_API_HOST = BITSKI_USER_API_HOST;
const BITSKI_TRANSACTION_API_BASE_URL = 'https://api.bitski.com/v1';
exports.BITSKI_TRANSACTION_API_BASE_URL = BITSKI_TRANSACTION_API_BASE_URL;
const BITSKI_RPC_BASE_URL = 'https://api.bitski.com/v1/web3';
exports.BITSKI_RPC_BASE_URL = BITSKI_RPC_BASE_URL;
const BITSKI_WEB_BASE_URL = 'https://sign.bitski.com';
exports.BITSKI_WEB_BASE_URL = BITSKI_WEB_BASE_URL;
const IFRAME_MESSAGE_ORIGIN_INCLUDES = '.bitski.com'; // OAuth

exports.IFRAME_MESSAGE_ORIGIN_INCLUDES = IFRAME_MESSAGE_ORIGIN_INCLUDES;
const DEFAULT_OAUTH_CONFIGURATION = {
  authorization_endpoint: 'https://account.bitski.com/oauth2/auth',
  revocation_endpoint: '',
  token_endpoint: 'https://account.bitski.com/oauth2/token',
  userinfo_endpoint: 'https://account.bitski.com/userinfo'
};
exports.DEFAULT_OAUTH_CONFIGURATION = DEFAULT_OAUTH_CONFIGURATION;
const DEFAULT_SCOPES = ['openid']; // scopes that are always included

exports.DEFAULT_SCOPES = DEFAULT_SCOPES;
const DEFAULT_OPTIONAL_SCOPES = ['offline']; // scopes that are included by default, but can be overridden
// Popup Window

exports.DEFAULT_OPTIONAL_SCOPES = DEFAULT_OPTIONAL_SCOPES;
const CHECK_FOR_POPUP_CLOSE_INTERVAL = 500;
exports.CHECK_FOR_POPUP_CLOSE_INTERVAL = CHECK_FOR_POPUP_CLOSE_INTERVAL;
const DEFAULT_POPUP_FEATURES = {
  location: 'no',
  toolbar: 'no',
  width: 500,
  height: 500,
  left: 100,
  top: 100
}; // Storage

exports.DEFAULT_POPUP_FEATURES = DEFAULT_POPUP_FEATURES;
const REFRESH_TOKEN_KEY = 'bitski.refresh_token';
exports.REFRESH_TOKEN_KEY = REFRESH_TOKEN_KEY;
const ACCESS_TOKEN_KEY = 'bitski.access_token';
exports.ACCESS_TOKEN_KEY = ACCESS_TOKEN_KEY;
const USER_KEY = 'bitski.user'; // Methods

exports.USER_KEY = USER_KEY;
const CACHED_METHODS = ['eth_accounts'];
exports.CACHED_METHODS = CACHED_METHODS;
const DEFAULT_AUTHORIZED_METHODS = ['eth_sendTransaction', 'eth_signTransaction', 'eth_sign', 'personal_sign', 'eth_signTypedData', 'eth_signTypedData_v3'];
exports.DEFAULT_AUTHORIZED_METHODS = DEFAULT_AUTHORIZED_METHODS;

},{}],12:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AuthenticationError = exports.AuthenticationErrorCode = void 0;
var AuthenticationErrorCode;
exports.AuthenticationErrorCode = AuthenticationErrorCode;

(function (AuthenticationErrorCode) {
  // The user is not currently signed in
  AuthenticationErrorCode[AuthenticationErrorCode["NotSignedIn"] = 1000] = "NotSignedIn"; // The user cancelled the auth request

  AuthenticationErrorCode[AuthenticationErrorCode["UserCancelled"] = 1001] = "UserCancelled"; // Either you did not request offline access, or the user did not approve your app for offline access

  AuthenticationErrorCode[AuthenticationErrorCode["NoRefreshToken"] = 1002] = "NoRefreshToken"; // You requested silent sign in, which is deprecated

  AuthenticationErrorCode[AuthenticationErrorCode["UnsupportedAuthenticationMethod"] = 1003] = "UnsupportedAuthenticationMethod"; // We received an error from the oauth server

  AuthenticationErrorCode[AuthenticationErrorCode["ServerError"] = 1004] = "ServerError"; // The SDK is configured incorrectly

  AuthenticationErrorCode[AuthenticationErrorCode["InvalidConfiguration"] = 1005] = "InvalidConfiguration"; // Popup blocked

  AuthenticationErrorCode[AuthenticationErrorCode["PopupBlocked"] = 1006] = "PopupBlocked";
})(AuthenticationErrorCode || (exports.AuthenticationErrorCode = AuthenticationErrorCode = {}));
/**
 * Represents an error that is thrown during the authentication process
 */


class AuthenticationError extends Error {
  constructor(message, code) {
    super(message);
    this.name = 'AuthenticationError'; // Maintains proper stack trace for where our error was thrown (only available on V8)

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, AuthenticationError);
    }

    this.code = code;
  } // throw AuthenticationError.NotSignedIn()


  static NotSignedIn() {
    return new AuthenticationError('Not signed in.', AuthenticationErrorCode.NotSignedIn);
  } // throw AuthenticationError.UserCancelled()


  static UserCancelled() {
    return new AuthenticationError('Sign in request was cancelled.', AuthenticationErrorCode.UserCancelled);
  } // throw AuthenticationError.NoRefreshToken()


  static NoRefreshToken() {
    return new AuthenticationError('Refresh token is not available.', AuthenticationErrorCode.NoRefreshToken);
  } // throw AuthenticationError.UnsupportedAuthenticationMethod()


  static UnsupportedAuthenticationMethod() {
    return new AuthenticationError('Sign in method not supported.', AuthenticationErrorCode.UnsupportedAuthenticationMethod);
  } // throw AuthenticationError.PopupBlocked()


  static PopupBlocked(baseUrl) {
    const msg = "The popup was blocked. Please make sure ".concat(baseUrl, " is allowed to open popups.");
    return new AuthenticationError(msg, AuthenticationErrorCode.PopupBlocked);
  } // throw Authentication Error.ServerError(message, description)


  static ServerError(message, description) {
    const err = new AuthenticationError("Error from the server: ".concat(message), AuthenticationErrorCode.ServerError);
    err.description = description;
    return err;
  } // throw AuthenticationError.InvalidConfiguration()


  static InvalidConfiguration(reason) {
    return new AuthenticationError("The OAuth Configuration is invalid: ".concat(reason), AuthenticationErrorCode.InvalidConfiguration);
  }

}

exports.AuthenticationError = AuthenticationError;

},{}],13:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ParseError = exports.ParseErrorCode = void 0;
var ParseErrorCode;
exports.ParseErrorCode = ParseErrorCode;

(function (ParseErrorCode) {
  // Could not parse response as JSON
  ParseErrorCode[ParseErrorCode["InvalidJSON"] = 2000] = "InvalidJSON"; // Received an error response status,
  // but not error body was provided.

  ParseErrorCode[ParseErrorCode["NoErrorBody"] = 2001] = "NoErrorBody";
})(ParseErrorCode || (exports.ParseErrorCode = ParseErrorCode = {}));
/**
 * Represents an error that is thrown during decoding
 */


class ParseError extends Error {
  constructor(message, code) {
    super(message);
    this.name = 'ParseError'; // Maintains proper stack trace for where our error was thrown (only available on V8)

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, ParseError);
    }

    this.code = code;
  }

  static InvalidJSON() {
    return new ParseError('Could not decode response as JSON', ParseErrorCode.InvalidJSON);
  }

  static UnknownError() {
    return new ParseError('An unknown error occurred.', ParseErrorCode.NoErrorBody);
  }

}

exports.ParseError = ParseError;

},{}],14:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SignerError = exports.SignerErrorCode = void 0;
var SignerErrorCode;
exports.SignerErrorCode = SignerErrorCode;

(function (SignerErrorCode) {
  // The signer module received a request to sign via an unsupported RPC method
  SignerErrorCode[SignerErrorCode["UnsupportedMethod"] = 3000] = "UnsupportedMethod"; // The user cancelled or rejected the transaction

  SignerErrorCode[SignerErrorCode["UserCancelled"] = 3001] = "UserCancelled"; // The request is missing params for the transaction.
  // Check that params is an array, and the transaction is the first object.

  SignerErrorCode[SignerErrorCode["MissingTransaction"] = 3002] = "MissingTransaction"; // The message signature request is missing expected params.
  // Check that params is an array, and that they include both a from address, and a message to sign.

  SignerErrorCode[SignerErrorCode["MissingMessage"] = 3003] = "MissingMessage"; // Missing from address in typed data request

  SignerErrorCode[SignerErrorCode["MissingFrom"] = 3004] = "MissingFrom"; // Missing typed data params. Make sure params is an array and includes
  // both a from address, and a typed data payload.

  SignerErrorCode[SignerErrorCode["MissingTypedData"] = 3005] = "MissingTypedData";
})(SignerErrorCode || (exports.SignerErrorCode = SignerErrorCode = {}));

class SignerError extends Error {
  constructor(message, code) {
    super(message);
    this.name = 'TransactionError'; // Maintains proper stack trace for where our error was thrown (only available on V8)

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, SignerError);
    }

    this.code = code;
  }

  static UnsupportedMethod() {
    return new SignerError('The method requested is not currently supported.', SignerErrorCode.UnsupportedMethod);
  }

  static UserCancelled() {
    return new SignerError('The user cancelled this transaction', SignerErrorCode.UserCancelled);
  }

  static MissingTransaction() {
    return new SignerError('Could not find transaction in request', SignerErrorCode.MissingTransaction);
  }

  static MissingMessage() {
    return new SignerError('Could not find message params in request', SignerErrorCode.MissingMessage);
  }

  static MissingFrom() {
    return new SignerError('Could not find from address in request params.', SignerErrorCode.MissingFrom);
  }

  static MissingTypedData() {
    return new SignerError('Could not find data to sign in request params.', SignerErrorCode.MissingTypedData);
  }

}

exports.SignerError = SignerError;

},{}],15:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BitskiBrowserEngine = void 0;

var _bitskiProvider = require("bitski-provider");

var _constants = require("../constants");

var _transactionSigner = require("../signing/transaction-signer");

var _authenticatedCache = require("../subproviders/authenticated-cache");

var _remoteAccounts = require("../subproviders/remote-accounts");

var _restFetch = require("../subproviders/rest-fetch");

var _signature = require("../subproviders/signature");

// Predicate to determine if the token provider is an AuthProvider
function isAuthProvider(object) {
  return object.getUser !== undefined;
}

class BitskiBrowserEngine extends _bitskiProvider.BitskiEngine {
  constructor(clientId, tokenProvider, sdkVersion, network) {
    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
    super(options);
    options = options || {};
    this.network = network;
    this.clientId = clientId;
    this.sdkVersion = sdkVersion;
    this.apiBaseUrl = options.apiBaseUrl || _constants.BITSKI_TRANSACTION_API_BASE_URL;
    this.webBaseUrl = options.webBaseUrl || _constants.BITSKI_WEB_BASE_URL;
    this.tokenProvider = tokenProvider;
    const defaultBitskiHeaders = {
      'X-API-KEY': this.clientId,
      'X-CLIENT-ID': this.clientId,
      'X-CLIENT-VERSION': this.sdkVersion
    };
    this.headers = defaultBitskiHeaders;
    this.rpcHeaders = {};

    if (options && options.additionalHeaders) {
      this.headers = Object.assign({}, options.additionalHeaders, this.headers);
      this.rpcHeaders = options.additionalHeaders;
    }

    if (this.network && this.network.rpcUrl.includes('bitski.com')) {
      this.rpcHeaders = Object.assign({}, this.rpcHeaders, defaultBitskiHeaders);
    }

    this.signer = new _transactionSigner.BitskiTransactionSigner(this.webBaseUrl, this.apiBaseUrl, this.headers, options.callbackURL);
    this.addSubproviders();
  }

  addSubproviders() {
    // Used for eth_accounts calls
    const accountsProvider = new _remoteAccounts.RemoteAccountSubprovider("".concat(_constants.BITSKI_RPC_BASE_URL, "/mainnet"), false, this.tokenProvider, this.headers); // Used for all other calls

    const fetchSubprovider = new _bitskiProvider.AuthenticatedFetchSubprovider(this.network.rpcUrl, false, this.tokenProvider, this.rpcHeaders); // Respond to some requests via userinfo object if available

    if (isAuthProvider(this.tokenProvider)) {
      const cacheSubprovider = new _authenticatedCache.AuthenticatedCacheSubprovider(this.tokenProvider, this);
      this.addProvider(cacheSubprovider);
    } // Ensure that whenever accounts are requested, they go through Bitski


    this.addProvider(accountsProvider); // Respond to requests that need signed with an iframe

    const signatureSubprovider = new _signature.SignatureSubprovider(this.network, this.signer, this.tokenProvider);
    this.addProvider(signatureSubprovider); // Respond to block request via REST is using Bitski RPC endpoint

    if (this.network.rpcUrl.startsWith('https://api.bitski.com')) {
      const blockProvider = new _restFetch.RestFetchSubprovider({
        rpcUrl: this.network.rpcUrl,
        defaultHeaders: this.headers
      });
      this.addProvider(blockProvider);
    } // Finally, add our basic HTTP provider


    this.addProvider(fetchSubprovider);
  }

}

exports.BitskiBrowserEngine = BitskiBrowserEngine;

},{"../constants":11,"../signing/transaction-signer":16,"../subproviders/authenticated-cache":20,"../subproviders/remote-accounts":21,"../subproviders/rest-fetch":22,"../subproviders/signature":23,"bitski-provider":123}],16:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BitskiTransactionSigner = void 0;

var _dialog = require("../components/dialog");

var _constants = require("../constants");

var _signerError = require("../errors/signer-error");

var _requestUtils = require("../utils/request-utils");

/**
 * This class is responsible for signing transactions. It only knows about Bitski's proprietary transaction objects.
 * It is also the only class that knows about the iframe signing implementation.
 */
class BitskiTransactionSigner {
  constructor(webBaseUrl, apiBaseUrl, defaultHeaders, callbackURL) {
    this.webBaseUrl = webBaseUrl;
    this.apiBaseUrl = apiBaseUrl;
    this.defaultHeaders = defaultHeaders;
    this.callbackURL = callbackURL; // Watch for new messages on the window.

    window.addEventListener('message', this.receiveMessage.bind(this), false);
  }

  async sign(transaction, accessToken) {
    // If we have a callback URL, use the redirect flow
    if (this.callbackURL) {
      const persisted = await this.submitTransaction(transaction, accessToken);
      return this.redirectToCallbackURL(persisted.transaction);
    }

    this.submitTransaction(transaction, accessToken).catch(error => {
      return this.handleCallback({
        error
      });
    }); // Show the modal (await response)

    return this.showAuthorizationModal(transaction);
  }
  /**
   * Event listener for callbacks from the iframe
   * @param event MessageEvent received from the browser
   */


  receiveMessage(event) {
    // Ignore messages from the current window, and from frames that aren't on Bitski.com
    if (event.source === window || !event.origin.includes(_constants.IFRAME_MESSAGE_ORIGIN_INCLUDES)) {
      return;
    }

    const data = event.data; // Ignore message events that don't actually have data

    if (data === undefined || data === null) {
      return;
    }

    this.handleCallback(data);
  }

  handleCallback(callback) {
    // Ignore messages when we don't have a current request in flight
    if (this.currentRequest === undefined) {
      return;
    }

    const [fulfill, reject] = this.currentRequest; // Dismiss current dialog

    if (this.currentRequestDialog) {
      this.currentRequestDialog.dismiss();
    } // Call the callback to complete the request


    if (callback.error) {
      reject(callback.error);
    } else {
      fulfill(callback.result);
    } // Clear state


    this.currentRequest = undefined;
    this.currentRequestDialog = undefined;
  }
  /**
   * Responsible for submitting the Transaction object to the API
   * @param transaction The Transaction object to submit
   * @param accessToken The current user's access token
   */


  async submitTransaction(transaction, accessToken) {
    const requestBody = {
      transaction
    };
    const headers = Object.assign({}, this.defaultHeaders, {
      'Authorization': "Bearer ".concat(accessToken),
      'Content-Type': 'application/json'
    });
    const response = await fetch("".concat(this.apiBaseUrl, "/transactions"), {
      method: 'POST',
      body: JSON.stringify(requestBody),
      headers
    });
    return (0, _requestUtils.parseResponse)(response);
  }
  /**
   * Displays the authorization form in a modal window
   * @param transaction The transaction that has been submitted
   */


  showAuthorizationModal(transaction) {
    return new Promise((fulfill, reject) => {
      const url = "".concat(this.webBaseUrl, "/transactions/").concat(transaction.id);
      const iframe = document.createElement('iframe');
      iframe.style.position = 'absolute';
      iframe.style.top = '0';
      iframe.style.left = '0';
      iframe.style.width = '100%';
      iframe.style.height = '100%';
      iframe.frameBorder = '0';
      iframe.src = url; // Dismiss any existing dialogs to prevent UI glitches.

      if (this.currentRequestDialog) {
        this.currentRequestDialog.close();
      }

      this.currentRequest = [fulfill, reject];
      this.currentRequestDialog = new _dialog.Dialog(iframe, true);

      this.currentRequestDialog.onClose = () => {
        // Capture reject callback
        reject(_signerError.SignerError.UserCancelled());
      };
    });
  }

  redirectToCallbackURL(transaction) {
    const url = "".concat(this.webBaseUrl, "/transactions/").concat(transaction.id, "?redirectURI=").concat(this.callbackURL);
    window.location.href = url;
    return Promise.resolve('');
  }

}

exports.BitskiTransactionSigner = BitskiTransactionSigner;

},{"../components/dialog":10,"../constants":11,"../errors/signer-error":14,"../utils/request-utils":28}],17:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/* tslint:disable */
const css = "\n.bitski-connect-button {\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, 'Helvetica Neue', sans-serif;\n  font-weight: 500;\n  background-color: #1C11D9;\n  background-repeat: no-repeat;\n  background-position: 0px 0px;\n  border: none;\n  color: #fff;\n  margin: 0;\n  padding: 0;\n  cursor: pointer;\n  text-shadow: 1px 0 1px rgba(0, 0, 0, 0.03);\n  box-shadow: 0 1px 1px rgba(0, 0, 0, 0.14);\n  transition: background 200ms linear, transform 200ms ease-out;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n.bitski-connect-button:focus,\n.bitski-connect-button:active {\n  background-color: #2117C7;\n  transform: scale(0.99, 0.99);\n  color: rgba(255, 255, 255, 0.8);\n}\n.bitski-connect-button.size-small {\n  background-image: url('https://cdn.bitskistatic.com/sdk/btn-v2-bg-sm.svg');\n  border-radius: 3px;\n  font-size: 10px;\n  height: 22px;\n  line-height: 19px;\n  padding-left: 30px;\n  padding-right: 8px;\n}\n.bitski-connect-button.size-medium {\n  background-image: url('https://cdn.bitskistatic.com/sdk/btn-v2-bg-md.svg');\n  border-radius: 4px;\n  font-size: 11px;\n  height: 30px;\n  line-height: 29px;\n  padding-left: 40px;\n  padding-right: 12px;\n}\n.bitski-connect-button.size-large {\n  background-image: url('https://cdn.bitskistatic.com/sdk/btn-v2-bg-lg.svg');\n  border-radius: 5px;\n  font-size: 14px;\n  height: 44px;\n  line-height: 44px;\n  padding-left: 57px;\n  padding-right: 15px;\n}\n";
var _default = css;
exports.default = _default;

},{}],18:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/* tslint:disable */
const css = "\n#bitski-dialog-container {\n  position: fixed;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  background: rgba(0, 0, 0, 0);\n  z-index: 1000;\n  transition: background linear 0.2s;\n  pointer-events: none;\n}\n#bitski-dialog-container.bitski-visible {\n  background: rgba(0, 0, 0, 0.5);\n  pointer-events: auto;\n}\n.bitski-dialog {\n  opacity: 0;\n  transform: translateY(100vh);\n  transition: opacity 300ms linear, transform 400ms cubic-bezier(0.19, 1, 0.22, 1);\n  pointer-events: none;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n#bitski-dialog-container.bitski-visible .bitski-dialog {\n  opacity: 1;\n  transform: none;\n  transition: opacity 300ms linear, transform 600ms cubic-bezier(0.19, 1, 0.22, 1);\n  pointer-events: auto;\n}\n.bitski-dialog .bitski-close-button {\n  background: transparent url('https://cdn.bitskistatic.com/sdk/close.svg') no-repeat 50% 50%;\n  position: absolute;\n  right: 12px;\n  top: 12px;\n  border: none;\n  outline: none;\n  margin: 0;\n  cursor: pointer;\n  padding: 0;\n  width: 28px;\n  height: 28px;\n  z-index: 100;\n  overflow: hidden;\n  text-indent: -1000px;\n}\n.bitski-dialog-body {\n  background: #fff;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  z-index: 5;\n  max-width: 100%;\n}\n.bitski-dialog-body.bitski-loading::after {\n  content: \"\";\n  background: url('https://cdn.bitskistatic.com/sdk/loading.svg') no-repeat 50% 50%;\n  animation: rotate 600ms linear infinite;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  opacity: 0.3;\n  width: 38px;\n  height: 38px;\n  margin-left: -19px;\n  margin-top: -19px;\n  z-index: -1;\n}\n@media (min-width: 600px) {\n  #bitski-dialog-container {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n  }\n  .bitski-dialog {\n    position: relative;\n    width: 400px;\n    height: 420px;\n  }\n  .bitski-dialog-body {\n    border-radius: 16px;\n    overflow: hidden;\n    box-shadow: 0px 0px 0px 1px rgba(0,0,0,0.1), 0px 10px 50px rgba(0,0,0,0.4);\n  }\n}\n\n@keyframes rotate {\n  0% {\n    transform: rotate(0deg);\n  }\n  50% {\n    transform: rotate(180deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}\n";
var _default = css;
exports.default = _default;

},{}],19:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _connectButton = _interopRequireDefault(require("./connect-button"));

var _dialog = _interopRequireDefault(require("./dialog"));

/* tslint:disable */
const css = "\n  ".concat(_dialog.default, "\n  ").concat(_connectButton.default, "\n");
var _default = css;
exports.default = _default;

},{"./connect-button":17,"./dialog":18,"@babel/runtime/helpers/interopRequireDefault":29}],20:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AuthenticatedCacheSubprovider = void 0;

var _providerEngine = require("@bitski/provider-engine");

var _constants = require("../constants");

/*
 * Subprovider that caches values related to the user.
 */
class AuthenticatedCacheSubprovider extends _providerEngine.Subprovider {
  constructor(authProvider, engine) {
    super();
    this.authProvider = authProvider;
    this.cachedValues = new Map();

    if (engine) {
      engine.on('signOut', () => this.cachedValues.clear());
    }
  }

  handleRequest(payload, next, end) {
    // Only evaluate matching methods
    if (this.supportsCache(payload.method) === false) {
      return next();
    } // Allow overriding the cache


    if (payload.skipCache) {
      return next();
    } // Load from cache


    this.checkCachedValues(payload.method).then(value => {
      if (value !== undefined) {
        // Value for method is cached, return value
        end(undefined, value);
      } else {
        // Value for method is not cached, fallback to fetch
        next();
      }
    }).catch(() => {
      // If method is not supported, or we encounter an error, fallback to fetch provider
      return next();
    });
  }

  supportsCache(methodName) {
    return _constants.CACHED_METHODS.includes(methodName);
  }

  checkCachedValues(methodName) {
    // First, check in-memory cache
    if (this.cachedValues.has(methodName)) {
      return Promise.resolve(this.cachedValues.get(methodName));
    } // Fallback to local-storage cache


    switch (methodName) {
      case 'eth_accounts':
        return this.getAccounts();

      default:
        return Promise.reject(new Error('Method not supported'));
    }
  }

  getAccounts() {
    // TODO: Move this to a subscription model and load into memory automatically
    return this.authProvider.getUser().then(user => {
      if (user.accounts) {
        this.cachedValues.set('eth_accounts', user.accounts);
        return user.accounts;
      }

      throw new Error('Accounts not found on user');
    });
  }

}

exports.AuthenticatedCacheSubprovider = AuthenticatedCacheSubprovider;

},{"../constants":11,"@bitski/provider-engine":35}],21:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RemoteAccountSubprovider = void 0;

var _bitskiProvider = require("bitski-provider");

// A subprovider that loads accounts from a custom rpc endpoint.
// This is necessary because to guarantee that account related calls go through Bitski
class RemoteAccountSubprovider extends _bitskiProvider.AuthenticatedFetchSubprovider {
  handleRequest(payload, next, end) {
    if (payload.method === 'eth_accounts') {
      this.handleAuthenticatedRequest(payload, next, end);
    } else {
      next();
    }
  }

}

exports.RemoteAccountSubprovider = RemoteAccountSubprovider;

},{"bitski-provider":123}],22:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RestFetchSubprovider = void 0;

var _providerEngine = require("@bitski/provider-engine");

var _asyncify = _interopRequireDefault(require("async/asyncify"));

var _retry = _interopRequireDefault(require("async/retry"));

var _waterfall = _interopRequireDefault(require("async/waterfall"));

var _crossFetch = _interopRequireDefault(require("cross-fetch"));

var _jsonRpcError = _interopRequireDefault(require("json-rpc-error"));

var _promiseToCallback = _interopRequireDefault(require("promise-to-callback"));

const RETRIABLE_ERRORS = [// ignore server overload errors
'Gateway timeout', 'ETIMEDOUT', // ignore server sent html error pages
// or truncated json responses
'SyntaxError'];
const MATCHING_METHODS = ['eth_getBlockByNumber', 'eth_blockNumber', 'net_Version', 'eth_getLogs'];

class RestFetchSubprovider extends _providerEngine.Subprovider {
  constructor(opts) {
    super();
    this.rpcUrl = opts.rpcUrl;
    this.defaultHeaders = opts.defaultHeaders;
    this.originHttpHeaderKey = opts.originHttpHeaderKey;
  }

  handleRequest(payload, next, end) {
    if (MATCHING_METHODS.includes(payload.method)) {
      this.handleRestRequest(payload, end);
    } else {
      next();
    }
  }

  handleRestRequest(payload, end) {
    const originDomain = payload.origin;
    const query = payload.params.length > 0 ? "?params=".concat(encodeURIComponent(JSON.stringify(payload.params))) : '';
    const url = "".concat(this.rpcUrl, "/").concat(payload.method).concat(query);
    const reqParams = {
      method: 'GET',
      headers: Object.assign({
        'Accept': 'application/json',
        'Content-Type': 'application/json'
      }, this.defaultHeaders),
      credentials: 'omit'
    };

    if (this.originHttpHeaderKey && originDomain) {
      reqParams.headers[this.originHttpHeaderKey] = originDomain;
    }

    (0, _retry.default)({
      times: 5,
      interval: 1000,
      errorFilter: isErrorRetriable
    }, cb => this._submitRequest(url, reqParams, cb), (err, result) => {
      // ends on retriable error
      if (err && isErrorRetriable(err)) {
        const errMsg = "FetchSubprovider - cannot complete request. All retries exhausted.\nOriginal Error:\n".concat(err.toString(), "\n\n");
        const retriesExhaustedErr = new Error(errMsg);
        return end(retriesExhaustedErr);
      } // otherwise continue normally


      return end(err, result);
    });
  }

  _submitRequest(targetUrl, reqParams, done) {
    (0, _promiseToCallback.default)((0, _crossFetch.default)(targetUrl, reqParams))((err, res) => {
      if (err) {
        return done(err);
      } // continue parsing result


      (0, _waterfall.default)([checkForHttpErrors, // buffer body
      cb => (0, _promiseToCallback.default)(res.text())(cb), // parse body
      (0, _asyncify.default)(rawBody => JSON.parse(rawBody)), parseResponse], done);

      function checkForHttpErrors(cb) {
        // check for errors
        switch (res.status) {
          case 405:
            return cb(new _jsonRpcError.default.MethodNotFound());

          case 418:
            return cb(createRatelimitError());

          case 503:
          case 504:
            return cb(createTimeoutError());

          default:
            return cb();
        }
      }

      function parseResponse(body, cb) {
        // check for error code
        if (res.status !== 200) {
          return cb(new _jsonRpcError.default.InternalError(body));
        }

        cb(null, body);
      }
    });
  }

}

exports.RestFetchSubprovider = RestFetchSubprovider;

function isErrorRetriable(err) {
  const errMsg = err.toString();
  return RETRIABLE_ERRORS.some(phrase => errMsg.includes(phrase));
}

function createRatelimitError() {
  const msg = 'Request is being rate limited.';
  const err = new Error(msg);
  return new _jsonRpcError.default.InternalError(err);
}

function createTimeoutError() {
  let msg = 'Gateway timeout. The request took too long to process. ';
  msg += 'This can happen when querying logs over too wide a block range.';
  const err = new Error(msg);
  return new _jsonRpcError.default.InternalError(err);
}

},{"@babel/runtime/helpers/interopRequireDefault":29,"@bitski/provider-engine":35,"async/asyncify":107,"async/retry":115,"async/waterfall":116,"cross-fetch":135,"json-rpc-error":146,"promise-to-callback":154}],23:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SignatureSubprovider = exports.TransactionKind = void 0;

var _providerEngine = require("@bitski/provider-engine");

var _uuid = require("uuid");

var _constants = require("../constants");

var _signerError = require("../errors/signer-error");

var TransactionKind;
exports.TransactionKind = TransactionKind;

(function (TransactionKind) {
  TransactionKind["SendTransaction"] = "ETH_SEND_TRANSACTION";
  TransactionKind["SignTransaction"] = "ETH_SIGN_TRANSACTION";
  TransactionKind["Sign"] = "ETH_SIGN";
  TransactionKind["SignTypedData"] = "ETH_SIGN_TYPED_DATA";
})(TransactionKind || (exports.TransactionKind = TransactionKind = {}));
/**
 * A Subprovider that manages the interface between JSON-RPC and Bitski's proprietary transaction signing flow.
 * This class is responsible for transforming the JSON-RPC request into a Transaction object that the Bitski signer understands.
 * Also responsible for submitting the transaction to the network, and converting the response back into an RPC response.
 *
 * Important: this class assumes the transaction has all the necessary fields populated. The TransactionValidatorSubprovider
 * should be placed in front of this subprovider.
 */


class SignatureSubprovider extends _providerEngine.Subprovider {
  constructor(network, signer, tokenProvider, signatureMethods) {
    super();
    this.network = network;
    this.tokenProvider = tokenProvider;
    this.signer = signer;
    this.signatureMethods = signatureMethods || _constants.DEFAULT_AUTHORIZED_METHODS;
  }
  /**
   * Handle RPC request from engine (called by)
   * @param payload RPC request payload
   * @param next Callback to skip handling this request
   * @param end Completion handler
   */


  handleRequest(payload, next, end) {
    if (this.requiresSignature(payload.method)) {
      this.handleSignatureRequest(payload, end);
      return;
    }

    next();
  }
  /**
   * Called when a payload is received that needs a signature
   * @param payload The JSON-RPC request
   * @param callback The callback to call when the request has been handled
   */


  async handleSignatureRequest(payload, callback) {
    try {
      // Get access token
      const accessToken = await this.tokenProvider.getAccessToken(); // Prepare a transaction object

      const transaction = await this.createBitskiTransaction(payload); // Sign the transaction object

      const signedResponse = await this.signer.sign(transaction, accessToken); // Send the transaction if needed

      const result = await this.sendIfNeeded(payload, signedResponse); // Call the callback with the result

      callback(undefined, result);
    } catch (error) {
      // Call with the error if any of the steps fail
      callback(error, undefined);
    }
  }
  /** Should this subprovider handle the request?
   * @param method The RPC method of the request
   */


  requiresSignature(method) {
    return this.signatureMethods.includes(method);
  }
  /**
   * This will forward transactions that should be automatically submitted to the network, otherwise
   * resolve with the original value.
   * @param payload The original request payload
   * @param signedData signed data for the transaction
   */


  sendIfNeeded(payload, signedData) {
    if (payload.method === 'eth_sendTransaction') {
      // Create a send raw transaction payload
      const sendPayload = {
        id: 0,
        jsonrpc: '2.0',
        method: 'eth_sendRawTransaction',
        params: [signedData]
      };
      return this.performRequest(sendPayload);
    }

    return Promise.resolve(signedData);
  }
  /**
   * Load the balance so the web approval dialog can give the user better context
   * @param payload Payload for the request
   */


  loadBalanceIfNeeded(payload) {
    // Only necessary if this is a transaction
    const isTransaction = payload.method === 'eth_sendTransaction' || payload.method === 'eth_signTransaction';
    const isCustomRPC = !this.network.rpcUrl.includes('api.bitski.com');

    if (isTransaction && isCustomRPC) {
      const transaction = payload.params[0];
      const balancePayload = {
        id: 0,
        jsonrpc: '2.0',
        method: 'eth_getBalance',
        params: [transaction.from, 'latest']
      };
      return this.performRequest(balancePayload);
    }

    return Promise.resolve();
  }
  /**
   * Responsible for creating the Transaction object from a given RPC payload
   * @param payload JSON-RPC payload to extract the values from
   */


  async createBitskiTransaction(payload) {
    const context = await this.createContext(payload);
    const kind = this.kindForMethod(payload.method);
    const extractedPayload = this.createPayload(payload);
    const transaction = {
      id: (0, _uuid.v4)(),
      kind,
      payload: extractedPayload,
      context
    };
    return transaction;
  }

  async createContext(request) {
    switch (request.method) {
      case 'eth_sendTransaction':
      case 'eth_signTransaction':
        const balance = await this.loadBalanceIfNeeded(request);
        return {
          chainId: this.network.chainId,
          currentBalance: balance
        };

      case 'eth_signTypedData':
      case 'eth_signTypedData_v3':
        // The from address should be the first parameter as a 20 byte hex string
        if (request.params && request.params.length > 0) {
          return {
            from: request.params[0]
          };
        }

        throw _signerError.SignerError.MissingFrom();

      default:
        // Other transaction types do not need context
        return {};
    }
  }
  /**
   * Responsible for creating the payload from a given RPC request
   * @param request JSON-RPC request to extract params from
   */


  createPayload(request) {
    switch (request.method) {
      case 'eth_sendTransaction':
      case 'eth_signTransaction':
        if (request.params && request.params.length > 0) {
          return request.params[0];
        } else {
          throw _signerError.SignerError.MissingTransaction();
        }

      case 'eth_sign':
        if (request.params && request.params.length > 1) {
          return {
            from: request.params[0],
            message: request.params[1]
          };
        } else {
          throw _signerError.SignerError.MissingMessage();
        }

      case 'personal_sign':
        if (request.params && request.params.length > 1) {
          return {
            from: request.params[1],
            message: request.params[0]
          };
        } else {
          throw _signerError.SignerError.MissingMessage();
        }

      case 'eth_signTypedData':
      case 'eth_signTypedData_v3':
        if (request.params && request.params.length > 1) {
          return request.params[1];
        } else {
          throw _signerError.SignerError.MissingTypedData();
        }

      default:
        throw _signerError.SignerError.UnsupportedMethod();
    }
  }
  /**
   * Determines a BitskiTransaction.Kind value from a given RPC method name
   * @param method The JSON-RPC method being requested
   */


  kindForMethod(method) {
    switch (method) {
      case 'eth_sendTransaction':
      case 'eth_signTransaction':
        // Convert both *sign* and *send* methods into a sign transaction.
        // (we will forward the transaction locally if needed)
        return TransactionKind.SignTransaction;

      case 'eth_sign':
      case 'personal_sign':
        return TransactionKind.Sign;

      case 'eth_signTypedData':
      case 'eth_signTypedData_v3':
        return TransactionKind.SignTypedData;

      default:
        throw _signerError.SignerError.UnsupportedMethod();
    }
  } // Wraps emitPayload in a promise


  performRequest(payload) {
    return new Promise((fulfill, reject) => {
      this.emitPayload(payload, (err, result) => {
        if (err) {
          reject(err);
        } else {
          fulfill(result.result);
        }
      });
    });
  }

}

exports.SignatureSubprovider = SignatureSubprovider;

},{"../constants":11,"../errors/signer-error":14,"@bitski/provider-engine":35,"uuid":162}],24:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.processCallback = processCallback;
exports.parseUrlParams = parseUrlParams;

/**
 * Automatically handles finalizing the oauth sign in process with the Bitski SDK
 */
function processCallback() {
  if (window.opener) {
    notifyOpener(window.location);
  } else {
    throw new Error('Parent window could not be found');
  }
}
/**
 * Notifies the opener when in a popup
 * @param url the url that contains the query params
 */


function notifyOpener(url) {
  if (window.opener) {
    if (url) {
      // parse url to get state
      const data = parseUrlParams(url);

      if (data.state) {
        const name = "popupCallback_".concat(data.state);
        const callback = window.opener[name];

        if (callback) {
          callback(url);
        } else {
          throw new Error('No callback found on opener');
        }
      } else {
        throw new Error('No state found in response');
      }
    }
  } else {
    throw new Error('No window.opener');
  }
}
/**
 * Extracts query params from the hash of the url
 * @param url the url to parse
 */


function parseUrlParams(url) {
  let params;

  if (url.href.includes('#')) {
    params = extractQuery(url.hash);
  } else if (url.href.includes('?')) {
    params = url.search.split('?').pop();
  }

  if (!params) {
    throw new Error('No params found in result');
  }

  return params.split('&').reduce((prev, item) => {
    const [key, value] = item.split('=');

    if (key && value) {
      prev[decodeURIComponent(key)] = decodeURIComponent(value);
    }

    return prev;
  }, {});
}

function extractQuery(url) {
  if (!url.includes('#')) {
    throw new Error('No params found in result');
  }

  return url.split('#').pop();
}

},{}],25:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LocalStorageStore = void 0;

// Default implementation of generic store interface.
// Uses localStorage or sessionStorage (pass which one you want in constructor).
class LocalStorageStore {
  constructor() {
    let storage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : localStorage;
    this.storage = storage;
  }

  clear() {
    this.storage.clear();
  }

  getItem(key) {
    return this.storage.getItem(key);
  }

  setItem(key, value) {
    this.storage.setItem(key, value);
  }

  clearItem(key) {
    this.storage.removeItem(key);
  }

}

exports.LocalStorageStore = LocalStorageStore;

},{}],26:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NoHashQueryStringUtils = void 0;

var _appauth = require("@openid/appauth");

class NoHashQueryStringUtils extends _appauth.BasicQueryStringUtils {
  parse(input, useHash) {
    return super.parse(input, false
    /* never use hash */
    );
  }

}

exports.NoHashQueryStringUtils = NoHashQueryStringUtils;

},{"@openid/appauth":97}],27:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PopupValidator = void 0;

/**
 * A simple utility class that will check to see if a popup is blocked.
 * Derived from info and examples on this page:
 * https://stackoverflow.com/questions/2914/how-can-i-detect-if-a-browser-is-blocking-a-popup
 */
class PopupValidator {
  constructor(errorHandler) {
    this.errorHandler = errorHandler;
  } // Check a popup window to see if it has been blocked.
  // The error handler will be called asynchronously if
  // the window has been detected to have been blocked.


  check(popup) {
    if (popup) {
      if (/chrome/.test(navigator.userAgent.toLowerCase())) {
        setTimeout(() => {
          this.isPopupBlocked(popup);
        }, 200);
      } else {
        popup.onload = () => {
          this.isPopupBlocked(popup);
        };
      }
    } else {
      this.handleBlocked();
    }
  }

  isPopupBlocked(popup) {
    if (popup.innerHeight > 0 === false) {
      this.handleBlocked();
    }
  }

  handleBlocked() {
    this.errorHandler();
  }

}

exports.PopupValidator = PopupValidator;

},{}],28:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseResponse = parseResponse;

var _bitskiProvider = require("bitski-provider");

var _parseError = require("../errors/parse-error");

/**
 * Parses a Fetch Response to extract either the result or the error
 * @param response the fetch response to parse
 */
function parseResponse(response) {
  return response.json().catch(() => {
    throw _parseError.ParseError.InvalidJSON();
  }).then(json => {
    if (response.status >= 200 && response.status < 300) {
      return json;
    } else {
      if (json && json.error && json.error.message) {
        throw new _bitskiProvider.ServerError(json.error.message, response.status, response.url);
      } else if (json && json.error) {
        throw new _bitskiProvider.ServerError(json.error, response.status, response.url);
      } else {
        throw _parseError.ParseError.UnknownError();
      }
    }
  });
}

},{"../errors/parse-error":13,"bitski-provider":123}],29:[function(require,module,exports){
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;
},{}],30:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("events");
var provider_engine_error_1 = require("./errors/provider-engine-error");
var create_payload_1 = require("./util/create-payload");
// The base class which ProviderEngine will extend from that provides the basic Web3 Provider interface
var BaseProvider = /** @class */ (function (_super) {
    __extends(BaseProvider, _super);
    function BaseProvider() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // Modern send method
    BaseProvider.prototype.send = function (method, params) {
        var payload = create_payload_1.createPayload({ method: method, params: params });
        return this.sendPayload(payload).then(function (response) {
            return response.result;
        });
    };
    // Legacy sendAsync method
    BaseProvider.prototype.sendAsync = function (payload, cb) {
        this.sendPayload(payload).then(function (response) {
            cb(null, response);
        }).catch(function (error) {
            cb(error, null);
        });
    };
    // Whether or not this provider supports subscriptions
    BaseProvider.prototype.supportsSubscriptions = function () {
        // Override this in your subclass if you support subscriptions
        return false;
    };
    // Method to subscribe to a given subscription type
    BaseProvider.prototype.subscribe = function (subscribeMethod, subscriptionMethod, parameters) {
        // Override this with subscription implementation
        return Promise.reject(new provider_engine_error_1.ProviderEngineError('Subscriptions are not supported', provider_engine_error_1.ProviderEngineErrorCode.UnsupportedFeature));
    };
    // Method to unsubscribe
    BaseProvider.prototype.unsubscribe = function (subscriptionId, unsubscribeMethod) {
        // Override this with unsubscribe implementation
        return Promise.reject(new provider_engine_error_1.ProviderEngineError('Subscriptions are not supported', provider_engine_error_1.ProviderEngineErrorCode.UnsupportedFeature));
    };
    return BaseProvider;
}(events_1.EventEmitter));
exports.default = BaseProvider;

},{"./errors/provider-engine-error":33,"./util/create-payload":59,"events":132}],31:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var BlockTrackerErrorCode;
(function (BlockTrackerErrorCode) {
    // Block data was not found after retries
    BlockTrackerErrorCode[BlockTrackerErrorCode["BlockNotFound"] = 3000] = "BlockNotFound";
})(BlockTrackerErrorCode = exports.BlockTrackerErrorCode || (exports.BlockTrackerErrorCode = {}));
/**
 * Represents errors that occur in the block tracker
 */
var BlockTrackerError = /** @class */ (function (_super) {
    __extends(BlockTrackerError, _super);
    function BlockTrackerError(message, code) {
        var _this = _super.call(this, message) || this;
        // Maintains proper stack trace for where our error was thrown (only available on V8)
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, BlockTrackerError);
        }
        _this.code = code;
        return _this;
    }
    BlockTrackerError.BlockNotFound = function (blockNumber) {
        return new BlockTrackerError("Could not load block " + blockNumber, BlockTrackerErrorCode.BlockNotFound);
    };
    return BlockTrackerError;
}(Error));
exports.BlockTrackerError = BlockTrackerError;

},{}],32:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var GasPriceErrorCode;
(function (GasPriceErrorCode) {
    GasPriceErrorCode[GasPriceErrorCode["BlockNotFound"] = 4000] = "BlockNotFound";
})(GasPriceErrorCode = exports.GasPriceErrorCode || (exports.GasPriceErrorCode = {}));
/**
 * Represents errors that occur in the gas price subprovider
 */
var GasPriceError = /** @class */ (function (_super) {
    __extends(GasPriceError, _super);
    function GasPriceError(message, code) {
        var _this = _super.call(this, message) || this;
        // Maintains proper stack trace for where our error was thrown (only available on V8)
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, GasPriceError);
        }
        _this.code = code;
        return _this;
    }
    GasPriceError.BlockNotFound = function (blockNumber) {
        var msg = "Could not calculate gas. Block " + blockNumber + " was not found";
        return new GasPriceError(msg, GasPriceErrorCode.BlockNotFound);
    };
    return GasPriceError;
}(Error));
exports.GasPriceError = GasPriceError;

},{}],33:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ProviderEngineErrorCode;
(function (ProviderEngineErrorCode) {
    ProviderEngineErrorCode[ProviderEngineErrorCode["UnhandledRequest"] = 1000] = "UnhandledRequest";
    ProviderEngineErrorCode[ProviderEngineErrorCode["MissingImplementation"] = 1001] = "MissingImplementation";
    ProviderEngineErrorCode[ProviderEngineErrorCode["UnsupportedFeature"] = 1002] = "UnsupportedFeature";
})(ProviderEngineErrorCode = exports.ProviderEngineErrorCode || (exports.ProviderEngineErrorCode = {}));
/**
 * Represents errors specific to ProviderEngine
 */
var ProviderEngineError = /** @class */ (function (_super) {
    __extends(ProviderEngineError, _super);
    function ProviderEngineError(message, code) {
        var _this = _super.call(this, message) || this;
        // Maintains proper stack trace for where our error was thrown (only available on V8)
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, ProviderEngineError);
        }
        _this.code = code;
        return _this;
    }
    return ProviderEngineError;
}(Error));
exports.ProviderEngineError = ProviderEngineError;

},{}],34:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var SubscriptionErrorCode;
(function (SubscriptionErrorCode) {
    SubscriptionErrorCode[SubscriptionErrorCode["UnsupportedType"] = 2000] = "UnsupportedType";
    SubscriptionErrorCode[SubscriptionErrorCode["NotFound"] = 2001] = "NotFound";
})(SubscriptionErrorCode = exports.SubscriptionErrorCode || (exports.SubscriptionErrorCode = {}));
/**
 * Represents an error that occurs in the subscriptions subprovider
 */
var SubscriptionError = /** @class */ (function (_super) {
    __extends(SubscriptionError, _super);
    function SubscriptionError(message, code) {
        var _this = _super.call(this, message) || this;
        // Maintains proper stack trace for where our error was thrown (only available on V8)
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, SubscriptionError);
        }
        _this.code = code;
        return _this;
    }
    SubscriptionError.UnsupportedType = function (type) {
        return new SubscriptionError("Unsupported subscription type: " + type, SubscriptionErrorCode.UnsupportedType);
    };
    SubscriptionError.NotFound = function (subscriptionId) {
        return new SubscriptionError("Subscription with id " + subscriptionId + " not found", SubscriptionErrorCode.NotFound);
    };
    return SubscriptionError;
}(Error));
exports.SubscriptionError = SubscriptionError;

},{}],35:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var provider_engine_1 = __importDefault(require("./provider-engine"));
var subprovider_1 = __importDefault(require("./subprovider"));
exports.Subprovider = subprovider_1.default;
exports.default = provider_engine_1.default;
// Errors
var block_tracker_error_1 = require("./errors/block-tracker-error");
exports.BlockTrackerError = block_tracker_error_1.BlockTrackerError;
exports.BlockTrackerErrorCode = block_tracker_error_1.BlockTrackerErrorCode;
var gas_price_error_1 = require("./errors/gas-price-error");
exports.GasPriceError = gas_price_error_1.GasPriceError;
exports.GasPriceErrorCode = gas_price_error_1.GasPriceErrorCode;
var provider_engine_error_1 = require("./errors/provider-engine-error");
exports.ProviderEngineError = provider_engine_error_1.ProviderEngineError;
exports.ProviderEngineErrorCode = provider_engine_error_1.ProviderEngineErrorCode;
var subscription_error_1 = require("./errors/subscription-error");
exports.SubscriptionError = subscription_error_1.SubscriptionError;
exports.SubscriptionErrorCode = subscription_error_1.SubscriptionErrorCode;
__export(require("./subproviders/index"));

},{"./errors/block-tracker-error":31,"./errors/gas-price-error":32,"./errors/provider-engine-error":33,"./errors/subscription-error":34,"./provider-engine":36,"./subprovider":37,"./subproviders/index":52}],36:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var eachSeries_1 = __importDefault(require("async/eachSeries"));
var base_provider_1 = __importDefault(require("./base-provider"));
var provider_engine_error_1 = require("./errors/provider-engine-error");
var block_tracker_1 = __importDefault(require("./util/block-tracker"));
var stoplight_1 = __importDefault(require("./util/stoplight"));
var Web3ProviderEngine = /** @class */ (function (_super) {
    __extends(Web3ProviderEngine, _super);
    function Web3ProviderEngine(opts) {
        var _this = _super.call(this) || this;
        _this._pollForBlocks = true;
        _this._running = false;
        _this.setMaxListeners(30);
        // parse options
        opts = opts || {};
        // block polling
        var directProvider = {
            sendAsync: function (req, cb) {
                _this.sendPayload(req).then(function (res) {
                    cb(null, res);
                }).catch(function (err) {
                    cb(err);
                });
            },
        };
        if (opts.disableBlockTracking === true) {
            _this._pollForBlocks = false;
        }
        var blockTrackerProvider = opts.blockTrackerProvider || directProvider;
        _this._blockTracker = new block_tracker_1.default({
            provider: blockTrackerProvider,
            blockTracker: opts.blockTracker,
            pollingInterval: opts.pollingInterval || 4000,
        });
        _this._blockTracker.on('block', _this._setCurrentBlock.bind(_this));
        _this._blockTracker.on('sync', _this.emit.bind(_this, 'sync'));
        _this._blockTracker.on('rawBlock', _this.emit.bind(_this, 'rawBlock'));
        _this._blockTracker.on('latest', _this.emit.bind(_this, 'latest'));
        // Handle errors instead of re-emitting, since they will throw otherwise
        _this._blockTracker.on('error', function (error) {
            // Ignore errors from the block tracker unless debug is enabled
            if (opts.debug) {
                console.log('DEBUG: ' + error.message);
            }
        });
        // set initialization blocker
        _this._ready = new stoplight_1.default();
        _this._providers = [];
        return _this;
    }
    Web3ProviderEngine.prototype.isRunning = function () {
        return this._running;
    };
    Web3ProviderEngine.prototype.start = function () {
        // trigger start
        this._ready.go();
        if (this._pollForBlocks) {
            // start tracking blocks
            this._blockTracker.start();
        }
        // update state
        this._running = true;
        // signal that we started
        this.emit('start');
    };
    Web3ProviderEngine.prototype.stop = function () {
        // stop block tracking
        this._blockTracker.stop();
        // update state
        this._running = false;
        // signal that we stopped
        this.emit('stop');
    };
    Web3ProviderEngine.prototype.addProvider = function (source) {
        this._providers.push(source);
        source.setEngine(this);
    };
    Web3ProviderEngine.prototype.send = function (method, params) {
        var _this = this;
        // Wrap base class with Stoplight
        return new Promise(function (fulfill, reject) {
            _this._ready.await(function () {
                _super.prototype.send.call(_this, method, params).then(fulfill, reject);
            });
        });
    };
    Web3ProviderEngine.prototype.sendAsync = function (payload, cb) {
        var _this = this;
        // Wrap base class with Stoplight
        this._ready.await(function () {
            _super.prototype.sendAsync.call(_this, payload, cb);
        });
    };
    // Actually perform the request
    Web3ProviderEngine.prototype.sendPayload = function (payload) {
        var _this = this;
        return new Promise(function (fulfill, reject) {
            var currentProvider = -1;
            var result = null;
            var error = null;
            // Stack of subprovider next callbacks
            var stack = [];
            var next = function (callback) {
                currentProvider += 1;
                if (callback) {
                    // Insert in front since eachSeries traverses from front
                    stack.unshift(callback);
                }
                // Bubbled down as far as we could go, and the request wasn't
                // handled. Return an error.
                if (currentProvider >= _this._providers.length) {
                    // tslint:disable-next-line: max-line-length
                    var msg = "Request for method \"" + payload.method + "\" not handled by any subprovider.";
                    end(new provider_engine_error_1.ProviderEngineError(msg, provider_engine_error_1.ProviderEngineErrorCode.UnhandledRequest));
                    return;
                }
                // Handle request in next subprovider
                try {
                    var provider = _this._providers[currentProvider];
                    provider.handleRequest(payload, next, end);
                }
                catch (e) {
                    end(e);
                }
            };
            var notifySubprovider = function (fn, callback) {
                if (fn) {
                    fn(error, result, callback);
                }
                else {
                    callback();
                }
            };
            var end = function (e, r) {
                error = e;
                result = r;
                // Call any callbacks from subproviders
                eachSeries_1.default(stack, notifySubprovider).then(function () {
                    // Reconstruct JSONRPCResponse
                    var resultObj = {
                        id: payload.id,
                        jsonrpc: payload.jsonrpc,
                        result: result,
                    };
                    // Complete promise
                    if (error) {
                        reject(error);
                    }
                    else {
                        fulfill(resultObj);
                    }
                });
            };
            // Call next() to kick things off
            next();
        });
    };
    Web3ProviderEngine.prototype._setCurrentBlock = function (bufferBlock) {
        this.currentBlock = bufferBlock;
        this.emit('block', bufferBlock);
    };
    return Web3ProviderEngine;
}(base_provider_1.default));
exports.default = Web3ProviderEngine;

},{"./base-provider":30,"./errors/provider-engine-error":33,"./util/block-tracker":58,"./util/stoplight":64,"async/eachSeries":69}],37:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("events");
var create_payload_1 = require("./util/create-payload");
// this is the base class for a subprovider -- mostly helpers
var Subprovider = /** @class */ (function (_super) {
    __extends(Subprovider, _super);
    function Subprovider() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Subprovider.prototype.setEngine = function (engine) {
        var _this = this;
        this.engine = engine;
        engine.on('block', function (block) {
            _this.currentBlock = block;
        });
    };
    Subprovider.prototype.emitPayload = function (payload, cb) {
        this.engine.sendAsync(create_payload_1.createPayload(payload), cb);
    };
    return Subprovider;
}(events_1.EventEmitter));
exports.default = Subprovider;

},{"./util/create-payload":59,"events":132}],38:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var clone_1 = __importDefault(require("clone"));
var eth_util_1 = require("../../util/eth-util");
var rpc_cache_utils_1 = require("../../util/rpc-cache-utils");
var cache_strategy_1 = __importDefault(require("./cache-strategy"));
//
// BlockCacheStrategy
//
var BlockCacheStrategy = /** @class */ (function (_super) {
    __extends(BlockCacheStrategy, _super);
    function BlockCacheStrategy() {
        var _this = _super.call(this) || this;
        _this.cache = {};
        return _this;
    }
    BlockCacheStrategy.prototype.getBlockCacheForPayload = function (payload, blockNumberHex) {
        var blockNumber = parseInt(blockNumberHex, 16);
        var blockCache = this.cache[blockNumber];
        // create new cache if necesary
        if (!blockCache) {
            var newCache = {};
            this.cache[blockNumber] = newCache;
            blockCache = newCache;
        }
        return blockCache;
    };
    BlockCacheStrategy.prototype.hitCheck = function (payload, requestedBlockNumber, hit, miss) {
        var blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);
        if (!blockCache) {
            return miss();
        }
        var identifier = rpc_cache_utils_1.cacheIdentifierForPayload(payload);
        var cached = blockCache[identifier];
        if (cached) {
            var clonedValue = clone_1.default(cached);
            return hit(null, clonedValue);
        }
        else {
            return miss();
        }
    };
    BlockCacheStrategy.prototype.cacheResult = function (payload, result, requestedBlockNumber, callback) {
        if (result) {
            var blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);
            var identifier = rpc_cache_utils_1.cacheIdentifierForPayload(payload);
            var clonedValue = clone_1.default(result);
            blockCache[identifier] = clonedValue;
        }
        callback();
    };
    BlockCacheStrategy.prototype.canCache = function (payload) {
        if (!rpc_cache_utils_1.canCache(payload)) {
            return false;
        }
        var blockTag = rpc_cache_utils_1.blockTagForPayload(payload);
        return (blockTag !== 'pending');
    };
    // naively removes older block caches
    BlockCacheStrategy.prototype.cacheRollOff = function (previousBlock) {
        var _this = this;
        var previousHex = eth_util_1.bufferToHex(previousBlock.number);
        var oldBlockNumber = parseInt(previousHex, 16);
        // clear old caches
        Object.keys(this.cache)
            .map(Number)
            .filter(function (num) { return num <= oldBlockNumber; })
            .forEach(function (num) { return delete _this.cache[num]; });
    };
    return BlockCacheStrategy;
}(cache_strategy_1.default));
exports.default = BlockCacheStrategy;

},{"../../util/eth-util":60,"../../util/rpc-cache-utils":62,"./cache-strategy":39,"clone":134}],39:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var CacheStrategy = /** @class */ (function () {
    function CacheStrategy() {
    }
    return CacheStrategy;
}());
exports.default = CacheStrategy;

},{}],40:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var cache_strategy_1 = __importDefault(require("./cache-strategy"));
var perma_cache_strategy_1 = __importDefault(require("./perma-cache-strategy"));
//
// ConditionalPermaCacheStrategy
//
var ConditionalPermaCacheStrategy = /** @class */ (function (_super) {
    __extends(ConditionalPermaCacheStrategy, _super);
    function ConditionalPermaCacheStrategy(conditionals) {
        var _this = _super.call(this) || this;
        _this.strategy = new perma_cache_strategy_1.default();
        _this.conditionals = conditionals;
        return _this;
    }
    ConditionalPermaCacheStrategy.prototype.hitCheck = function (payload, requestedBlockNumber, hit, miss) {
        return this.strategy.hitCheck(payload, requestedBlockNumber, hit, miss);
    };
    ConditionalPermaCacheStrategy.prototype.cacheResult = function (payload, result, requestedBlockNumber, callback) {
        var conditional = this.conditionals[payload.method];
        if (conditional) {
            if (conditional(result)) {
                this.strategy.cacheResult(payload, result, requestedBlockNumber, callback);
            }
            else {
                callback();
            }
        }
        else {
            // Cache all requests that don't have a conditional
            this.strategy.cacheResult(payload, result, requestedBlockNumber, callback);
        }
    };
    ConditionalPermaCacheStrategy.prototype.canCache = function (payload) {
        return this.strategy.canCache(payload);
    };
    return ConditionalPermaCacheStrategy;
}(cache_strategy_1.default));
exports.default = ConditionalPermaCacheStrategy;

},{"./cache-strategy":39,"./perma-cache-strategy":41}],41:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var clone_1 = __importDefault(require("clone"));
var rpc_cache_utils_1 = require("../../util/rpc-cache-utils");
var cache_strategy_1 = __importDefault(require("./cache-strategy"));
var PermaCacheStrategy = /** @class */ (function (_super) {
    __extends(PermaCacheStrategy, _super);
    function PermaCacheStrategy() {
        var _this = _super.call(this) || this;
        _this.cache = {};
        // clear cache every ten minutes
        var timeout = setInterval(function () {
            _this.cache = {};
        }, 10 * 60 * 1e3);
        // do not require the Node.js event loop to remain active
        if (timeout.unref) {
            timeout.unref();
        }
        return _this;
    }
    PermaCacheStrategy.prototype.hitCheck = function (payload, requestedBlockNumber, hit, miss) {
        var identifier = rpc_cache_utils_1.cacheIdentifierForPayload(payload);
        var cached = this.cache[identifier];
        if (!cached) {
            return miss();
        }
        // If the block number we're requesting at is greater than or
        // equal to the block where we cached a previous response,
        // the cache is valid. If it's from earlier than the cache,
        // send it back down to the client (where it will be recached.)
        var cacheIsEarlyEnough = compareHex(requestedBlockNumber, cached.blockNumber) >= 0;
        if (cacheIsEarlyEnough) {
            var clonedValue = clone_1.default(cached.result);
            return hit(null, clonedValue);
        }
        else {
            return miss();
        }
    };
    PermaCacheStrategy.prototype.cacheResult = function (payload, result, requestedBlockNumber, callback) {
        var identifier = rpc_cache_utils_1.cacheIdentifierForPayload(payload);
        if (result) {
            var clonedValue = clone_1.default(result);
            this.cache[identifier] = {
                blockNumber: requestedBlockNumber,
                result: clonedValue,
            };
        }
        callback();
    };
    PermaCacheStrategy.prototype.canCache = function (payload) {
        return rpc_cache_utils_1.canCache(payload);
    };
    return PermaCacheStrategy;
}(cache_strategy_1.default));
exports.default = PermaCacheStrategy;
function compareHex(hexA, hexB) {
    var numA = parseInt(hexA, 16);
    var numB = parseInt(hexB, 16);
    return numA === numB ? 0 : (numA > numB ? 1 : -1);
}

},{"../../util/rpc-cache-utils":62,"./cache-strategy":39,"clone":134}],42:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var bn_js_1 = __importDefault(require("bn.js"));
var subprovider_1 = __importDefault(require("../subprovider"));
var eth_util_1 = require("../util/eth-util");
var rpc_cache_utils_1 = require("../util/rpc-cache-utils");
var block_strategy_1 = __importDefault(require("./cache-strategies/block-strategy"));
var conditional_perma_strategy_1 = __importDefault(require("./cache-strategies/conditional-perma-strategy"));
var BlockCacheProvider = /** @class */ (function (_super) {
    __extends(BlockCacheProvider, _super);
    function BlockCacheProvider() {
        var _this = _super.call(this) || this;
        _this.isEnabled = false;
        _this.strategies = {
            perma: new conditional_perma_strategy_1.default({
                eth_getTransactionByHash: containsBlockhash,
                eth_getTransactionReceipt: containsBlockhash,
            }),
            block: new block_strategy_1.default(),
            fork: new block_strategy_1.default(),
        };
        return _this;
    }
    // setup a block listener on 'setEngine'
    BlockCacheProvider.prototype.setEngine = function (engine) {
        var _this = this;
        _super.prototype.setEngine.call(this, engine);
        // unblock initialization after first block
        engine.once('block', function () {
            _this.isEnabled = true;
            // from now on, empty old cache every block
            engine.on('block', _this.clearOldCache.bind(_this));
        });
    };
    BlockCacheProvider.prototype.handleRequest = function (payload, next, end) {
        // skip cache if told to do so
        if (payload.skipCache) {
            // console.log('CACHE SKIP - skip cache if told to do so')
            return next();
        }
        // Ignore requests for the latest block
        if (payload.method === 'eth_getBlockByNumber' && payload.params[0] === 'latest') {
            // console.log('CACHE SKIP - Ignore block polling requests.')
            return next();
        }
        // Block cache should not start handling requests until blocks have been received.
        if (!this.isEnabled) {
            return next();
        }
        // actually handle the request
        this._handleRequest(payload, next, end);
    };
    BlockCacheProvider.prototype._handleRequest = function (payload, next, end) {
        var type = rpc_cache_utils_1.cacheTypeForPayload(payload);
        var strategy = this.strategies[type];
        // If there's no strategy in place, pass it down the chain.
        if (!strategy) {
            return next();
        }
        // If the strategy can't cache this request, ignore it.
        if (!strategy.canCache(payload)) {
            return next();
        }
        var blockTag = rpc_cache_utils_1.blockTagForPayload(payload);
        if (!blockTag) {
            blockTag = 'latest';
        }
        var requestedBlockNumber;
        if (blockTag === 'earliest') {
            requestedBlockNumber = '0x00';
        }
        else if (blockTag === 'latest') {
            requestedBlockNumber = eth_util_1.bufferToHex(this.currentBlock.number);
        }
        else {
            // We have a hex number
            requestedBlockNumber = blockTag;
        }
        // console.log('REQUEST at block 0x' + requestedBlockNumber.toString('hex'))
        // end on a hit, continue on a miss
        strategy.hitCheck(payload, requestedBlockNumber, end, function () {
            // miss fallthrough to provider chain, caching the result on the way back up.
            next(function (err, result, cb) {
                // err is already handled by engine
                if (err) {
                    return cb();
                }
                strategy.cacheResult(payload, result, requestedBlockNumber, cb);
            });
        });
    };
    BlockCacheProvider.prototype.clearOldCache = function (newBlock) {
        var previousBlock = this.currentBlock;
        this.currentBlock = newBlock;
        if (!previousBlock) {
            return;
        }
        this.strategies.block.cacheRollOff(previousBlock);
        this.strategies.fork.cacheRollOff(previousBlock);
    };
    return BlockCacheProvider;
}(subprovider_1.default));
exports.default = BlockCacheProvider;
function hexToBN(hex) {
    return new bn_js_1.default(eth_util_1.toBuffer(hex));
}
function containsBlockhash(result) {
    if (!result) {
        return false;
    }
    if (!result.blockHash) {
        return false;
    }
    var hasNonZeroHash = hexToBN(result.blockHash).gt(new bn_js_1.default(0));
    return hasNonZeroHash;
}

},{"../subprovider":37,"../util/eth-util":60,"../util/rpc-cache-utils":62,"./cache-strategies/block-strategy":38,"./cache-strategies/conditional-perma-strategy":40,"bn.js":130}],43:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var xtend_1 = __importDefault(require("xtend"));
var fixture_1 = __importDefault(require("./fixture"));
var DefaultFixtures = /** @class */ (function (_super) {
    __extends(DefaultFixtures, _super);
    function DefaultFixtures(opts) {
        var _this = this;
        opts = opts || {};
        var responses = xtend_1.default({
            web3_clientVersion: 'ProviderEngine' + '/javascript',
            net_listening: true,
            eth_hashrate: '0x00',
            eth_mining: false,
        }, opts);
        _this = _super.call(this, responses) || this;
        return _this;
    }
    return DefaultFixtures;
}(fixture_1.default));
exports.default = DefaultFixtures;

},{"./fixture":50,"xtend":171}],44:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var asyncify_1 = __importDefault(require("async/asyncify"));
var retry_1 = __importDefault(require("async/retry"));
var waterfall_1 = __importDefault(require("async/waterfall"));
var cross_fetch_1 = __importDefault(require("cross-fetch"));
var json_rpc_error_1 = __importDefault(require("json-rpc-error"));
var promise_to_callback_1 = __importDefault(require("promise-to-callback"));
var subprovider_1 = __importDefault(require("../subprovider"));
var create_payload_1 = require("../util/create-payload");
var RETRIABLE_ERRORS = [
    // ignore server overload errors
    'Gateway timeout',
    'ETIMEDOUT',
    // ignore server sent html error pages
    // or truncated json responses
    'SyntaxError',
];
var FetchSubprovider = /** @class */ (function (_super) {
    __extends(FetchSubprovider, _super);
    function FetchSubprovider(opts) {
        var _this = _super.call(this) || this;
        _this.rpcUrl = opts.rpcUrl;
        _this.originHttpHeaderKey = opts.originHttpHeaderKey;
        return _this;
    }
    FetchSubprovider.prototype.handleRequest = function (payload, next, end) {
        var _this = this;
        var originDomain = payload.origin;
        // overwrite id to not conflict with other concurrent users
        var newPayload = this.createPayload(payload);
        // remove extra parameter from request
        delete newPayload.origin;
        var reqParams = {
            method: 'POST',
            headers: {
                'Accept': 'application/json',
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(newPayload),
        };
        if (this.originHttpHeaderKey && originDomain) {
            reqParams.headers[this.originHttpHeaderKey] = originDomain;
        }
        retry_1.default({
            times: 5,
            interval: 1000,
            errorFilter: isErrorRetriable,
        }, function (cb) { return _this._submitRequest(reqParams, cb); }, function (err, result) {
            // ends on retriable error
            if (err && isErrorRetriable(err)) {
                var errMsg = "FetchSubprovider - cannot complete request. All retries exhausted.\nOriginal Error:\n" + err.toString() + "\n\n";
                var retriesExhaustedErr = new Error(errMsg);
                return end(retriesExhaustedErr);
            }
            // otherwise continue normally
            return end(err, result);
        });
    };
    FetchSubprovider.prototype.createPayload = function (payload) {
        return create_payload_1.createPayload(payload);
    };
    FetchSubprovider.prototype._submitRequest = function (reqParams, done) {
        var targetUrl = this.rpcUrl;
        promise_to_callback_1.default(cross_fetch_1.default(targetUrl, reqParams))(function (err, res) {
            if (err) {
                return done(err);
            }
            // continue parsing result
            waterfall_1.default([
                checkForHttpErrors,
                // buffer body
                function (cb) { return promise_to_callback_1.default(res.text())(cb); },
                // parse body
                asyncify_1.default(function (rawBody) { return JSON.parse(rawBody); }),
                parseResponse,
            ], done);
            function checkForHttpErrors(cb) {
                // check for errors
                switch (res.status) {
                    case 405:
                        return cb(new json_rpc_error_1.default.MethodNotFound());
                    case 418:
                        return cb(createRatelimitError());
                    case 503:
                    case 504:
                        return cb(createTimeoutError());
                    default:
                        return cb();
                }
            }
            function parseResponse(body, cb) {
                // check for error code
                if (res.status !== 200) {
                    return cb(new json_rpc_error_1.default.InternalError(body));
                }
                // check for rpc error
                if (body.error) {
                    return cb(new json_rpc_error_1.default.InternalError(body.error));
                }
                // return successful result
                cb(null, body.result);
            }
        });
    };
    return FetchSubprovider;
}(subprovider_1.default));
exports.default = FetchSubprovider;
function isErrorRetriable(err) {
    var errMsg = err.toString();
    return RETRIABLE_ERRORS.some(function (phrase) { return errMsg.includes(phrase); });
}
function createRatelimitError() {
    var msg = "Request is being rate limited.";
    var err = new Error(msg);
    return new json_rpc_error_1.default.InternalError(err);
}
function createTimeoutError() {
    var msg = "Gateway timeout. The request took too long to process. ";
    msg += "This can happen when querying logs over too wide a block range.";
    var err = new Error(msg);
    return new json_rpc_error_1.default.InternalError(err);
}

},{"../subprovider":37,"../util/create-payload":59,"async/asyncify":65,"async/retry":88,"async/waterfall":89,"cross-fetch":135,"json-rpc-error":146,"promise-to-callback":154}],45:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var parallel_1 = __importDefault(require("async/parallel"));
var subprovider_1 = __importDefault(require("../subprovider"));
var eth_util_1 = require("../util/eth-util");
var stoplight_1 = __importDefault(require("../util/stoplight"));
var block_filter_1 = __importDefault(require("./filters/block-filter"));
var log_filter_1 = __importDefault(require("./filters/log-filter"));
var pending_tx_filter_1 = __importDefault(require("./filters/pending-tx-filter"));
var FilterSubprovider = /** @class */ (function (_super) {
    __extends(FilterSubprovider, _super);
    function FilterSubprovider(opts) {
        var _this = _super.call(this) || this;
        opts = opts || {};
        _this.filterIndex = 0;
        _this.filters = {};
        _this.filterDestroyHandlers = {};
        _this.asyncBlockHandlers = {};
        _this.asyncPendingBlockHandlers = {};
        _this._ready = new stoplight_1.default();
        _this._ready.setMaxListeners(opts.maxFilters || 25);
        _this._ready.go();
        _this.pendingBlockTimeout = opts.pendingBlockTimeout || 4000;
        _this.checkForPendingBlocksActive = false;
        // TODO: Actually load the blocks
        // we dont have engine immeditately
        setTimeout(function () {
            // asyncBlockHandlers require locking provider until updates are completed
            _this.engine.on('block', function (block) {
                // pause processing
                _this._ready.stop();
                // update filters
                var updaters = valuesFor(_this.asyncBlockHandlers).map(function (fn) { return fn.bind(null, block); });
                parallel_1.default(updaters, function (err) {
                    // tslint:disable-next-line: no-console
                    if (err) {
                        console.error(err);
                    }
                    // unpause processing
                    _this._ready.go();
                });
            });
        });
        return _this;
    }
    FilterSubprovider.prototype.handleRequest = function (payload, next, end) {
        var _this = this;
        switch (payload.method) {
            case 'eth_newBlockFilter':
                this.newBlockFilter(end);
                return;
            case 'eth_newPendingTransactionFilter':
                this.newPendingTransactionFilter(end);
                this.checkForPendingBlocks();
                return;
            case 'eth_newFilter':
                this.newLogFilter(payload.params[0], end);
                return;
            case 'eth_getFilterChanges':
                this._ready.await(function () {
                    _this.getFilterChanges(payload.params[0], end);
                });
                return;
            case 'eth_getFilterLogs':
                this._ready.await(function () {
                    _this.getFilterLogs(payload.params[0], end);
                });
                return;
            case 'eth_uninstallFilter':
                this._ready.await(function () {
                    _this.uninstallFilter(payload.params[0], end);
                });
                return;
            default:
                next();
                return;
        }
    };
    FilterSubprovider.prototype.newBlockFilter = function (cb) {
        var _this = this;
        this._getBlockNumber(function (err, blockNumber) {
            if (err) {
                return cb(err);
            }
            var filter = new block_filter_1.default({
                blockNumber: blockNumber,
            });
            var newBlockHandler = filter.update.bind(filter);
            _this.engine.on('block', newBlockHandler);
            var destroyHandler = function () {
                _this.engine.removeListener('block', newBlockHandler);
            };
            _this.filterIndex++;
            _this.filters[_this.filterIndex] = filter;
            _this.filterDestroyHandlers[_this.filterIndex] = destroyHandler;
            var hexFilterIndex = eth_util_1.intToHex(_this.filterIndex);
            cb(null, hexFilterIndex);
        });
    };
    FilterSubprovider.prototype.newLogFilter = function (opts, done) {
        var _this = this;
        var filter = new log_filter_1.default(opts);
        var newLogHandler = filter.update.bind(filter);
        var blockHandler = function (block, cb) {
            _this._logsForBlock(block, function (err, logs) {
                if (err) {
                    return cb(err);
                }
                newLogHandler(logs);
                cb();
            });
        };
        this.filterIndex++;
        this.asyncBlockHandlers[this.filterIndex] = blockHandler;
        this.filters[this.filterIndex] = filter;
        var hexFilterIndex = eth_util_1.intToHex(this.filterIndex);
        done(null, hexFilterIndex);
    };
    FilterSubprovider.prototype.newPendingTransactionFilter = function (done) {
        var _this = this;
        var filter = new pending_tx_filter_1.default();
        var newTxHandler = filter.update.bind(filter);
        var blockHandler = function (block, cb) {
            _this._txHashesForBlock(block, function (err, txs) {
                if (err) {
                    return cb(err);
                }
                newTxHandler(txs);
                cb();
            });
        };
        this.filterIndex++;
        this.asyncPendingBlockHandlers[this.filterIndex] = blockHandler;
        this.filters[this.filterIndex] = filter;
        var hexFilterIndex = eth_util_1.intToHex(this.filterIndex);
        done(null, hexFilterIndex);
    };
    FilterSubprovider.prototype.getFilterChanges = function (hexFilterId, cb) {
        var filterId = parseInt(hexFilterId, 16);
        var filter = this.filters[filterId];
        // if (!filter) { console.warn('FilterSubprovider - no filter with that id:', hexFilterId); }
        if (!filter) {
            return cb(null, []);
        }
        var results = filter.getChanges();
        filter.clearChanges();
        cb(null, results);
    };
    FilterSubprovider.prototype.getFilterLogs = function (hexFilterId, cb) {
        var filterId = parseInt(hexFilterId, 16);
        var filter = this.filters[filterId];
        // if (!filter) { console.warn('FilterSubprovider - no filter with that id:', hexFilterId); }
        if (!filter) {
            return cb(null, []);
        }
        if (filter.type === 'log') {
            this.emitPayload({
                id: 0,
                jsonrpc: '2.0',
                method: 'eth_getLogs',
                params: [{
                        fromBlock: filter.fromBlock,
                        toBlock: filter.toBlock,
                        address: filter.address,
                        topics: filter.topics,
                    }],
            }, function (err, res) {
                if (err) {
                    return cb(err);
                }
                cb(null, res.result);
            });
        }
        else {
            cb(null, []);
        }
    };
    FilterSubprovider.prototype.uninstallFilter = function (hexFilterId, cb) {
        var filterId = parseInt(hexFilterId, 16);
        var filter = this.filters[filterId];
        if (!filter) {
            cb(null, false);
            return;
        }
        this.filters[filterId].removeAllListeners();
        var destroyHandler = this.filterDestroyHandlers[filterId];
        delete this.filters[filterId];
        delete this.asyncBlockHandlers[filterId];
        delete this.asyncPendingBlockHandlers[filterId];
        delete this.filterDestroyHandlers[filterId];
        if (destroyHandler) {
            destroyHandler();
        }
        cb(null, true);
    };
    FilterSubprovider.prototype.checkForPendingBlocks = function () {
        var _this = this;
        if (this.checkForPendingBlocksActive) {
            return;
        }
        var activePendingTxFilters = !!Object.keys(this.asyncPendingBlockHandlers).length;
        if (activePendingTxFilters) {
            this.checkForPendingBlocksActive = true;
            this.emitPayload({
                id: 0,
                jsonrpc: '2.0',
                method: 'eth_getBlockByNumber',
                params: ['pending', true],
            }, function (err, res) {
                if (err) {
                    _this.checkForPendingBlocksActive = false;
                    // console.error(err);
                    return;
                }
                _this.onNewPendingBlock(res.result, function () {
                    // if (err) { console.error(err); }
                    _this.checkForPendingBlocksActive = false;
                    setTimeout(_this.checkForPendingBlocks.bind(_this), _this.pendingBlockTimeout);
                });
            });
        }
    };
    FilterSubprovider.prototype.onNewPendingBlock = function (block, cb) {
        // update filters
        var updaters = valuesFor(this.asyncPendingBlockHandlers).map(function (fn) { return fn.bind(null, block); });
        parallel_1.default(updaters, cb);
    };
    FilterSubprovider.prototype._getBlockNumber = function (cb) {
        var blockNumber = bufferToNumberHex(this.engine.currentBlock.number);
        cb(null, blockNumber);
    };
    FilterSubprovider.prototype._logsForBlock = function (block, cb) {
        var blockNumber = bufferToNumberHex(block.number);
        this.emitPayload({
            id: 0,
            jsonrpc: '2.0',
            method: 'eth_getLogs',
            params: [{
                    fromBlock: blockNumber,
                    toBlock: blockNumber,
                }],
        }, function (err, response) {
            if (err) {
                return cb(err);
            }
            if (response.error) {
                return cb(response.error);
            }
            cb(null, response.result);
        });
    };
    FilterSubprovider.prototype._txHashesForBlock = function (block, cb) {
        var txs = block.transactions;
        // short circuit if empty
        if (txs.length === 0) {
            return cb(null, []);
        }
        // txs are already hashes
        if ('string' === typeof txs[0]) {
            cb(null, txs);
            // txs are obj, need to map to hashes
        }
        else {
            var results = txs.map(function (tx) { return tx.hash; });
            cb(null, results);
        }
    };
    return FilterSubprovider;
}(subprovider_1.default));
exports.default = FilterSubprovider;
// util
function bufferToNumberHex(buffer) {
    return stripLeadingZero(buffer.toString('hex'));
}
function stripLeadingZero(hexNum) {
    var stripped = eth_util_1.stripHexPrefix(hexNum);
    while (stripped[0] === '0') {
        stripped = stripped.substr(1);
    }
    return "0x" + stripped;
}
function valuesFor(obj) {
    return Object.keys(obj).map(function (key) { return obj[key]; });
}

},{"../subprovider":37,"../util/eth-util":60,"../util/stoplight":64,"./filters/block-filter":46,"./filters/log-filter":48,"./filters/pending-tx-filter":49,"async/parallel":87}],46:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var filter_1 = __importDefault(require("./filter"));
//
// BlockFilter
//
var BlockFilter = /** @class */ (function (_super) {
    __extends(BlockFilter, _super);
    function BlockFilter(opts) {
        var _this = 
        // console.log('BlockFilter - new')
        _super.call(this) || this;
        _this.type = 'block';
        _this.engine = opts.engine;
        _this.blockNumber = opts.blockNumber;
        _this.updates = [];
        return _this;
    }
    BlockFilter.prototype.update = function (block) {
        var blockHash = bufferToHex(block.hash);
        this.updates.push(blockHash);
        this.emit('data', block);
    };
    BlockFilter.prototype.getChanges = function () {
        // console.log('BlockFilter - getChanges:', results.length)
        return this.updates;
    };
    BlockFilter.prototype.clearChanges = function () {
        // console.log('BlockFilter - clearChanges')
        this.updates = [];
    };
    return BlockFilter;
}(filter_1.default));
exports.default = BlockFilter;
function bufferToHex(buffer) {
    return '0x' + buffer.toString('hex');
}

},{"./filter":47}],47:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("events");
var Filter = /** @class */ (function (_super) {
    __extends(Filter, _super);
    function Filter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Filter;
}(events_1.EventEmitter));
exports.default = Filter;

},{"events":132}],48:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var filter_1 = __importDefault(require("./filter"));
//
// LogFilter
//
var LogFilter = /** @class */ (function (_super) {
    __extends(LogFilter, _super);
    function LogFilter(opts) {
        var _this = 
        // console.log('LogFilter - new')
        _super.call(this) || this;
        _this.type = 'log';
        _this.fromBlock = (opts.fromBlock !== undefined) ? opts.fromBlock : 'latest';
        _this.toBlock = (opts.toBlock !== undefined) ? opts.toBlock : 'latest';
        var expectedAddress = opts.address && (Array.isArray(opts.address) ? opts.address : [opts.address]);
        _this.address = expectedAddress && expectedAddress.map(normalizeHex);
        _this.topics = opts.topics || [];
        _this.updates = [];
        _this.allResults = [];
        return _this;
    }
    LogFilter.prototype.update = function (logs) {
        var _this = this;
        // validate filter match
        var validLogs = [];
        logs.forEach(function (log) {
            var validated = _this.validateLog(log);
            if (!validated) {
                return;
            }
            // add to results
            validLogs.push(log);
            _this.updates.push(log);
            _this.allResults.push(log);
        });
        if (validLogs.length > 0) {
            this.emit('data', validLogs);
        }
    };
    LogFilter.prototype.getChanges = function () {
        // console.log('LogFilter - getChanges')
        return this.updates;
    };
    LogFilter.prototype.getAllResults = function () {
        // console.log('LogFilter - getAllResults')
        return this.allResults;
    };
    LogFilter.prototype.clearChanges = function () {
        // console.log('LogFilter - clearChanges')
        this.updates = [];
    };
    LogFilter.prototype.validateLog = function (log) {
        // console.log('LogFilter - validateLog:', log)
        // check if block number in bounds:
        // console.log('LogFilter - validateLog - blockNumber', this.fromBlock, this.toBlock)
        if (blockTagIsNumber(this.fromBlock) && hexToInt(this.fromBlock) >= hexToInt(log.blockNumber)) {
            return false;
        }
        if (blockTagIsNumber(this.toBlock) && hexToInt(this.toBlock) <= hexToInt(log.blockNumber)) {
            return false;
        }
        // address is correct:
        // console.log('LogFilter - validateLog - address', this.address)
        if (this.address && !(this.address.map(function (a) { return a.toLowerCase(); }).includes(log.address.toLowerCase()))) {
            return false;
        }
        // topics match:
        // topics are position-dependant
        // topics can be nested to represent `or` [[a || b], c]
        // topics can be null, representing a wild card for that position
        // console.log('LogFilter - validateLog - topics', log.topics)
        // console.log('LogFilter - validateLog - against topics', this.topics)
        var topicsMatch = this.topics.reduce(function (previousMatched, topicPattern, index) {
            // abort in progress
            if (!previousMatched) {
                return false;
            }
            // wild card
            if (!topicPattern) {
                return true;
            }
            // pattern is longer than actual topics
            var logTopic = log.topics[index];
            if (!logTopic) {
                return false;
            }
            // check each possible matching topic
            var subtopicsToMatch = Array.isArray(topicPattern) ? topicPattern : [topicPattern];
            var topicDoesMatch = subtopicsToMatch.filter(function (subTopic) {
                return logTopic.toLowerCase() === subTopic.toLowerCase();
            }).length > 0;
            return topicDoesMatch;
        }, true);
        // console.log('LogFilter - validateLog - '+(topicsMatch ? 'approved!' : 'denied!')+' ==============')
        return topicsMatch;
    };
    return LogFilter;
}(filter_1.default));
exports.default = LogFilter;
function blockTagIsNumber(blockTag) {
    return blockTag && ['earliest', 'latest', 'pending'].indexOf(blockTag) === -1;
}
function hexToInt(hexString) {
    return Number(hexString);
}
function normalizeHex(hexString) {
    return hexString.slice(0, 2) === '0x' ? hexString : '0x' + hexString;
}

},{"./filter":47}],49:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var filter_1 = __importDefault(require("./filter"));
//
// PendingTxFilter
//
var PendingTransactionFilter = /** @class */ (function (_super) {
    __extends(PendingTransactionFilter, _super);
    function PendingTransactionFilter() {
        var _this = 
        // console.log('PendingTransactionFilter - new')
        _super.call(this) || this;
        _this.type = 'pendingTx';
        _this.updates = [];
        _this.allResults = [];
        return _this;
    }
    PendingTransactionFilter.prototype.update = function (txs) {
        var _this = this;
        // console.log('PendingTransactionFilter - update')
        var validTxs = [];
        txs.forEach(function (tx) {
            // validate filter match
            var validated = _this.validateUnique(tx);
            if (!validated) {
                return;
            }
            // add to results
            validTxs.push(tx);
            _this.updates.push(tx);
            _this.allResults.push(tx);
        });
        if (validTxs.length > 0) {
            this.emit('data', validTxs);
        }
    };
    PendingTransactionFilter.prototype.getChanges = function () {
        // console.log('PendingTransactionFilter - getChanges')
        return this.updates;
    };
    PendingTransactionFilter.prototype.getAllResults = function () {
        // console.log('PendingTransactionFilter - getAllResults')
        return this.allResults;
    };
    PendingTransactionFilter.prototype.clearChanges = function () {
        // console.log('PendingTransactionFilter - clearChanges')
        this.updates = [];
    };
    PendingTransactionFilter.prototype.validateUnique = function (tx) {
        return this.allResults.indexOf(tx) === -1;
    };
    return PendingTransactionFilter;
}(filter_1.default));
exports.default = PendingTransactionFilter;

},{"./filter":47}],50:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var subprovider_1 = __importDefault(require("../subprovider"));
var FixtureProvider = /** @class */ (function (_super) {
    __extends(FixtureProvider, _super);
    function FixtureProvider(staticResponses) {
        var _this = _super.call(this) || this;
        _this.staticResponses = staticResponses || {};
        return _this;
    }
    FixtureProvider.prototype.handleRequest = function (payload, next, end) {
        var staticResponse = this.staticResponses[payload.method];
        // async function
        if ('function' === typeof staticResponse) {
            staticResponse(payload, next, end);
            // static response - null is valid response
        }
        else if (staticResponse !== undefined) {
            // return result asynchronously
            setTimeout(function () { return end(null, staticResponse); });
            // no prepared response - skip
        }
        else {
            next();
        }
    };
    return FixtureProvider;
}(subprovider_1.default));
exports.default = FixtureProvider;

},{"../subprovider":37}],51:[function(require,module,exports){
"use strict";
/*
 * Calculate gasPrice based on last blocks.
 * @author github.com/axic
 *
 * FIXME: support minimum suggested gas and perhaps other options from geth:
 * https://github.com/ethereum/go-ethereum/blob/master/eth/gasprice.go
 * https://github.com/ethereum/go-ethereum/wiki/Gas-Price-Oracle
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var map_1 = __importDefault(require("async/map"));
var gas_price_error_1 = require("../errors/gas-price-error");
var subprovider_1 = __importDefault(require("../subprovider"));
var GaspriceProvider = /** @class */ (function (_super) {
    __extends(GaspriceProvider, _super);
    function GaspriceProvider(opts) {
        var _this = this;
        opts = opts || {};
        _this = _super.call(this) || this;
        _this.numberOfBlocks = opts.numberOfBlocks || 10;
        _this.delayInBlocks = opts.delayInBlocks || 5;
        return _this;
    }
    GaspriceProvider.prototype.handleRequest = function (payload, next, end) {
        var _this = this;
        if (payload.method !== 'eth_gasPrice') {
            return next();
        }
        var p = { id: 0, jsonrpc: '2.0', method: 'eth_blockNumber', params: [] };
        this.emitPayload(p, function (_, res) {
            // FIXME: convert number using a bignum library
            var lastBlock = parseInt(res.result, 16) - _this.delayInBlocks;
            var blockNumbers = [];
            for (var i = 0; i < _this.numberOfBlocks; i++) {
                blockNumbers.push('0x' + lastBlock.toString(16));
                lastBlock--;
            }
            var getBlock = function (item, cb) {
                var p2 = { id: 0, jsonrpc: '2.0', method: 'eth_getBlockByNumber', params: [item, true] };
                _this.emitPayload(p2, function (err, blockRes) {
                    if (err) {
                        return cb(err);
                    }
                    if (!blockRes.result) {
                        return cb(gas_price_error_1.GasPriceError.BlockNotFound(item));
                    }
                    cb(null, blockRes.result.transactions);
                });
            };
            // FIXME: this could be made much faster
            var calcPrice = function (err, transactions) {
                // flatten array
                transactions = transactions.reduce(function (a, b) { return a.concat(b); }, []);
                // leave only the gasprice
                // FIXME: convert number using a bignum library
                transactions = transactions.map(function (a) { return parseInt(a.gasPrice, 16); }, []);
                // order ascending
                transactions.sort(function (a, b) { return a - b; });
                // ze median
                var half = Math.floor(transactions.length / 2);
                var median;
                if (transactions.length % 2) {
                    median = transactions[half];
                }
                else {
                    median = Math.floor((transactions[half - 1] + transactions[half]) / 2.0);
                }
                end(null, median);
            };
            map_1.default(blockNumbers, getBlock, calcPrice);
        });
    };
    return GaspriceProvider;
}(subprovider_1.default));
exports.default = GaspriceProvider;

},{"../errors/gas-price-error":32,"../subprovider":37,"async/map":86}],52:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var cache_1 = require("./cache");
exports.BlockCacheSubprovider = cache_1.default;
var default_fixture_1 = require("./default-fixture");
exports.DefaultFixtureSubprovider = default_fixture_1.default;
var fetch_1 = require("./fetch");
exports.FetchSubprovider = fetch_1.default;
var filters_1 = require("./filters");
exports.FilterSubprovider = filters_1.default;
var fixture_1 = require("./fixture");
exports.FixtureSubprovider = fixture_1.default;
var gasprice_1 = require("./gasprice");
exports.GasPriceSubprovider = gasprice_1.default;
var inflight_cache_1 = require("./inflight-cache");
exports.InflightCacheSubprovider = inflight_cache_1.default;
var provider_1 = require("./provider");
exports.ProviderSubprovider = provider_1.default;
var sanitizer_1 = require("./sanitizer");
exports.SanitizerSubprovider = sanitizer_1.default;
var subscriptions_1 = require("./subscriptions");
exports.SubscriptionSubprovider = subscriptions_1.default;

},{"./cache":42,"./default-fixture":43,"./fetch":44,"./filters":45,"./fixture":50,"./gasprice":51,"./inflight-cache":53,"./provider":54,"./sanitizer":55,"./subscriptions":56}],53:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var clone_1 = __importDefault(require("clone"));
var subprovider_1 = __importDefault(require("../subprovider"));
var rpc_cache_utils_1 = require("../util/rpc-cache-utils");
var InflightCacheSubprovider = /** @class */ (function (_super) {
    __extends(InflightCacheSubprovider, _super);
    function InflightCacheSubprovider() {
        var _this = _super.call(this) || this;
        _this.inflightRequests = {};
        return _this;
    }
    InflightCacheSubprovider.prototype.handleRequest = function (payload, next, end) {
        var _this = this;
        var cacheId = rpc_cache_utils_1.cacheIdentifierForPayload(payload, { includeBlockRef: true });
        // if not cacheable, skip
        if (!cacheId) {
            return next();
        }
        // check for matching requests
        var activeRequestHandlers = this.inflightRequests[cacheId];
        if (!activeRequestHandlers) {
            // create inflight cache for cacheId
            activeRequestHandlers = [];
            this.inflightRequests[cacheId] = activeRequestHandlers;
            next(function (err, result, cb) {
                // complete inflight for cacheId
                delete _this.inflightRequests[cacheId];
                activeRequestHandlers.forEach(function (handler) { return handler(err, clone_1.default(result)); });
                result = clone_1.default(result);
                cb();
            });
        }
        else {
            // hit inflight cache for cacheId
            // setup the response listener
            activeRequestHandlers.push(end);
        }
    };
    return InflightCacheSubprovider;
}(subprovider_1.default));
exports.default = InflightCacheSubprovider;

},{"../subprovider":37,"../util/rpc-cache-utils":62,"clone":134}],54:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var json_rpc_error_1 = __importDefault(require("json-rpc-error"));
var subprovider_1 = __importDefault(require("../subprovider"));
// wraps a provider in a subprovider interface
var ProviderSubprovider = /** @class */ (function (_super) {
    __extends(ProviderSubprovider, _super);
    function ProviderSubprovider(provider) {
        var _this = _super.call(this) || this;
        _this.provider = provider;
        return _this;
    }
    ProviderSubprovider.prototype.handleRequest = function (payload, next, end) {
        this.provider.sendAsync(payload, function (err, response) {
            if (err) {
                return end(err);
            }
            if (response.error) {
                return end(new json_rpc_error_1.default.InternalError(response.error));
            }
            end(null, response.result);
        });
    };
    return ProviderSubprovider;
}(subprovider_1.default));
exports.default = ProviderSubprovider;

},{"../subprovider":37,"json-rpc-error":146}],55:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var subprovider_1 = __importDefault(require("../subprovider"));
var eth_util_1 = require("../util/eth-util");
var SanitizerSubprovider = /** @class */ (function (_super) {
    __extends(SanitizerSubprovider, _super);
    function SanitizerSubprovider() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SanitizerSubprovider.prototype.handleRequest = function (payload, next, end) {
        var txParams = payload.params[0];
        if (typeof txParams === 'object' && !Array.isArray(txParams)) {
            var sanitized = cloneTxParams(txParams);
            payload.params[0] = sanitized;
        }
        next();
    };
    return SanitizerSubprovider;
}(subprovider_1.default));
exports.default = SanitizerSubprovider;
// we use this to clean any custom params from the txParams
var permitted = [
    'from',
    'to',
    'value',
    'data',
    'gas',
    'gasPrice',
    'nonce',
    'fromBlock',
    'toBlock',
    'address',
    'topics',
];
function cloneTxParams(txParams) {
    var sanitized = permitted.reduce(function (copy, p) {
        if (p in txParams) {
            if (Array.isArray(txParams[p])) {
                copy[p] = txParams[p].map(function (item) { return sanitize(item); });
            }
            else {
                copy[p] = sanitize(txParams[p]);
            }
        }
        return copy;
    }, {});
    return sanitized;
}
function sanitize(value) {
    switch (value) {
        case 'latest':
            return value;
        case 'pending':
            return value;
        case 'earliest':
            return value;
        default:
            if (typeof value === 'string') {
                return eth_util_1.addHexPrefix(value.toLowerCase());
            }
            else {
                return value;
            }
    }
}

},{"../subprovider":37,"../util/eth-util":60}],56:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var subscription_error_1 = require("../errors/subscription-error");
var eth_util_1 = require("../util/eth-util");
var rpc_hex_encoding_1 = require("../util/rpc-hex-encoding");
var filters_1 = __importDefault(require("./filters"));
var SubscriptionSubprovider = /** @class */ (function (_super) {
    __extends(SubscriptionSubprovider, _super);
    function SubscriptionSubprovider(opts) {
        var _this = _super.call(this, opts) || this;
        _this.subscriptions = {};
        return _this;
    }
    SubscriptionSubprovider.prototype.handleRequest = function (payload, next, end) {
        switch (payload.method) {
            case 'eth_subscribe':
                this.eth_subscribe(payload, end);
                break;
            case 'eth_unsubscribe':
                this.eth_unsubscribe(payload, end);
                break;
            default:
                _super.prototype.handleRequest.call(this, payload, next, end);
        }
    };
    SubscriptionSubprovider.prototype.eth_subscribe = function (payload, cb) {
        var _this = this;
        var subscriptionType = payload.params[0];
        var callback = function (err, hexId) {
            if (err) {
                return cb(err);
            }
            var id = parseInt(hexId, 16);
            _this.subscriptions[id] = subscriptionType;
            _this.filters[id].on('data', function (results) {
                _this.filters[id].clearChanges();
                if (!Array.isArray(results)) {
                    results = [results];
                }
                results.forEach(function (r) { return _this._notificationHandler(hexId, subscriptionType, r); });
            });
            if (subscriptionType === 'newPendingTransactions') {
                _this.checkForPendingBlocks();
            }
            cb(null, hexId);
        };
        switch (subscriptionType) {
            case 'logs':
                var options = payload.params[1];
                this.newLogFilter(options, callback);
                break;
            case 'newPendingTransactions':
                this.newPendingTransactionFilter(callback);
                break;
            case 'newHeads':
                this.newBlockFilter(callback);
                break;
            case 'syncing':
            default:
                cb(subscription_error_1.SubscriptionError.UnsupportedType(subscriptionType));
                return;
        }
    };
    SubscriptionSubprovider.prototype.eth_unsubscribe = function (payload, cb) {
        var _this = this;
        var hexId = payload.params[0];
        var id = parseInt(hexId, 16);
        if (!this.subscriptions[id]) {
            cb(subscription_error_1.SubscriptionError.NotFound(hexId));
        }
        else {
            this.uninstallFilter(hexId, function (err, result) {
                delete _this.subscriptions[id];
                cb(err, result);
            });
        }
    };
    SubscriptionSubprovider.prototype._notificationHandler = function (hexId, subscriptionType, result) {
        if (subscriptionType === 'newHeads') {
            result = this._notificationResultFromBlock(result);
        }
        // it seems that web3 doesn't expect there to be a separate error event
        // so we must emit null along with the result object
        this.emit('data', null, {
            jsonrpc: '2.0',
            method: 'eth_subscription',
            params: {
                subscription: hexId,
                result: result,
            },
        });
    };
    SubscriptionSubprovider.prototype._notificationResultFromBlock = function (block) {
        return {
            hash: eth_util_1.bufferToHex(block.hash),
            parentHash: eth_util_1.bufferToHex(block.parentHash),
            sha3Uncles: eth_util_1.bufferToHex(block.sha3Uncles),
            miner: eth_util_1.bufferToHex(block.miner),
            stateRoot: eth_util_1.bufferToHex(block.stateRoot),
            transactionsRoot: eth_util_1.bufferToHex(block.transactionsRoot),
            receiptsRoot: eth_util_1.bufferToHex(block.receiptsRoot),
            logsBloom: eth_util_1.bufferToHex(block.logsBloom),
            difficulty: rpc_hex_encoding_1.bufferToQuantityHex(block.difficulty),
            number: rpc_hex_encoding_1.bufferToQuantityHex(block.number),
            gasLimit: rpc_hex_encoding_1.bufferToQuantityHex(block.gasLimit),
            gasUsed: rpc_hex_encoding_1.bufferToQuantityHex(block.gasUsed),
            nonce: block.nonce ? eth_util_1.bufferToHex(block.nonce) : null,
            mixHash: eth_util_1.bufferToHex(block.mixHash),
            timestamp: rpc_hex_encoding_1.bufferToQuantityHex(block.timestamp),
            extraData: eth_util_1.bufferToHex(block.extraData),
        };
    };
    return SubscriptionSubprovider;
}(filters_1.default));
exports.default = SubscriptionSubprovider;

},{"../errors/subscription-error":34,"../util/eth-util":60,"../util/rpc-hex-encoding":63,"./filters":45}],57:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function assert(condition, message) {
    if (!condition) {
        throw message || 'Assertion failed';
    }
}
exports.assert = assert;

},{}],58:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var eth_block_tracker_1 = __importDefault(require("eth-block-tracker"));
var events_1 = require("events");
var block_tracker_error_1 = require("../errors/block-tracker-error");
var create_payload_1 = require("./create-payload");
var eth_util_1 = require("./eth-util");
// Class responsible for tracking new blocks as they are mined,
// loading them, parsing them, and alerting subscribers via events.
var BlockTracker = /** @class */ (function (_super) {
    __extends(BlockTracker, _super);
    function BlockTracker(opts) {
        var _this = _super.call(this) || this;
        // Number of milliseconds to wait before retrying
        _this.blockTimeout = 300;
        // Maximum attempts to load a block
        _this.maxBlockRetries = 3;
        _this.provider = opts.provider;
        _this._blockTracker = opts.blockTracker || new eth_block_tracker_1.default(__assign({}, opts, { setSkipCacheFlag: true }));
        return _this;
    }
    BlockTracker.prototype.start = function () {
        this.createSubscriptions();
    };
    BlockTracker.prototype.stop = function () {
        this.destroySubscriptions();
    };
    BlockTracker.prototype.fetchLatest = function () {
        var _this = this;
        return this._blockTracker.checkForLatestBlock().catch(function (error) {
            _this.emit('error', error);
        });
    };
    BlockTracker.prototype.createSubscriptions = function () {
        // on new block, request block body and emit as events
        this._blockTracker.on('latest', this.onLatest.bind(this));
        // forward other events
        this._blockTracker.on('sync', this.emit.bind(this, 'sync'));
        this._blockTracker.on('error', this.emit.bind(this, 'error'));
    };
    BlockTracker.prototype.destroySubscriptions = function () {
        // stop block polling by removing event listeners
        this._blockTracker.removeAllListeners();
    };
    BlockTracker.prototype.onLatest = function (blockNumber) {
        this.currentBlockNumber = blockNumber;
        this.loadBlock(blockNumber);
    };
    // Tries to get the block payload recursively
    BlockTracker.prototype.loadBlock = function (blockNumber, callCount) {
        var _this = this;
        if (callCount === void 0) { callCount = 0; }
        this._getBlockByNumber(blockNumber).then(function (blockResponse) {
            // Result can be null if the block hasn't fully propagated to the nodes
            if (blockResponse.result) {
                _this.updateBlock(blockResponse.result);
            }
            else if (callCount < _this.maxBlockRetries && blockNumber === _this.currentBlockNumber) {
                // Only call recursively if the current block number is still the same
                // and if we are under the retry limit.
                setTimeout(function () {
                    _this.loadBlock(blockNumber, callCount + 1);
                }, _this.blockTimeout);
            }
            else {
                throw block_tracker_error_1.BlockTrackerError.BlockNotFound(blockNumber);
            }
        }).catch(function (err) {
            // Don't retry for errors (provider should have already retried)
            _this.emit('error', err);
        });
    };
    BlockTracker.prototype._getBlockByNumber = function (blockNumber) {
        var _this = this;
        var req = create_payload_1.createPayload({ method: 'eth_getBlockByNumber', params: [blockNumber, false], skipCache: true });
        return new Promise(function (fulfill, reject) {
            _this.provider.sendAsync(req, function (err, result) {
                if (err) {
                    return reject(err);
                }
                fulfill(result);
            });
        });
    };
    // Parse the block into a buffer representation and update subscribers.
    BlockTracker.prototype.updateBlock = function (block) {
        var bufferBlock = toBufferBlock(block);
        // set current + emit "block" event
        this._setCurrentBlock(bufferBlock);
        // emit other events
        this.emit('rawBlock', block);
        this.emit('latest', block);
    };
    BlockTracker.prototype._setCurrentBlock = function (bufferBlock) {
        this.currentBlock = bufferBlock;
        this.emit('block', bufferBlock);
    };
    return BlockTracker;
}(events_1.EventEmitter));
exports.default = BlockTracker;
// util
function toBufferBlock(jsonBlock) {
    return {
        number: eth_util_1.toBuffer(jsonBlock.number),
        hash: eth_util_1.toBuffer(jsonBlock.hash),
        parentHash: eth_util_1.toBuffer(jsonBlock.parentHash),
        nonce: eth_util_1.toBuffer(jsonBlock.nonce),
        mixHash: eth_util_1.toBuffer(jsonBlock.mixHash),
        sha3Uncles: eth_util_1.toBuffer(jsonBlock.sha3Uncles),
        logsBloom: eth_util_1.toBuffer(jsonBlock.logsBloom),
        transactionsRoot: eth_util_1.toBuffer(jsonBlock.transactionsRoot),
        stateRoot: eth_util_1.toBuffer(jsonBlock.stateRoot),
        receiptsRoot: eth_util_1.toBuffer(jsonBlock.receiptsRoot),
        miner: eth_util_1.toBuffer(jsonBlock.miner),
        difficulty: eth_util_1.toBuffer(jsonBlock.difficulty),
        totalDifficulty: eth_util_1.toBuffer(jsonBlock.totalDifficulty),
        size: eth_util_1.toBuffer(jsonBlock.size),
        extraData: eth_util_1.toBuffer(jsonBlock.extraData),
        gasLimit: eth_util_1.toBuffer(jsonBlock.gasLimit),
        gasUsed: eth_util_1.toBuffer(jsonBlock.gasUsed),
        timestamp: eth_util_1.toBuffer(jsonBlock.timestamp),
        transactions: jsonBlock.transactions,
    };
}

},{"../errors/block-tracker-error":31,"./create-payload":59,"./eth-util":60,"eth-block-tracker":138,"events":132}],59:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var xtend_1 = __importDefault(require("xtend"));
var random_id_1 = require("./random-id");
function createPayload(data) {
    return xtend_1.default({
        // defaults
        id: random_id_1.createRandomId(),
        jsonrpc: '2.0',
        params: [],
    }, data);
}
exports.createPayload = createPayload;

},{"./random-id":61,"xtend":171}],60:[function(require,module,exports){
(function (Buffer){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var bn_js_1 = __importDefault(require("bn.js"));
var ethjs_util_1 = __importDefault(require("ethjs-util"));
// Methods from ethereumjs-util
/**
 * Attempts to turn a value into a `Buffer`. As input it supports
 * `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.
 * @param v the value
 */
function toBuffer(v) {
    if (!Buffer.isBuffer(v)) {
        if (Array.isArray(v)) {
            v = Buffer.from(v);
        }
        else if (typeof v === 'string') {
            if (ethjs_util_1.default.isHexString(v)) {
                v = Buffer.from(ethjs_util_1.default.padToEven(ethjs_util_1.default.stripHexPrefix(v)), 'hex');
            }
            else {
                throw new TypeError(
                // tslint:disable-next-line: max-line-length
                "Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: " + v);
            }
        }
        else if (typeof v === 'number') {
            v = ethjs_util_1.default.intToBuffer(v);
        }
        else if (v === null || v === undefined) {
            v = Buffer.allocUnsafe(0);
        }
        else if (bn_js_1.default.isBN(v)) {
            v = v.toArrayLike(Buffer);
        }
        else if (v.toArray) {
            // converts a BN to a Buffer
            v = Buffer.from(v.toArray());
        }
        else {
            throw new TypeError("invalid type: " + v);
        }
    }
    return v;
}
exports.toBuffer = toBuffer;
/**
 * Adds "0x" to a given `String` if it does not already start with "0x".
 */
function addHexPrefix(str) {
    if (typeof str !== 'string') {
        return str;
    }
    return ethjs_util_1.default.isHexPrefixed(str) ? str : '0x' + str;
}
exports.addHexPrefix = addHexPrefix;
function stripHexPrefix(str) {
    return ethjs_util_1.default.stripHexPrefix(str);
}
exports.stripHexPrefix = stripHexPrefix;
function intToHex(n) {
    return ethjs_util_1.default.intToHex(n);
}
exports.intToHex = intToHex;
function intToBuffer(n) {
    return ethjs_util_1.default.intToBuffer(n);
}
exports.intToBuffer = intToBuffer;
/**
 * Converts a `Buffer` into a hex `String`.
 * @param buf `Buffer` object to convert
 */
function bufferToHex(buf) {
    buf = toBuffer(buf);
    return '0x' + buf.toString('hex');
}
exports.bufferToHex = bufferToHex;
/**
 * Converts a `Buffer` to a `Number`.
 * @param buf `Buffer` object to convert
 * @throws If the input number exceeds 53 bits.
 */
function bufferToInt(buf) {
    return new bn_js_1.default(toBuffer(buf)).toNumber();
}
exports.bufferToInt = bufferToInt;
/**
 * Trims leading zeros from a `Buffer` or an `Array`.
 * @param a (Buffer|Array|String)
 * @return (Buffer|Array|String)
 */
function unpad(a) {
    a = ethjs_util_1.default.stripHexPrefix(a);
    var first = a[0];
    while (a.length > 0 && first.toString() === '0') {
        a = a.slice(1);
        first = a[0];
    }
    return a;
}
exports.unpad = unpad;

}).call(this,require("buffer").Buffer)

},{"bn.js":130,"buffer":133,"ethjs-util":140}],61:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// gotta keep it within MAX_SAFE_INTEGER
var extraDigits = 3;
function createRandomId() {
    // 13 time digits
    var datePart = new Date().getTime() * Math.pow(10, extraDigits);
    // 3 random digits
    var extraPart = Math.floor(Math.random() * Math.pow(10, extraDigits));
    // 16 digits
    return datePart + extraPart;
}
exports.createRandomId = createRandomId;

},{}],62:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var json_stable_stringify_1 = __importDefault(require("json-stable-stringify"));
function cacheIdentifierForPayload(payload, opts) {
    if (opts === void 0) { opts = {}; }
    if (!canCache(payload)) {
        return null;
    }
    var includeBlockRef = opts.includeBlockRef;
    var params = includeBlockRef ? payload.params : paramsWithoutBlockTag(payload);
    return payload.method + ':' + json_stable_stringify_1.default(params);
}
exports.cacheIdentifierForPayload = cacheIdentifierForPayload;
function canCache(payload) {
    return cacheTypeForPayload(payload) !== 'never';
}
exports.canCache = canCache;
function blockTagForPayload(payload) {
    var index = blockTagParamIndex(payload);
    // Block tag param not passed.
    if (index >= payload.params.length) {
        return null;
    }
    return payload.params[index];
}
exports.blockTagForPayload = blockTagForPayload;
function paramsWithoutBlockTag(payload) {
    var index = blockTagParamIndex(payload);
    // Block tag param not passed.
    if (index >= payload.params.length) {
        return payload.params;
    }
    // eth_getBlockByNumber has the block tag first, then the optional includeTx? param
    if (payload.method === 'eth_getBlockByNumber') {
        return payload.params.slice(1);
    }
    return payload.params.slice(0, index);
}
exports.paramsWithoutBlockTag = paramsWithoutBlockTag;
function blockTagParamIndex(payload) {
    switch (payload.method) {
        // blockTag is third param
        case 'eth_getStorageAt':
            return 2;
        // blockTag is second param
        case 'eth_getBalance':
        case 'eth_getCode':
        case 'eth_getTransactionCount':
        case 'eth_call':
        case 'eth_estimateGas':
            return 1;
        // blockTag is first param
        case 'eth_getBlockByNumber':
            return 0;
        // there is no blockTag
        default:
            return undefined;
    }
}
exports.blockTagParamIndex = blockTagParamIndex;
function cacheTypeForPayload(payload) {
    switch (payload.method) {
        // cache permanently
        case 'net_version':
        case 'web3_clientVersion':
        case 'web3_sha3':
        case 'eth_protocolVersion':
        case 'eth_getBlockTransactionCountByHash':
        case 'eth_getUncleCountByBlockHash':
        case 'eth_getCode':
        case 'eth_getBlockByHash':
        case 'eth_getTransactionByHash':
        case 'eth_getTransactionByBlockHashAndIndex':
        case 'eth_getTransactionReceipt':
        case 'eth_getUncleByBlockHashAndIndex':
        case 'eth_getCompilers':
        case 'eth_compileLLL':
        case 'eth_compileSolidity':
        case 'eth_compileSerpent':
        case 'shh_version':
            return 'perma';
        // cache until fork
        case 'eth_getBlockByNumber':
        case 'eth_getBlockTransactionCountByNumber':
        case 'eth_getUncleCountByBlockNumber':
        case 'eth_getTransactionByBlockNumberAndIndex':
        case 'eth_getUncleByBlockNumberAndIndex':
            return 'fork';
        // cache for block
        case 'eth_gasPrice':
        case 'eth_blockNumber':
        case 'eth_getBalance':
        case 'eth_getStorageAt':
        case 'eth_getTransactionCount':
        case 'eth_call':
        case 'eth_estimateGas':
        case 'eth_getFilterLogs':
        case 'eth_getLogs':
        case 'net_peerCount':
            return 'block';
        // never cache
        case 'net_peerCount':
        case 'net_listening':
        case 'eth_syncing':
        case 'eth_sign':
        case 'eth_coinbase':
        case 'eth_mining':
        case 'eth_hashrate':
        case 'eth_accounts':
        case 'eth_sendTransaction':
        case 'eth_sendRawTransaction':
        case 'eth_newFilter':
        case 'eth_newBlockFilter':
        case 'eth_newPendingTransactionFilter':
        case 'eth_uninstallFilter':
        case 'eth_getFilterChanges':
        case 'eth_getWork':
        case 'eth_submitWork':
        case 'eth_submitHashrate':
        case 'db_putString':
        case 'db_getString':
        case 'db_putHex':
        case 'db_getHex':
        case 'shh_post':
        case 'shh_newIdentity':
        case 'shh_hasIdentity':
        case 'shh_newGroup':
        case 'shh_addToGroup':
        case 'shh_newFilter':
        case 'shh_uninstallFilter':
        case 'shh_getFilterChanges':
        case 'shh_getMessages':
            return 'never';
    }
}
exports.cacheTypeForPayload = cacheTypeForPayload;

},{"json-stable-stringify":149}],63:[function(require,module,exports){
(function (Buffer){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var assert_1 = require("./assert");
var eth_util_1 = require("./eth-util");
/*
 * As per https://github.com/ethereum/wiki/wiki/JSON-RPC#hex-value-encoding
 * Quantities should be represented by the most compact hex representation possible
 * This means that no leading zeroes are allowed. There helpers make it easy
 * to convert to and from integers and their compact hex representation
 */
function bufferToQuantityHex(buffer) {
    buffer = eth_util_1.toBuffer(buffer);
    var hex = buffer.toString('hex');
    var trimmed = eth_util_1.unpad(hex);
    return eth_util_1.addHexPrefix(trimmed);
}
exports.bufferToQuantityHex = bufferToQuantityHex;
function intToQuantityHex(n) {
    assert_1.assert(typeof n === 'number' && n === Math.floor(n), 'intToQuantityHex arg must be an integer');
    var nHex = eth_util_1.toBuffer(n).toString('hex');
    if (nHex[0] === '0') {
        nHex = nHex.substring(1);
    }
    return eth_util_1.addHexPrefix(nHex);
}
exports.intToQuantityHex = intToQuantityHex;
function quantityHexToInt(prefixedQuantityHex) {
    assert_1.assert(typeof prefixedQuantityHex === 'string', 'arg to quantityHexToInt must be a string');
    var quantityHex = eth_util_1.stripHexPrefix(prefixedQuantityHex);
    var isEven = quantityHex.length % 2 === 0;
    if (!isEven) {
        quantityHex = '0' + quantityHex;
    }
    var buf = new Buffer(quantityHex, 'hex');
    return eth_util_1.bufferToInt(buf);
}
exports.quantityHexToInt = quantityHexToInt;

}).call(this,require("buffer").Buffer)

},{"./assert":57,"./eth-util":60,"buffer":133}],64:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("events");
var Stoplight = /** @class */ (function (_super) {
    __extends(Stoplight, _super);
    function Stoplight() {
        var _this = _super.call(this) || this;
        _this.isLocked = true;
        return _this;
    }
    Stoplight.prototype.go = function () {
        this.isLocked = false;
        this.emit('unlock');
    };
    Stoplight.prototype.stop = function () {
        this.isLocked = true;
        this.emit('lock');
    };
    Stoplight.prototype.await = function (fn) {
        if (this.isLocked) {
            this.once('unlock', fn);
        }
        else {
            setTimeout(fn);
        }
    };
    return Stoplight;
}(events_1.EventEmitter));
exports.default = Stoplight;

},{"events":132}],65:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = asyncify;

var _initialParams = require('./internal/initialParams');

var _initialParams2 = _interopRequireDefault(_initialParams);

var _setImmediate = require('./internal/setImmediate');

var _setImmediate2 = _interopRequireDefault(_setImmediate);

var _wrapAsync = require('./internal/wrapAsync');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Take a sync function and make it async, passing its return value to a
 * callback. This is useful for plugging sync functions into a waterfall,
 * series, or other async functions. Any arguments passed to the generated
 * function will be passed to the wrapped function (except for the final
 * callback argument). Errors thrown will be passed to the callback.
 *
 * If the function passed to `asyncify` returns a Promise, that promises's
 * resolved/rejected state will be used to call the callback, rather than simply
 * the synchronous return value.
 *
 * This also means you can asyncify ES2017 `async` functions.
 *
 * @name asyncify
 * @static
 * @memberOf module:Utils
 * @method
 * @alias wrapSync
 * @category Util
 * @param {Function} func - The synchronous function, or Promise-returning
 * function to convert to an {@link AsyncFunction}.
 * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be
 * invoked with `(args..., callback)`.
 * @example
 *
 * // passing a regular synchronous function
 * async.waterfall([
 *     async.apply(fs.readFile, filename, "utf8"),
 *     async.asyncify(JSON.parse),
 *     function (data, next) {
 *         // data is the result of parsing the text.
 *         // If there was a parsing error, it would have been caught.
 *     }
 * ], callback);
 *
 * // passing a function returning a promise
 * async.waterfall([
 *     async.apply(fs.readFile, filename, "utf8"),
 *     async.asyncify(function (contents) {
 *         return db.model.create(contents);
 *     }),
 *     function (model, next) {
 *         // `model` is the instantiated model object.
 *         // If there was an error, this function would be skipped.
 *     }
 * ], callback);
 *
 * // es2017 example, though `asyncify` is not needed if your JS environment
 * // supports async functions out of the box
 * var q = async.queue(async.asyncify(async function(file) {
 *     var intermediateStep = await processFile(file);
 *     return await somePromise(intermediateStep)
 * }));
 *
 * q.push(files);
 */
function asyncify(func) {
    if ((0, _wrapAsync.isAsync)(func)) {
        return function (...args /*, callback*/) {
            const callback = args.pop();
            const promise = func.apply(this, args);
            return handlePromise(promise, callback);
        };
    }

    return (0, _initialParams2.default)(function (args, callback) {
        var result;
        try {
            result = func.apply(this, args);
        } catch (e) {
            return callback(e);
        }
        // if result is Promise object
        if (result && typeof result.then === 'function') {
            return handlePromise(result, callback);
        } else {
            callback(null, result);
        }
    });
}

function handlePromise(promise, callback) {
    return promise.then(value => {
        invokeCallback(callback, null, value);
    }, err => {
        invokeCallback(callback, err && err.message ? err : new Error(err));
    });
}

function invokeCallback(callback, error, value) {
    try {
        callback(error, value);
    } catch (err) {
        (0, _setImmediate2.default)(e => {
            throw e;
        }, err);
    }
}
module.exports = exports['default'];
},{"./internal/initialParams":75,"./internal/setImmediate":83,"./internal/wrapAsync":85}],66:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _eachOfLimit = require('./internal/eachOfLimit');

var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);

var _withoutIndex = require('./internal/withoutIndex');

var _withoutIndex2 = _interopRequireDefault(_withoutIndex);

var _wrapAsync = require('./internal/wrapAsync');

var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

var _awaitify = require('./internal/awaitify');

var _awaitify2 = _interopRequireDefault(_awaitify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The same as [`each`]{@link module:Collections.each} but runs a maximum of `limit` async operations at a time.
 *
 * @name eachLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.each]{@link module:Collections.each}
 * @alias forEachLimit
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The array index is not passed to the iteratee.
 * If you need the index, use `eachOfLimit`.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @returns {Promise} a promise, if a callback is omitted
 */
function eachLimit(coll, limit, iteratee, callback) {
  return (0, _eachOfLimit2.default)(limit)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);
}
exports.default = (0, _awaitify2.default)(eachLimit, 4);
module.exports = exports['default'];
},{"./internal/awaitify":71,"./internal/eachOfLimit":73,"./internal/withoutIndex":84,"./internal/wrapAsync":85}],67:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _isArrayLike = require('./internal/isArrayLike');

var _isArrayLike2 = _interopRequireDefault(_isArrayLike);

var _breakLoop = require('./internal/breakLoop');

var _breakLoop2 = _interopRequireDefault(_breakLoop);

var _eachOfLimit = require('./eachOfLimit');

var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);

var _once = require('./internal/once');

var _once2 = _interopRequireDefault(_once);

var _onlyOnce = require('./internal/onlyOnce');

var _onlyOnce2 = _interopRequireDefault(_onlyOnce);

var _wrapAsync = require('./internal/wrapAsync');

var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

var _awaitify = require('./internal/awaitify');

var _awaitify2 = _interopRequireDefault(_awaitify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eachOf implementation optimized for array-likes
function eachOfArrayLike(coll, iteratee, callback) {
    callback = (0, _once2.default)(callback);
    var index = 0,
        completed = 0,
        { length } = coll,
        canceled = false;
    if (length === 0) {
        callback(null);
    }

    function iteratorCallback(err, value) {
        if (err === false) {
            canceled = true;
        }
        if (canceled === true) return;
        if (err) {
            callback(err);
        } else if (++completed === length || value === _breakLoop2.default) {
            callback(null);
        }
    }

    for (; index < length; index++) {
        iteratee(coll[index], index, (0, _onlyOnce2.default)(iteratorCallback));
    }
}

// a generic version of eachOf which can handle array, object, and iterator cases.
function eachOfGeneric(coll, iteratee, callback) {
    return (0, _eachOfLimit2.default)(coll, Infinity, iteratee, callback);
}

/**
 * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument
 * to the iteratee.
 *
 * @name eachOf
 * @static
 * @memberOf module:Collections
 * @method
 * @alias forEachOf
 * @category Collection
 * @see [async.each]{@link module:Collections.each}
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A function to apply to each
 * item in `coll`.
 * The `key` is the item's key, or index in the case of an array.
 * Invoked with (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @returns {Promise} a promise, if a callback is omitted
 * @example
 *
 * var obj = {dev: "/dev.json", test: "/test.json", prod: "/prod.json"};
 * var configs = {};
 *
 * async.forEachOf(obj, function (value, key, callback) {
 *     fs.readFile(__dirname + value, "utf8", function (err, data) {
 *         if (err) return callback(err);
 *         try {
 *             configs[key] = JSON.parse(data);
 *         } catch (e) {
 *             return callback(e);
 *         }
 *         callback();
 *     });
 * }, function (err) {
 *     if (err) console.error(err.message);
 *     // configs is now a map of JSON data
 *     doSomethingWith(configs);
 * });
 */
function eachOf(coll, iteratee, callback) {
    var eachOfImplementation = (0, _isArrayLike2.default)(coll) ? eachOfArrayLike : eachOfGeneric;
    return eachOfImplementation(coll, (0, _wrapAsync2.default)(iteratee), callback);
}

exports.default = (0, _awaitify2.default)(eachOf, 3);
module.exports = exports['default'];
},{"./eachOfLimit":68,"./internal/awaitify":71,"./internal/breakLoop":72,"./internal/isArrayLike":76,"./internal/once":79,"./internal/onlyOnce":80,"./internal/wrapAsync":85}],68:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _eachOfLimit2 = require('./internal/eachOfLimit');

var _eachOfLimit3 = _interopRequireDefault(_eachOfLimit2);

var _wrapAsync = require('./internal/wrapAsync');

var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

var _awaitify = require('./internal/awaitify');

var _awaitify2 = _interopRequireDefault(_awaitify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name eachOfLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.eachOf]{@link module:Collections.eachOf}
 * @alias forEachOfLimit
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async function to apply to each
 * item in `coll`. The `key` is the item's key, or index in the case of an
 * array.
 * Invoked with (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @returns {Promise} a promise, if a callback is omitted
 */
function eachOfLimit(coll, limit, iteratee, callback) {
  return (0, _eachOfLimit3.default)(limit)(coll, (0, _wrapAsync2.default)(iteratee), callback);
}

exports.default = (0, _awaitify2.default)(eachOfLimit, 4);
module.exports = exports['default'];
},{"./internal/awaitify":71,"./internal/eachOfLimit":73,"./internal/wrapAsync":85}],69:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _eachLimit = require('./eachLimit');

var _eachLimit2 = _interopRequireDefault(_eachLimit);

var _awaitify = require('./internal/awaitify');

var _awaitify2 = _interopRequireDefault(_awaitify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The same as [`each`]{@link module:Collections.each} but runs only a single async operation at a time.
 *
 * Note, that unlike [`each`]{@link module:Collections.each}, this function applies iteratee to each item
 * in series and therefore the iteratee functions will complete in order.

 * @name eachSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.each]{@link module:Collections.each}
 * @alias forEachSeries
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each
 * item in `coll`.
 * The array index is not passed to the iteratee.
 * If you need the index, use `eachOfSeries`.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @returns {Promise} a promise, if a callback is omitted
 */
function eachSeries(coll, iteratee, callback) {
  return (0, _eachLimit2.default)(coll, 1, iteratee, callback);
}
exports.default = (0, _awaitify2.default)(eachSeries, 3);
module.exports = exports['default'];
},{"./eachLimit":66,"./internal/awaitify":71}],70:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = asyncEachOfLimit;

var _breakLoop = require('./breakLoop');

var _breakLoop2 = _interopRequireDefault(_breakLoop);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// for async generators
function asyncEachOfLimit(generator, limit, iteratee, callback) {
    let done = false;
    let canceled = false;
    let awaiting = false;
    let running = 0;
    let idx = 0;

    function replenish() {
        //console.log('replenish')
        if (running >= limit || awaiting || done) return;
        //console.log('replenish awaiting')
        awaiting = true;
        generator.next().then(({ value, done: iterDone }) => {
            //console.log('got value', value)
            if (canceled || done) return;
            awaiting = false;
            if (iterDone) {
                done = true;
                if (running <= 0) {
                    //console.log('done nextCb')
                    callback(null);
                }
                return;
            }
            running++;
            iteratee(value, idx, iterateeCallback);
            idx++;
            replenish();
        }).catch(handleError);
    }

    function iterateeCallback(err, result) {
        //console.log('iterateeCallback')
        running -= 1;
        if (canceled) return;
        if (err) return handleError(err);

        if (err === false) {
            done = true;
            canceled = true;
            return;
        }

        if (result === _breakLoop2.default || done && running <= 0) {
            done = true;
            //console.log('done iterCb')
            return callback(null);
        }
        replenish();
    }

    function handleError(err) {
        if (canceled) return;
        awaiting = false;
        done = true;
        callback(err);
    }

    replenish();
}
module.exports = exports['default'];
},{"./breakLoop":72}],71:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = awaitify;
// conditionally promisify a function.
// only return a promise if a callback is omitted
function awaitify(asyncFn, arity = asyncFn.length) {
    if (!arity) throw new Error('arity is undefined');
    function awaitable(...args) {
        if (typeof args[arity - 1] === 'function') {
            return asyncFn.apply(this, args);
        }

        return new Promise((resolve, reject) => {
            args[arity - 1] = (err, ...cbArgs) => {
                if (err) return reject(err);
                resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
            };
            asyncFn.apply(this, args);
        });
    }

    Object.defineProperty(awaitable, 'name', {
        value: `awaitable(${asyncFn.name})`
    });

    return awaitable;
}
module.exports = exports['default'];
},{}],72:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
// A temporary value used to identify if the loop should be broken.
// See #1064, #1293
const breakLoop = {};
exports.default = breakLoop;
module.exports = exports["default"];
},{}],73:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _once = require('./once');

var _once2 = _interopRequireDefault(_once);

var _iterator = require('./iterator');

var _iterator2 = _interopRequireDefault(_iterator);

var _onlyOnce = require('./onlyOnce');

var _onlyOnce2 = _interopRequireDefault(_onlyOnce);

var _wrapAsync = require('./wrapAsync');

var _asyncEachOfLimit = require('./asyncEachOfLimit');

var _asyncEachOfLimit2 = _interopRequireDefault(_asyncEachOfLimit);

var _breakLoop = require('./breakLoop');

var _breakLoop2 = _interopRequireDefault(_breakLoop);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = limit => {
    return (obj, iteratee, callback) => {
        callback = (0, _once2.default)(callback);
        if (limit <= 0) {
            throw new RangeError('concurrency limit cannot be less than 1');
        }
        if (!obj) {
            return callback(null);
        }
        if ((0, _wrapAsync.isAsyncGenerator)(obj)) {
            return (0, _asyncEachOfLimit2.default)(obj, limit, iteratee, callback);
        }
        if ((0, _wrapAsync.isAsyncIterable)(obj)) {
            return (0, _asyncEachOfLimit2.default)(obj[Symbol.asyncIterator](), limit, iteratee, callback);
        }
        var nextElem = (0, _iterator2.default)(obj);
        var done = false;
        var canceled = false;
        var running = 0;
        var looping = false;

        function iterateeCallback(err, value) {
            if (canceled) return;
            running -= 1;
            if (err) {
                done = true;
                callback(err);
            } else if (err === false) {
                done = true;
                canceled = true;
            } else if (value === _breakLoop2.default || done && running <= 0) {
                done = true;
                return callback(null);
            } else if (!looping) {
                replenish();
            }
        }

        function replenish() {
            looping = true;
            while (running < limit && !done) {
                var elem = nextElem();
                if (elem === null) {
                    done = true;
                    if (running <= 0) {
                        callback(null);
                    }
                    return;
                }
                running += 1;
                iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));
            }
            looping = false;
        }

        replenish();
    };
};

module.exports = exports['default'];
},{"./asyncEachOfLimit":70,"./breakLoop":72,"./iterator":77,"./once":79,"./onlyOnce":80,"./wrapAsync":85}],74:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = function (coll) {
    return coll[Symbol.iterator] && coll[Symbol.iterator]();
};

module.exports = exports["default"];
},{}],75:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = function (fn) {
    return function (...args /*, callback*/) {
        var callback = args.pop();
        return fn.call(this, args, callback);
    };
};

module.exports = exports["default"];
},{}],76:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isArrayLike;
function isArrayLike(value) {
    return value && typeof value.length === 'number' && value.length >= 0 && value.length % 1 === 0;
}
module.exports = exports['default'];
},{}],77:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = createIterator;

var _isArrayLike = require('./isArrayLike');

var _isArrayLike2 = _interopRequireDefault(_isArrayLike);

var _getIterator = require('./getIterator');

var _getIterator2 = _interopRequireDefault(_getIterator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createArrayIterator(coll) {
    var i = -1;
    var len = coll.length;
    return function next() {
        return ++i < len ? { value: coll[i], key: i } : null;
    };
}

function createES2015Iterator(iterator) {
    var i = -1;
    return function next() {
        var item = iterator.next();
        if (item.done) return null;
        i++;
        return { value: item.value, key: i };
    };
}

function createObjectIterator(obj) {
    var okeys = obj ? Object.keys(obj) : [];
    var i = -1;
    var len = okeys.length;
    return function next() {
        var key = okeys[++i];
        return i < len ? { value: obj[key], key } : null;
    };
}

function createIterator(coll) {
    if ((0, _isArrayLike2.default)(coll)) {
        return createArrayIterator(coll);
    }

    var iterator = (0, _getIterator2.default)(coll);
    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
}
module.exports = exports['default'];
},{"./getIterator":74,"./isArrayLike":76}],78:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = _asyncMap;

var _wrapAsync = require('./wrapAsync');

var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncMap(eachfn, arr, iteratee, callback) {
    arr = arr || [];
    var results = [];
    var counter = 0;
    var _iteratee = (0, _wrapAsync2.default)(iteratee);

    return eachfn(arr, (value, _, iterCb) => {
        var index = counter++;
        _iteratee(value, (err, v) => {
            results[index] = v;
            iterCb(err);
        });
    }, err => {
        callback(err, results);
    });
}
module.exports = exports['default'];
},{"./wrapAsync":85}],79:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = once;
function once(fn) {
    function wrapper(...args) {
        if (fn === null) return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
    }
    Object.assign(wrapper, fn);
    return wrapper;
}
module.exports = exports["default"];
},{}],80:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = onlyOnce;
function onlyOnce(fn) {
    return function (...args) {
        if (fn === null) throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
    };
}
module.exports = exports["default"];
},{}],81:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _isArrayLike = require('./isArrayLike');

var _isArrayLike2 = _interopRequireDefault(_isArrayLike);

var _wrapAsync = require('./wrapAsync');

var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

var _awaitify = require('./awaitify');

var _awaitify2 = _interopRequireDefault(_awaitify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = (0, _awaitify2.default)((eachfn, tasks, callback) => {
    var results = (0, _isArrayLike2.default)(tasks) ? [] : {};

    eachfn(tasks, (task, key, taskCb) => {
        (0, _wrapAsync2.default)(task)((err, ...result) => {
            if (result.length < 2) {
                [result] = result;
            }
            results[key] = result;
            taskCb(err);
        });
    }, err => callback(err, results));
}, 3);
module.exports = exports['default'];
},{"./awaitify":71,"./isArrayLike":76,"./wrapAsync":85}],82:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
const PROMISE_SYMBOL = Symbol('promiseCallback');

function promiseCallback() {
    let resolve, reject;
    function callback(err, ...args) {
        if (err) return reject(err);
        resolve(args.length > 1 ? args : args[0]);
    }

    callback[PROMISE_SYMBOL] = new Promise((res, rej) => {
        resolve = res, reject = rej;
    });

    return callback;
}

exports.promiseCallback = promiseCallback;
exports.PROMISE_SYMBOL = PROMISE_SYMBOL;
},{}],83:[function(require,module,exports){
(function (process,setImmediate){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fallback = fallback;
exports.wrap = wrap;
var hasSetImmediate = exports.hasSetImmediate = typeof setImmediate === 'function' && setImmediate;
var hasNextTick = exports.hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';

function fallback(fn) {
    setTimeout(fn, 0);
}

function wrap(defer) {
    return (fn, ...args) => defer(() => fn(...args));
}

var _defer;

if (hasSetImmediate) {
    _defer = setImmediate;
} else if (hasNextTick) {
    _defer = process.nextTick;
} else {
    _defer = fallback;
}

exports.default = wrap(_defer);
}).call(this,require('_process'),require("timers").setImmediate)

},{"_process":153,"timers":158}],84:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = _withoutIndex;
function _withoutIndex(iteratee) {
    return (value, index, callback) => iteratee(value, callback);
}
module.exports = exports["default"];
},{}],85:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isAsyncIterable = exports.isAsyncGenerator = exports.isAsync = undefined;

var _asyncify = require('../asyncify');

var _asyncify2 = _interopRequireDefault(_asyncify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isAsync(fn) {
    return fn[Symbol.toStringTag] === 'AsyncFunction';
}

function isAsyncGenerator(fn) {
    return fn[Symbol.toStringTag] === 'AsyncGenerator';
}

function isAsyncIterable(obj) {
    return typeof obj[Symbol.asyncIterator] === 'function';
}

function wrapAsync(asyncFn) {
    if (typeof asyncFn !== 'function') throw new Error('expected a function');
    return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;
}

exports.default = wrapAsync;
exports.isAsync = isAsync;
exports.isAsyncGenerator = isAsyncGenerator;
exports.isAsyncIterable = isAsyncIterable;
},{"../asyncify":65}],86:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _map2 = require('./internal/map');

var _map3 = _interopRequireDefault(_map2);

var _eachOf = require('./eachOf');

var _eachOf2 = _interopRequireDefault(_eachOf);

var _awaitify = require('./internal/awaitify');

var _awaitify2 = _interopRequireDefault(_awaitify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Produces a new collection of values by mapping each value in `coll` through
 * the `iteratee` function. The `iteratee` is called with an item from `coll`
 * and a callback for when it has finished processing. Each of these callback
 * takes 2 arguments: an `error`, and the transformed item from `coll`. If
 * `iteratee` passes an error to its callback, the main `callback` (for the
 * `map` function) is immediately called with the error.
 *
 * Note, that since this function applies the `iteratee` to each item in
 * parallel, there is no guarantee that the `iteratee` functions will complete
 * in order. However, the results array will be in the same order as the
 * original `coll`.
 *
 * If `map` is passed an Object, the results will be an Array.  The results
 * will roughly be in the order of the original Objects' keys (but this can
 * vary across JavaScript engines).
 *
 * @name map
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with the transformed item.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Results is an Array of the
 * transformed items from the `coll`. Invoked with (err, results).
 * @returns {Promise} a promise, if no callback is passed
 * @example
 *
 * async.map(['file1','file2','file3'], fs.stat, function(err, results) {
 *     // results is now an array of stats for each file
 * });
 */
function map(coll, iteratee, callback) {
  return (0, _map3.default)(_eachOf2.default, coll, iteratee, callback);
}
exports.default = (0, _awaitify2.default)(map, 3);
module.exports = exports['default'];
},{"./eachOf":67,"./internal/awaitify":71,"./internal/map":78}],87:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parallel;

var _eachOf = require('./eachOf');

var _eachOf2 = _interopRequireDefault(_eachOf);

var _parallel2 = require('./internal/parallel');

var _parallel3 = _interopRequireDefault(_parallel2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Run the `tasks` collection of functions in parallel, without waiting until
 * the previous function has completed. If any of the functions pass an error to
 * its callback, the main `callback` is immediately called with the value of the
 * error. Once the `tasks` have completed, the results are passed to the final
 * `callback` as an array.
 *
 * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about
 * parallel execution of code.  If your tasks do not use any timers or perform
 * any I/O, they will actually be executed in series.  Any synchronous setup
 * sections for each task will happen one after the other.  JavaScript remains
 * single-threaded.
 *
 * **Hint:** Use [`reflect`]{@link module:Utils.reflect} to continue the
 * execution of other tasks when a task fails.
 *
 * It is also possible to use an object instead of an array. Each property will
 * be run as a function and the results will be passed to the final `callback`
 * as an object instead of an array. This can be a more readable way of handling
 * results from {@link async.parallel}.
 *
 * @name parallel
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection of
 * [async functions]{@link AsyncFunction} to run.
 * Each async function can complete with any number of optional `result` values.
 * @param {Function} [callback] - An optional callback to run once all the
 * functions have completed successfully. This function gets a results array
 * (or object) containing all the result arguments passed to the task callbacks.
 * Invoked with (err, results).
 * @returns {Promise} a promise, if a callback is not passed
 *
 * @example
 * async.parallel([
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'one');
 *         }, 200);
 *     },
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'two');
 *         }, 100);
 *     }
 * ],
 * // optional callback
 * function(err, results) {
 *     // the results array will equal ['one','two'] even though
 *     // the second function had a shorter timeout.
 * });
 *
 * // an example using an object instead of an array
 * async.parallel({
 *     one: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 1);
 *         }, 200);
 *     },
 *     two: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 2);
 *         }, 100);
 *     }
 * }, function(err, results) {
 *     // results is now equals to: {one: 1, two: 2}
 * });
 */
function parallel(tasks, callback) {
  return (0, _parallel3.default)(_eachOf2.default, tasks, callback);
}
module.exports = exports['default'];
},{"./eachOf":67,"./internal/parallel":81}],88:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = retry;

var _wrapAsync = require('./internal/wrapAsync');

var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

var _promiseCallback = require('./internal/promiseCallback');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function constant(value) {
    return function () {
        return value;
    };
}

/**
 * Attempts to get a successful response from `task` no more than `times` times
 * before returning an error. If the task is successful, the `callback` will be
 * passed the result of the successful task. If all attempts fail, the callback
 * will be passed the error and result (if any) of the final attempt.
 *
 * @name retry
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @see [async.retryable]{@link module:ControlFlow.retryable}
 * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an
 * object with `times` and `interval` or a number.
 * * `times` - The number of attempts to make before giving up.  The default
 *   is `5`.
 * * `interval` - The time to wait between retries, in milliseconds.  The
 *   default is `0`. The interval may also be specified as a function of the
 *   retry count (see example).
 * * `errorFilter` - An optional synchronous function that is invoked on
 *   erroneous result. If it returns `true` the retry attempts will continue;
 *   if the function returns `false` the retry flow is aborted with the current
 *   attempt's error and result being returned to the final callback.
 *   Invoked with (err).
 * * If `opts` is a number, the number specifies the number of times to retry,
 *   with the default interval of `0`.
 * @param {AsyncFunction} task - An async function to retry.
 * Invoked with (callback).
 * @param {Function} [callback] - An optional callback which is called when the
 * task has succeeded, or after the final failed attempt. It receives the `err`
 * and `result` arguments of the last attempt at completing the `task`. Invoked
 * with (err, results).
 * @returns {Promise} a promise if no callback provided
 *
 * @example
 *
 * // The `retry` function can be used as a stand-alone control flow by passing
 * // a callback, as shown below:
 *
 * // try calling apiMethod 3 times
 * async.retry(3, apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // try calling apiMethod 3 times, waiting 200 ms between each retry
 * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // try calling apiMethod 10 times with exponential backoff
 * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)
 * async.retry({
 *   times: 10,
 *   interval: function(retryCount) {
 *     return 50 * Math.pow(2, retryCount);
 *   }
 * }, apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // try calling apiMethod the default 5 times no delay between each retry
 * async.retry(apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // try calling apiMethod only when error condition satisfies, all other
 * // errors will abort the retry control flow and return to final callback
 * async.retry({
 *   errorFilter: function(err) {
 *     return err.message === 'Temporary error'; // only retry on a specific error
 *   }
 * }, apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // to retry individual methods that are not as reliable within other
 * // control flow functions, use the `retryable` wrapper:
 * async.auto({
 *     users: api.getUsers.bind(api),
 *     payments: async.retryable(3, api.getPayments.bind(api))
 * }, function(err, results) {
 *     // do something with the results
 * });
 *
 */
const DEFAULT_TIMES = 5;
const DEFAULT_INTERVAL = 0;

function retry(opts, task, callback) {
    var options = {
        times: DEFAULT_TIMES,
        intervalFunc: constant(DEFAULT_INTERVAL)
    };

    if (arguments.length < 3 && typeof opts === 'function') {
        callback = task || (0, _promiseCallback.promiseCallback)();
        task = opts;
    } else {
        parseTimes(options, opts);
        callback = callback || (0, _promiseCallback.promiseCallback)();
    }

    if (typeof task !== 'function') {
        throw new Error("Invalid arguments for async.retry");
    }

    var _task = (0, _wrapAsync2.default)(task);

    var attempt = 1;
    function retryAttempt() {
        _task((err, ...args) => {
            if (err === false) return;
            if (err && attempt++ < options.times && (typeof options.errorFilter != 'function' || options.errorFilter(err))) {
                setTimeout(retryAttempt, options.intervalFunc(attempt - 1));
            } else {
                callback(err, ...args);
            }
        });
    }

    retryAttempt();
    return callback[_promiseCallback.PROMISE_SYMBOL];
}

function parseTimes(acc, t) {
    if (typeof t === 'object') {
        acc.times = +t.times || DEFAULT_TIMES;

        acc.intervalFunc = typeof t.interval === 'function' ? t.interval : constant(+t.interval || DEFAULT_INTERVAL);

        acc.errorFilter = t.errorFilter;
    } else if (typeof t === 'number' || typeof t === 'string') {
        acc.times = +t || DEFAULT_TIMES;
    } else {
        throw new Error("Invalid arguments for async.retry");
    }
}
module.exports = exports['default'];
},{"./internal/promiseCallback":82,"./internal/wrapAsync":85}],89:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _once = require('./internal/once');

var _once2 = _interopRequireDefault(_once);

var _onlyOnce = require('./internal/onlyOnce');

var _onlyOnce2 = _interopRequireDefault(_onlyOnce);

var _wrapAsync = require('./internal/wrapAsync');

var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

var _awaitify = require('./internal/awaitify');

var _awaitify2 = _interopRequireDefault(_awaitify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Runs the `tasks` array of functions in series, each passing their results to
 * the next in the array. However, if any of the `tasks` pass an error to their
 * own callback, the next function is not executed, and the main `callback` is
 * immediately called with the error.
 *
 * @name waterfall
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}
 * to run.
 * Each function should complete with any number of `result` values.
 * The `result` values will be passed as arguments, in order, to the next task.
 * @param {Function} [callback] - An optional callback to run once all the
 * functions have completed. This will be passed the results of the last task's
 * callback. Invoked with (err, [results]).
 * @returns undefined
 * @example
 *
 * async.waterfall([
 *     function(callback) {
 *         callback(null, 'one', 'two');
 *     },
 *     function(arg1, arg2, callback) {
 *         // arg1 now equals 'one' and arg2 now equals 'two'
 *         callback(null, 'three');
 *     },
 *     function(arg1, callback) {
 *         // arg1 now equals 'three'
 *         callback(null, 'done');
 *     }
 * ], function (err, result) {
 *     // result now equals 'done'
 * });
 *
 * // Or, with named functions:
 * async.waterfall([
 *     myFirstFunction,
 *     mySecondFunction,
 *     myLastFunction,
 * ], function (err, result) {
 *     // result now equals 'done'
 * });
 * function myFirstFunction(callback) {
 *     callback(null, 'one', 'two');
 * }
 * function mySecondFunction(arg1, arg2, callback) {
 *     // arg1 now equals 'one' and arg2 now equals 'two'
 *     callback(null, 'three');
 * }
 * function myLastFunction(arg1, callback) {
 *     // arg1 now equals 'three'
 *     callback(null, 'done');
 * }
 */
function waterfall(tasks, callback) {
    callback = (0, _once2.default)(callback);
    if (!Array.isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));
    if (!tasks.length) return callback();
    var taskIndex = 0;

    function nextTask(args) {
        var task = (0, _wrapAsync2.default)(tasks[taskIndex++]);
        task(...args, (0, _onlyOnce2.default)(next));
    }

    function next(err, ...args) {
        if (err === false) return;
        if (err || taskIndex === tasks.length) {
            return callback(err, ...args);
        }
        nextTask(args);
    }

    nextTask([]);
}

exports.default = (0, _awaitify2.default)(waterfall);
module.exports = exports['default'];
},{"./internal/awaitify":71,"./internal/once":79,"./internal/onlyOnce":80,"./internal/wrapAsync":85}],90:[function(require,module,exports){
"use strict";
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var crypto_utils_1 = require("./crypto_utils");
var logger_1 = require("./logger");
/**
 * Generates a cryptographically random new state. Useful for CSRF protection.
 */
var SIZE = 10; // 10 bytes
var newState = function (crypto) {
    return crypto.generateRandom(SIZE);
};
/**
 * Represents the AuthorizationRequest.
 * For more information look at
 * https://tools.ietf.org/html/rfc6749#section-4.1.1
 */
var AuthorizationRequest = /** @class */ (function () {
    /**
     * Constructs a new AuthorizationRequest.
     * Use a `undefined` value for the `state` parameter, to generate a random
     * state for CSRF protection.
     */
    function AuthorizationRequest(request, crypto, usePkce) {
        if (crypto === void 0) { crypto = new crypto_utils_1.DefaultCrypto(); }
        if (usePkce === void 0) { usePkce = true; }
        this.crypto = crypto;
        this.usePkce = usePkce;
        this.clientId = request.client_id;
        this.redirectUri = request.redirect_uri;
        this.scope = request.scope;
        this.responseType = request.response_type || AuthorizationRequest.RESPONSE_TYPE_CODE;
        this.state = request.state || newState(crypto);
        this.extras = request.extras;
        // read internal properties if available
        this.internal = request.internal;
    }
    AuthorizationRequest.prototype.setupCodeVerifier = function () {
        var _this = this;
        if (!this.usePkce) {
            return Promise.resolve();
        }
        else {
            var codeVerifier_1 = this.crypto.generateRandom(128);
            var challenge = this.crypto.deriveChallenge(codeVerifier_1).catch(function (error) {
                logger_1.log('Unable to generate PKCE challenge. Not using PKCE', error);
                return undefined;
            });
            return challenge.then(function (result) {
                if (result) {
                    // keep track of the code used.
                    _this.internal = _this.internal || {};
                    _this.internal['code_verifier'] = codeVerifier_1;
                    _this.extras = _this.extras || {};
                    _this.extras['code_challenge'] = result;
                    // We always use S256. Plain is not good enough.
                    _this.extras['code_challenge_method'] = 'S256';
                }
            });
        }
    };
    /**
     * Serializes the AuthorizationRequest to a JavaScript Object.
     */
    AuthorizationRequest.prototype.toJson = function () {
        var _this = this;
        // Always make sure that the code verifier is setup when toJson() is called.
        return this.setupCodeVerifier().then(function () {
            return {
                response_type: _this.responseType,
                client_id: _this.clientId,
                redirect_uri: _this.redirectUri,
                scope: _this.scope,
                state: _this.state,
                extras: _this.extras,
                internal: _this.internal
            };
        });
    };
    AuthorizationRequest.RESPONSE_TYPE_TOKEN = 'token';
    AuthorizationRequest.RESPONSE_TYPE_CODE = 'code';
    return AuthorizationRequest;
}());
exports.AuthorizationRequest = AuthorizationRequest;

},{"./crypto_utils":94,"./logger":98}],91:[function(require,module,exports){
"use strict";
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var logger_1 = require("./logger");
/**
 * Authorization Service notifier.
 * This manages the communication of the AuthorizationResponse to the 3p client.
 */
var AuthorizationNotifier = /** @class */ (function () {
    function AuthorizationNotifier() {
        this.listener = null;
    }
    AuthorizationNotifier.prototype.setAuthorizationListener = function (listener) {
        this.listener = listener;
    };
    /**
     * The authorization complete callback.
     */
    AuthorizationNotifier.prototype.onAuthorizationComplete = function (request, response, error) {
        if (this.listener) {
            // complete authorization request
            this.listener(request, response, error);
        }
    };
    return AuthorizationNotifier;
}());
exports.AuthorizationNotifier = AuthorizationNotifier;
// TODO(rahulrav@): add more built in parameters.
/* built in parameters. */
exports.BUILT_IN_PARAMETERS = ['redirect_uri', 'client_id', 'response_type', 'state', 'scope'];
/**
 * Defines the interface which is capable of handling an authorization request
 * using various methods (iframe / popup / different process etc.).
 */
var AuthorizationRequestHandler = /** @class */ (function () {
    function AuthorizationRequestHandler(utils, crypto) {
        this.utils = utils;
        this.crypto = crypto;
        // notifier send the response back to the client.
        this.notifier = null;
    }
    /**
     * A utility method to be able to build the authorization request URL.
     */
    AuthorizationRequestHandler.prototype.buildRequestUrl = function (configuration, request) {
        // build the query string
        // coerce to any type for convenience
        var requestMap = {
            'redirect_uri': request.redirectUri,
            'client_id': request.clientId,
            'response_type': request.responseType,
            'state': request.state,
            'scope': request.scope
        };
        // copy over extras
        if (request.extras) {
            for (var extra in request.extras) {
                if (request.extras.hasOwnProperty(extra)) {
                    // check before inserting to requestMap
                    if (exports.BUILT_IN_PARAMETERS.indexOf(extra) < 0) {
                        requestMap[extra] = request.extras[extra];
                    }
                }
            }
        }
        var query = this.utils.stringify(requestMap);
        var baseUrl = configuration.authorizationEndpoint;
        var url = baseUrl + "?" + query;
        return url;
    };
    /**
     * Completes the authorization request if necessary & when possible.
     */
    AuthorizationRequestHandler.prototype.completeAuthorizationRequestIfPossible = function () {
        var _this = this;
        // call complete authorization if possible to see there might
        // be a response that needs to be delivered.
        logger_1.log("Checking to see if there is an authorization response to be delivered.");
        if (!this.notifier) {
            logger_1.log("Notifier is not present on AuthorizationRequest handler.\n          No delivery of result will be possible");
        }
        return this.completeAuthorizationRequest().then(function (result) {
            if (!result) {
                logger_1.log("No result is available yet.");
            }
            if (result && _this.notifier) {
                _this.notifier.onAuthorizationComplete(result.request, result.response, result.error);
            }
        });
    };
    /**
     * Sets the default Authorization Service notifier.
     */
    AuthorizationRequestHandler.prototype.setAuthorizationNotifier = function (notifier) {
        this.notifier = notifier;
        return this;
    };
    ;
    return AuthorizationRequestHandler;
}());
exports.AuthorizationRequestHandler = AuthorizationRequestHandler;

},{"./logger":98}],92:[function(require,module,exports){
"use strict";
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Represents the Authorization Response type.
 * For more information look at
 * https://tools.ietf.org/html/rfc6749#section-4.1.2
 */
var AuthorizationResponse = /** @class */ (function () {
    function AuthorizationResponse(response) {
        this.code = response.code;
        this.state = response.state;
    }
    AuthorizationResponse.prototype.toJson = function () {
        return { code: this.code, state: this.state };
    };
    return AuthorizationResponse;
}());
exports.AuthorizationResponse = AuthorizationResponse;
/**
 * Represents the Authorization error response.
 * For more information look at:
 * https://tools.ietf.org/html/rfc6749#section-4.1.2.1
 */
var AuthorizationError = /** @class */ (function () {
    function AuthorizationError(error) {
        this.error = error.error;
        this.errorDescription = error.error_description;
        this.errorUri = error.error_uri;
        this.state = error.state;
    }
    AuthorizationError.prototype.toJson = function () {
        return {
            error: this.error,
            error_description: this.errorDescription,
            error_uri: this.errorUri,
            state: this.state
        };
    };
    return AuthorizationError;
}());
exports.AuthorizationError = AuthorizationError;

},{}],93:[function(require,module,exports){
"use strict";
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var xhr_1 = require("./xhr");
/**
 * The standard base path for well-known resources on domains.
 * See https://tools.ietf.org/html/rfc5785 for more information.
 */
var WELL_KNOWN_PATH = '.well-known';
/**
 * The standard resource under the well known path at which an OpenID Connect
 * discovery document can be found under an issuer's base URI.
 */
var OPENID_CONFIGURATION = 'openid-configuration';
/**
 * Configuration details required to interact with an authorization service.
 *
 * More information at https://openid.net/specs/openid-connect-discovery-1_0-17.html
 */
var AuthorizationServiceConfiguration = /** @class */ (function () {
    function AuthorizationServiceConfiguration(request) {
        this.authorizationEndpoint = request.authorization_endpoint;
        this.tokenEndpoint = request.token_endpoint;
        this.revocationEndpoint = request.revocation_endpoint;
        this.userInfoEndpoint = request.userinfo_endpoint;
        this.endSessionEndpoint = request.end_session_endpoint;
    }
    AuthorizationServiceConfiguration.prototype.toJson = function () {
        return {
            authorization_endpoint: this.authorizationEndpoint,
            token_endpoint: this.tokenEndpoint,
            revocation_endpoint: this.revocationEndpoint,
            end_session_endpoint: this.endSessionEndpoint,
            userinfo_endpoint: this.userInfoEndpoint
        };
    };
    AuthorizationServiceConfiguration.fetchFromIssuer = function (openIdIssuerUrl, requestor) {
        var fullUrl = openIdIssuerUrl + "/" + WELL_KNOWN_PATH + "/" + OPENID_CONFIGURATION;
        var requestorToUse = requestor || new xhr_1.JQueryRequestor();
        return requestorToUse
            .xhr({ url: fullUrl, dataType: 'json', method: 'GET' })
            .then(function (json) { return new AuthorizationServiceConfiguration(json); });
    };
    return AuthorizationServiceConfiguration;
}());
exports.AuthorizationServiceConfiguration = AuthorizationServiceConfiguration;

},{"./xhr":106}],94:[function(require,module,exports){
"use strict";
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var base64 = require("base64-js");
var errors_1 = require("./errors");
var HAS_CRYPTO = typeof window !== 'undefined' && !!window.crypto;
var HAS_SUBTLE_CRYPTO = HAS_CRYPTO && !!window.crypto.subtle;
var CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
function bufferToString(buffer) {
    var state = [];
    for (var i = 0; i < buffer.byteLength; i += 1) {
        var index = buffer[i] % CHARSET.length;
        state.push(CHARSET[index]);
    }
    return state.join('');
}
exports.bufferToString = bufferToString;
function urlSafe(buffer) {
    var encoded = base64.fromByteArray(new Uint8Array(buffer));
    return encoded.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
}
exports.urlSafe = urlSafe;
// adapted from source: http://stackoverflow.com/a/11058858
// this is used in place of TextEncode as the api is not yet
// well supported: https://caniuse.com/#search=TextEncoder
function textEncodeLite(str) {
    var buf = new ArrayBuffer(str.length);
    var bufView = new Uint8Array(buf);
    for (var i = 0; i < str.length; i++) {
        bufView[i] = str.charCodeAt(i);
    }
    return bufView;
}
exports.textEncodeLite = textEncodeLite;
/**
 * The default implementation of the `Crypto` interface.
 * This uses the capabilities of the browser.
 */
var DefaultCrypto = /** @class */ (function () {
    function DefaultCrypto() {
    }
    DefaultCrypto.prototype.generateRandom = function (size) {
        var buffer = new Uint8Array(size);
        if (HAS_CRYPTO) {
            window.crypto.getRandomValues(buffer);
        }
        else {
            // fall back to Math.random() if nothing else is available
            for (var i = 0; i < size; i += 1) {
                buffer[i] = (Math.random() * CHARSET.length) | 0;
            }
        }
        return bufferToString(buffer);
    };
    DefaultCrypto.prototype.deriveChallenge = function (code) {
        if (code.length < 43 || code.length > 128) {
            return Promise.reject(new errors_1.AppAuthError('Invalid code length.'));
        }
        if (!HAS_SUBTLE_CRYPTO) {
            return Promise.reject(new errors_1.AppAuthError('window.crypto.subtle is unavailable.'));
        }
        return new Promise(function (resolve, reject) {
            crypto.subtle.digest('SHA-256', textEncodeLite(code)).then(function (buffer) {
                return resolve(urlSafe(new Uint8Array(buffer)));
            }, function (error) { return reject(error); });
        });
    };
    return DefaultCrypto;
}());
exports.DefaultCrypto = DefaultCrypto;

},{"./errors":95,"base64-js":117}],95:[function(require,module,exports){
"use strict";
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Represents the AppAuthError type.
 */
var AppAuthError = /** @class */ (function () {
    function AppAuthError(message, extras) {
        this.message = message;
        this.extras = extras;
    }
    return AppAuthError;
}());
exports.AppAuthError = AppAuthError;

},{}],96:[function(require,module,exports){
"use strict";
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/* Global flags that control the behavior of App Auth JS. */
/* Logging turned on ? */
exports.IS_LOG = true;
/* Profiling turned on ? */
exports.IS_PROFILE = false;

},{}],97:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("./authorization_request"));
__export(require("./authorization_request_handler"));
__export(require("./authorization_response"));
__export(require("./authorization_service_configuration"));
__export(require("./crypto_utils"));
__export(require("./errors"));
__export(require("./flags"));
__export(require("./logger"));
__export(require("./query_string_utils"));
__export(require("./redirect_based_handler"));
__export(require("./revoke_token_request"));
__export(require("./storage"));
__export(require("./token_request"));
__export(require("./token_request_handler"));
__export(require("./token_response"));
__export(require("./xhr"));

},{"./authorization_request":90,"./authorization_request_handler":91,"./authorization_response":92,"./authorization_service_configuration":93,"./crypto_utils":94,"./errors":95,"./flags":96,"./logger":98,"./query_string_utils":99,"./redirect_based_handler":100,"./revoke_token_request":101,"./storage":102,"./token_request":103,"./token_request_handler":104,"./token_response":105,"./xhr":106}],98:[function(require,module,exports){
"use strict";
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var flags_1 = require("./flags");
function log(message) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    if (flags_1.IS_LOG) {
        var length_1 = args ? args.length : 0;
        if (length_1 > 0) {
            console.log.apply(console, __spreadArrays([message], args));
        }
        else {
            console.log(message);
        }
    }
}
exports.log = log;
;
// check to see if native support for profiling is available.
var NATIVE_PROFILE_SUPPORT = typeof window !== 'undefined' && !!window.performance && !!console.profile;
/**
 * A decorator that can profile a function.
 */
function profile(target, propertyKey, descriptor) {
    if (flags_1.IS_PROFILE) {
        return performProfile(target, propertyKey, descriptor);
    }
    else {
        // return as-is
        return descriptor;
    }
}
exports.profile = profile;
function performProfile(target, propertyKey, descriptor) {
    var originalCallable = descriptor.value;
    // name must exist
    var name = originalCallable.name;
    if (!name) {
        name = 'anonymous function';
    }
    if (NATIVE_PROFILE_SUPPORT) {
        descriptor.value = function (args) {
            console.profile(name);
            var startTime = window.performance.now();
            var result = originalCallable.call.apply(originalCallable, __spreadArrays([this || window], args));
            var duration = window.performance.now() - startTime;
            console.log(name + " took " + duration + " ms");
            console.profileEnd();
            return result;
        };
    }
    else {
        descriptor.value = function (args) {
            log("Profile start " + name);
            var start = Date.now();
            var result = originalCallable.call.apply(originalCallable, __spreadArrays([this || window], args));
            var duration = Date.now() - start;
            log("Profile end " + name + " took " + duration + " ms.");
            return result;
        };
    }
    return descriptor;
}

},{"./flags":96}],99:[function(require,module,exports){
"use strict";
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var BasicQueryStringUtils = /** @class */ (function () {
    function BasicQueryStringUtils() {
    }
    BasicQueryStringUtils.prototype.parse = function (input, useHash) {
        if (useHash) {
            return this.parseQueryString(input.hash);
        }
        else {
            return this.parseQueryString(input.search);
        }
    };
    BasicQueryStringUtils.prototype.parseQueryString = function (query) {
        var result = {};
        // if anything starts with ?, # or & remove it
        query = query.trim().replace(/^(\?|#|&)/, '');
        var params = query.split('&');
        for (var i = 0; i < params.length; i += 1) {
            var param = params[i]; // looks something like a=b
            var parts = param.split('=');
            if (parts.length >= 2) {
                var key = decodeURIComponent(parts.shift());
                var value = parts.length > 0 ? parts.join('=') : null;
                if (value) {
                    result[key] = decodeURIComponent(value);
                }
            }
        }
        return result;
    };
    BasicQueryStringUtils.prototype.stringify = function (input) {
        var encoded = [];
        for (var key in input) {
            if (input.hasOwnProperty(key) && input[key]) {
                encoded.push(encodeURIComponent(key) + "=" + encodeURIComponent(input[key]));
            }
        }
        return encoded.join('&');
    };
    return BasicQueryStringUtils;
}());
exports.BasicQueryStringUtils = BasicQueryStringUtils;

},{}],100:[function(require,module,exports){
"use strict";
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var authorization_request_1 = require("./authorization_request");
var authorization_request_handler_1 = require("./authorization_request_handler");
var authorization_response_1 = require("./authorization_response");
var crypto_utils_1 = require("./crypto_utils");
var logger_1 = require("./logger");
var query_string_utils_1 = require("./query_string_utils");
var storage_1 = require("./storage");
/** key for authorization request. */
var authorizationRequestKey = function (handle) {
    return handle + "_appauth_authorization_request";
};
/** key for authorization service configuration */
var authorizationServiceConfigurationKey = function (handle) {
    return handle + "_appauth_authorization_service_configuration";
};
/** key in local storage which represents the current authorization request. */
var AUTHORIZATION_REQUEST_HANDLE_KEY = 'appauth_current_authorization_request';
/**
 * Represents an AuthorizationRequestHandler which uses a standard
 * redirect based code flow.
 */
var RedirectRequestHandler = /** @class */ (function (_super) {
    __extends(RedirectRequestHandler, _super);
    function RedirectRequestHandler(
    // use the provided storage backend
    // or initialize local storage with the default storage backend which
    // uses window.localStorage
    storageBackend, utils, locationLike, crypto) {
        if (storageBackend === void 0) { storageBackend = new storage_1.LocalStorageBackend(); }
        if (utils === void 0) { utils = new query_string_utils_1.BasicQueryStringUtils(); }
        if (locationLike === void 0) { locationLike = window.location; }
        if (crypto === void 0) { crypto = new crypto_utils_1.DefaultCrypto(); }
        var _this = _super.call(this, utils, crypto) || this;
        _this.storageBackend = storageBackend;
        _this.locationLike = locationLike;
        return _this;
    }
    RedirectRequestHandler.prototype.performAuthorizationRequest = function (configuration, request) {
        var _this = this;
        var handle = this.crypto.generateRandom(10);
        // before you make request, persist all request related data in local storage.
        var persisted = Promise.all([
            this.storageBackend.setItem(AUTHORIZATION_REQUEST_HANDLE_KEY, handle),
            // Calling toJson() adds in the code & challenge when possible
            request.toJson().then(function (result) {
                return _this.storageBackend.setItem(authorizationRequestKey(handle), JSON.stringify(result));
            }),
            this.storageBackend.setItem(authorizationServiceConfigurationKey(handle), JSON.stringify(configuration.toJson())),
        ]);
        persisted.then(function () {
            // make the redirect request
            var url = _this.buildRequestUrl(configuration, request);
            logger_1.log('Making a request to ', request, url);
            _this.locationLike.assign(url);
        });
    };
    /**
     * Attempts to introspect the contents of storage backend and completes the
     * request.
     */
    RedirectRequestHandler.prototype.completeAuthorizationRequest = function () {
        var _this = this;
        // TODO(rahulrav@): handle authorization errors.
        return this.storageBackend.getItem(AUTHORIZATION_REQUEST_HANDLE_KEY).then(function (handle) {
            if (handle) {
                // we have a pending request.
                // fetch authorization request, and check state
                return _this.storageBackend
                    .getItem(authorizationRequestKey(handle))
                    // requires a corresponding instance of result
                    // TODO(rahulrav@): check for inconsitent state here
                    .then(function (result) { return JSON.parse(result); })
                    .then(function (json) { return new authorization_request_1.AuthorizationRequest(json); })
                    .then(function (request) {
                    // check redirect_uri and state
                    var currentUri = "" + _this.locationLike.origin + _this.locationLike.pathname;
                    var queryParams = _this.utils.parse(_this.locationLike, true /* use hash */);
                    var state = queryParams['state'];
                    var code = queryParams['code'];
                    var error = queryParams['error'];
                    logger_1.log('Potential authorization request ', currentUri, queryParams, state, code, error);
                    var shouldNotify = state === request.state;
                    var authorizationResponse = null;
                    var authorizationError = null;
                    if (shouldNotify) {
                        if (error) {
                            // get additional optional info.
                            var errorUri = queryParams['error_uri'];
                            var errorDescription = queryParams['error_description'];
                            authorizationError = new authorization_response_1.AuthorizationError({
                                error: error,
                                error_description: errorDescription,
                                error_uri: errorUri,
                                state: state
                            });
                        }
                        else {
                            authorizationResponse = new authorization_response_1.AuthorizationResponse({ code: code, state: state });
                        }
                        // cleanup state
                        return Promise
                            .all([
                            _this.storageBackend.removeItem(AUTHORIZATION_REQUEST_HANDLE_KEY),
                            _this.storageBackend.removeItem(authorizationRequestKey(handle)),
                            _this.storageBackend.removeItem(authorizationServiceConfigurationKey(handle))
                        ])
                            .then(function () {
                            logger_1.log('Delivering authorization response');
                            return {
                                request: request,
                                response: authorizationResponse,
                                error: authorizationError
                            };
                        });
                    }
                    else {
                        logger_1.log('Mismatched request (state and request_uri) dont match.');
                        return Promise.resolve(null);
                    }
                });
            }
            else {
                return null;
            }
        });
    };
    return RedirectRequestHandler;
}(authorization_request_handler_1.AuthorizationRequestHandler));
exports.RedirectRequestHandler = RedirectRequestHandler;

},{"./authorization_request":90,"./authorization_request_handler":91,"./authorization_response":92,"./crypto_utils":94,"./logger":98,"./query_string_utils":99,"./storage":102}],101:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Represents a revoke token request.
 * For more information look at:
 * https://tools.ietf.org/html/rfc7009#section-2.1
 */
var RevokeTokenRequest = /** @class */ (function () {
    function RevokeTokenRequest(request) {
        this.token = request.token;
        this.tokenTypeHint = request.token_type_hint;
        this.clientId = request.client_id;
        this.clientSecret = request.client_secret;
    }
    /**
     * Serializes a TokenRequest to a JavaScript object.
     */
    RevokeTokenRequest.prototype.toJson = function () {
        var json = { token: this.token };
        if (this.tokenTypeHint) {
            json['token_type_hint'] = this.tokenTypeHint;
        }
        if (this.clientId) {
            json['client_id'] = this.clientId;
        }
        if (this.clientSecret) {
            json['client_secret'] = this.clientSecret;
        }
        return json;
    };
    RevokeTokenRequest.prototype.toStringMap = function () {
        var json = this.toJson();
        // :(
        return json;
    };
    return RevokeTokenRequest;
}());
exports.RevokeTokenRequest = RevokeTokenRequest;

},{}],102:[function(require,module,exports){
"use strict";
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Asynchronous storage APIs. All methods return a `Promise`.
 * All methods take the `DOMString`
 * IDL type (as it is the lowest common denominator).
 */
var StorageBackend = /** @class */ (function () {
    function StorageBackend() {
    }
    return StorageBackend;
}());
exports.StorageBackend = StorageBackend;
/**
 * A `StorageBackend` backed by `localstorage`.
 */
var LocalStorageBackend = /** @class */ (function (_super) {
    __extends(LocalStorageBackend, _super);
    function LocalStorageBackend(storage) {
        var _this = _super.call(this) || this;
        _this.storage = storage || window.localStorage;
        return _this;
    }
    LocalStorageBackend.prototype.getItem = function (name) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var value = _this.storage.getItem(name);
            if (value) {
                resolve(value);
            }
            else {
                resolve(null);
            }
        });
    };
    LocalStorageBackend.prototype.removeItem = function (name) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.storage.removeItem(name);
            resolve();
        });
    };
    LocalStorageBackend.prototype.clear = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.storage.clear();
            resolve();
        });
    };
    LocalStorageBackend.prototype.setItem = function (name, value) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.storage.setItem(name, value);
            resolve();
        });
    };
    return LocalStorageBackend;
}(StorageBackend));
exports.LocalStorageBackend = LocalStorageBackend;

},{}],103:[function(require,module,exports){
"use strict";
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.GRANT_TYPE_AUTHORIZATION_CODE = 'authorization_code';
exports.GRANT_TYPE_REFRESH_TOKEN = 'refresh_token';
/**
 * Represents an Access Token request.
 * For more information look at:
 * https://tools.ietf.org/html/rfc6749#section-4.1.3
 */
var TokenRequest = /** @class */ (function () {
    function TokenRequest(request) {
        this.clientId = request.client_id;
        this.redirectUri = request.redirect_uri;
        this.grantType = request.grant_type;
        this.code = request.code;
        this.refreshToken = request.refresh_token;
        this.extras = request.extras;
    }
    /**
     * Serializes a TokenRequest to a JavaScript object.
     */
    TokenRequest.prototype.toJson = function () {
        return {
            grant_type: this.grantType,
            code: this.code,
            refresh_token: this.refreshToken,
            redirect_uri: this.redirectUri,
            client_id: this.clientId,
            extras: this.extras
        };
    };
    TokenRequest.prototype.toStringMap = function () {
        var map = {
            grant_type: this.grantType,
            client_id: this.clientId,
            redirect_uri: this.redirectUri
        };
        if (this.code) {
            map['code'] = this.code;
        }
        if (this.refreshToken) {
            map['refresh_token'] = this.refreshToken;
        }
        // copy over extras
        if (this.extras) {
            for (var extra in this.extras) {
                if (this.extras.hasOwnProperty(extra) && !map.hasOwnProperty(extra)) {
                    // check before inserting to requestMap
                    map[extra] = this.extras[extra];
                }
            }
        }
        return map;
    };
    return TokenRequest;
}());
exports.TokenRequest = TokenRequest;

},{}],104:[function(require,module,exports){
"use strict";
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var errors_1 = require("./errors");
var query_string_utils_1 = require("./query_string_utils");
var token_response_1 = require("./token_response");
var xhr_1 = require("./xhr");
/**
 * The default token request handler.
 */
var BaseTokenRequestHandler = /** @class */ (function () {
    function BaseTokenRequestHandler(requestor, utils) {
        if (requestor === void 0) { requestor = new xhr_1.JQueryRequestor(); }
        if (utils === void 0) { utils = new query_string_utils_1.BasicQueryStringUtils(); }
        this.requestor = requestor;
        this.utils = utils;
    }
    BaseTokenRequestHandler.prototype.isTokenResponse = function (response) {
        return response.error === undefined;
    };
    BaseTokenRequestHandler.prototype.performRevokeTokenRequest = function (configuration, request) {
        var revokeTokenResponse = this.requestor.xhr({
            url: configuration.revocationEndpoint,
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            data: this.utils.stringify(request.toStringMap())
        });
        return revokeTokenResponse.then(function (response) {
            return true;
        });
    };
    BaseTokenRequestHandler.prototype.performTokenRequest = function (configuration, request) {
        var _this = this;
        var tokenResponse = this.requestor.xhr({
            url: configuration.tokenEndpoint,
            method: 'POST',
            dataType: 'json',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            data: this.utils.stringify(request.toStringMap())
        });
        return tokenResponse.then(function (response) {
            if (_this.isTokenResponse(response)) {
                return new token_response_1.TokenResponse(response);
            }
            else {
                return Promise.reject(new errors_1.AppAuthError(response.error, new token_response_1.TokenError(response)));
            }
        });
    };
    return BaseTokenRequestHandler;
}());
exports.BaseTokenRequestHandler = BaseTokenRequestHandler;

},{"./errors":95,"./query_string_utils":99,"./token_response":105,"./xhr":106}],105:[function(require,module,exports){
"use strict";
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
// constants
var AUTH_EXPIRY_BUFFER = 10 * 60 * -1; // 10 mins in seconds
/**
 * Returns the instant of time in seconds.
 */
exports.nowInSeconds = function () { return Math.round(new Date().getTime() / 1000); };
/**
 * Represents the Token Response type.
 * For more information look at:
 * https://tools.ietf.org/html/rfc6749#section-5.1
 */
var TokenResponse = /** @class */ (function () {
    function TokenResponse(response) {
        this.accessToken = response.access_token;
        this.tokenType = response.token_type || 'bearer';
        this.expiresIn = response.expires_in;
        this.refreshToken = response.refresh_token;
        this.scope = response.scope;
        this.idToken = response.id_token;
        this.issuedAt = response.issued_at || exports.nowInSeconds();
    }
    TokenResponse.prototype.toJson = function () {
        return {
            access_token: this.accessToken,
            id_token: this.idToken,
            refresh_token: this.refreshToken,
            scope: this.scope,
            token_type: this.tokenType,
            issued_at: this.issuedAt,
            expires_in: this.expiresIn
        };
    };
    TokenResponse.prototype.isValid = function (buffer) {
        if (buffer === void 0) { buffer = AUTH_EXPIRY_BUFFER; }
        if (this.expiresIn) {
            var now = exports.nowInSeconds();
            return now < this.issuedAt + this.expiresIn + buffer;
        }
        else {
            return true;
        }
    };
    return TokenResponse;
}());
exports.TokenResponse = TokenResponse;
/**
 * Represents the Token Error type.
 * For more information look at:
 * https://tools.ietf.org/html/rfc6749#section-5.2
 */
var TokenError = /** @class */ (function () {
    function TokenError(tokenError) {
        this.error = tokenError.error;
        this.errorDescription = tokenError.error_description;
        this.errorUri = tokenError.error_uri;
    }
    TokenError.prototype.toJson = function () {
        return {
            error: this.error, error_description: this.errorDescription, error_uri: this.errorUri
        };
    };
    return TokenError;
}());
exports.TokenError = TokenError;

},{}],106:[function(require,module,exports){
"use strict";
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var errors_1 = require("./errors");
/**
 * An class that abstracts away the ability to make an XMLHttpRequest.
 */
var Requestor = /** @class */ (function () {
    function Requestor() {
    }
    return Requestor;
}());
exports.Requestor = Requestor;
/**
 * Uses $.ajax to makes the Ajax requests.
 */
var JQueryRequestor = /** @class */ (function (_super) {
    __extends(JQueryRequestor, _super);
    function JQueryRequestor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    JQueryRequestor.prototype.xhr = function (settings) {
        // NOTE: using jquery to make XHR's as whatwg-fetch requires
        // that I target ES6.
        var xhr = $.ajax(settings);
        return new Promise(function (resolve, reject) {
            xhr.then(function (data, textStatus, jqXhr) {
                resolve(data);
            }, function (jqXhr, textStatus, error) {
                reject(new errors_1.AppAuthError(error));
            });
        });
    };
    return JQueryRequestor;
}(Requestor));
exports.JQueryRequestor = JQueryRequestor;
/**
 * Uses fetch API to make Ajax requests
 */
var FetchRequestor = /** @class */ (function (_super) {
    __extends(FetchRequestor, _super);
    function FetchRequestor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    FetchRequestor.prototype.xhr = function (settings) {
        if (!settings.url) {
            return Promise.reject(new errors_1.AppAuthError('A URL must be provided.'));
        }
        var url = new URL(settings.url);
        var requestInit = {};
        requestInit.method = settings.method;
        requestInit.mode = 'cors';
        if (settings.data) {
            if (settings.method && settings.method.toUpperCase() === 'POST') {
                requestInit.body = settings.data;
            }
            else {
                var searchParams = new URLSearchParams(settings.data);
                searchParams.forEach(function (value, key) {
                    url.searchParams.append(key, value);
                });
            }
        }
        // Set the request headers
        requestInit.headers = {};
        if (settings.headers) {
            for (var i in settings.headers) {
                if (settings.headers.hasOwnProperty(i)) {
                    requestInit.headers[i] = settings.headers[i];
                }
            }
        }
        var isJsonDataType = settings.dataType && settings.dataType.toLowerCase() === 'json';
        // Set 'Accept' header value for json requests (Taken from
        // https://github.com/jquery/jquery/blob/e0d941156900a6bff7c098c8ea7290528e468cf8/src/ajax.js#L644
        // )
        if (isJsonDataType) {
            requestInit.headers['Accept'] = 'application/json, text/javascript, */*; q=0.01';
        }
        return fetch(url.toString(), requestInit).then(function (response) {
            if (response.status >= 200 && response.status < 300) {
                var contentType = response.headers.get('content-type');
                if (isJsonDataType || (contentType && contentType.indexOf('application/json') !== -1)) {
                    return response.json();
                }
                else {
                    return response.text();
                }
            }
            else {
                return Promise.reject(new errors_1.AppAuthError(response.status.toString(), response.statusText));
            }
        });
    };
    return FetchRequestor;
}(Requestor));
exports.FetchRequestor = FetchRequestor;
/**
 * Should be used only in the context of testing. Just uses the underlying
 * Promise to mock the behavior of the Requestor.
 */
var TestRequestor = /** @class */ (function (_super) {
    __extends(TestRequestor, _super);
    function TestRequestor(promise) {
        var _this = _super.call(this) || this;
        _this.promise = promise;
        return _this;
    }
    TestRequestor.prototype.xhr = function (settings) {
        return this.promise; // unsafe cast
    };
    return TestRequestor;
}(Requestor));
exports.TestRequestor = TestRequestor;

},{"./errors":95}],107:[function(require,module,exports){
arguments[4][65][0].apply(exports,arguments)
},{"./internal/initialParams":109,"./internal/setImmediate":113,"./internal/wrapAsync":114,"dup":65}],108:[function(require,module,exports){
arguments[4][71][0].apply(exports,arguments)
},{"dup":71}],109:[function(require,module,exports){
arguments[4][75][0].apply(exports,arguments)
},{"dup":75}],110:[function(require,module,exports){
arguments[4][79][0].apply(exports,arguments)
},{"dup":79}],111:[function(require,module,exports){
arguments[4][80][0].apply(exports,arguments)
},{"dup":80}],112:[function(require,module,exports){
arguments[4][82][0].apply(exports,arguments)
},{"dup":82}],113:[function(require,module,exports){
(function (process,setImmediate){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fallback = fallback;
exports.wrap = wrap;
var hasSetImmediate = exports.hasSetImmediate = typeof setImmediate === 'function' && setImmediate;
var hasNextTick = exports.hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';

function fallback(fn) {
    setTimeout(fn, 0);
}

function wrap(defer) {
    return (fn, ...args) => defer(() => fn(...args));
}

var _defer;

if (hasSetImmediate) {
    _defer = setImmediate;
} else if (hasNextTick) {
    _defer = process.nextTick;
} else {
    _defer = fallback;
}

exports.default = wrap(_defer);
}).call(this,require('_process'),require("timers").setImmediate)

},{"_process":153,"timers":158}],114:[function(require,module,exports){
arguments[4][85][0].apply(exports,arguments)
},{"../asyncify":107,"dup":85}],115:[function(require,module,exports){
arguments[4][88][0].apply(exports,arguments)
},{"./internal/promiseCallback":112,"./internal/wrapAsync":114,"dup":88}],116:[function(require,module,exports){
arguments[4][89][0].apply(exports,arguments)
},{"./internal/awaitify":108,"./internal/once":110,"./internal/onlyOnce":111,"./internal/wrapAsync":114,"dup":89}],117:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],118:[function(require,module,exports){
"use strict";

(function (factory) {
  if (typeof module === "object" && typeof module.exports === "object") {
    var v = factory(require, exports);
    if (v !== undefined) module.exports = v;
  } else if (typeof define === "function" && define.amd) {
    define(["require", "exports"], factory);
  }
})(function (require, exports) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  /**
   * A token that provides access to Bitski on behalf of a user.
   */

  class AccessToken {
    constructor(token, expiresIn) {
      this.expiresAt = undefined;
      this.token = token;

      if (expiresIn) {
        this.expiresAt = Math.floor(Date.now() / 1000) + expiresIn;
      }
    }

    get expired() {
      if (this.expiresAt) {
        const now = Math.floor(Date.now() / 1000);
        const expiresIn = this.expiresAt - now;
        return expiresIn <= 0;
      }

      return false;
    }

  }

  exports.AccessToken = AccessToken;
});

},{}],119:[function(require,module,exports){
"use strict";

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result["default"] = mod;
  return result;
};

(function (factory) {
  if (typeof module === "object" && typeof module.exports === "object") {
    var v = factory(require, exports);
    if (v !== undefined) module.exports = v;
  } else if (typeof define === "function" && define.amd) {
    define(["require", "exports", "@bitski/provider-engine", "./errors/provider-error", "./subproviders/nonce-tracker", "./subproviders/transaction-validator", "./subproviders/typed-data"], factory);
  }
})(function (require, exports) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  const provider_engine_1 = __importStar(require("@bitski/provider-engine"));

  const provider_error_1 = require("./errors/provider-error");

  const nonce_tracker_1 = require("./subproviders/nonce-tracker");

  const transaction_validator_1 = require("./subproviders/transaction-validator");

  const typed_data_1 = require("./subproviders/typed-data");

  class BitskiEngine extends provider_engine_1.default {
    constructor(options) {
      super(options);
      options = options || {}; // Handles static responses

      this.addProvider(new provider_engine_1.DefaultFixtureSubprovider()); // Monitors requests to eth_getTransactionCount and eth_sendTransaction to track
      // pending transactions

      this.addProvider(new nonce_tracker_1.NonceTrackerSubprovider()); // Sanitizes transaction params, removing anything invalid

      this.addProvider(new provider_engine_1.SanitizerSubprovider());
      const enableValidator = !(options && options.disableValidation === true);

      if (enableValidator) {
        // Ensures that transactions are well formed (nonce, gas, gasPrice, from) before they are sent to Bitski
        this.addProvider(new transaction_validator_1.TransactionValidatorSubprovider(options.minGasPrice));
        this.addProvider(new typed_data_1.TypedDataSanitizerSubprovider());
      }

      const enableCache = !(options && options.disableCaching === true);

      if (enableCache) {
        // Block Cache - caches certain requests by their block number
        this.addProvider(new provider_engine_1.BlockCacheSubprovider());
      } // Handles subscriptions and filters


      const filterAndSubsSubprovider = new provider_engine_1.SubscriptionSubprovider(); // Watch for updates from subscriptions

      filterAndSubsSubprovider.on('data', (_, notification) => {
        this.onMessage(notification);
      });
      this.addProvider(filterAndSubsSubprovider);

      if (enableCache) {
        // Debounces duplicate requests that occur at the same time
        this.addProvider(new provider_engine_1.InflightCacheSubprovider());
      }
    }

    supportsSubscriptions() {
      return this._pollForBlocks;
    }

    subscribe() {
      let subscribeMethod = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'eth_subscribe';
      let subscriptionMethod = arguments.length > 1 ? arguments[1] : undefined;
      let parameters = arguments.length > 2 ? arguments[2] : undefined;

      if (!this._pollForBlocks) {
        return Promise.reject(provider_error_1.ProviderError.SubscriptionsUnavailable());
      }

      parameters.unshift(subscriptionMethod);
      return this.send(subscribeMethod, parameters);
    }

    unsubscribe(subscriptionId) {
      let unsubscribeMethod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'eth_unsubscribe';

      if (!this._pollForBlocks) {
        return Promise.reject(provider_error_1.ProviderError.SubscriptionsUnavailable());
      }

      return this.send(unsubscribeMethod, [subscriptionId]).then(response => {
        if (response) {
          this.removeAllListeners(subscriptionId);
        }

        return response;
      });
    }

    onMessage(notification) {
      // Re-emit (previous behavior ~ web3 1.0.0-beta.37)
      this.emit('data', null, notification);

      if (notification && notification.params && notification.params.subscription) {
        // Current web3 behavior - emit subscription id
        this.emit(notification.params.subscription, notification.params);
      }
    }

  }

  exports.BitskiEngine = BitskiEngine;
});

},{"./errors/provider-error":121,"./subproviders/nonce-tracker":126,"./subproviders/transaction-validator":127,"./subproviders/typed-data":128,"@bitski/provider-engine":35}],120:[function(require,module,exports){
"use strict";

(function (factory) {
  if (typeof module === "object" && typeof module.exports === "object") {
    var v = factory(require, exports);
    if (v !== undefined) module.exports = v;
  } else if (typeof define === "function" && define.amd) {
    define(["require", "exports"], factory);
  }
})(function (require, exports) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  }); // JSON-RPC methods that require Authorization header

  exports.AUTHENTICATED_METHODS = ['eth_accounts', 'eth_sendTransaction', 'eth_signTransaction', 'eth_signTypedData', 'personal_sign', 'eth_sign']; // Error messages that are usually transient and should be retried

  exports.RETRIABLE_ERRORS = [// ignore server overload errors
  'Gateway timeout', 'ETIMEDOUT', 'ENOTFOUND', // ignore server sent html error pages
  // or truncated json responses
  'SyntaxError', 'ECONNRESET', 'EHOSTUNREACH', 'Timeout out while waiting for response']; // Errors that indicate the access token is not valid

  exports.UNAUTHORIZED_ERRORS = ['Missing auth', 'Invalid client id', 'Not Authorized'];
});

},{}],121:[function(require,module,exports){
"use strict";

(function (factory) {
  if (typeof module === "object" && typeof module.exports === "object") {
    var v = factory(require, exports);
    if (v !== undefined) module.exports = v;
  } else if (typeof define === "function" && define.amd) {
    define(["require", "exports"], factory);
  }
})(function (require, exports) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var ProviderErrorCode;

  (function (ProviderErrorCode) {
    // Thrown when accessing subscription features when they are disabled.
    ProviderErrorCode[ProviderErrorCode["SubscriptionsUnavailable"] = 4000] = "SubscriptionsUnavailable"; // Thrown when request is missing required params or data

    ProviderErrorCode[ProviderErrorCode["InvalidRequest"] = 4001] = "InvalidRequest";
  })(ProviderErrorCode = exports.ProviderErrorCode || (exports.ProviderErrorCode = {}));

  class ProviderError extends Error {
    constructor(message, code) {
      super(message);
      this.name = 'ProviderError'; // Maintains proper stack trace for where our error was thrown (only available on V8)

      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, ProviderError);
      }

      this.code = code;
    }

    static SubscriptionsUnavailable() {
      return new ProviderError('Subscriptions are disabled. Enable block polling to use this feature.', ProviderErrorCode.SubscriptionsUnavailable);
    }

    static InvalidRequest(reason) {
      return new ProviderError("Invalid request: ".concat(reason), ProviderErrorCode.InvalidRequest);
    }

  }

  exports.ProviderError = ProviderError;
});

},{}],122:[function(require,module,exports){
"use strict";

(function (factory) {
  if (typeof module === "object" && typeof module.exports === "object") {
    var v = factory(require, exports);
    if (v !== undefined) module.exports = v;
  } else if (typeof define === "function" && define.amd) {
    define(["require", "exports"], factory);
  }
})(function (require, exports) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  /**
   * Represents an error that is received from the server
   * You can access the response code via the code property, and the URI from the requestURI property.
   * The retried property will indicate whether or not the request failed after multiple tries.
   */

  class ServerError extends Error {
    constructor(message, code, requestURI) {
      let retried = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      super(message);
      this.name = 'ServerError'; // Maintains proper stack trace for where our error was thrown (only available on V8)

      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, ServerError);
      }

      this.code = code;
      this.requestURI = requestURI;
      this.retried = retried;
    }

  }

  exports.ServerError = ServerError;
});

},{}],123:[function(require,module,exports){
"use strict";

(function (factory) {
  if (typeof module === "object" && typeof module.exports === "object") {
    var v = factory(require, exports);
    if (v !== undefined) module.exports = v;
  } else if (typeof define === "function" && define.amd) {
    define(["require", "exports", "./bitski-engine", "./auth/access-token", "./subproviders/authenticated-fetch", "./network", "./errors/server-error", "./errors/provider-error"], factory);
  }
})(function (require, exports) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var bitski_engine_1 = require("./bitski-engine");

  exports.BitskiEngine = bitski_engine_1.BitskiEngine;

  var access_token_1 = require("./auth/access-token");

  exports.AccessToken = access_token_1.AccessToken;

  var authenticated_fetch_1 = require("./subproviders/authenticated-fetch");

  exports.AuthenticatedFetchSubprovider = authenticated_fetch_1.AuthenticatedFetchSubprovider;

  var network_1 = require("./network");

  exports.Mainnet = network_1.Mainnet;
  exports.Rinkeby = network_1.Rinkeby;
  exports.Kovan = network_1.Kovan;

  var server_error_1 = require("./errors/server-error");

  exports.ServerError = server_error_1.ServerError;

  var provider_error_1 = require("./errors/provider-error");

  exports.ProviderError = provider_error_1.ProviderError;
  exports.ProviderErrorCode = provider_error_1.ProviderErrorCode;
});

},{"./auth/access-token":118,"./bitski-engine":119,"./errors/provider-error":121,"./errors/server-error":122,"./network":124,"./subproviders/authenticated-fetch":125}],124:[function(require,module,exports){
"use strict";

(function (factory) {
  if (typeof module === "object" && typeof module.exports === "object") {
    var v = factory(require, exports);
    if (v !== undefined) module.exports = v;
  } else if (typeof define === "function" && define.amd) {
    define(["require", "exports"], factory);
  }
})(function (require, exports) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Mainnet = {
    chainId: 1,
    rpcUrl: 'https://api.bitski.com/v1/web3/mainnet'
  };
  exports.Rinkeby = {
    chainId: 4,
    rpcUrl: 'https://api.bitski.com/v1/web3/rinkeby'
  };
  exports.Kovan = {
    chainId: 42,
    rpcUrl: 'https://api.bitski.com/v1/web3/kovan'
  };
});

},{}],125:[function(require,module,exports){
"use strict";

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

(function (factory) {
  if (typeof module === "object" && typeof module.exports === "object") {
    var v = factory(require, exports);
    if (v !== undefined) module.exports = v;
  } else if (typeof define === "function" && define.amd) {
    define(["require", "exports", "@bitski/provider-engine", "async/retry", "../constants", "../errors/server-error"], factory);
  }
})(function (require, exports) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  const provider_engine_1 = require("@bitski/provider-engine");

  const retry_1 = __importDefault(require("async/retry"));

  const constants_1 = require("../constants");

  const server_error_1 = require("../errors/server-error");
  /*
   * Subprovider that fetches over HTTP and manages authentication headers
   */


  class AuthenticatedFetchSubprovider extends provider_engine_1.FetchSubprovider {
    constructor(rpcUrl, debug, accessTokenProvider) {
      let defaultHeaders = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      super({
        rpcUrl
      });
      this.authenticatedMethods = constants_1.AUTHENTICATED_METHODS;
      this.accessTokenProvider = accessTokenProvider;
      this.defaultHeaders = defaultHeaders;
    }

    handleRequest(payload, next, end) {
      if (this.requiresAuthentication(payload)) {
        return this.handleAuthenticatedRequest(payload, next, end);
      } else {
        return this.handleUnauthenticatedRequest(payload, next, end);
      }
    }

    handleAuthenticatedRequest(payload, next, end) {
      this.accessTokenProvider.getAccessToken().then(accessToken => {
        const parameters = this.generateParameters(payload, accessToken);
        return this.sendRequest(parameters, next, end);
      }).catch(error => {
        end(error);
      });
    }

    handleUnauthenticatedRequest(payload, next, end) {
      const parameters = this.generateParameters(payload);
      return this.sendRequest(parameters, next, end);
    }

    requiresAuthentication(payload) {
      return this.authenticatedMethods.some(method => method === payload.method);
    }

    generateParameters(payload, accessToken) {
      // overwrite id to not conflict with other concurrent users
      const newPayload = this.createPayload(payload); // remove extra parameter from request

      delete newPayload.origin;
      let headers = {
        'Accept': 'application/json',
        'Content-Type': 'application/json'
      };
      headers = Object.assign({}, headers, this.defaultHeaders);
      const originDomain = payload.origin;

      if (this.originHttpHeaderKey && originDomain) {
        headers[this.originHttpHeaderKey] = originDomain;
      }

      if (accessToken) {
        headers.Authorization = "Bearer ".concat(accessToken);
      }

      const requestParameters = {
        body: JSON.stringify(newPayload),
        headers,
        method: 'POST'
      };
      return requestParameters;
    }

    sendRequest(parameters, next, end) {
      retry_1.default({
        errorFilter: this.isErrorRetriable,
        interval: 1000,
        times: 5
      }, cb => this._submitRequest(parameters, cb), (err, result) => {
        // ends on retriable error
        if (err && this.isErrorRetriable(err)) {
          const retriesExhaustedErr = new server_error_1.ServerError(err.message, 200, this.rpcUrl, true);
          return end(retriesExhaustedErr);
        }

        if (err && this.isUnauthorizedError(err)) {
          return this.accessTokenProvider.invalidateToken().then(() => {
            return end(err);
          });
        } // otherwise continue normally


        return end(err, result);
      });
    }

    isErrorRetriable(err) {
      const errMsg = err.toString();
      return constants_1.RETRIABLE_ERRORS.some(phrase => errMsg.includes(phrase));
    }

    isUnauthorizedError(err) {
      return constants_1.UNAUTHORIZED_ERRORS.some(phrase => err.message.includes(phrase));
    }

  }

  exports.AuthenticatedFetchSubprovider = AuthenticatedFetchSubprovider;
});

},{"../constants":120,"../errors/server-error":122,"@bitski/provider-engine":35,"async/retry":115}],126:[function(require,module,exports){
"use strict";

(function (factory) {
  if (typeof module === "object" && typeof module.exports === "object") {
    var v = factory(require, exports);
    if (v !== undefined) module.exports = v;
  } else if (typeof define === "function" && define.amd) {
    define(["require", "exports", "@bitski/provider-engine"], factory);
  }
})(function (require, exports) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  const provider_engine_1 = require("@bitski/provider-engine");
  /**
   * A subprovider that tracks and automatically increments the nonce on the client.
   * Heavily based on the provider-engine NonceTrackerSubprovider, but modified for
   * Bitski's transaction flow.
   */


  class NonceTrackerSubprovider extends provider_engine_1.Subprovider {
    constructor() {
      super();
      this.nonceCache = new Map();
    }

    handleRequest(payload, next, end) {
      switch (payload.method) {
        case 'eth_getTransactionCount':
          this.handleTransactionCountRequest(payload, next, end);
          return;

        case 'eth_sendTransaction':
          this.handleSendTransactionRequest(payload, next);
          return;

        default:
          next();
          return;
      }
    } // Return cached result if present


    handleTransactionCountRequest(payload, next, end) {
      const blockTag = payload.params.length > 1 ? payload.params[1] : null; // Only handle pending tag

      if (blockTag !== 'pending') {
        next();
        return;
      }

      const address = payload.params[0].toLowerCase();
      const cachedResult = this.nonceCache.get(address); // Return cached result it we have it

      if (cachedResult) {
        end(null, cachedResult);
        return;
      } // Fallthrough and populate cache


      next((err, result, cb) => {
        if (!err) {
          this.nonceCache.set(address, result);
        }

        cb();
      });
    }

    toHex(num) {
      const base16 = num.toString(16);
      let hex = base16;

      if (base16.length % 2 !== 0) {
        hex = '0' + base16;
      }

      return '0x' + hex;
    }

    fromHex(str) {
      return parseInt(str, 16);
    }

    nextNonce(nonce) {
      const submittedNonce = this.fromHex(nonce);
      const nextNonce = submittedNonce + 1;
      return this.toHex(nextNonce);
    } // Increment next nonce for address


    handleSendTransactionRequest(payload, next) {
      // Submit the request, then monitor the result
      next((err, result, cb) => {
        const transaction = payload.params.length > 0 ? payload.params[0] : {};
        const submittedNonce = transaction.nonce;
        const address = transaction.from;

        if (!err) {
          if (submittedNonce && address) {
            // Increment nonce
            const nextNonce = this.nextNonce(submittedNonce);
            this.nonceCache.set(address, nextNonce);
          }
        } else {
          // Remove cached value if we encounter an error
          this.nonceCache.delete(address);
        }

        cb();
      });
    }

  }

  exports.NonceTrackerSubprovider = NonceTrackerSubprovider;
});

},{"@bitski/provider-engine":35}],127:[function(require,module,exports){
"use strict";

(function (factory) {
  if (typeof module === "object" && typeof module.exports === "object") {
    var v = factory(require, exports);
    if (v !== undefined) module.exports = v;
  } else if (typeof define === "function" && define.amd) {
    define(["require", "exports", "@bitski/provider-engine"], factory);
  }
})(function (require, exports) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  const provider_engine_1 = require("@bitski/provider-engine");
  /**
   * A subprovider that automatically populates missing transaction details.
   * This is needed because it has become common to submit transactions with
   * only some of the parameters and rely on the provider or node to fill in the rest.
   */


  class TransactionValidatorSubprovider extends provider_engine_1.Subprovider {
    constructor() {
      let minGasPrice = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      super();
      this.minGasPrice = minGasPrice;
    }

    handleRequest(payload, next, _) {
      // Only handle transactions
      if (payload.method === 'eth_sendTransaction' || payload.method === 'eth_signTransaction') {
        this.populateTransactionFields(payload).then(() => {
          // Payload was modified. Continue.
          next();
        }).catch(() => {
          // Fall through if we cannot populate fields
          next();
        });
      } else {
        next();
      }
    } // Examine transaction and populate missing params


    async populateTransactionFields(payload) {
      const params = payload.params || [];
      let transaction = {};

      if (params.length > 0) {
        transaction = params[0];
      }

      const promises = []; // Populate missing from with default account

      if (transaction.from === undefined) {
        const accounts = await this.getAccounts();
        transaction.from = accounts[0];
      } // Populate missing gasPrice


      if (transaction.gasPrice === undefined) {
        promises.push(this.estimateGasPrice());
      } else {
        promises.push(transaction.gasPrice);
      } // Populate missing nonce


      if (transaction.nonce === undefined) {
        promises.push(this.getNonce(transaction.from));
      } else {
        promises.push(transaction.nonce);
      } // Populate missing gas


      if (transaction.gas === undefined) {
        promises.push(this.estimateGas(transaction));
      } else {
        promises.push(transaction.gas);
      } // Execute promises


      const values = await Promise.all(promises); // Update parameters with loaded values. Must be very careful with the indexes here.

      transaction.gasPrice = values[0];
      transaction.nonce = values[1];
      transaction.gas = values[2]; // Set the params on the payload

      payload.params[0] = transaction;
      return payload;
    }

    async getNonce(address) {
      const request = {
        id: 0,
        jsonrpc: '2.0',
        method: 'eth_getTransactionCount',
        params: [address, 'latest']
      };
      return this.performRequest(request);
    }

    async getAccounts() {
      const request = {
        id: 0,
        jsonrpc: '2.0',
        method: 'eth_accounts',
        params: []
      };
      return this.performRequest(request);
    }

    async estimateGas(transaction) {
      const request = {
        id: 0,
        jsonrpc: '2.0',
        method: 'eth_estimateGas',
        params: [transaction]
      };
      return this.performRequest(request);
    }

    async estimateGasPrice() {
      const request = {
        id: 0,
        jsonrpc: '2.0',
        method: 'eth_gasPrice',
        params: []
      };
      return this.performRequest(request).then(gasPrice => {
        if (gasPrice === '0x0') {
          return "0x".concat(this.minGasPrice.toString(16));
        }

        return gasPrice;
      });
    } // Wraps emitPayload in a promise


    performRequest(payload) {
      return new Promise((fulfill, reject) => {
        this.emitPayload(payload, (err, result) => {
          if (err) {
            reject(err);
          } else {
            fulfill(result.result);
          }
        });
      });
    }

  }

  exports.TransactionValidatorSubprovider = TransactionValidatorSubprovider;
});

},{"@bitski/provider-engine":35}],128:[function(require,module,exports){
"use strict";

(function (factory) {
  if (typeof module === "object" && typeof module.exports === "object") {
    var v = factory(require, exports);
    if (v !== undefined) module.exports = v;
  } else if (typeof define === "function" && define.amd) {
    define(["require", "exports", "@bitski/provider-engine", "../errors/provider-error", "../utils/parse-utils"], factory);
  }
})(function (require, exports) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  const provider_engine_1 = require("@bitski/provider-engine");

  const provider_error_1 = require("../errors/provider-error");

  const parse_utils_1 = require("../utils/parse-utils");

  class TypedDataSanitizerSubprovider extends provider_engine_1.Subprovider {
    handleRequest(payload, next, end) {
      if (payload.method === 'eth_signTypedData' || payload.method === 'eth_signTypedData_v3') {
        try {
          this.sanitizePayload(payload);
        } catch (err) {
          return end(err, undefined);
        }
      }

      next();
    }

    sanitizePayload(payload) {
      const typedData = this.extractTypedData(payload); // create map of types

      const typeMapping = createTypeMapping(typedData); // sanitize domain

      sanitizeDomain(typedData, typeMapping); // sanitize message

      sanitizeMessage(typedData, typeMapping); // Re-assign typed data to params in case it has been parsed
      // from a string.

      payload.params[1] = typedData;
    } // Given a JSON-RPC request, extract the typed data from the params


    extractTypedData(payload) {
      if (!payload.params || payload.params.length < 2) {
        throw provider_error_1.ProviderError.InvalidRequest('Missing params for typed data');
      } // Some implementations pass typed data as a string


      if (typeof payload.params[1] === 'string') {
        return JSON.parse(payload.params[1]);
      }

      return payload.params[1];
    }

  }

  exports.TypedDataSanitizerSubprovider = TypedDataSanitizerSubprovider;
  /**
   * Sanitizes the `domain` values from the TypedData
   *
   * @param typedData TypedData payload
   * @param typeMapping a TypeMapping pre-generated from the TypedData
   */

  function sanitizeDomain(typedData, typeMapping) {
    if (typeof typedData.domain === 'undefined') {
      throw provider_error_1.ProviderError.InvalidRequest('Missing domain for typed data');
    }

    if (typeof typedData.types.EIP712Domain === 'undefined') {
      throw provider_error_1.ProviderError.InvalidRequest('Missing type definition for domain');
    }

    sanitizeType('EIP712Domain', typedData.domain, typeMapping);
  }

  exports.sanitizeDomain = sanitizeDomain;
  /**
   * Sanitizes the `message` values from the TypedData
   *
   * @param typedData TypedData payload
   * @param typeMapping a TypeMapping pre-generated from the TypedData
   */

  function sanitizeMessage(typedData, typeMapping) {
    if (typeof typedData.message === 'undefined') {
      throw provider_error_1.ProviderError.InvalidRequest('Missing message in typed data');
    }

    if (typeof typedData.primaryType !== 'string') {
      throw provider_error_1.ProviderError.InvalidRequest('Missing primary type in typed data');
    }

    sanitizeType(typedData.primaryType, typedData.message, typeMapping);
  }

  exports.sanitizeMessage = sanitizeMessage;
  /**
   * Recursively examines each value and determines type from the type mapping to
   * format and sanitize the value if needed.
   *
   * Currently this will only convert number values into a consistent hex format,
   * but in the future additional transformations may be necessary.
   *
   * @param typeName Name of the type we are starting from
   * @param values The root object containing the keys and values
   * @param typeMapping The type mapping that represents this data
   */

  function sanitizeType(typeName, values, typeMapping) {
    // For each key in the 'values' object...
    Object.keys(values).forEach(key => {
      // Find the type name associated from the mapping
      const type = typeMapping[typeName][key];

      if (type === undefined) {// Do nothing if we don't have a type for this key
      } else if (isArray(type)) {
        // find the base type (left side of the brackets)
        const baseType = type.split('[')[0];

        if (typeof values[key].length === 'undefined') {
          throw new TypeError("Could not parse ".concat(values[key], " for type ").concat(type, ". Expected array."));
        } // If base type is a struct, iterate through each instance of struct


        if (typeMapping[baseType]) {
          // values[key] is expected to be an array, where each element
          // is an object that represents the struct named baseType.
          values[key].forEach(itemValues => {
            sanitizeType(baseType, itemValues, typeMapping);
          });
        } else if (baseType.startsWith('uint') || baseType.startsWith('int')) {
          // If we have an array of primitive types that are numbers, we need to encode the numbers as hex
          const numberValues = values[key].map(numberValue => {
            return parse_utils_1.encodeNumber(numberValue, baseType, true);
          });
          values[key] = numberValues;
        } else {// Do nothing with regular array values
          // int8[], etc should already be strings
        }
      } else if (typeMapping[type]) {
        // If type name is a custom struct, it should live in the type mapping
        // We need to recursively check the custom types until we get to primitive values
        sanitizeType(type, values[key], typeMapping);
      } else if (type.startsWith('uint') || type.startsWith('int')) {
        // Finally, if we have a primitive type that is a number, we need to encode the numbers as hex
        values[key] = parse_utils_1.encodeNumber(values[key], type, true);
      }
    });
  }

  exports.sanitizeType = sanitizeType;
  /**
   * Returns true if type name indicates that an array
   * @param typeName solidity type name
   */

  function isArray(typeName) {
    if (typeName.includes('[') && typeName.includes(']')) {
      return true;
    }

    return false;
  }
  /**
   * Maps the type definitions from the typed data for easy look-up.
   * Top level keys represent the structs defined, while top-level values
   * are an object keyed by property with string values of the type name.
   *
   * For example:
   * {
   *    EIP712Domain: {
   *      name: 'string',
   *      version: 'string',
   *      chainId: 'uint256'
   *    }
   * }
   * @param typedData The TypedData to map
   * @returns {TypeMapping} the mapped data schema
   */


  function createTypeMapping(typedData) {
    if (typeof typedData.types === 'undefined') {
      throw provider_error_1.ProviderError.InvalidRequest('Missing type definitions for typed data');
    } // Go through each of the top level keys. These represent the custom types.


    return Object.keys(typedData.types).reduce((acc, current) => {
      // Reduce into a new single object
      // Set a key for each type, reduce array of property names and types to an object
      acc[current] = typedData.types[current].reduce((acc2, typeDef) => {
        // For each type, set the key as the property name, and the value as the type name
        acc2[typeDef.name] = typeDef.type;
        return acc2;
      }, {});
      return acc;
    }, {});
  }

  exports.createTypeMapping = createTypeMapping;
});

},{"../errors/provider-error":121,"../utils/parse-utils":129,"@bitski/provider-engine":35}],129:[function(require,module,exports){
"use strict";

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

(function (factory) {
  if (typeof module === "object" && typeof module.exports === "object") {
    var v = factory(require, exports);
    if (v !== undefined) module.exports = v;
  } else if (typeof define === "function" && define.amd) {
    define(["require", "exports", "bn.js"], factory);
  }
})(function (require, exports) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  const bn_js_1 = __importDefault(require("bn.js"));
  /**
   * parseNumber
   * Converts a value that represents a number into a hex value.
   * @param arg {string | number | BN} A number value to convert to hex.
   * Can be a regular number, base-10 string, base-16 string, or BN instance.
   * @returns {BN} BN instance representing the number
   *
   * (Adapted from ethereumjs-abi)
   */


  function parseNumber(arg) {
    const type = typeof arg;

    if (type === 'string') {
      if (arg.substr(0, 2) === '0x') {
        return new bn_js_1.default(arg.substr(2), 16);
      } else {
        return new bn_js_1.default(arg, 10);
      }
    } else if (type === 'number') {
      return new bn_js_1.default(arg);
    } else if (arg.toArray) {
      // assume this is a BN for the moment, replace with BN.isBN soon
      return arg;
    } else {
      throw new Error('Argument is not a number');
    }
  }

  function parseBitWidth(type, offset) {
    // default to 256 bit if not specified
    let size = 256; // If type string is longer than offset, parse bits from the type string

    if (type.length > offset) {
      size = parseInt(type.substr(offset), 10);
    } // bit width must be a multiple of 8, and in the range 8-256.


    if (size % 8 || size < 8 || size > 256) {
      throw new Error("Invalid bit width ".concat(type));
    }

    return size;
  }
  /**
   * encodeNumber
   * Takes a decimal string, hex string, regular number, or BN instance and returns a hex string in the specified format.
   * Typically these conversions are done in web3, but until web3 adds direct support, this is necessary for normalizing
   * numbers eth_signTypedData payloads.
   * @param num The value to convert
   * @param type The solidity ABI type to format the data as (eg. uint256, int8, etc). Only supports int and uint variants.
   * @param compact boolean (default false). Whether to use compact encoding for uints, or pad with zeroes.
   * @returns {string} A hex string formatted as the specified type.
   */


  function encodeNumber(num, type) {
    let compact = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if (type.startsWith('uint')) {
      const size = parseBitWidth(type, 4); // start after 'uint'

      const length = size / 4; // length in characters for the string. hex is 1 character for 4 bits.

      const parsed = parseNumber(num); // uint can never be negative

      if (parsed.isNeg()) {
        throw new Error('Supplied uint is negative');
      } // Convert to hex, and prepend 0x


      if (compact) {
        return '0x' + parsed.toString(16);
      }

      return '0x' + parsed.toString(16, length);
    } else if (type.startsWith('int')) {
      // bit width must be a multiple of 8, and in the range 8-256.
      const size = parseBitWidth(type, 3);
      const length = size / 4; // length in characters for the string. hex is 1 character for 4 bits.

      const parsed = parseNumber(num); // Convert to twos complement at the bit size from the type, then convert value to hex

      return '0x' + parsed.toTwos(size).toString(16, length);
    } else {
      throw new Error('Invalid type passed');
    }
  }

  exports.encodeNumber = encodeNumber;
});

},{"bn.js":130}],130:[function(require,module,exports){
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    Buffer = require('buffer').Buffer;
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
    }

    if (base === 16) {
      this._parseHex(number, start);
    } else {
      this._parseBase(number, base, start);
    }

    if (number[0] === '-') {
      this.negative = 1;
    }

    this.strip();

    if (endian !== 'le') return;

    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex (str, start, end) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r <<= 4;

      // 'a' - 'f'
      if (c >= 49 && c <= 54) {
        r |= c - 49 + 0xa;

      // 'A' - 'F'
      } else if (c >= 17 && c <= 22) {
        r |= c - 17 + 0xa;

      // '0' - '9'
      } else {
        r |= c & 0xf;
      }
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    // Scan 24-bit chunks and add them to the number
    var off = 0;
    for (i = number.length - 6, j = 0; i >= start; i -= 6) {
      w = parseHex(number, i, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
    if (i + 6 !== start) {
      w = parseHex(number, start, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
    }
    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      r.strip();
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

},{"buffer":131}],131:[function(require,module,exports){

},{}],132:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var objectCreate = Object.create || objectCreatePolyfill
var objectKeys = Object.keys || objectKeysPolyfill
var bind = Function.prototype.bind || functionBindPolyfill

function EventEmitter() {
  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {
    this._events = objectCreate(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

var hasDefineProperty;
try {
  var o = {};
  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });
  hasDefineProperty = o.x === 0;
} catch (err) { hasDefineProperty = false }
if (hasDefineProperty) {
  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      // check whether the input is a positive number (whose value is zero or
      // greater and not a NaN).
      if (typeof arg !== 'number' || arg < 0 || arg !== arg)
        throw new TypeError('"defaultMaxListeners" must be a positive number');
      defaultMaxListeners = arg;
    }
  });
} else {
  EventEmitter.defaultMaxListeners = defaultMaxListeners;
}

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    if (arguments.length > 1)
      er = arguments[1];
    if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Unhandled "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
      // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
      // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = objectCreate(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
          listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
          prepend ? [listener, existing] : [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
            existing.length + ' "' + String(type) + '" listeners ' +
            'added. Use emitter.setMaxListeners() to ' +
            'increase limit.');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        if (typeof console === 'object' && console.warn) {
          console.warn('%s: %s', w.name, w.message);
        }
      }
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    switch (arguments.length) {
      case 0:
        return this.listener.call(this.target);
      case 1:
        return this.listener.call(this.target, arguments[0]);
      case 2:
        return this.listener.call(this.target, arguments[0], arguments[1]);
      case 3:
        return this.listener.call(this.target, arguments[0], arguments[1],
            arguments[2]);
      default:
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i)
          args[i] = arguments[i];
        this.listener.apply(this.target, args);
    }
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = bind.call(onceWrapper, state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = objectCreate(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else
          spliceOne(list, position);

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = objectCreate(null);
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = objectKeys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = objectCreate(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (!events)
    return [];

  var evlistener = events[type];
  if (!evlistener)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function objectCreatePolyfill(proto) {
  var F = function() {};
  F.prototype = proto;
  return new F;
}
function objectKeysPolyfill(obj) {
  var keys = [];
  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
    keys.push(k);
  }
  return k;
}
function functionBindPolyfill(context) {
  var fn = this;
  return function () {
    return fn.apply(context, arguments);
  };
}

},{}],133:[function(require,module,exports){
(function (Buffer){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol.for === 'function')
    ? Symbol.for('nodejs.util.inspect.custom')
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    var proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = (function () {
  var alphabet = '0123456789abcdef'
  var table = new Array(256)
  for (var i = 0; i < 16; ++i) {
    var i16 = i * 16
    for (var j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

}).call(this,require("buffer").Buffer)

},{"base64-js":117,"buffer":133,"ieee754":142}],134:[function(require,module,exports){
(function (Buffer){
var clone = (function() {
'use strict';

function _instanceof(obj, type) {
  return type != null && obj instanceof type;
}

var nativeMap;
try {
  nativeMap = Map;
} catch(_) {
  // maybe a reference error because no `Map`. Give it a dummy value that no
  // value will ever be an instanceof.
  nativeMap = function() {};
}

var nativeSet;
try {
  nativeSet = Set;
} catch(_) {
  nativeSet = function() {};
}

var nativePromise;
try {
  nativePromise = Promise;
} catch(_) {
  nativePromise = function() {};
}

/**
 * Clones (copies) an Object using deep copying.
 *
 * This function supports circular references by default, but if you are certain
 * there are no circular references in your object, you can save some CPU time
 * by calling clone(obj, false).
 *
 * Caution: if `circular` is false and `parent` contains circular references,
 * your program may enter an infinite loop and crash.
 *
 * @param `parent` - the object to be cloned
 * @param `circular` - set to true if the object to be cloned may contain
 *    circular references. (optional - true by default)
 * @param `depth` - set to a number if the object is only to be cloned to
 *    a particular depth. (optional - defaults to Infinity)
 * @param `prototype` - sets the prototype to be used when cloning an object.
 *    (optional - defaults to parent prototype).
 * @param `includeNonEnumerable` - set to true if the non-enumerable properties
 *    should be cloned as well. Non-enumerable properties on the prototype
 *    chain will be ignored. (optional - false by default)
*/
function clone(parent, circular, depth, prototype, includeNonEnumerable) {
  if (typeof circular === 'object') {
    depth = circular.depth;
    prototype = circular.prototype;
    includeNonEnumerable = circular.includeNonEnumerable;
    circular = circular.circular;
  }
  // maintain two arrays for circular references, where corresponding parents
  // and children have the same index
  var allParents = [];
  var allChildren = [];

  var useBuffer = typeof Buffer != 'undefined';

  if (typeof circular == 'undefined')
    circular = true;

  if (typeof depth == 'undefined')
    depth = Infinity;

  // recurse this function so we don't reset allParents and allChildren
  function _clone(parent, depth) {
    // cloning null always returns null
    if (parent === null)
      return null;

    if (depth === 0)
      return parent;

    var child;
    var proto;
    if (typeof parent != 'object') {
      return parent;
    }

    if (_instanceof(parent, nativeMap)) {
      child = new nativeMap();
    } else if (_instanceof(parent, nativeSet)) {
      child = new nativeSet();
    } else if (_instanceof(parent, nativePromise)) {
      child = new nativePromise(function (resolve, reject) {
        parent.then(function(value) {
          resolve(_clone(value, depth - 1));
        }, function(err) {
          reject(_clone(err, depth - 1));
        });
      });
    } else if (clone.__isArray(parent)) {
      child = [];
    } else if (clone.__isRegExp(parent)) {
      child = new RegExp(parent.source, __getRegExpFlags(parent));
      if (parent.lastIndex) child.lastIndex = parent.lastIndex;
    } else if (clone.__isDate(parent)) {
      child = new Date(parent.getTime());
    } else if (useBuffer && Buffer.isBuffer(parent)) {
      if (Buffer.allocUnsafe) {
        // Node.js >= 4.5.0
        child = Buffer.allocUnsafe(parent.length);
      } else {
        // Older Node.js versions
        child = new Buffer(parent.length);
      }
      parent.copy(child);
      return child;
    } else if (_instanceof(parent, Error)) {
      child = Object.create(parent);
    } else {
      if (typeof prototype == 'undefined') {
        proto = Object.getPrototypeOf(parent);
        child = Object.create(proto);
      }
      else {
        child = Object.create(prototype);
        proto = prototype;
      }
    }

    if (circular) {
      var index = allParents.indexOf(parent);

      if (index != -1) {
        return allChildren[index];
      }
      allParents.push(parent);
      allChildren.push(child);
    }

    if (_instanceof(parent, nativeMap)) {
      parent.forEach(function(value, key) {
        var keyChild = _clone(key, depth - 1);
        var valueChild = _clone(value, depth - 1);
        child.set(keyChild, valueChild);
      });
    }
    if (_instanceof(parent, nativeSet)) {
      parent.forEach(function(value) {
        var entryChild = _clone(value, depth - 1);
        child.add(entryChild);
      });
    }

    for (var i in parent) {
      var attrs;
      if (proto) {
        attrs = Object.getOwnPropertyDescriptor(proto, i);
      }

      if (attrs && attrs.set == null) {
        continue;
      }
      child[i] = _clone(parent[i], depth - 1);
    }

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(parent);
      for (var i = 0; i < symbols.length; i++) {
        // Don't need to worry about cloning a symbol because it is a primitive,
        // like a number or string.
        var symbol = symbols[i];
        var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);
        if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
          continue;
        }
        child[symbol] = _clone(parent[symbol], depth - 1);
        if (!descriptor.enumerable) {
          Object.defineProperty(child, symbol, {
            enumerable: false
          });
        }
      }
    }

    if (includeNonEnumerable) {
      var allPropertyNames = Object.getOwnPropertyNames(parent);
      for (var i = 0; i < allPropertyNames.length; i++) {
        var propertyName = allPropertyNames[i];
        var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);
        if (descriptor && descriptor.enumerable) {
          continue;
        }
        child[propertyName] = _clone(parent[propertyName], depth - 1);
        Object.defineProperty(child, propertyName, {
          enumerable: false
        });
      }
    }

    return child;
  }

  return _clone(parent, depth);
}

/**
 * Simple flat clone using prototype, accepts only objects, usefull for property
 * override on FLAT configuration object (no nested props).
 *
 * USE WITH CAUTION! This may not behave as you wish if you do not know how this
 * works.
 */
clone.clonePrototype = function clonePrototype(parent) {
  if (parent === null)
    return null;

  var c = function () {};
  c.prototype = parent;
  return new c();
};

// private utility functions

function __objToStr(o) {
  return Object.prototype.toString.call(o);
}
clone.__objToStr = __objToStr;

function __isDate(o) {
  return typeof o === 'object' && __objToStr(o) === '[object Date]';
}
clone.__isDate = __isDate;

function __isArray(o) {
  return typeof o === 'object' && __objToStr(o) === '[object Array]';
}
clone.__isArray = __isArray;

function __isRegExp(o) {
  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
}
clone.__isRegExp = __isRegExp;

function __getRegExpFlags(re) {
  var flags = '';
  if (re.global) flags += 'g';
  if (re.ignoreCase) flags += 'i';
  if (re.multiline) flags += 'm';
  return flags;
}
clone.__getRegExpFlags = __getRegExpFlags;

return clone;
})();

if (typeof module === 'object' && module.exports) {
  module.exports = clone;
}

}).call(this,require("buffer").Buffer)

},{"buffer":133}],135:[function(require,module,exports){
var __root__ = (function (root) {
function F() { this.fetch = false; }
F.prototype = root;
return new F();
})(typeof self !== 'undefined' ? self : this);
(function(self) {

(function(self) {

  if (self.fetch) {
    return
  }

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob: 'FileReader' in self && 'Blob' in self && (function() {
      try {
        new Blob();
        return true
      } catch(e) {
        return false
      }
    })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ];

    var isDataView = function(obj) {
      return obj && DataView.prototype.isPrototypeOf(obj)
    };

    var isArrayBufferView = ArrayBuffer.isView || function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return {done: value === undefined, value: value}
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      };
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue+','+value : value;
  };

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null
  };

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  };

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) { items.push(name); });
    return iteratorFor(items)
  };

  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) { items.push(value); });
    return iteratorFor(items)
  };

  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) { items.push([name, value]); });
    return iteratorFor(items)
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function(body) {
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        throw new Error('unsupported BodyInit type')
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      };

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      };
    }

    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    };

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      };
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    };

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return (methods.indexOf(upcased) > -1) ? upcased : method
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'omit';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body);
  }

  Request.prototype.clone = function() {
    return new Request(this, { body: this._bodyInit })
  };

  function decode(body) {
    var form = new FormData();
    body.trim().split('&').forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=');
        var name = split.shift().replace(/\+/g, ' ');
        var value = split.join('=').replace(/\+/g, ' ');
        form.append(decodeURIComponent(name), decodeURIComponent(value));
      }
    });
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
    // https://tools.ietf.org/html/rfc7230#section-3.2
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
    preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':');
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(':').trim();
        headers.append(key, value);
      }
    });
    return headers
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = options.status === undefined ? 200 : options.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = 'statusText' in options ? options.statusText : 'OK';
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  };

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''});
    response.type = 'error';
    return response
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  };

  self.Headers = Headers;
  self.Request = Request;
  self.Response = Response;

  self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init);
      var xhr = new XMLHttpRequest();

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options));
      };

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.open(request.method, request.url, true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      } else if (request.credentials === 'omit') {
        xhr.withCredentials = false;
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    })
  };
  self.fetch.polyfill = true;
})(typeof self !== 'undefined' ? self : this);
}).call(__root__, void(0));
var fetch = __root__.fetch;
var Response = fetch.Response = __root__.Response;
var Request = fetch.Request = __root__.Request;
var Headers = fetch.Headers = __root__.Headers;
if (typeof module === 'object' && module.exports) {
module.exports = fetch;
// Needed for TypeScript consumers without esModuleInterop.
module.exports.default = fetch;
}

},{}],136:[function(require,module,exports){
'use strict';

const processFn = (fn, opts) => function () {
	const P = opts.promiseModule;
	const args = new Array(arguments.length);

	for (let i = 0; i < arguments.length; i++) {
		args[i] = arguments[i];
	}

	return new P((resolve, reject) => {
		if (opts.errorFirst) {
			args.push(function (err, result) {
				if (opts.multiArgs) {
					const results = new Array(arguments.length - 1);

					for (let i = 1; i < arguments.length; i++) {
						results[i - 1] = arguments[i];
					}

					if (err) {
						results.unshift(err);
						reject(results);
					} else {
						resolve(results);
					}
				} else if (err) {
					reject(err);
				} else {
					resolve(result);
				}
			});
		} else {
			args.push(function (result) {
				if (opts.multiArgs) {
					const results = new Array(arguments.length - 1);

					for (let i = 0; i < arguments.length; i++) {
						results[i] = arguments[i];
					}

					resolve(results);
				} else {
					resolve(result);
				}
			});
		}

		fn.apply(this, args);
	});
};

module.exports = (obj, opts) => {
	opts = Object.assign({
		exclude: [/.+(Sync|Stream)$/],
		errorFirst: true,
		promiseModule: Promise
	}, opts);

	const filter = key => {
		const match = pattern => typeof pattern === 'string' ? key === pattern : pattern.test(key);
		return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
	};

	let ret;
	if (typeof obj === 'function') {
		ret = function () {
			if (opts.excludeMain) {
				return obj.apply(this, arguments);
			}

			return processFn(obj, opts).apply(this, arguments);
		};
	} else {
		ret = Object.create(Object.getPrototypeOf(obj));
	}

	for (const key in obj) { // eslint-disable-line guard-for-in
		const x = obj[key];
		ret[key] = typeof x === 'function' && filter(key) ? processFn(x, opts) : x;
	}

	return ret;
};

},{}],137:[function(require,module,exports){
const EthQuery = require('eth-query')
const pify = require('pify')
const SafeEventEmitter = require('safe-event-emitter')

const sec = 1000

const calculateSum = (accumulator, currentValue) => accumulator + currentValue
const blockTrackerEvents = ['sync', 'latest']

class BaseBlockTracker extends SafeEventEmitter {

  //
  // public
  //

  constructor (opts = {}) {
    super()
    // config
    this._blockResetDuration = opts.blockResetDuration || 20 * sec
    // state
    this._blockResetTimeout
    this._currentBlock = null
    this._isRunning = false
    // bind functions for internal use
    this._onNewListener = this._onNewListener.bind(this)
    this._onRemoveListener = this._onRemoveListener.bind(this)
    this._resetCurrentBlock = this._resetCurrentBlock.bind(this)
    // listen for handler changes
    this._setupInternalEvents()
  }

  isRunning () {
    return this._isRunning
  }

  getCurrentBlock () {
    return this._currentBlock
  }

  async getLatestBlock () {
    // return if available
    if (this._currentBlock) return this._currentBlock
    // wait for a new latest block
    const latestBlock = await new Promise(resolve => this.once('latest', resolve))
    // return newly set current block
    return latestBlock
  }

  // dont allow module consumer to remove our internal event listeners
  removeAllListeners (eventName) {
    // perform default behavior, preserve fn arity
    if (eventName) {
      super.removeAllListeners(eventName)
    } else {
      super.removeAllListeners()
    }
    // re-add internal events
    this._setupInternalEvents()
    // trigger stop check just in case
    this._onRemoveListener()
  }

  //
  // to be implemented in subclass
  //

  _start () {
    // default behavior is noop
  }

  _end () {
    // default behavior is noop
  }

  //
  // private
  //

  _setupInternalEvents () {
    // first remove listeners for idempotence
    this.removeListener('newListener', this._onNewListener)
    this.removeListener('removeListener', this._onRemoveListener)
    // then add them
    this.on('newListener', this._onNewListener)
    this.on('removeListener', this._onRemoveListener)
  }

  _onNewListener (eventName, handler) {
    // `newListener` is called *before* the listener is added
    if (!blockTrackerEvents.includes(eventName)) return
    this._maybeStart()
  }

  _onRemoveListener (eventName, handler) {
    // `removeListener` is called *after* the listener is removed
    if (this._getBlockTrackerEventCount() > 0) return
    this._maybeEnd()
  }

  _maybeStart () {
    if (this._isRunning) return
    this._isRunning = true
    // cancel setting latest block to stale
    this._cancelBlockResetTimeout()
    this._start()
  }

  _maybeEnd () {
    if (!this._isRunning) return
    this._isRunning = false
    this._setupBlockResetTimeout()
    this._end()
  }

  _getBlockTrackerEventCount () {
    return blockTrackerEvents
      .map(eventName => this.listenerCount(eventName))
      .reduce(calculateSum)
  }

  _newPotentialLatest (newBlock) {
    const currentBlock = this._currentBlock
    // only update if blok number is higher
    if (currentBlock && (hexToInt(newBlock) <= hexToInt(currentBlock))) return
    this._setCurrentBlock(newBlock)
  }

  _setCurrentBlock (newBlock) {
    const oldBlock = this._currentBlock
    this._currentBlock = newBlock
    this.emit('latest', newBlock)
    this.emit('sync', { oldBlock, newBlock })
  }

  _setupBlockResetTimeout () {
    // clear any existing timeout
    this._cancelBlockResetTimeout()
    // clear latest block when stale
    this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration)
    // nodejs - dont hold process open
    if (this._blockResetTimeout.unref) {
      this._blockResetTimeout.unref()
    }
  }

  _cancelBlockResetTimeout () {
    clearTimeout(this._blockResetTimeout)
  }

  _resetCurrentBlock () {
    this._currentBlock = null
  }

}

module.exports = BaseBlockTracker

function hexToInt(hexInt) {
  return Number.parseInt(hexInt, 16)
}

},{"eth-query":139,"pify":136,"safe-event-emitter":155}],138:[function(require,module,exports){
const pify = require('pify')
const BaseBlockTracker = require('./base')

const sec = 1000

class PollingBlockTracker extends BaseBlockTracker {

  constructor (opts = {}) {
    // parse + validate args
    if (!opts.provider) throw new Error('PollingBlockTracker - no provider specified.')
    const pollingInterval = opts.pollingInterval || 20 * sec
    const retryTimeout = opts.retryTimeout || pollingInterval / 10
    const keepEventLoopActive = opts.keepEventLoopActive !== undefined ? opts.keepEventLoopActive : true
    const setSkipCacheFlag = opts.setSkipCacheFlag || false
    // BaseBlockTracker constructor
    super(Object.assign({
      blockResetDuration: pollingInterval,
    }, opts))
    // config
    this._provider = opts.provider
    this._pollingInterval = pollingInterval
    this._retryTimeout = retryTimeout
    this._keepEventLoopActive = keepEventLoopActive
    this._setSkipCacheFlag = setSkipCacheFlag
  }

  //
  // public
  //

  // trigger block polling
  async checkForLatestBlock () {
    await this._updateLatestBlock()
    return await this.getLatestBlock()
  }

  //
  // private
  //

  _start () {
    this._performSync().catch(err => this.emit('error', err))
  }

  async _performSync () {
    while (this._isRunning) {
      try {
        await this._updateLatestBlock()
        await timeout(this._pollingInterval, !this._keepEventLoopActive)
      } catch (err) {
        const newErr = new Error(`PollingBlockTracker - encountered an error while attempting to update latest block:\n${err.stack}`)
        try {
          this.emit('error', newErr)
        } catch (emitErr) {
          console.error(newErr)
        }
        await timeout(this._retryTimeout, !this._keepEventLoopActive)
      }
    }
  }

  async _updateLatestBlock () {
    // fetch + set latest block
    const latestBlock = await this._fetchLatestBlock()
    this._newPotentialLatest(latestBlock)
  }

  async _fetchLatestBlock () {
    const req = { jsonrpc: "2.0", id: 1, method: 'eth_blockNumber', params: [] }
    if (this._setSkipCacheFlag) req.skipCache = true
    const res = await pify((cb) => this._provider.sendAsync(req, cb))()
    if (res.error) throw new Error(`PollingBlockTracker - encountered error fetching block:\n${res.error}`)
    return res.result
  }

}

module.exports = PollingBlockTracker

function timeout (duration, unref) {
  return new Promise(resolve => {
    const timoutRef = setTimeout(resolve, duration)
    // don't keep process open
    if (timoutRef.unref && unref) {
      timoutRef.unref()
    }
  })
}

},{"./base":137,"pify":136}],139:[function(require,module,exports){
const extend = require('xtend')
const createRandomId = require('json-rpc-random-id')()

module.exports = EthQuery


function EthQuery(provider){
  const self = this
  self.currentProvider = provider
}

//
// base queries
//

// default block
EthQuery.prototype.getBalance =                          generateFnWithDefaultBlockFor(2, 'eth_getBalance')
EthQuery.prototype.getCode =                             generateFnWithDefaultBlockFor(2, 'eth_getCode')
EthQuery.prototype.getTransactionCount =                 generateFnWithDefaultBlockFor(2, 'eth_getTransactionCount')
EthQuery.prototype.getStorageAt =                        generateFnWithDefaultBlockFor(3, 'eth_getStorageAt')
EthQuery.prototype.call =                                generateFnWithDefaultBlockFor(2, 'eth_call')
// standard
EthQuery.prototype.protocolVersion =                     generateFnFor('eth_protocolVersion')
EthQuery.prototype.syncing =                             generateFnFor('eth_syncing')
EthQuery.prototype.coinbase =                            generateFnFor('eth_coinbase')
EthQuery.prototype.mining =                              generateFnFor('eth_mining')
EthQuery.prototype.hashrate =                            generateFnFor('eth_hashrate')
EthQuery.prototype.gasPrice =                            generateFnFor('eth_gasPrice')
EthQuery.prototype.accounts =                            generateFnFor('eth_accounts')
EthQuery.prototype.blockNumber =                         generateFnFor('eth_blockNumber')
EthQuery.prototype.getBlockTransactionCountByHash =      generateFnFor('eth_getBlockTransactionCountByHash')
EthQuery.prototype.getBlockTransactionCountByNumber =    generateFnFor('eth_getBlockTransactionCountByNumber')
EthQuery.prototype.getUncleCountByBlockHash =            generateFnFor('eth_getUncleCountByBlockHash')
EthQuery.prototype.getUncleCountByBlockNumber =          generateFnFor('eth_getUncleCountByBlockNumber')
EthQuery.prototype.sign =                                generateFnFor('eth_sign')
EthQuery.prototype.sendTransaction =                     generateFnFor('eth_sendTransaction')
EthQuery.prototype.sendRawTransaction =                  generateFnFor('eth_sendRawTransaction')
EthQuery.prototype.estimateGas =                         generateFnFor('eth_estimateGas')
EthQuery.prototype.getBlockByHash =                      generateFnFor('eth_getBlockByHash')
EthQuery.prototype.getBlockByNumber =                    generateFnFor('eth_getBlockByNumber')
EthQuery.prototype.getTransactionByHash =                generateFnFor('eth_getTransactionByHash')
EthQuery.prototype.getTransactionByBlockHashAndIndex =   generateFnFor('eth_getTransactionByBlockHashAndIndex')
EthQuery.prototype.getTransactionByBlockNumberAndIndex = generateFnFor('eth_getTransactionByBlockNumberAndIndex')
EthQuery.prototype.getTransactionReceipt =               generateFnFor('eth_getTransactionReceipt')
EthQuery.prototype.getUncleByBlockHashAndIndex =         generateFnFor('eth_getUncleByBlockHashAndIndex')
EthQuery.prototype.getUncleByBlockNumberAndIndex =       generateFnFor('eth_getUncleByBlockNumberAndIndex')
EthQuery.prototype.getCompilers =                        generateFnFor('eth_getCompilers')
EthQuery.prototype.compileLLL =                          generateFnFor('eth_compileLLL')
EthQuery.prototype.compileSolidity =                     generateFnFor('eth_compileSolidity')
EthQuery.prototype.compileSerpent =                      generateFnFor('eth_compileSerpent')
EthQuery.prototype.newFilter =                           generateFnFor('eth_newFilter')
EthQuery.prototype.newBlockFilter =                      generateFnFor('eth_newBlockFilter')
EthQuery.prototype.newPendingTransactionFilter =         generateFnFor('eth_newPendingTransactionFilter')
EthQuery.prototype.uninstallFilter =                     generateFnFor('eth_uninstallFilter')
EthQuery.prototype.getFilterChanges =                    generateFnFor('eth_getFilterChanges')
EthQuery.prototype.getFilterLogs =                       generateFnFor('eth_getFilterLogs')
EthQuery.prototype.getLogs =                             generateFnFor('eth_getLogs')
EthQuery.prototype.getWork =                             generateFnFor('eth_getWork')
EthQuery.prototype.submitWork =                          generateFnFor('eth_submitWork')
EthQuery.prototype.submitHashrate =                      generateFnFor('eth_submitHashrate')

// network level

EthQuery.prototype.sendAsync = function(opts, cb){
  const self = this
  self.currentProvider.sendAsync(createPayload(opts), function(err, response){
    if (!err && response.error) err = new Error('EthQuery - RPC Error - '+response.error.message)
    if (err) return cb(err)
    cb(null, response.result)
  })
}

// util

function generateFnFor(methodName){
  return function(){
    const self = this
    var args = [].slice.call(arguments)
    var cb = args.pop()
    self.sendAsync({
      method: methodName,
      params: args,
    }, cb)
  }
}

function generateFnWithDefaultBlockFor(argCount, methodName){
  return function(){
    const self = this
    var args = [].slice.call(arguments)
    var cb = args.pop()
    // set optional default block param
    if (args.length < argCount) args.push('latest')
    self.sendAsync({
      method: methodName,
      params: args,
    }, cb)
  }
}

function createPayload(data){
  return extend({
    // defaults
    id: createRandomId(),
    jsonrpc: '2.0',
    params: [],
    // user-specified
  }, data)
}

},{"json-rpc-random-id":148,"xtend":171}],140:[function(require,module,exports){
(function (Buffer){
'use strict';

var isHexPrefixed = require('is-hex-prefixed');
var stripHexPrefix = require('strip-hex-prefix');

/**
 * Pads a `String` to have an even length
 * @param {String} value
 * @return {String} output
 */
function padToEven(value) {
  var a = value; // eslint-disable-line

  if (typeof a !== 'string') {
    throw new Error('[ethjs-util] while padding to even, value must be string, is currently ' + typeof a + ', while padToEven.');
  }

  if (a.length % 2) {
    a = '0' + a;
  }

  return a;
}

/**
 * Converts a `Number` into a hex `String`
 * @param {Number} i
 * @return {String}
 */
function intToHex(i) {
  var hex = i.toString(16); // eslint-disable-line

  return '0x' + hex;
}

/**
 * Converts an `Number` to a `Buffer`
 * @param {Number} i
 * @return {Buffer}
 */
function intToBuffer(i) {
  var hex = intToHex(i);

  return new Buffer(padToEven(hex.slice(2)), 'hex');
}

/**
 * Get the binary size of a string
 * @param {String} str
 * @return {Number}
 */
function getBinarySize(str) {
  if (typeof str !== 'string') {
    throw new Error('[ethjs-util] while getting binary size, method getBinarySize requires input \'str\' to be type String, got \'' + typeof str + '\'.');
  }

  return Buffer.byteLength(str, 'utf8');
}

/**
 * Returns TRUE if the first specified array contains all elements
 * from the second one. FALSE otherwise.
 *
 * @param {array} superset
 * @param {array} subset
 *
 * @returns {boolean}
 */
function arrayContainsArray(superset, subset, some) {
  if (Array.isArray(superset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'superset\' to be an array got type \'' + typeof superset + '\'');
  }
  if (Array.isArray(subset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'subset\' to be an array got type \'' + typeof subset + '\'');
  }

  return subset[Boolean(some) && 'some' || 'every'](function (value) {
    return superset.indexOf(value) >= 0;
  });
}

/**
 * Should be called to get utf8 from it's hex representation
 *
 * @method toUtf8
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toUtf8(hex) {
  var bufferValue = new Buffer(padToEven(stripHexPrefix(hex).replace(/^0+|0+$/g, '')), 'hex');

  return bufferValue.toString('utf8');
}

/**
 * Should be called to get ascii from it's hex representation
 *
 * @method toAscii
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toAscii(hex) {
  var str = ''; // eslint-disable-line
  var i = 0,
      l = hex.length; // eslint-disable-line

  if (hex.substring(0, 2) === '0x') {
    i = 2;
  }

  for (; i < l; i += 2) {
    var code = parseInt(hex.substr(i, 2), 16);
    str += String.fromCharCode(code);
  }

  return str;
}

/**
 * Should be called to get hex representation (prefixed by 0x) of utf8 string
 *
 * @method fromUtf8
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromUtf8(stringValue) {
  var str = new Buffer(stringValue, 'utf8');

  return '0x' + padToEven(str.toString('hex')).replace(/^0+|0+$/g, '');
}

/**
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 *
 * @method fromAscii
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromAscii(stringValue) {
  var hex = ''; // eslint-disable-line
  for (var i = 0; i < stringValue.length; i++) {
    // eslint-disable-line
    var code = stringValue.charCodeAt(i);
    var n = code.toString(16);
    hex += n.length < 2 ? '0' + n : n;
  }

  return '0x' + hex;
}

/**
 * getKeys([{a: 1, b: 2}, {a: 3, b: 4}], 'a') => [1, 3]
 *
 * @method getKeys get specific key from inner object array of objects
 * @param {String} params
 * @param {String} key
 * @param {Boolean} allowEmpty
 * @returns {Array} output just a simple array of output keys
 */
function getKeys(params, key, allowEmpty) {
  if (!Array.isArray(params)) {
    throw new Error('[ethjs-util] method getKeys expecting type Array as \'params\' input, got \'' + typeof params + '\'');
  }
  if (typeof key !== 'string') {
    throw new Error('[ethjs-util] method getKeys expecting type String for input \'key\' got \'' + typeof key + '\'.');
  }

  var result = []; // eslint-disable-line

  for (var i = 0; i < params.length; i++) {
    // eslint-disable-line
    var value = params[i][key]; // eslint-disable-line
    if (allowEmpty && !value) {
      value = '';
    } else if (typeof value !== 'string') {
      throw new Error('invalid abi');
    }
    result.push(value);
  }

  return result;
}

/**
 * Is the string a hex string.
 *
 * @method check if string is hex string of specific length
 * @param {String} value
 * @param {Number} length
 * @returns {Boolean} output the string is a hex string
 */
function isHexString(value, length) {
  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }

  if (length && value.length !== 2 + 2 * length) {
    return false;
  }

  return true;
}

module.exports = {
  arrayContainsArray: arrayContainsArray,
  intToBuffer: intToBuffer,
  getBinarySize: getBinarySize,
  isHexPrefixed: isHexPrefixed,
  stripHexPrefix: stripHexPrefix,
  padToEven: padToEven,
  intToHex: intToHex,
  fromAscii: fromAscii,
  fromUtf8: fromUtf8,
  toAscii: toAscii,
  toUtf8: toUtf8,
  getKeys: getKeys,
  isHexString: isHexString
};
}).call(this,require("buffer").Buffer)

},{"buffer":133,"is-hex-prefixed":145,"strip-hex-prefix":157}],141:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = $getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  var args = [];
  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    ReflectApply(this.listener, this.target, args);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

},{}],142:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],143:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],144:[function(require,module,exports){
'use strict';
var toString = Object.prototype.toString;

module.exports = function (x) {
	return toString.call(x) === '[object Function]';
};

},{}],145:[function(require,module,exports){
/**
 * Returns a `Boolean` on whether or not the a `String` starts with '0x'
 * @param {String} str the string input value
 * @return {Boolean} a boolean if it is or is not hex prefixed
 * @throws if the str input is not a string
 */
module.exports = function isHexPrefixed(str) {
  if (typeof str !== 'string') {
    throw new Error("[is-hex-prefixed] value must be type 'string', is currently type " + (typeof str) + ", while checking isHexPrefixed.");
  }

  return str.slice(0, 2) === '0x';
}

},{}],146:[function(require,module,exports){
module.exports = require('./lib/errors');
},{"./lib/errors":147}],147:[function(require,module,exports){
var inherits = require('inherits');

var JsonRpcError = function(message, code, data) {
  if (!(this instanceof JsonRpcError)) {
    return new JsonRpcError(message, code, data);
  }

  this.message = message;
  this.code = code;

  if (typeof data !== 'undefined') {
    this.data = data;
  }
};

inherits(JsonRpcError, Error);

var ParseError = function() {
  if (!(this instanceof ParseError)) {
    return new ParseError();
  }

  JsonRpcError.call(this, 'Parse error', -32700);
};

inherits(ParseError, JsonRpcError);

var InvalidRequest = function() {
  if (!(this instanceof InvalidRequest)) {
    return new InvalidRequest();
  }

  JsonRpcError.call(this, 'Invalid Request', -32600);
};

inherits(InvalidRequest, JsonRpcError);

var MethodNotFound = function() {
  if (!(this instanceof MethodNotFound)) {
    return new MethodNotFound();
  }

  JsonRpcError.call(this, 'Method not found', -32601);
};

inherits(MethodNotFound, JsonRpcError);

var InvalidParams = function() {
  if (!(this instanceof InvalidParams)) {
    return new InvalidParams();
  }

  JsonRpcError.call(this, 'Invalid params', -32602);
};

inherits(InvalidParams, JsonRpcError);

var InternalError = function(err) {
  var message;

  if (!(this instanceof InternalError)) {
    return new InternalError(err);
  }

  if (err && err.message) {
    message = err.message;
  } else {
    message = 'Internal error';
  }

  JsonRpcError.call(this, message, -32603);
};

inherits(InternalError, JsonRpcError);

var ServerError = function(code) {
  if (code < -32099 || code > -32000) {
    throw new Error('Invalid error code');
  }

  if (!(this instanceof ServerError)) {
    return new ServerError(code);
  }

  JsonRpcError.call(this, 'Server error', code);
};

inherits(ServerError, JsonRpcError);

JsonRpcError.ParseError = ParseError;
JsonRpcError.InvalidRequest = InvalidRequest;
JsonRpcError.MethodNotFound = MethodNotFound;
JsonRpcError.InvalidParams = InvalidParams;
JsonRpcError.InternalError = InternalError;
JsonRpcError.ServerError = ServerError;

module.exports = JsonRpcError;



},{"inherits":143}],148:[function(require,module,exports){
module.exports = IdIterator

function IdIterator(opts){
  opts = opts || {}
  var max = opts.max || Number.MAX_SAFE_INTEGER
  var idCounter = typeof opts.start !== 'undefined' ? opts.start : Math.floor(Math.random() * max)

  return function createRandomId () {
    idCounter = idCounter % max
    return idCounter++
  }

}
},{}],149:[function(require,module,exports){
var json = typeof JSON !== 'undefined' ? JSON : require('jsonify');

module.exports = function (obj, opts) {
    if (!opts) opts = {};
    if (typeof opts === 'function') opts = { cmp: opts };
    var space = opts.space || '';
    if (typeof space === 'number') space = Array(space+1).join(' ');
    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;
    var replacer = opts.replacer || function(key, value) { return value; };

    var cmp = opts.cmp && (function (f) {
        return function (node) {
            return function (a, b) {
                var aobj = { key: a, value: node[a] };
                var bobj = { key: b, value: node[b] };
                return f(aobj, bobj);
            };
        };
    })(opts.cmp);

    var seen = [];
    return (function stringify (parent, key, node, level) {
        var indent = space ? ('\n' + new Array(level + 1).join(space)) : '';
        var colonSeparator = space ? ': ' : ':';

        if (node && node.toJSON && typeof node.toJSON === 'function') {
            node = node.toJSON();
        }

        node = replacer.call(parent, key, node);

        if (node === undefined) {
            return;
        }
        if (typeof node !== 'object' || node === null) {
            return json.stringify(node);
        }
        if (isArray(node)) {
            var out = [];
            for (var i = 0; i < node.length; i++) {
                var item = stringify(node, i, node[i], level+1) || json.stringify(null);
                out.push(indent + space + item);
            }
            return '[' + out.join(',') + indent + ']';
        }
        else {
            if (seen.indexOf(node) !== -1) {
                if (cycles) return json.stringify('__cycle__');
                throw new TypeError('Converting circular structure to JSON');
            }
            else seen.push(node);

            var keys = objectKeys(node).sort(cmp && cmp(node));
            var out = [];
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var value = stringify(node, key, node[key], level+1);

                if(!value) continue;

                var keyValue = json.stringify(key)
                    + colonSeparator
                    + value;
                ;
                out.push(indent + space + keyValue);
            }
            seen.splice(seen.indexOf(node), 1);
            return '{' + out.join(',') + indent + '}';
        }
    })({ '': obj }, '', obj, 0);
};

var isArray = Array.isArray || function (x) {
    return {}.toString.call(x) === '[object Array]';
};

var objectKeys = Object.keys || function (obj) {
    var has = Object.prototype.hasOwnProperty || function () { return true };
    var keys = [];
    for (var key in obj) {
        if (has.call(obj, key)) keys.push(key);
    }
    return keys;
};

},{"jsonify":150}],150:[function(require,module,exports){
exports.parse = require('./lib/parse');
exports.stringify = require('./lib/stringify');

},{"./lib/parse":151,"./lib/stringify":152}],151:[function(require,module,exports){
var at, // The index of the current character
    ch, // The current character
    escapee = {
        '"':  '"',
        '\\': '\\',
        '/':  '/',
        b:    '\b',
        f:    '\f',
        n:    '\n',
        r:    '\r',
        t:    '\t'
    },
    text,

    error = function (m) {
        // Call error when something is wrong.
        throw {
            name:    'SyntaxError',
            message: m,
            at:      at,
            text:    text
        };
    },
    
    next = function (c) {
        // If a c parameter is provided, verify that it matches the current character.
        if (c && c !== ch) {
            error("Expected '" + c + "' instead of '" + ch + "'");
        }
        
        // Get the next character. When there are no more characters,
        // return the empty string.
        
        ch = text.charAt(at);
        at += 1;
        return ch;
    },
    
    number = function () {
        // Parse a number value.
        var number,
            string = '';
        
        if (ch === '-') {
            string = '-';
            next('-');
        }
        while (ch >= '0' && ch <= '9') {
            string += ch;
            next();
        }
        if (ch === '.') {
            string += '.';
            while (next() && ch >= '0' && ch <= '9') {
                string += ch;
            }
        }
        if (ch === 'e' || ch === 'E') {
            string += ch;
            next();
            if (ch === '-' || ch === '+') {
                string += ch;
                next();
            }
            while (ch >= '0' && ch <= '9') {
                string += ch;
                next();
            }
        }
        number = +string;
        if (!isFinite(number)) {
            error("Bad number");
        } else {
            return number;
        }
    },
    
    string = function () {
        // Parse a string value.
        var hex,
            i,
            string = '',
            uffff;
        
        // When parsing for string values, we must look for " and \ characters.
        if (ch === '"') {
            while (next()) {
                if (ch === '"') {
                    next();
                    return string;
                } else if (ch === '\\') {
                    next();
                    if (ch === 'u') {
                        uffff = 0;
                        for (i = 0; i < 4; i += 1) {
                            hex = parseInt(next(), 16);
                            if (!isFinite(hex)) {
                                break;
                            }
                            uffff = uffff * 16 + hex;
                        }
                        string += String.fromCharCode(uffff);
                    } else if (typeof escapee[ch] === 'string') {
                        string += escapee[ch];
                    } else {
                        break;
                    }
                } else {
                    string += ch;
                }
            }
        }
        error("Bad string");
    },

    white = function () {

// Skip whitespace.

        while (ch && ch <= ' ') {
            next();
        }
    },

    word = function () {

// true, false, or null.

        switch (ch) {
        case 't':
            next('t');
            next('r');
            next('u');
            next('e');
            return true;
        case 'f':
            next('f');
            next('a');
            next('l');
            next('s');
            next('e');
            return false;
        case 'n':
            next('n');
            next('u');
            next('l');
            next('l');
            return null;
        }
        error("Unexpected '" + ch + "'");
    },

    value,  // Place holder for the value function.

    array = function () {

// Parse an array value.

        var array = [];

        if (ch === '[') {
            next('[');
            white();
            if (ch === ']') {
                next(']');
                return array;   // empty array
            }
            while (ch) {
                array.push(value());
                white();
                if (ch === ']') {
                    next(']');
                    return array;
                }
                next(',');
                white();
            }
        }
        error("Bad array");
    },

    object = function () {

// Parse an object value.

        var key,
            object = {};

        if (ch === '{') {
            next('{');
            white();
            if (ch === '}') {
                next('}');
                return object;   // empty object
            }
            while (ch) {
                key = string();
                white();
                next(':');
                if (Object.hasOwnProperty.call(object, key)) {
                    error('Duplicate key "' + key + '"');
                }
                object[key] = value();
                white();
                if (ch === '}') {
                    next('}');
                    return object;
                }
                next(',');
                white();
            }
        }
        error("Bad object");
    };

value = function () {

// Parse a JSON value. It could be an object, an array, a string, a number,
// or a word.

    white();
    switch (ch) {
    case '{':
        return object();
    case '[':
        return array();
    case '"':
        return string();
    case '-':
        return number();
    default:
        return ch >= '0' && ch <= '9' ? number() : word();
    }
};

// Return the json_parse function. It will have access to all of the above
// functions and variables.

module.exports = function (source, reviver) {
    var result;
    
    text = source;
    at = 0;
    ch = ' ';
    result = value();
    white();
    if (ch) {
        error("Syntax error");
    }

    // If there is a reviver function, we recursively walk the new structure,
    // passing each name/value pair to the reviver function for possible
    // transformation, starting with a temporary root object that holds the result
    // in an empty key. If there is not a reviver function, we simply return the
    // result.

    return typeof reviver === 'function' ? (function walk(holder, key) {
        var k, v, value = holder[key];
        if (value && typeof value === 'object') {
            for (k in value) {
                if (Object.prototype.hasOwnProperty.call(value, k)) {
                    v = walk(value, k);
                    if (v !== undefined) {
                        value[k] = v;
                    } else {
                        delete value[k];
                    }
                }
            }
        }
        return reviver.call(holder, key, value);
    }({'': result}, '')) : result;
};

},{}],152:[function(require,module,exports){
var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    gap,
    indent,
    meta = {    // table of character substitutions
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"' : '\\"',
        '\\': '\\\\'
    },
    rep;

function quote(string) {
    // If the string contains no control characters, no quote characters, and no
    // backslash characters, then we can safely slap some quotes around it.
    // Otherwise we must also replace the offending characters with safe escape
    // sequences.
    
    escapable.lastIndex = 0;
    return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
        var c = meta[a];
        return typeof c === 'string' ? c :
            '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    }) + '"' : '"' + string + '"';
}

function str(key, holder) {
    // Produce a string from holder[key].
    var i,          // The loop counter.
        k,          // The member key.
        v,          // The member value.
        length,
        mind = gap,
        partial,
        value = holder[key];
    
    // If the value has a toJSON method, call it to obtain a replacement value.
    if (value && typeof value === 'object' &&
            typeof value.toJSON === 'function') {
        value = value.toJSON(key);
    }
    
    // If we were called with a replacer function, then call the replacer to
    // obtain a replacement value.
    if (typeof rep === 'function') {
        value = rep.call(holder, key, value);
    }
    
    // What happens next depends on the value's type.
    switch (typeof value) {
        case 'string':
            return quote(value);
        
        case 'number':
            // JSON numbers must be finite. Encode non-finite numbers as null.
            return isFinite(value) ? String(value) : 'null';
        
        case 'boolean':
        case 'null':
            // If the value is a boolean or null, convert it to a string. Note:
            // typeof null does not produce 'null'. The case is included here in
            // the remote chance that this gets fixed someday.
            return String(value);
            
        case 'object':
            if (!value) return 'null';
            gap += indent;
            partial = [];
            
            // Array.isArray
            if (Object.prototype.toString.apply(value) === '[object Array]') {
                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }
                
                // Join all of the elements together, separated with commas, and
                // wrap them in brackets.
                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }
            
            // If the replacer is an array, use it to select the members to be
            // stringified.
            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    k = rep[i];
                    if (typeof k === 'string') {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            else {
                // Otherwise, iterate through all of the keys in the object.
                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            
        // Join all of the member texts together, separated with commas,
        // and wrap them in braces.

        v = partial.length === 0 ? '{}' : gap ?
            '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
            '{' + partial.join(',') + '}';
        gap = mind;
        return v;
    }
}

module.exports = function (value, replacer, space) {
    var i;
    gap = '';
    indent = '';
    
    // If the space parameter is a number, make an indent string containing that
    // many spaces.
    if (typeof space === 'number') {
        for (i = 0; i < space; i += 1) {
            indent += ' ';
        }
    }
    // If the space parameter is a string, it will be used as the indent string.
    else if (typeof space === 'string') {
        indent = space;
    }

    // If there is a replacer, it must be a function or an array.
    // Otherwise, throw an error.
    rep = replacer;
    if (replacer && typeof replacer !== 'function'
    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
        throw new Error('JSON.stringify');
    }
    
    // Make a fake root object containing our value under the key of ''.
    // Return the result of stringifying the value.
    return str('', {'': value});
};

},{}],153:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],154:[function(require,module,exports){
'use strict';
var isFn = require('is-fn');
var setImmediate = require('set-immediate-shim');

module.exports = function (promise) {
	if (!isFn(promise.then)) {
		throw new TypeError('Expected a promise');
	}

	return function (cb) {
		promise.then(function (data) {
			setImmediate(cb, null, data);
		}, function (err) {
			setImmediate(cb, err);
		});
	};
};

},{"is-fn":144,"set-immediate-shim":156}],155:[function(require,module,exports){
const util = require('util')
const EventEmitter = require('events/')

var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
}

module.exports = SafeEventEmitter


function SafeEventEmitter() {
  EventEmitter.call(this)
}

util.inherits(SafeEventEmitter, EventEmitter)

SafeEventEmitter.prototype.emit = function (type) {
  // copied from https://github.com/Gozala/events/blob/master/events.js
  // modified lines are commented with "edited:"
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    // edited: using safeApply
    safeApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      // edited: using safeApply
      safeApply(listeners[i], this, args);
  }

  return true;
}

function safeApply(handler, context, args) {
  try {
    ReflectApply(handler, context, args)
  } catch (err) {
    // throw error after timeout so as not to interupt the stack
    setTimeout(() => {
      throw err
    })
  }
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

},{"events/":141,"util":160}],156:[function(require,module,exports){
(function (setImmediate){
'use strict';
module.exports = typeof setImmediate === 'function' ? setImmediate :
	function setImmediate() {
		var args = [].slice.apply(arguments);
		args.splice(1, 0, 0);
		setTimeout.apply(null, args);
	};

}).call(this,require("timers").setImmediate)

},{"timers":158}],157:[function(require,module,exports){
var isHexPrefixed = require('is-hex-prefixed');

/**
 * Removes '0x' from a given `String` is present
 * @param {String} str the string value
 * @return {String|Optional} a string by pass if necessary
 */
module.exports = function stripHexPrefix(str) {
  if (typeof str !== 'string') {
    return str;
  }

  return isHexPrefixed(str) ? str.slice(2) : str;
}

},{"is-hex-prefixed":145}],158:[function(require,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,require("timers").setImmediate,require("timers").clearImmediate)

},{"process/browser.js":153,"timers":158}],159:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],160:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":159,"_process":153,"inherits":143}],161:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];

for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex; // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4

  return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join('');
}

var _default = bytesToUuid;
exports.default = _default;
module.exports = exports.default;
},{}],162:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "v1", {
  enumerable: true,
  get: function () {
    return _v.default;
  }
});
Object.defineProperty(exports, "v3", {
  enumerable: true,
  get: function () {
    return _v2.default;
  }
});
Object.defineProperty(exports, "v4", {
  enumerable: true,
  get: function () {
    return _v3.default;
  }
});
Object.defineProperty(exports, "v5", {
  enumerable: true,
  get: function () {
    return _v4.default;
  }
});

var _v = _interopRequireDefault(require("./v1.js"));

var _v2 = _interopRequireDefault(require("./v3.js"));

var _v3 = _interopRequireDefault(require("./v4.js"));

var _v4 = _interopRequireDefault(require("./v5.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./v1.js":166,"./v3.js":167,"./v4.js":169,"./v5.js":170}],163:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */
function md5(bytes) {
  if (typeof bytes == 'string') {
    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = new Array(msg.length);

    for (var i = 0; i < msg.length; i++) bytes[i] = msg.charCodeAt(i);
  }

  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */


function md5ToHexEncodedArray(input) {
  var i;
  var x;
  var output = [];
  var length32 = input.length * 32;
  var hexTab = '0123456789abcdef';
  var hex;

  for (i = 0; i < length32; i += 8) {
    x = input[i >> 5] >>> i % 32 & 0xff;
    hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
    output.push(hex);
  }

  return output;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */


function wordsToMd5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << len % 32;
  x[(len + 64 >>> 9 << 4) + 14] = len;
  var i;
  var olda;
  var oldb;
  var oldc;
  var oldd;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;

  for (i = 0; i < x.length; i += 16) {
    olda = a;
    oldb = b;
    oldc = c;
    oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }

  return [a, b, c, d];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */


function bytesToWords(input) {
  var i;
  var output = [];
  output[(input.length >> 2) - 1] = undefined;

  for (i = 0; i < output.length; i += 1) {
    output[i] = 0;
  }

  var length8 = input.length * 8;

  for (i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
  }

  return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */


function safeAdd(x, y) {
  var lsw = (x & 0xffff) + (y & 0xffff);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xffff;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */


function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */


function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}

function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}

function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}

function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}

function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}

var _default = md5;
exports.default = _default;
module.exports = exports.default;
},{}],164:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rng;
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
// getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
// find the complete implementation of crypto (msCrypto) on IE11.
var getRandomValues = typeof crypto != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != 'undefined' && typeof msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto);
var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

function rng() {
  if (!getRandomValues) {
    throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
  }

  return getRandomValues(rnds8);
}

module.exports = exports.default;
},{}],165:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;

    case 1:
      return x ^ y ^ z;

    case 2:
      return x & y ^ x & z ^ y & z;

    case 3:
      return x ^ y ^ z;
  }
}

function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}

function sha1(bytes) {
  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

  if (typeof bytes == 'string') {
    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = new Array(msg.length);

    for (var i = 0; i < msg.length; i++) bytes[i] = msg.charCodeAt(i);
  }

  bytes.push(0x80);
  var l = bytes.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);

  for (var i = 0; i < N; i++) {
    M[i] = new Array(16);

    for (var j = 0; j < 16; j++) {
      M[i][j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }
  }

  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

  for (var i = 0; i < N; i++) {
    var W = new Array(80);

    for (var t = 0; t < 16; t++) W[t] = M[i][t];

    for (var t = 16; t < 80; t++) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }

    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];

    for (var t = 0; t < 80; t++) {
      var s = Math.floor(t / 20);
      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }

    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }

  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
}

var _default = sha1;
exports.default = _default;
module.exports = exports.default;
},{}],166:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rng = _interopRequireDefault(require("./rng.js"));

var _bytesToUuid = _interopRequireDefault(require("./bytesToUuid.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
var _nodeId;

var _clockseq; // Previous uuid creation time


var _lastMSecs = 0;
var _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || _rng.default)();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : (0, _bytesToUuid.default)(b);
}

var _default = v1;
exports.default = _default;
module.exports = exports.default;
},{"./bytesToUuid.js":161,"./rng.js":164}],167:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _v = _interopRequireDefault(require("./v35.js"));

var _md = _interopRequireDefault(require("./md5.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v3 = (0, _v.default)('v3', 0x30, _md.default);
var _default = v3;
exports.default = _default;
module.exports = exports.default;
},{"./md5.js":163,"./v35.js":168}],168:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.URL = exports.DNS = void 0;

var _bytesToUuid = _interopRequireDefault(require("./bytesToUuid.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function uuidToBytes(uuid) {
  // Note: We assume we're being passed a valid uuid string
  var bytes = [];
  uuid.replace(/[a-fA-F0-9]{2}/g, function (hex) {
    bytes.push(parseInt(hex, 16));
  });
  return bytes;
}

function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  var bytes = new Array(str.length);

  for (var i = 0; i < str.length; i++) {
    bytes[i] = str.charCodeAt(i);
  }

  return bytes;
}

const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.DNS = DNS;
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
exports.URL = URL;

function _default(name, version, hashfunc) {
  var generateUUID = function (value, namespace, buf, offset) {
    var off = buf && offset || 0;
    if (typeof value == 'string') value = stringToBytes(value);
    if (typeof namespace == 'string') namespace = uuidToBytes(namespace);
    if (!Array.isArray(value)) throw TypeError('value must be an array of bytes');
    if (!Array.isArray(namespace) || namespace.length !== 16) throw TypeError('namespace must be uuid string or an Array of 16 byte values'); // Per 4.3

    var bytes = hashfunc(namespace.concat(value));
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      for (var idx = 0; idx < 16; ++idx) {
        buf[off + idx] = bytes[idx];
      }
    }

    return buf || (0, _bytesToUuid.default)(bytes);
  }; // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name;
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}
},{"./bytesToUuid.js":161}],169:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rng = _interopRequireDefault(require("./rng.js"));

var _bytesToUuid = _interopRequireDefault(require("./bytesToUuid.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof options == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }

  options = options || {};

  var rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`


  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || (0, _bytesToUuid.default)(rnds);
}

var _default = v4;
exports.default = _default;
module.exports = exports.default;
},{"./bytesToUuid.js":161,"./rng.js":164}],170:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _v = _interopRequireDefault(require("./v35.js"));

var _sha = _interopRequireDefault(require("./sha1.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v5 = (0, _v.default)('v5', 0x50, _sha.default);
var _default = v5;
exports.default = _default;
module.exports = exports.default;
},{"./sha1.js":165,"./v35.js":168}],171:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}]},{},[8])(8)
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJkaXN0L2VzbS9hdXRoL2FjY2Vzcy10b2tlbi5qcyIsImRpc3QvZXNtL2F1dGgvb2F1dGgtbWFuYWdlci5qcyIsImRpc3QvZXNtL2F1dGgvb3BlbmlkLWF1dGgtcHJvdmlkZXIuanMiLCJkaXN0L2VzbS9hdXRoL3BvcHVwLWhhbmRsZXIuanMiLCJkaXN0L2VzbS9hdXRoL3Rva2VuLXN0b3JlLmpzIiwiZGlzdC9lc20vYXV0aC91c2VyLXN0b3JlLmpzIiwiZGlzdC9lc20vYXV0aC91c2VyLmpzIiwiZGlzdC9lc20vYml0c2tpLmpzIiwiZGlzdC9lc20vY29tcG9uZW50cy9jb25uZWN0LWJ1dHRvbi5qcyIsImRpc3QvZXNtL2NvbXBvbmVudHMvZGlhbG9nLmpzIiwiZGlzdC9lc20vY29uc3RhbnRzLmpzIiwiZGlzdC9lc20vZXJyb3JzL2F1dGhlbnRpY2F0aW9uLWVycm9yLmpzIiwiZGlzdC9lc20vZXJyb3JzL3BhcnNlLWVycm9yLmpzIiwiZGlzdC9lc20vZXJyb3JzL3NpZ25lci1lcnJvci5qcyIsImRpc3QvZXNtL3Byb3ZpZGVycy9iaXRza2ktYnJvd3Nlci1lbmdpbmUuanMiLCJkaXN0L2VzbS9zaWduaW5nL3RyYW5zYWN0aW9uLXNpZ25lci5qcyIsImRpc3QvZXNtL3N0eWxlcy9jb25uZWN0LWJ1dHRvbi5qcyIsImRpc3QvZXNtL3N0eWxlcy9kaWFsb2cuanMiLCJkaXN0L2VzbS9zdHlsZXMvaW5kZXguanMiLCJkaXN0L2VzbS9zdWJwcm92aWRlcnMvYXV0aGVudGljYXRlZC1jYWNoZS5qcyIsImRpc3QvZXNtL3N1YnByb3ZpZGVycy9yZW1vdGUtYWNjb3VudHMuanMiLCJkaXN0L2VzbS9zdWJwcm92aWRlcnMvcmVzdC1mZXRjaC5qcyIsImRpc3QvZXNtL3N1YnByb3ZpZGVycy9zaWduYXR1cmUuanMiLCJkaXN0L2VzbS91dGlscy9jYWxsYmFjay5qcyIsImRpc3QvZXNtL3V0aWxzL2xvY2Fsc3RvcmFnZS1zdG9yZS5qcyIsImRpc3QvZXNtL3V0aWxzL25vLWhhc2gtcXVlcnktc3RyaW5nLXV0aWxzLmpzIiwiZGlzdC9lc20vdXRpbHMvcG9wdXAtdmFsaWRhdG9yLmpzIiwiZGlzdC9lc20vdXRpbHMvcmVxdWVzdC11dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdC5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9kaXN0L2Jhc2UtcHJvdmlkZXIuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvZGlzdC9lcnJvcnMvYmxvY2stdHJhY2tlci1lcnJvci5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9kaXN0L2Vycm9ycy9nYXMtcHJpY2UtZXJyb3IuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvZGlzdC9lcnJvcnMvcHJvdmlkZXItZW5naW5lLWVycm9yLmpzIiwibm9kZV9tb2R1bGVzL0BiaXRza2kvcHJvdmlkZXItZW5naW5lL2Rpc3QvZXJyb3JzL3N1YnNjcmlwdGlvbi1lcnJvci5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BiaXRza2kvcHJvdmlkZXItZW5naW5lL2Rpc3QvcHJvdmlkZXItZW5naW5lLmpzIiwibm9kZV9tb2R1bGVzL0BiaXRza2kvcHJvdmlkZXItZW5naW5lL2Rpc3Qvc3VicHJvdmlkZXIuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvZGlzdC9zdWJwcm92aWRlcnMvY2FjaGUtc3RyYXRlZ2llcy9ibG9jay1zdHJhdGVneS5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9kaXN0L3N1YnByb3ZpZGVycy9jYWNoZS1zdHJhdGVnaWVzL2NhY2hlLXN0cmF0ZWd5LmpzIiwibm9kZV9tb2R1bGVzL0BiaXRza2kvcHJvdmlkZXItZW5naW5lL2Rpc3Qvc3VicHJvdmlkZXJzL2NhY2hlLXN0cmF0ZWdpZXMvY29uZGl0aW9uYWwtcGVybWEtc3RyYXRlZ3kuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvZGlzdC9zdWJwcm92aWRlcnMvY2FjaGUtc3RyYXRlZ2llcy9wZXJtYS1jYWNoZS1zdHJhdGVneS5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9kaXN0L3N1YnByb3ZpZGVycy9jYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9kaXN0L3N1YnByb3ZpZGVycy9kZWZhdWx0LWZpeHR1cmUuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvZGlzdC9zdWJwcm92aWRlcnMvZmV0Y2guanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvZGlzdC9zdWJwcm92aWRlcnMvZmlsdGVycy5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9kaXN0L3N1YnByb3ZpZGVycy9maWx0ZXJzL2Jsb2NrLWZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9kaXN0L3N1YnByb3ZpZGVycy9maWx0ZXJzL2ZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9kaXN0L3N1YnByb3ZpZGVycy9maWx0ZXJzL2xvZy1maWx0ZXIuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvZGlzdC9zdWJwcm92aWRlcnMvZmlsdGVycy9wZW5kaW5nLXR4LWZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9kaXN0L3N1YnByb3ZpZGVycy9maXh0dXJlLmpzIiwibm9kZV9tb2R1bGVzL0BiaXRza2kvcHJvdmlkZXItZW5naW5lL2Rpc3Qvc3VicHJvdmlkZXJzL2dhc3ByaWNlLmpzIiwibm9kZV9tb2R1bGVzL0BiaXRza2kvcHJvdmlkZXItZW5naW5lL2Rpc3Qvc3VicHJvdmlkZXJzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BiaXRza2kvcHJvdmlkZXItZW5naW5lL2Rpc3Qvc3VicHJvdmlkZXJzL2luZmxpZ2h0LWNhY2hlLmpzIiwibm9kZV9tb2R1bGVzL0BiaXRza2kvcHJvdmlkZXItZW5naW5lL2Rpc3Qvc3VicHJvdmlkZXJzL3Byb3ZpZGVyLmpzIiwibm9kZV9tb2R1bGVzL0BiaXRza2kvcHJvdmlkZXItZW5naW5lL2Rpc3Qvc3VicHJvdmlkZXJzL3Nhbml0aXplci5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9kaXN0L3N1YnByb3ZpZGVycy9zdWJzY3JpcHRpb25zLmpzIiwibm9kZV9tb2R1bGVzL0BiaXRza2kvcHJvdmlkZXItZW5naW5lL2Rpc3QvdXRpbC9hc3NlcnQuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvZGlzdC91dGlsL2Jsb2NrLXRyYWNrZXIuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvZGlzdC91dGlsL2NyZWF0ZS1wYXlsb2FkLmpzIiwibm9kZV9tb2R1bGVzL0BiaXRza2kvcHJvdmlkZXItZW5naW5lL2Rpc3QvdXRpbC9ldGgtdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9kaXN0L3V0aWwvcmFuZG9tLWlkLmpzIiwibm9kZV9tb2R1bGVzL0BiaXRza2kvcHJvdmlkZXItZW5naW5lL2Rpc3QvdXRpbC9ycGMtY2FjaGUtdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvZGlzdC91dGlsL3JwYy1oZXgtZW5jb2RpbmcuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvZGlzdC91dGlsL3N0b3BsaWdodC5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9ub2RlX21vZHVsZXMvYXN5bmMvYXN5bmNpZnkuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvbm9kZV9tb2R1bGVzL2FzeW5jL2VhY2hMaW1pdC5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9ub2RlX21vZHVsZXMvYXN5bmMvZWFjaE9mLmpzIiwibm9kZV9tb2R1bGVzL0BiaXRza2kvcHJvdmlkZXItZW5naW5lL25vZGVfbW9kdWxlcy9hc3luYy9lYWNoT2ZMaW1pdC5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9ub2RlX21vZHVsZXMvYXN5bmMvZWFjaFNlcmllcy5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9ub2RlX21vZHVsZXMvYXN5bmMvaW50ZXJuYWwvYXN5bmNFYWNoT2ZMaW1pdC5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9ub2RlX21vZHVsZXMvYXN5bmMvaW50ZXJuYWwvYXdhaXRpZnkuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvbm9kZV9tb2R1bGVzL2FzeW5jL2ludGVybmFsL2JyZWFrTG9vcC5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9ub2RlX21vZHVsZXMvYXN5bmMvaW50ZXJuYWwvZWFjaE9mTGltaXQuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvbm9kZV9tb2R1bGVzL2FzeW5jL2ludGVybmFsL2dldEl0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL0BiaXRza2kvcHJvdmlkZXItZW5naW5lL25vZGVfbW9kdWxlcy9hc3luYy9pbnRlcm5hbC9pbml0aWFsUGFyYW1zLmpzIiwibm9kZV9tb2R1bGVzL0BiaXRza2kvcHJvdmlkZXItZW5naW5lL25vZGVfbW9kdWxlcy9hc3luYy9pbnRlcm5hbC9pc0FycmF5TGlrZS5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9ub2RlX21vZHVsZXMvYXN5bmMvaW50ZXJuYWwvaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvbm9kZV9tb2R1bGVzL2FzeW5jL2ludGVybmFsL21hcC5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9ub2RlX21vZHVsZXMvYXN5bmMvaW50ZXJuYWwvb25jZS5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9ub2RlX21vZHVsZXMvYXN5bmMvaW50ZXJuYWwvb25seU9uY2UuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvbm9kZV9tb2R1bGVzL2FzeW5jL2ludGVybmFsL3BhcmFsbGVsLmpzIiwibm9kZV9tb2R1bGVzL0BiaXRza2kvcHJvdmlkZXItZW5naW5lL25vZGVfbW9kdWxlcy9hc3luYy9pbnRlcm5hbC9wcm9taXNlQ2FsbGJhY2suanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvbm9kZV9tb2R1bGVzL2FzeW5jL2ludGVybmFsL3NldEltbWVkaWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9ub2RlX21vZHVsZXMvYXN5bmMvaW50ZXJuYWwvd2l0aG91dEluZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BiaXRza2kvcHJvdmlkZXItZW5naW5lL25vZGVfbW9kdWxlcy9hc3luYy9pbnRlcm5hbC93cmFwQXN5bmMuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvbm9kZV9tb2R1bGVzL2FzeW5jL21hcC5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9ub2RlX21vZHVsZXMvYXN5bmMvcGFyYWxsZWwuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvbm9kZV9tb2R1bGVzL2FzeW5jL3JldHJ5LmpzIiwibm9kZV9tb2R1bGVzL0BiaXRza2kvcHJvdmlkZXItZW5naW5lL25vZGVfbW9kdWxlcy9hc3luYy93YXRlcmZhbGwuanMiLCJub2RlX21vZHVsZXMvQG9wZW5pZC9hcHBhdXRoL3NyYy9hdXRob3JpemF0aW9uX3JlcXVlc3QudHMiLCJub2RlX21vZHVsZXMvQG9wZW5pZC9hcHBhdXRoL3NyYy9hdXRob3JpemF0aW9uX3JlcXVlc3RfaGFuZGxlci50cyIsIm5vZGVfbW9kdWxlcy9Ab3BlbmlkL2FwcGF1dGgvc3JjL2F1dGhvcml6YXRpb25fcmVzcG9uc2UudHMiLCJub2RlX21vZHVsZXMvQG9wZW5pZC9hcHBhdXRoL3NyYy9hdXRob3JpemF0aW9uX3NlcnZpY2VfY29uZmlndXJhdGlvbi50cyIsIm5vZGVfbW9kdWxlcy9Ab3BlbmlkL2FwcGF1dGgvc3JjL2NyeXB0b191dGlscy50cyIsIm5vZGVfbW9kdWxlcy9Ab3BlbmlkL2FwcGF1dGgvc3JjL2Vycm9ycy50cyIsIm5vZGVfbW9kdWxlcy9Ab3BlbmlkL2FwcGF1dGgvc3JjL2ZsYWdzLnRzIiwibm9kZV9tb2R1bGVzL0BvcGVuaWQvYXBwYXV0aC9zcmMvaW5kZXgudHMiLCJub2RlX21vZHVsZXMvQG9wZW5pZC9hcHBhdXRoL3NyYy9sb2dnZXIudHMiLCJub2RlX21vZHVsZXMvQG9wZW5pZC9hcHBhdXRoL3NyYy9xdWVyeV9zdHJpbmdfdXRpbHMudHMiLCJub2RlX21vZHVsZXMvQG9wZW5pZC9hcHBhdXRoL3NyYy9yZWRpcmVjdF9iYXNlZF9oYW5kbGVyLnRzIiwibm9kZV9tb2R1bGVzL0BvcGVuaWQvYXBwYXV0aC9zcmMvcmV2b2tlX3Rva2VuX3JlcXVlc3QudHMiLCJub2RlX21vZHVsZXMvQG9wZW5pZC9hcHBhdXRoL3NyYy9zdG9yYWdlLnRzIiwibm9kZV9tb2R1bGVzL0BvcGVuaWQvYXBwYXV0aC9zcmMvdG9rZW5fcmVxdWVzdC50cyIsIm5vZGVfbW9kdWxlcy9Ab3BlbmlkL2FwcGF1dGgvc3JjL3Rva2VuX3JlcXVlc3RfaGFuZGxlci50cyIsIm5vZGVfbW9kdWxlcy9Ab3BlbmlkL2FwcGF1dGgvc3JjL3Rva2VuX3Jlc3BvbnNlLnRzIiwibm9kZV9tb2R1bGVzL0BvcGVuaWQvYXBwYXV0aC9zcmMveGhyLnRzIiwibm9kZV9tb2R1bGVzL2FzeW5jL2ludGVybmFsL3NldEltbWVkaWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYml0c2tpLXByb3ZpZGVyL2xpYi9hdXRoL2FjY2Vzcy10b2tlbi5qcyIsIm5vZGVfbW9kdWxlcy9iaXRza2ktcHJvdmlkZXIvbGliL2JpdHNraS1lbmdpbmUuanMiLCJub2RlX21vZHVsZXMvYml0c2tpLXByb3ZpZGVyL2xpYi9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvYml0c2tpLXByb3ZpZGVyL2xpYi9lcnJvcnMvcHJvdmlkZXItZXJyb3IuanMiLCJub2RlX21vZHVsZXMvYml0c2tpLXByb3ZpZGVyL2xpYi9lcnJvcnMvc2VydmVyLWVycm9yLmpzIiwibm9kZV9tb2R1bGVzL2JpdHNraS1wcm92aWRlci9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYml0c2tpLXByb3ZpZGVyL2xpYi9uZXR3b3JrLmpzIiwibm9kZV9tb2R1bGVzL2JpdHNraS1wcm92aWRlci9saWIvc3VicHJvdmlkZXJzL2F1dGhlbnRpY2F0ZWQtZmV0Y2guanMiLCJub2RlX21vZHVsZXMvYml0c2tpLXByb3ZpZGVyL2xpYi9zdWJwcm92aWRlcnMvbm9uY2UtdHJhY2tlci5qcyIsIm5vZGVfbW9kdWxlcy9iaXRza2ktcHJvdmlkZXIvbGliL3N1YnByb3ZpZGVycy90cmFuc2FjdGlvbi12YWxpZGF0b3IuanMiLCJub2RlX21vZHVsZXMvYml0c2tpLXByb3ZpZGVyL2xpYi9zdWJwcm92aWRlcnMvdHlwZWQtZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9iaXRza2ktcHJvdmlkZXIvbGliL3V0aWxzL3BhcnNlLXV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2JuLmpzL2xpYi9ibi5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY2xvbmUvY2xvbmUuanMiLCJub2RlX21vZHVsZXMvY3Jvc3MtZmV0Y2gvZGlzdC9icm93c2VyLXBvbnlmaWxsLmpzIiwibm9kZV9tb2R1bGVzL2V0aC1ibG9jay10cmFja2VyL25vZGVfbW9kdWxlcy9waWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2V0aC1ibG9jay10cmFja2VyL3NyYy9iYXNlLmpzIiwibm9kZV9tb2R1bGVzL2V0aC1ibG9jay10cmFja2VyL3NyYy9wb2xsaW5nLmpzIiwibm9kZV9tb2R1bGVzL2V0aC1xdWVyeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ldGhqcy11dGlsL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9pcy1mbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1oZXgtcHJlZml4ZWQvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzb24tcnBjLWVycm9yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzb24tcnBjLWVycm9yL2xpYi9lcnJvcnMuanMiLCJub2RlX21vZHVsZXMvanNvbi1ycGMtcmFuZG9tLWlkL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzb24tc3RhYmxlLXN0cmluZ2lmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qc29uaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzb25pZnkvbGliL3BhcnNlLmpzIiwibm9kZV9tb2R1bGVzL2pzb25pZnkvbGliL3N0cmluZ2lmeS5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcHJvbWlzZS10by1jYWxsYmFjay9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zYWZlLWV2ZW50LWVtaXR0ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2V0LWltbWVkaWF0ZS1zaGltL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N0cmlwLWhleC1wcmVmaXgvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCJub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L2J5dGVzVG9VdWlkLmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvbWQ1LWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L3JuZy1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9zaGExLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L3YxLmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC92My5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvdjM1LmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC92NC5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvdjUuanMiLCJub2RlX21vZHVsZXMveHRlbmQvaW1tdXRhYmxlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztBQ0FBOzs7QUFHTyxNQUFNLFdBQU4sQ0FBa0I7QUFDckI7Ozs7OztBQU1BLEVBQUEsV0FBVyxDQUFDLEtBQUQsRUFBUSxTQUFSLEVBQW1CLEtBQW5CLEVBQTBC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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ24yR0E7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM2dCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdndEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCIvKipcbiAqIFJlcHJlc2VudHMgYSBCaXRza2kgYWNjZXNzIHRva2VuXG4gKi9cbmV4cG9ydCBjbGFzcyBBY2Nlc3NUb2tlbiB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdG9rZW4gdGhlIGFjY2VzcyB0b2tlblxuICAgICAqIEBwYXJhbSBleHBpcmVzQXQgdGhlIHRva2VuIGV4cGlyYXRpb24gZGF0ZSAoaW4gc2Vjb25kcykgKG9wdGlvbmFsKVxuICAgICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGVzIHRoaXMgdG9rZW4gcmVwcmVzZW50cyAob3B0aW9uYWwpXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodG9rZW4sIGV4cGlyZXNBdCwgc2NvcGUpIHtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgICAgIHRoaXMuZXhwaXJlc0F0ID0gZXhwaXJlc0F0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdG9rZW4gZnJvbSBhIFRva2VuUmVzcG9uc2Ugb2JqZWN0XG4gICAgICogQHBhcmFtIHRva2VuUmVzcG9uc2UgVGhlIHRva2VuIHJlc3BvbnNlIG9iamVjdCB0byBidWlsZCBhIHRva2VuIGZyb21cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVRva2VuUmVzcG9uc2UodG9rZW5SZXNwb25zZSkge1xuICAgICAgICBsZXQgZXhwaXJlc0F0O1xuICAgICAgICBpZiAodG9rZW5SZXNwb25zZS5leHBpcmVzSW4pIHtcbiAgICAgICAgICAgIGV4cGlyZXNBdCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApICsgdG9rZW5SZXNwb25zZS5leHBpcmVzSW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBY2Nlc3NUb2tlbih0b2tlblJlc3BvbnNlLmFjY2Vzc1Rva2VuLCBleHBpcmVzQXQsIHRva2VuUmVzcG9uc2Uuc2NvcGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdG9rZW4gZnJvbSBhIHN0b3JhZ2Ugc3RyaW5nXG4gICAgICogQHBhcmFtIHMgSlNPTiBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB0b2tlblxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tU3RyaW5nKHMpIHtcbiAgICAgICAgbGV0IHBhcnNlZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBhcnNlZCA9IEpTT04ucGFyc2Uocyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJzZWQudG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFjY2Vzc1Rva2VuKHBhcnNlZC50b2tlbiwgcGFyc2VkLmV4cGlyZXNBdCwgcGFyc2VkLnNjb3BlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyBpZiB0aGUgdG9rZW4gaXMgc3RpbGwgYWN0aXZlXG4gICAgICovXG4gICAgZ2V0IGV4cGlyZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmV4cGlyZXNBdCkge1xuICAgICAgICAgICAgY29uc3Qgbm93ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7XG4gICAgICAgICAgICBjb25zdCBleHBpcmVzSW4gPSB0aGlzLmV4cGlyZXNBdCAtIG5vdztcbiAgICAgICAgICAgIHJldHVybiBleHBpcmVzSW4gPD0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBKU09OIHN0cmluZyBzdWl0YWJsZSBmb3Igd3JpdGluZyBpbiBsb2NhbCBzdG9yYWdlXG4gICAgICovXG4gICAgdG9TdG9yYWdlU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgZXhwaXJlc0F0OiB0aGlzLmV4cGlyZXNBdCxcbiAgICAgICAgICAgIHNjb3BlOiB0aGlzLnNjb3BlLFxuICAgICAgICAgICAgdG9rZW46IHRoaXMudG9rZW4sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IEF1dGhvcml6YXRpb25Ob3RpZmllciwgQXV0aG9yaXphdGlvblJlcXVlc3QsIEF1dGhvcml6YXRpb25TZXJ2aWNlQ29uZmlndXJhdGlvbiwgQmFzZVRva2VuUmVxdWVzdEhhbmRsZXIsIEZldGNoUmVxdWVzdG9yLCBHUkFOVF9UWVBFX0FVVEhPUklaQVRJT05fQ09ERSwgR1JBTlRfVFlQRV9SRUZSRVNIX1RPS0VOLCBSZWRpcmVjdFJlcXVlc3RIYW5kbGVyLCBUb2tlblJlcXVlc3QsIH0gZnJvbSAnQG9wZW5pZC9hcHBhdXRoJztcbmltcG9ydCB7IEJJVFNLSV9VU0VSX0FQSV9IT1NULCBERUZBVUxUX09BVVRIX0NPTkZJR1VSQVRJT04sIERFRkFVTFRfT1BUSU9OQUxfU0NPUEVTLCBERUZBVUxUX1NDT1BFUyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBBdXRoZW50aWNhdGlvbkVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL2F1dGhlbnRpY2F0aW9uLWVycm9yJztcbmltcG9ydCB7IE5vSGFzaFF1ZXJ5U3RyaW5nVXRpbHMgfSBmcm9tICcuLi91dGlscy9uby1oYXNoLXF1ZXJ5LXN0cmluZy11dGlscyc7XG5pbXBvcnQgeyBwYXJzZVJlc3BvbnNlIH0gZnJvbSAnLi4vdXRpbHMvcmVxdWVzdC11dGlscyc7XG5pbXBvcnQgeyBQb3B1cEJsb2NrZWRFcnJvciwgUG9wdXBDbG9zZWRFcnJvciwgUG9wdXBSZXF1ZXN0SGFuZGxlciB9IGZyb20gJy4vcG9wdXAtaGFuZGxlcic7XG4vLyBVc2UgdGhpcyBjb25zdGFudCBpbiBsb2dpbl9oaW50IHRvIGluZGljYXRlIHRoYXQgdGhlIHNpZ24gdXAgVUkgc2hvdWxkIGJlIGRpc3BsYXllZFxuZXhwb3J0IGNvbnN0IExPR0lOX0hJTlRfU0lHTlVQID0gJ3NpZ251cCc7XG4vKipcbiAqIFJlc3BvbnNpYmxlIGZvciBzdWJtaXR0aW5nIHJlcXVlc3RzIHRvIG91ciBPQXV0aCBzZXJ2ZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBPQXV0aE1hbmFnZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBPQXV0aCBNYW5hZ2VyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgU2V0dGluZ3Mgb2JqZWN0XG4gICAgICogQHBhcmFtIG9wdGlvbnMuY2xpZW50SWQgc3RyaW5nOiBUaGUgY2xpZW50IGlkIHRvIHVzZSBmb3IgdmFyaW91cyByZXF1ZXN0c1xuICAgICAqIEBwYXJhbSBvcHRpb25zLnJlZGlyZWN0VXJpIHN0cmluZzogVGhlIHJlZGlyZWN0IFVSSSB0byB1c2UgZm9yIHJlc3BvbmRpbmcgdG8gYXV0aCByZXF1ZXN0c1xuICAgICAqIEBwYXJhbSBvcHRpb25zLmNvbmZpZ3VyYXRpb24gQXV0aG9yaXphdGlvblNlcnZpY2VDb25maWd1cmF0aW9uIChvcHRpb25hbCk6IFRoZSBjb25maWd1cmF0aW9uIGZvciB0aGUgT0F1dGggc2VydmVyXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYWRkaXRpb25hbFNjb3BlcyBzdHJpbmdbXSAob3B0aW9uYWwpOiBBZGRpdGlvbmFsIHNjb3BlcyB0byByZXF1ZXN0IG91dHNpZGUgb2Ygb3BlbmlkLlxuICAgICAqIERlZmF1bHQgaXMgb2ZmbGluZS4gUGFzcyBhbiBlbXB0eSBhcnJheSB0byBvbmx5IHJlcXVlc3Qgb3BlbmlkLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5jbGllbnRJZCA9IG9wdGlvbnMuY2xpZW50SWQ7XG4gICAgICAgIHRoaXMucmVkaXJlY3RVcmkgPSBvcHRpb25zLnJlZGlyZWN0VXJpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSBvcHRpb25zLmNvbmZpZ3VyYXRpb24gfHwgbmV3IEF1dGhvcml6YXRpb25TZXJ2aWNlQ29uZmlndXJhdGlvbihERUZBVUxUX09BVVRIX0NPTkZJR1VSQVRJT04pO1xuICAgICAgICBjb25zdCBhZGRpdGlvbmFsU2NvcGVzID0gb3B0aW9ucy5hZGRpdGlvbmFsU2NvcGVzIHx8IERFRkFVTFRfT1BUSU9OQUxfU0NPUEVTO1xuICAgICAgICB0aGlzLnNjb3BlcyA9IERFRkFVTFRfU0NPUEVTLmNvbmNhdChhZGRpdGlvbmFsU2NvcGVzKTtcbiAgICAgICAgdGhpcy50b2tlbkhhbmRsZXIgPSBuZXcgQmFzZVRva2VuUmVxdWVzdEhhbmRsZXIobmV3IEZldGNoUmVxdWVzdG9yKCkpO1xuICAgICAgICB0aGlzLm5vdGlmaWVyID0gbmV3IEF1dGhvcml6YXRpb25Ob3RpZmllcigpO1xuICAgICAgICB0aGlzLm5vdGlmaWVyLnNldEF1dGhvcml6YXRpb25MaXN0ZW5lcih0aGlzLmRpZENvbXBsZXRlQXV0aG9yaXphdGlvbkZsb3cuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyaWdnZXIgYSBwb3B1cCBzaWduIGluIGZsb3cgKHRoZSBkZWZhdWx0KVxuICAgICAqL1xuICAgIHNpZ25JblBvcHVwKG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgoZnVsZmlsbCwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdSZXNvbHZlciA9IHsgZnVsZmlsbCwgcmVqZWN0IH07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmF1dGhIYW5kbGVyID0gbmV3IFBvcHVwUmVxdWVzdEhhbmRsZXIoKTtcbiAgICAgICAgdGhpcy5hdXRoSGFuZGxlci5zZXRBdXRob3JpemF0aW9uTm90aWZpZXIodGhpcy5ub3RpZmllcik7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmNyZWF0ZUF1dGhSZXF1ZXN0KG9wdHMpO1xuICAgICAgICB0aGlzLmF1dGhIYW5kbGVyLnBlcmZvcm1BdXRob3JpemF0aW9uUmVxdWVzdCh0aGlzLmNvbmZpZ3VyYXRpb24sIHJlcXVlc3QpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdEFjY2Vzc1Rva2VuKHJlc3BvbnNlLmNvZGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJpZ2dlciBhIHJlZGlyZWN0IHNpZ24gaW4gZmxvdy4gUHJvbWlzZSBzaG91bGQgbmV2ZXIgZnVsZmlsbCwgYXMgeW91IHdpbGwgYmUgcmVkaXJlY3RlZC5cbiAgICAgKi9cbiAgICBzaWduSW5SZWRpcmVjdChvcHRzKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKGZ1bGZpbGwsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nUmVzb2x2ZXIgPSB7IGZ1bGZpbGwsIHJlamVjdCB9O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hdXRoSGFuZGxlciA9IG5ldyBSZWRpcmVjdFJlcXVlc3RIYW5kbGVyKHVuZGVmaW5lZCwgbmV3IE5vSGFzaFF1ZXJ5U3RyaW5nVXRpbHMoKSk7XG4gICAgICAgIHRoaXMuYXV0aEhhbmRsZXIuc2V0QXV0aG9yaXphdGlvbk5vdGlmaWVyKHRoaXMubm90aWZpZXIpO1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5jcmVhdGVBdXRoUmVxdWVzdChvcHRzKTtcbiAgICAgICAgdGhpcy5hdXRoSGFuZGxlci5wZXJmb3JtQXV0aG9yaXphdGlvblJlcXVlc3QodGhpcy5jb25maWd1cmF0aW9uLCByZXF1ZXN0KTtcbiAgICAgICAgLy8gU2luY2UgdGhpcyBtZXRob2QgcmVkaXJlY3RzIHRoZSB3aG9sZSB3aW5kb3csIHRoZSBwcm9taXNlIHdpbGxcbiAgICAgICAgLy8gbGlrZWx5IG5ldmVyIGNvbXBsZXRlIHVubGVzcyB3ZSBlbmNvdW50ZXIgYW4gZXJyb3IuXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0IHRvIGZpbmFsaXplIGF1dGggcmVxdWVzdCBmcm9tIGEgcmVkaXJlY3QgZmxvdy4gQ2FsbGVkIGZyb20geW91ciByZWRpcmVjdCB1cmwgb25jZSB5b3UndmUgYmVlblxuICAgICAqIHJlZGlyZWN0ZWQgYmFjay5cbiAgICAgKi9cbiAgICByZWRpcmVjdENhbGxiYWNrKCkge1xuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKGZ1bGZpbGwsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nUmVzb2x2ZXIgPSB7IGZ1bGZpbGwsIHJlamVjdCB9O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hdXRoSGFuZGxlciA9IG5ldyBSZWRpcmVjdFJlcXVlc3RIYW5kbGVyKHVuZGVmaW5lZCwgbmV3IE5vSGFzaFF1ZXJ5U3RyaW5nVXRpbHMoKSk7XG4gICAgICAgIHRoaXMuYXV0aEhhbmRsZXIuc2V0QXV0aG9yaXphdGlvbk5vdGlmaWVyKHRoaXMubm90aWZpZXIpO1xuICAgICAgICB0aGlzLmF1dGhIYW5kbGVyLmNvbXBsZXRlQXV0aG9yaXphdGlvblJlcXVlc3RJZlBvc3NpYmxlKCk7XG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0QWNjZXNzVG9rZW4ocmVzcG9uc2UuY29kZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGNoYW5nZSBhbiBhdXRob3JpemF0aW9uIGNvZGUgZm9yIGFuIGFjY2VzcyB0b2tlblxuICAgICAqIEBwYXJhbSBjb2RlIFRoZSBhdXRob3JpemF0aW9uIGNvZGUgdG8gZXhjaGFuZ2VcbiAgICAgKi9cbiAgICByZXF1ZXN0QWNjZXNzVG9rZW4oY29kZSkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5jcmVhdGVUb2tlblJlcXVlc3QoY29kZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRva2VuSGFuZGxlci5wZXJmb3JtVG9rZW5SZXF1ZXN0KHRoaXMuY29uZmlndXJhdGlvbiwgcmVxdWVzdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgYSBuZXcgYWNjZXNzIHRva2VuIGZyb20gYSBwcmV2aW91cyByZWZyZXNoIHRva2VuXG4gICAgICogQHBhcmFtIHJlZnJlc2hUb2tlbiBUaGUgcmVmcmVzaCB0b2tlbiB0byB1c2UgZm9yIGF1dGhvcml6YXRpb25cbiAgICAgKi9cbiAgICByZWZyZXNoQWNjZXNzVG9rZW4ocmVmcmVzaFRva2VuKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmNyZWF0ZVJlZnJlc2hUb2tlblJlcXVlc3QocmVmcmVzaFRva2VuKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5IYW5kbGVyLnBlcmZvcm1Ub2tlblJlcXVlc3QodGhpcy5jb25maWd1cmF0aW9uLCByZXF1ZXN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3VibWl0IGEgc2lnbiBvdXQgcmVxdWVzdCBvbiB0aGUgb2F1dGggZW5kcG9pbnRcbiAgICAgKiBAcGFyYW0gYWNjZXNzVG9rZW4gVGhlIGFjY2VzcyB0b2tlbiB0byBzaWduIG91dCB3aXRoXG4gICAgICovXG4gICAgcmVxdWVzdFNpZ25PdXQoYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIGZldGNoKGAke0JJVFNLSV9VU0VSX0FQSV9IT1NUfS9sb2dvdXRgLCB7XG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHthY2Nlc3NUb2tlbn1gLFxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIH0pLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IGEgdXNlcidzIHByb2ZpbGUgZnJvbSB0aGUgb2F1dGggc2VydmVyXG4gICAgICogQHBhcmFtIGFjY2Vzc1Rva2VuIFRoZSBhY2Nlc3MgdG9rZW4gZm9yIHRoZSB1c2VyXG4gICAgICovXG4gICAgcmVxdWVzdFVzZXJJbmZvKGFjY2Vzc1Rva2VuKSB7XG4gICAgICAgIGNvbnN0IHVzZXJJbmZvRW5kcG9pbnQgPSB0aGlzLmNvbmZpZ3VyYXRpb24udXNlckluZm9FbmRwb2ludDtcbiAgICAgICAgaWYgKCF1c2VySW5mb0VuZHBvaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoQXV0aGVudGljYXRpb25FcnJvci5JbnZhbGlkQ29uZmlndXJhdGlvbignQ291bGQgbm90IGZpbmQgdXNlciBpbmZvIGVuZHBvaW50JykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmZXRjaCh1c2VySW5mb0VuZHBvaW50LCB7XG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2FjY2Vzc1Rva2VufWAsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgY2FsbGJhY2sgZnJvbSBvdXIgQXV0aCBSZXF1ZXN0IGhhbmRsZXIuIFBhc3NlcyB0aGUgcmVzcG9uc2UgdGhyb3VnaCB0byBhIGNhY2hlZCBwcm9taXNlIGlmIGl0IGV4aXN0cy5cbiAgICAgKiBAcGFyYW0gcmVxdWVzdCBUaGUgb3JpZ2luYWwgYXV0aCByZXF1ZXN0XG4gICAgICogQHBhcmFtIHJlc3BvbnNlIFRoZSBhdXRoIHJlc3BvbnNlIGlmIGl0IHdhcyBzdWNjZXNzZnVsXG4gICAgICogQHBhcmFtIGVycm9yUmVzcG9uc2UgVGhlIGVycm9yIHJlc3BvbnNlIGlmIGl0IGZhaWxlZFxuICAgICAqL1xuICAgIGRpZENvbXBsZXRlQXV0aG9yaXphdGlvbkZsb3cocmVxdWVzdCwgcmVzcG9uc2UsIGVycm9yUmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ1Jlc29sdmVyKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdSZXNvbHZlci5mdWxmaWxsKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdSZXNvbHZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JSZXNwb25zZSBpbnN0YW5jZW9mIFBvcHVwQ2xvc2VkRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nUmVzb2x2ZXIucmVqZWN0KEF1dGhlbnRpY2F0aW9uRXJyb3IuVXNlckNhbmNlbGxlZCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3JSZXNwb25zZSBpbnN0YW5jZW9mIFBvcHVwQmxvY2tlZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIGRvbWFpbiBvZiB0aGUgYXV0aG9yaXR5LCB0byBsb2cgYmV0dGVyIGNvbnRleHQgZm9yIGVycm9yLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cmxNYXRjaCA9IC9eKGh0dHA/czpcXC9cXC9bXFx3Ll0qKVxcL1tcXHdcXC9dKiQvO1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgbWF0Y2hlcyBhZ2FpbnN0IHRoZSBhdXRob3JpdHlcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHRoaXMuY29uZmlndXJhdGlvbi5hdXRob3JpemF0aW9uRW5kcG9pbnQubWF0Y2godXJsTWF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiYXNlVXJsID0gbWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCA+IDEgPyBtYXRjaGVzWzFdIDogJyc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1Jlc29sdmVyLnJlamVjdChBdXRoZW50aWNhdGlvbkVycm9yLlBvcHVwQmxvY2tlZChiYXNlVXJsKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdSZXNvbHZlci5yZWplY3QoQXV0aGVudGljYXRpb25FcnJvci5TZXJ2ZXJFcnJvcihlcnJvclJlc3BvbnNlLmVycm9yLCBlcnJvclJlc3BvbnNlLmVycm9yRGVzY3JpcHRpb24pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nUmVzb2x2ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGFuIGF1dGggcmVxdWVzdFxuICAgICAqL1xuICAgIGNyZWF0ZUF1dGhSZXF1ZXN0KG9wdHMpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGJhc2UgcmVxdWVzdFxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IEF1dGhvcml6YXRpb25SZXF1ZXN0KHtcbiAgICAgICAgICAgIGNsaWVudF9pZDogdGhpcy5jbGllbnRJZCxcbiAgICAgICAgICAgIHJlZGlyZWN0X3VyaTogdGhpcy5yZWRpcmVjdFVyaSxcbiAgICAgICAgICAgIHJlc3BvbnNlX3R5cGU6IEF1dGhvcml6YXRpb25SZXF1ZXN0LlJFU1BPTlNFX1RZUEVfQ09ERSxcbiAgICAgICAgICAgIHNjb3BlOiB0aGlzLnNjb3Blcy5qb2luKCcgJyksXG4gICAgICAgIH0sIHVuZGVmaW5lZCwgZmFsc2UpO1xuICAgICAgICAvLyBQYXNzIG9wdGlvbnMgdGhyb3VnaFxuICAgICAgICBpZiAob3B0cy5sb2dpbl9oaW50KSB7XG4gICAgICAgICAgICAvLyBPbmx5IGFzc2lnbiBleHRyYXMgaWYgbG9naW5faGludCBpcyBpbmNsdWRlZCBpbiB0aGUgb3B0aW9uc1xuICAgICAgICAgICAgcmVxdWVzdC5leHRyYXMgPSB7IGxvZ2luX2hpbnQ6IG9wdHMubG9naW5faGludCB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSB0b2tlbiByZXF1ZXN0IHdpdGggYSByZWZyZXNoIHRva2VuXG4gICAgICogQHBhcmFtIHJlZnJlc2hUb2tlbiBSZWZyZXNoIHRva2VuIHRvIHVzZVxuICAgICAqL1xuICAgIGNyZWF0ZVJlZnJlc2hUb2tlblJlcXVlc3QocmVmcmVzaFRva2VuKSB7XG4gICAgICAgIHJldHVybiBuZXcgVG9rZW5SZXF1ZXN0KHtcbiAgICAgICAgICAgIGNsaWVudF9pZDogdGhpcy5jbGllbnRJZCxcbiAgICAgICAgICAgIGdyYW50X3R5cGU6IEdSQU5UX1RZUEVfUkVGUkVTSF9UT0tFTixcbiAgICAgICAgICAgIHJlZGlyZWN0X3VyaTogdGhpcy5yZWRpcmVjdFVyaSxcbiAgICAgICAgICAgIHJlZnJlc2hfdG9rZW46IHJlZnJlc2hUb2tlbixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIHRva2VuIHJlcXVlc3Qgd2l0aCBhbiBhdXRoIGNvZGVcbiAgICAgKiBAcGFyYW0gY29kZSBUaGUgYXV0aCBjb2RlIHRvIHVzZVxuICAgICAqL1xuICAgIGNyZWF0ZVRva2VuUmVxdWVzdChjb2RlKSB7XG4gICAgICAgIHJldHVybiBuZXcgVG9rZW5SZXF1ZXN0KHtcbiAgICAgICAgICAgIGNsaWVudF9pZDogdGhpcy5jbGllbnRJZCxcbiAgICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgICBncmFudF90eXBlOiBHUkFOVF9UWVBFX0FVVEhPUklaQVRJT05fQ09ERSxcbiAgICAgICAgICAgIHJlZGlyZWN0X3VyaTogdGhpcy5yZWRpcmVjdFVyaSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQXV0aGVudGljYXRpb25TdGF0dXMsIE9BdXRoU2lnbkluTWV0aG9kIH0gZnJvbSAnLi4vYml0c2tpJztcbmltcG9ydCB7IEF1dGhlbnRpY2F0aW9uRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvYXV0aGVudGljYXRpb24tZXJyb3InO1xuaW1wb3J0IHsgT0F1dGhNYW5hZ2VyIH0gZnJvbSAnLi9vYXV0aC1tYW5hZ2VyJztcbmltcG9ydCB7IFRva2VuU3RvcmUgfSBmcm9tICcuL3Rva2VuLXN0b3JlJztcbmltcG9ydCB7IFVzZXIgfSBmcm9tICcuL3VzZXInO1xuaW1wb3J0IHsgVXNlclN0b3JlIH0gZnJvbSAnLi91c2VyLXN0b3JlJztcbmV4cG9ydCBjbGFzcyBPcGVuaWRBdXRoUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudElkLCByZWRpcmVjdFVyaSwgYWRkaXRpb25hbFNjb3Blcywgb3B0cykge1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB7XG4gICAgICAgICAgICBhZGRpdGlvbmFsU2NvcGVzLFxuICAgICAgICAgICAgY2xpZW50SWQsXG4gICAgICAgICAgICByZWRpcmVjdFVyaSxcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihzZXR0aW5ncywgb3B0cyk7XG4gICAgICAgIHRoaXMub2F1dGhNYW5hZ2VyID0gbmV3IE9BdXRoTWFuYWdlcihzZXR0aW5ncyk7XG4gICAgICAgIHRoaXMudG9rZW5TdG9yZSA9IG5ldyBUb2tlblN0b3JlKGNsaWVudElkLCBvcHRzLnN0b3JlKTtcbiAgICAgICAgdGhpcy51c2VyU3RvcmUgPSBuZXcgVXNlclN0b3JlKGNsaWVudElkLCBvcHRzLnN0b3JlKTtcbiAgICB9XG4gICAgZ2V0IGF1dGhTdGF0dXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnRva2VuU3RvcmUuY3VycmVudFRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gQXV0aGVudGljYXRpb25TdGF0dXMuQ29ubmVjdGVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudG9rZW5TdG9yZS5yZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBBdXRoZW50aWNhdGlvblN0YXR1cy5FeHBpcmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEF1dGhlbnRpY2F0aW9uU3RhdHVzLk5vdENvbm5lY3RlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRBY2Nlc3NUb2tlbigpIHtcbiAgICAgICAgaWYgKHRoaXMudG9rZW5TdG9yZS5jdXJyZW50VG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy50b2tlblN0b3JlLmN1cnJlbnRUb2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudG9rZW5TdG9yZS5yZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZnJlc2hBY2Nlc3NUb2tlbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChBdXRoZW50aWNhdGlvbkVycm9yLk5vdFNpZ25lZEluKCkpO1xuICAgIH1cbiAgICBnZXRSZWZyZXNoVG9rZW4oKSB7XG4gICAgICAgIGlmICh0aGlzLnRva2VuU3RvcmUucmVmcmVzaFRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMudG9rZW5TdG9yZS5yZWZyZXNoVG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVycm9yOiB0aGUgdXNlciBkaWQgbm90IGFwcHJvdmUgdGhpcyBhcHAgZm9yIG9mZmxpbmUgYWNjZXNzXG4gICAgICAgIGlmICh0aGlzLnRva2VuU3RvcmUuY3VycmVudFRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoQXV0aGVudGljYXRpb25FcnJvci5Ob1JlZnJlc2hUb2tlbigpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFcnJvcjogdGhlIHVzZXIgaXMgbm90IHNpZ25lZCBpbi5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KEF1dGhlbnRpY2F0aW9uRXJyb3IuTm90U2lnbmVkSW4oKSk7XG4gICAgfVxuICAgIGludmFsaWRhdGVUb2tlbigpIHtcbiAgICAgICAgaWYgKHRoaXMudG9rZW5TdG9yZS5jdXJyZW50VG9rZW4pIHtcbiAgICAgICAgICAgIHRoaXMudG9rZW5TdG9yZS5pbnZhbGlkYXRlQ3VycmVudFRva2VuKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2lnbk91dENhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnNpZ25PdXRDYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgcmVmcmVzaEFjY2Vzc1Rva2VuKCkge1xuICAgICAgICBpZiAodGhpcy50b2tlblN0b3JlLnJlZnJlc2hUb2tlbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2F1dGhNYW5hZ2VyLnJlZnJlc2hBY2Nlc3NUb2tlbih0aGlzLnRva2VuU3RvcmUucmVmcmVzaFRva2VuKS50aGVuKCh0b2tlblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50b2tlblN0b3JlLnBlcnNpc3RUb2tlblJlc3BvbnNlKHRva2VuUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlblJlc3BvbnNlLmFjY2Vzc1Rva2VuO1xuICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgY2FuJ3QgcmVuZXcsIHdlIGxpa2VseSBoYXZlIGJhZCBkYXRhXG4gICAgICAgICAgICAgICAgdGhpcy50b2tlblN0b3JlLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy51c2VyU3RvcmUuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChBdXRoZW50aWNhdGlvbkVycm9yLk5vUmVmcmVzaFRva2VuKCkpO1xuICAgIH1cbiAgICBzaWduSW4obWV0aG9kLCBvcHRzKSB7XG4gICAgICAgIGxldCBwcm9taXNlO1xuICAgICAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSBPQXV0aFNpZ25Jbk1ldGhvZC5SZWRpcmVjdDpcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gdGhpcy5vYXV0aE1hbmFnZXIuc2lnbkluUmVkaXJlY3Qob3B0cyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE9BdXRoU2lnbkluTWV0aG9kLlNpbGVudDpcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoQXV0aGVudGljYXRpb25FcnJvci5VbnN1cHBvcnRlZEF1dGhlbnRpY2F0aW9uTWV0aG9kKCkpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gdGhpcy5vYXV0aE1hbmFnZXIuc2lnbkluUG9wdXAob3B0cyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbigodG9rZW5SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy50b2tlblN0b3JlLnBlcnNpc3RUb2tlblJlc3BvbnNlKHRva2VuUmVzcG9uc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9hZFVzZXIoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZnJlc2hBY2Nlc3NUb2tlbigpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9hZFVzZXIoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFVzZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9yRmV0Y2hVc2VyKCk7XG4gICAgfVxuICAgIHNpZ25Jbk9yQ29ubmVjdChzaWduSW5NZXRob2QgPSBPQXV0aFNpZ25Jbk1ldGhvZC5Qb3B1cCwgb3B0cykge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuYXV0aFN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSBBdXRoZW50aWNhdGlvblN0YXR1cy5Db25uZWN0ZWQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9hZFVzZXIoKTtcbiAgICAgICAgICAgIGNhc2UgQXV0aGVudGljYXRpb25TdGF0dXMuRXhwaXJlZDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0KCk7XG4gICAgICAgICAgICBjYXNlIEF1dGhlbnRpY2F0aW9uU3RhdHVzLk5vdENvbm5lY3RlZDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zaWduSW4oc2lnbkluTWV0aG9kLCBvcHRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWRpcmVjdENhbGxiYWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vYXV0aE1hbmFnZXIucmVkaXJlY3RDYWxsYmFjaygpLnRoZW4oKHRva2VuUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIHRoaXMudG9rZW5TdG9yZS5wZXJzaXN0VG9rZW5SZXNwb25zZSh0b2tlblJlc3BvbnNlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvYWRVc2VyKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaWduT3V0KCkge1xuICAgICAgICB0aGlzLnRva2VuU3RvcmUuY2xlYXIoKTtcbiAgICAgICAgdGhpcy51c2VyU3RvcmUuY2xlYXIoKTtcbiAgICAgICAgLy8gQ2FsbCB0aGUgc2lnbiBvdXQgY2FsbGJhY2sgaWYgb25lIGhhcyBiZWVuIHByb3ZpZGVkXG4gICAgICAgIGlmICh0aGlzLnNpZ25PdXRDYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5zaWduT3V0Q2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBkb24ndCBjdXJyZW50bHkgaGF2ZSB0aGUgYWJpbGl0eSB0byBpbnZhbGlkYXRlIGFjY2VzcyB0b2tlbnMsIHNvIGZvciBub3cgc2ltcGx5IHJlc29sdmUuXG4gICAgICAgIC8vIERvd24gdGhlIHJvYWQgdGhpcyBtYXkgcGVyZm9ybSBhIG5ldHdvcmsgcmVxdWVzdCB0byBpbnZhbGlkYXRlLlxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGdldE9yRmV0Y2hVc2VyKCkge1xuICAgICAgICBjb25zdCBjdXJyZW50VXNlciA9IHRoaXMudXNlclN0b3JlLmN1cnJlbnRVc2VyO1xuICAgICAgICBpZiAoY3VycmVudFVzZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY3VycmVudFVzZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRVc2VyKCk7XG4gICAgfVxuICAgIGxvYWRVc2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBY2Nlc3NUb2tlbigpLnRoZW4oKGFjY2Vzc1Rva2VuKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vYXV0aE1hbmFnZXIucmVxdWVzdFVzZXJJbmZvKGFjY2Vzc1Rva2VuKTtcbiAgICAgICAgfSkudGhlbigoanNvbikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFVzZXIuZnJvbUpzb24oanNvbik7XG4gICAgICAgIH0pLnRoZW4oKHVzZXIpID0+IHtcbiAgICAgICAgICAgIHRoaXMudXNlclN0b3JlLnNldCh1c2VyKTtcbiAgICAgICAgICAgIHJldHVybiB1c2VyO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCIvLyB0c2xpbnQ6ZGlzYWJsZSBtYXgtY2xhc3Nlcy1wZXItZmlsZVxuaW1wb3J0IHsgQXV0aG9yaXphdGlvbkVycm9yLCBBdXRob3JpemF0aW9uUmVxdWVzdEhhbmRsZXIsIEF1dGhvcml6YXRpb25SZXNwb25zZSwgQmFzaWNRdWVyeVN0cmluZ1V0aWxzLCBEZWZhdWx0Q3J5cHRvLCB9IGZyb20gJ0BvcGVuaWQvYXBwYXV0aCc7XG5pbXBvcnQgeyBDSEVDS19GT1JfUE9QVVBfQ0xPU0VfSU5URVJWQUwsIERFRkFVTFRfUE9QVVBfRkVBVFVSRVMgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgcGFyc2VVcmxQYXJhbXMgfSBmcm9tICcuLi91dGlscy9jYWxsYmFjayc7XG5pbXBvcnQgeyBQb3B1cFZhbGlkYXRvciB9IGZyb20gJy4uL3V0aWxzL3BvcHVwLXZhbGlkYXRvcic7XG4vLyBJbnRlcm1lZGlhdGUgZXJyb3JzLCBzaW5jZSBBdXRob3JpemF0aW9uUmVxdWVzdEhhbmRsZXIgbXVzdCByZXR1cm4gYW4gQXV0aG9yaXphdGlvbkVycm9yIGluc3RhbmNlLlxuLy8gVGhlc2Ugc2hvdWxkIG5vdCBiZSB1c2VyIHZpc2libGUuXG5leHBvcnQgY2xhc3MgUG9wdXBDbG9zZWRFcnJvciBleHRlbmRzIEF1dGhvcml6YXRpb25FcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKHsgZXJyb3I6ICdUaGUgcG9wdXAgd2FzIGRpc21pc3NlZC4nIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBQb3B1cEJsb2NrZWRFcnJvciBleHRlbmRzIEF1dGhvcml6YXRpb25FcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKHsgZXJyb3I6ICdUaGUgcG9wdXAgd2FzIGJsb2NrZWQuJyB9KTtcbiAgICB9XG59XG4vLyBDcmVhdGUgYSBwb3B1cCBmZWF0dXJlIHN0cmluZyBmcm9tIGFuIG9iamVjdCB3aXRoIGtleXMgYW5kIHZhbHVlc1xuZnVuY3Rpb24gY3JlYXRlUG9wdXBGZWF0dXJlU3RyaW5nKGZlYXR1cmVzKSB7XG4gICAgLy8gQ29udmVydCB0byBhcnJheSBvZiBzdHJpbmdzXG4gICAgY29uc3QgZmVhdHVyZXNBcnJheSA9IE9iamVjdC5rZXlzKGZlYXR1cmVzKS5yZWR1Y2UoKGFyciwga2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZmVhdHVyZXNba2V5XTtcbiAgICAgICAgLy8gY29udmVydCB0byBmZWF0dXJlIHN0cmluZyBmb3JtYXQ6IHRvcD0xMDBcbiAgICAgICAgYXJyLnB1c2goYCR7a2V5fT0ke3ZhbHVlfWApO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sIEFycmF5KCkpO1xuICAgIC8vIEpvaW4gc3RyaW5ncyB3aXRoICcsJyBhbmQgZmluaXNoIHdpdGggJzsnXG4gICAgcmV0dXJuIGZlYXR1cmVzQXJyYXkuam9pbignLCcpICsgJzsnO1xufVxuLy8gUmV0dXJucyBhIHNldCBvZiBhdHRyaWJ1dGVzIGZvciBhIGNlbnRlcmVkIHBvcHVwIGJhc2VkIG9uXG4vLyB0aGUgZGVmYXVsdCB2YWx1ZXMgZnJvbSBjb25zdGFudHMudHNcbmZ1bmN0aW9uIGNyZWF0ZUNlbnRlcmVkUG9wdXBGZWF0dXJlcygpIHtcbiAgICBjb25zdCB3aW5kb3dGZWF0dXJlcyA9IERFRkFVTFRfUE9QVVBfRkVBVFVSRVM7XG4gICAgY29uc3QgdyA9IHdpbmRvd0ZlYXR1cmVzLndpZHRoO1xuICAgIGNvbnN0IGggPSB3aW5kb3dGZWF0dXJlcy5oZWlnaHQ7XG4gICAgLy8gRml4ZXMgZHVhbC1zY3JlZW4gcG9zaXRpb25cbiAgICBjb25zdCBkdWFsU2NyZWVuTGVmdCA9IHdpbmRvdy5zY3JlZW5MZWZ0IHx8IHdpbmRvdy5zY3JlZW5YO1xuICAgIGNvbnN0IGR1YWxTY3JlZW5Ub3AgPSB3aW5kb3cuc2NyZWVuVG9wIHx8IHdpbmRvdy5zY3JlZW5ZO1xuICAgIGNvbnN0IHdpbmRvd1dpZHRoID0gd2luZG93LmlubmVyV2lkdGggfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIHx8IHNjcmVlbi53aWR0aDtcbiAgICBjb25zdCB3aW5kb3dIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCB8fCBzY3JlZW4uaGVpZ2h0O1xuICAgIGNvbnN0IGxlZnQgPSAod2luZG93V2lkdGggLyAyKSAtICh3IC8gMik7XG4gICAgY29uc3QgdG9wID0gKHdpbmRvd0hlaWdodCAvIDIpIC0gKGggLyAyKTtcbiAgICB3aW5kb3dGZWF0dXJlcy5sZWZ0ID0gbGVmdCArIGR1YWxTY3JlZW5MZWZ0O1xuICAgIHdpbmRvd0ZlYXR1cmVzLnRvcCA9IHRvcCArIGR1YWxTY3JlZW5Ub3A7XG4gICAgcmV0dXJuIHdpbmRvd0ZlYXR1cmVzO1xufVxuZXhwb3J0IGNsYXNzIFBvcHVwUmVxdWVzdEhhbmRsZXIgZXh0ZW5kcyBBdXRob3JpemF0aW9uUmVxdWVzdEhhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKHV0aWxzID0gbmV3IEJhc2ljUXVlcnlTdHJpbmdVdGlscygpLCBjcnlwdG8gPSBuZXcgRGVmYXVsdENyeXB0bygpKSB7XG4gICAgICAgIHN1cGVyKHV0aWxzLCBjcnlwdG8pO1xuICAgICAgICB0aGlzLnBvcHVwV2luZG93ID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc0NhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzQmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICAvLyBXYXRjaCBmb3IgdGhlIHBvcHVwIGJlaW5nIGJsb2NrZWRcbiAgICAgICAgdGhpcy52YWxpZGF0b3IgPSBuZXcgUG9wdXBWYWxpZGF0b3IoKCkgPT4ge1xuICAgICAgICAgICAgLy8gUmV0dXJuIGEgc3BlY2lmaWMgZXJyb3IgaWYgYmxvY2tlZCwgc28gdGhhdCB3ZSBjYW4gaGFuZGxlIGl0IGFwcHJvcHJpYXRlbHkuXG4gICAgICAgICAgICB0aGlzLmlzQmxvY2tlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRlQXV0aG9yaXphdGlvblJlcXVlc3RJZlBvc3NpYmxlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwZXJmb3JtQXV0aG9yaXphdGlvblJlcXVlc3QoY29uZmlndXJhdGlvbiwgcmVxdWVzdCkge1xuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLmJ1aWxkUmVxdWVzdFVybChjb25maWd1cmF0aW9uLCByZXF1ZXN0KTtcbiAgICAgICAgdGhpcy5wZW5kaW5nUmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgIHRoaXMuaWQgPSByZXF1ZXN0LnN0YXRlO1xuICAgICAgICAvLyBTZXQgYSB1bmlxdWUgaGFuZGxlciBvbiB0aGUgbWFpbiB3aW5kb3dcbiAgICAgICAgd2luZG93W2Bwb3B1cENhbGxiYWNrXyR7cmVxdWVzdC5zdGF0ZX1gXSA9IHRoaXMuY2FsbGJhY2suYmluZCh0aGlzKTtcbiAgICAgICAgLy8gU3RhcnQgbW9uaXRvcmluZyB0byBzZWUgaWYgdGhlIHBvcHVwIGhhcyBiZWVuIGNsb3NlZFxuICAgICAgICB0aGlzLmNsb3NlZFRpbWVyID0gd2luZG93LnNldEludGVydmFsKHRoaXMuY2hlY2tQb3B1cC5iaW5kKHRoaXMpLCBDSEVDS19GT1JfUE9QVVBfQ0xPU0VfSU5URVJWQUwpO1xuICAgICAgICAvLyBDcmVhdGUgZmVhdHVyZXMgZm9yIHBvcHVwXG4gICAgICAgIGNvbnN0IHdpbmRvd0ZlYXR1cmVzID0gY3JlYXRlQ2VudGVyZWRQb3B1cEZlYXR1cmVzKCk7XG4gICAgICAgIC8vIENyZWF0ZSBwb3B1cCB3aW5kb3dcbiAgICAgICAgdGhpcy5wb3B1cFdpbmRvdyA9IHdpbmRvdy5vcGVuKHVybCwgJ19ibGFuaycsIGNyZWF0ZVBvcHVwRmVhdHVyZVN0cmluZyh3aW5kb3dGZWF0dXJlcykpO1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgcG9wdXAgd2UganVzdCBjcmVhdGVkIHdhcyBibG9ja2VkLlxuICAgICAgICB0aGlzLnZhbGlkYXRvci5jaGVjayh0aGlzLnBvcHVwV2luZG93KTtcbiAgICAgICAgLy8gRm9jdXMgdGhlIHBvcHVwIHRvIGJyaW5nIGl0IHRvIHRoZSBmcm9udFxuICAgICAgICBpZiAodGhpcy5wb3B1cFdpbmRvdykge1xuICAgICAgICAgICAgdGhpcy5wb3B1cFdpbmRvdy5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbGxiYWNrKHVybCkge1xuICAgICAgICB0aGlzLnJlc3BvbnNlVXJsID0gdXJsO1xuICAgICAgICB0aGlzLmNvbXBsZXRlQXV0aG9yaXphdGlvblJlcXVlc3RJZlBvc3NpYmxlKCk7XG4gICAgfVxuICAgIC8vIEN1c3RvbSBpbXBsZW1lbnRhdGlvbiB0byByZW1vdmUgZXhjZXNzIGxvZyBzcGFtXG4gICAgY29tcGxldGVBdXRob3JpemF0aW9uUmVxdWVzdElmUG9zc2libGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlQXV0aG9yaXphdGlvblJlcXVlc3QoKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgJiYgdGhpcy5ub3RpZmllcikge1xuICAgICAgICAgICAgICAgIHRoaXMubm90aWZpZXIub25BdXRob3JpemF0aW9uQ29tcGxldGUocmVzdWx0LnJlcXVlc3QsIHJlc3VsdC5yZXNwb25zZSwgcmVzdWx0LmVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbXBsZXRlQXV0aG9yaXphdGlvblJlcXVlc3QoKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLnBlbmRpbmdSZXF1ZXN0O1xuICAgICAgICAvLyBBc3NlcnQgdGhlcmUgaXMgYSBwZW5kaW5nIHJlcXVlc3RcbiAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFzc2VydCB0aGUgcmVxdWVzdCB3YXNuJ3QgY2FuY2VsbGVkXG4gICAgICAgIGlmICh0aGlzLmlzQ2FuY2VsbGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNwb25kV2l0aENhbmNlbGxlZChyZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0Jsb2NrZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3BvbmRXaXRoQmxvY2tlZChyZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBc3NlcnQgdGhlcmUgaXMgbm8gZXJyb3JcbiAgICAgICAgaWYgKHRoaXMuZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3BvbmRXaXRoRXJyb3IocmVxdWVzdCwgdGhpcy5lcnJvci5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBc3NlcnQgdGhlcmUgaXMgYSByZXNwb25zZSB1cmwgdG8gcGFyc2VcbiAgICAgICAgaWYgKCF0aGlzLnJlc3BvbnNlVXJsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhcnNlIHRoZSB1cmwgaW50byBkYXRhXG4gICAgICAgIGNvbnN0IGRhdGEgPSBwYXJzZVVybFBhcmFtcyh0aGlzLnJlc3BvbnNlVXJsKTtcbiAgICAgICAgLy8gRXh0cmEgdGhlIHN0YXRlXG4gICAgICAgIGNvbnN0IHN0YXRlID0gZGF0YS5zdGF0ZTtcbiAgICAgICAgLy8gVmFsaWRhdGUgc3RhdGUgaXMgc2FtZSBhcyByZXF1ZXN0XG4gICAgICAgIGlmIChyZXF1ZXN0LnN0YXRlICE9PSBzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBmb3IgYW4gZXJyb3IgcmVzcG9uc2VcbiAgICAgICAgY29uc3QgZXJyb3IgPSBkYXRhLmVycm9yO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIGdldCBhZGRpdGlvbmFsIG9wdGlvbmFsIGluZm8uXG4gICAgICAgICAgICBjb25zdCBlcnJvclVyaSA9IGRhdGEuZXJyb3JfdXJpO1xuICAgICAgICAgICAgY29uc3QgZXJyb3JEZXNjcmlwdGlvbiA9IGRhdGEuZXJyb3JfZGVzY3JpcHRpb247XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNwb25kV2l0aEVycm9yKHJlcXVlc3QsIGVycm9yLCBlcnJvckRlc2NyaXB0aW9uLCBlcnJvclVyaSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzcG9uZCB3aXRoIGEgY29kZVxuICAgICAgICBjb25zdCBjb2RlID0gZGF0YS5jb2RlO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNwb25kV2l0aENvZGUocmVxdWVzdCwgY29kZSk7XG4gICAgfVxuICAgIHJlc3BvbmRXaXRoQmxvY2tlZChyZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IFBvcHVwQmxvY2tlZEVycm9yKCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0geyByZXF1ZXN0LCBlcnJvciwgcmVzcG9uc2U6IG51bGwgfTtcbiAgICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzcG9uc2UpO1xuICAgIH1cbiAgICByZXNwb25kV2l0aENhbmNlbGxlZChyZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IFBvcHVwQ2xvc2VkRXJyb3IoKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB7IHJlcXVlc3QsIGVycm9yLCByZXNwb25zZTogbnVsbCB9O1xuICAgICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXNwb25zZSk7XG4gICAgfVxuICAgIHJlc3BvbmRXaXRoRXJyb3IocmVxdWVzdCwgZXJyb3JNZXNzYWdlLCBlcnJvckRlc2NyaXB0aW9uLCBlcnJvclVyaSkge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBBdXRob3JpemF0aW9uRXJyb3IoeyBlcnJvcjogZXJyb3JNZXNzYWdlLCBlcnJvcl9kZXNjcmlwdGlvbjogZXJyb3JEZXNjcmlwdGlvbiwgZXJyb3JfdXJpOiBlcnJvclVyaSwgc3RhdGU6IHJlcXVlc3Quc3RhdGUgfSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0geyByZXF1ZXN0LCBlcnJvciwgcmVzcG9uc2U6IG51bGwgfTtcbiAgICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzcG9uc2UpO1xuICAgIH1cbiAgICByZXNwb25kV2l0aENvZGUocmVxdWVzdCwgY29kZSkge1xuICAgICAgICBsZXQgYXV0aG9yaXphdGlvblJlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgaWYgKGNvZGUpIHtcbiAgICAgICAgICAgIGF1dGhvcml6YXRpb25SZXNwb25zZSA9IG5ldyBBdXRob3JpemF0aW9uUmVzcG9uc2UoeyBjb2RlLCBzdGF0ZTogcmVxdWVzdC5zdGF0ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IHsgcmVxdWVzdCwgcmVzcG9uc2U6IGF1dGhvcml6YXRpb25SZXNwb25zZSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzcG9uc2UpO1xuICAgIH1cbiAgICBjbGVhbnVwKCkge1xuICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLmNsb3NlZFRpbWVyKTtcbiAgICAgICAgZGVsZXRlIHdpbmRvd1tgcG9wdXBDYWxsYmFja18ke3RoaXMuaWR9YF07XG4gICAgICAgIGlmICh0aGlzLnBvcHVwV2luZG93KSB7XG4gICAgICAgICAgICB0aGlzLnBvcHVwV2luZG93LmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3B1cFdpbmRvdyA9IG51bGw7XG4gICAgICAgIHRoaXMucGVuZGluZ1JlcXVlc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmVzcG9uc2VVcmwgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNoZWNrUG9wdXAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBvcHVwV2luZG93ICYmIHRoaXMucG9wdXBXaW5kb3cuY2xvc2VkKSB7XG4gICAgICAgICAgICAvLyBTdG9wIGNoZWNraW5nXG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLmNsb3NlZFRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMuaXNDYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jb21wbGV0ZUF1dGhvcml6YXRpb25SZXF1ZXN0SWZQb3NzaWJsZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQUNDRVNTX1RPS0VOX0tFWSwgUkVGUkVTSF9UT0tFTl9LRVkgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgTG9jYWxTdG9yYWdlU3RvcmUgfSBmcm9tICcuLi91dGlscy9sb2NhbHN0b3JhZ2Utc3RvcmUnO1xuaW1wb3J0IHsgQWNjZXNzVG9rZW4gfSBmcm9tICcuL2FjY2Vzcy10b2tlbic7XG5leHBvcnQgY2xhc3MgVG9rZW5TdG9yZSB7XG4gICAgY29uc3RydWN0b3IoY2xpZW50SWQsIHN0b3JlKSB7XG4gICAgICAgIHRoaXMuY2xpZW50SWQgPSBjbGllbnRJZDtcbiAgICAgICAgdGhpcy5zdG9yZSA9IHN0b3JlIHx8IG5ldyBMb2NhbFN0b3JhZ2VTdG9yZSgpO1xuICAgICAgICBjb25zdCBhY2Nlc3NUb2tlblN0cmluZyA9IHRoaXMuc3RvcmUuZ2V0SXRlbSh0aGlzLmFjY2Vzc1Rva2VuS2V5KTtcbiAgICAgICAgaWYgKGFjY2Vzc1Rva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICBsZXQgcGFyc2VkVG9rZW47XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBhcnNlZFRva2VuID0gQWNjZXNzVG9rZW4uZnJvbVN0cmluZyhhY2Nlc3NUb2tlblN0cmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuID0gcGFyc2VkVG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRUb2tlbigpIHtcbiAgICAgICAgaWYgKHRoaXMuYWNjZXNzVG9rZW4gJiYgIXRoaXMuYWNjZXNzVG9rZW4uZXhwaXJlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWNjZXNzVG9rZW4udG9rZW47XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHJlZnJlc2hUb2tlbigpIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLnN0b3JlLmdldEl0ZW0odGhpcy5yZWZyZXNoVG9rZW5LZXkpO1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgYWNjZXNzVG9rZW5LZXkoKSB7XG4gICAgICAgIHJldHVybiBgJHtBQ0NFU1NfVE9LRU5fS0VZfS4ke3RoaXMuY2xpZW50SWR9YDtcbiAgICB9XG4gICAgZ2V0IHJlZnJlc2hUb2tlbktleSgpIHtcbiAgICAgICAgcmV0dXJuIGAke1JFRlJFU0hfVE9LRU5fS0VZfS4ke3RoaXMuY2xpZW50SWR9YDtcbiAgICB9XG4gICAgcGVyc2lzdFRva2VuUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnJlZnJlc2hUb2tlbikge1xuICAgICAgICAgICAgdGhpcy5zdG9yZS5zZXRJdGVtKHRoaXMucmVmcmVzaFRva2VuS2V5LCByZXNwb25zZS5yZWZyZXNoVG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFRva2VuID0gQWNjZXNzVG9rZW4uZnJvbVRva2VuUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB0aGlzLnN0b3JlLnNldEl0ZW0odGhpcy5hY2Nlc3NUb2tlbktleSwgcGFyc2VkVG9rZW4udG9TdG9yYWdlU3RyaW5nKCkpO1xuICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuID0gcGFyc2VkVG9rZW47XG4gICAgfVxuICAgIGludmFsaWRhdGVDdXJyZW50VG9rZW4oKSB7XG4gICAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc3RvcmUuY2xlYXJJdGVtKHRoaXMuYWNjZXNzVG9rZW5LZXkpO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zdG9yZS5jbGVhckl0ZW0odGhpcy5yZWZyZXNoVG9rZW5LZXkpO1xuICAgICAgICB0aGlzLnN0b3JlLmNsZWFySXRlbSh0aGlzLmFjY2Vzc1Rva2VuS2V5KTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBVU0VSX0tFWSB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBMb2NhbFN0b3JhZ2VTdG9yZSB9IGZyb20gJy4uL3V0aWxzL2xvY2Fsc3RvcmFnZS1zdG9yZSc7XG5pbXBvcnQgeyBVc2VyIH0gZnJvbSAnLi91c2VyJztcbmV4cG9ydCBjbGFzcyBVc2VyU3RvcmUge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudElkLCBzdG9yZSkge1xuICAgICAgICB0aGlzLmNsaWVudElkID0gY2xpZW50SWQ7XG4gICAgICAgIHRoaXMuc3RvcmUgPSBzdG9yZSB8fCBuZXcgTG9jYWxTdG9yYWdlU3RvcmUoKTtcbiAgICAgICAgdGhpcy51c2VyID0gdGhpcy5mZXRjaFVzZXIoKTtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRVc2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51c2VyIHx8IHRoaXMuZmV0Y2hVc2VyKCk7XG4gICAgfVxuICAgIGdldCBzdG9yYWdlS2V5KCkge1xuICAgICAgICByZXR1cm4gYCR7VVNFUl9LRVl9LiR7dGhpcy5jbGllbnRJZH1gO1xuICAgIH1cbiAgICBzZXQodXNlcikge1xuICAgICAgICB0aGlzLnVzZXIgPSB1c2VyO1xuICAgICAgICB0aGlzLmNhY2hlVXNlcih1c2VyKTtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMudXNlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jYWNoZVVzZXIodW5kZWZpbmVkKTtcbiAgICB9XG4gICAgZmV0Y2hVc2VyKCkge1xuICAgICAgICBjb25zdCB1c2VyRGF0YSA9IHRoaXMuc3RvcmUuZ2V0SXRlbSh0aGlzLnN0b3JhZ2VLZXkpO1xuICAgICAgICBpZiAodXNlckRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBVc2VyLmZyb21TdHJpbmcodXNlckRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhY2hlVXNlcih1c2VyKSB7XG4gICAgICAgIGlmICh1c2VyKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3JlLnNldEl0ZW0odGhpcy5zdG9yYWdlS2V5LCB1c2VyLnRvU3RvcmFnZVN0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmUuY2xlYXJJdGVtKHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJleHBvcnQgY2xhc3MgVXNlciB7XG4gICAgY29uc3RydWN0b3IoaWQsIGFjY291bnRzLCBlbWFpbCwgZW1haWxWZXJpZmllZCwgcGhvbmUsIHBob25lTnVtYmVyVmVyaWZpZWQpIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmFjY291bnRzID0gYWNjb3VudHM7XG4gICAgICAgIHRoaXMuZW1haWwgPSBlbWFpbDtcbiAgICAgICAgdGhpcy5lbWFpbFZlcmlmaWVkID0gZW1haWxWZXJpZmllZDtcbiAgICAgICAgdGhpcy5waG9uZU51bWJlciA9IHBob25lO1xuICAgICAgICB0aGlzLnBob25lTnVtYmVyVmVyaWZpZWQgPSBwaG9uZU51bWJlclZlcmlmaWVkO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb24oanNvbikge1xuICAgICAgICByZXR1cm4gbmV3IFVzZXIoanNvbi5zdWIsIGpzb24uYWNjb3VudHMsIGpzb24uZW1haWwsIGpzb24uZW1haWxfdmVyaWZpZWQsIGpzb24ucGhvbmVfbnVtYmVyLCBqc29uLnBob25lX251bWJlcl92ZXJpZmllZCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU3RyaW5nKHMpIHtcbiAgICAgICAgbGV0IHBhcnNlZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBhcnNlZCA9IEpTT04ucGFyc2Uocyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyc2VkLmlkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVzZXIocGFyc2VkLmlkLCBwYXJzZWQuYWNjb3VudHMsIHBhcnNlZC5lbWFpbCwgcGFyc2VkLmVtYWlsVmVyaWZpZWQsIHBhcnNlZC5waG9uZU51bWJlciwgcGFyc2VkLnBob25lTnVtYmVyVmVyaWZpZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdG9TdG9yYWdlU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgYWNjb3VudHM6IHRoaXMuYWNjb3VudHMsXG4gICAgICAgICAgICBlbWFpbDogdGhpcy5lbWFpbCxcbiAgICAgICAgICAgIGVtYWlsVmVyaWZpZWQ6IHRoaXMuZW1haWxWZXJpZmllZCxcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgcGhvbmVOdW1iZXI6IHRoaXMucGhvbmVOdW1iZXIsXG4gICAgICAgICAgICBwaG9uZU51bWJlclZlcmlmaWVkOiB0aGlzLnBob25lTnVtYmVyVmVyaWZpZWQsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IEtvdmFuLCBNYWlubmV0LCBSaW5rZWJ5IH0gZnJvbSAnYml0c2tpLXByb3ZpZGVyJztcbmltcG9ydCB7IExPR0lOX0hJTlRfU0lHTlVQIH0gZnJvbSAnLi9hdXRoL29hdXRoLW1hbmFnZXInO1xuaW1wb3J0IHsgT3BlbmlkQXV0aFByb3ZpZGVyIH0gZnJvbSAnLi9hdXRoL29wZW5pZC1hdXRoLXByb3ZpZGVyJztcbmltcG9ydCB7IENvbm5lY3RCdXR0b24sIENvbm5lY3RCdXR0b25TaXplIH0gZnJvbSAnLi9jb21wb25lbnRzL2Nvbm5lY3QtYnV0dG9uJztcbmltcG9ydCB7IFNES19WRVJTSU9OIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgQml0c2tpQnJvd3NlckVuZ2luZSB9IGZyb20gJy4vcHJvdmlkZXJzL2JpdHNraS1icm93c2VyLWVuZ2luZSc7XG5pbXBvcnQgY3NzIGZyb20gJy4vc3R5bGVzL2luZGV4JztcbmltcG9ydCB7IHByb2Nlc3NDYWxsYmFjayB9IGZyb20gJy4vdXRpbHMvY2FsbGJhY2snO1xuaW1wb3J0IHsgTG9jYWxTdG9yYWdlU3RvcmUgfSBmcm9tICcuL3V0aWxzL2xvY2Fsc3RvcmFnZS1zdG9yZSc7XG5leHBvcnQgdmFyIE9BdXRoU2lnbkluTWV0aG9kO1xuKGZ1bmN0aW9uIChPQXV0aFNpZ25Jbk1ldGhvZCkge1xuICAgIE9BdXRoU2lnbkluTWV0aG9kW1wiUmVkaXJlY3RcIl0gPSBcIlJFRElSRUNUXCI7XG4gICAgT0F1dGhTaWduSW5NZXRob2RbXCJQb3B1cFwiXSA9IFwiUE9QVVBcIjtcbiAgICBPQXV0aFNpZ25Jbk1ldGhvZFtcIlNpbGVudFwiXSA9IFwiU0lMRU5UXCI7XG59KShPQXV0aFNpZ25Jbk1ldGhvZCB8fCAoT0F1dGhTaWduSW5NZXRob2QgPSB7fSkpO1xuZXhwb3J0IHZhciBBdXRoZW50aWNhdGlvblN0YXR1cztcbihmdW5jdGlvbiAoQXV0aGVudGljYXRpb25TdGF0dXMpIHtcbiAgICBBdXRoZW50aWNhdGlvblN0YXR1c1tcIkNvbm5lY3RlZFwiXSA9IFwiQ09OTkVDVEVEXCI7XG4gICAgQXV0aGVudGljYXRpb25TdGF0dXNbXCJFeHBpcmVkXCJdID0gXCJFWFBJUkVEXCI7XG4gICAgQXV0aGVudGljYXRpb25TdGF0dXNbXCJOb3RDb25uZWN0ZWRcIl0gPSBcIk5PVF9DT05ORUNURURcIjtcbn0pKEF1dGhlbnRpY2F0aW9uU3RhdHVzIHx8IChBdXRoZW50aWNhdGlvblN0YXR1cyA9IHt9KSk7XG4vLyBDdXN0b21pemUgdG9rZW4gYW5kIHVzZXIgY2FjaGluZ1xuZXhwb3J0IHsgTG9jYWxTdG9yYWdlU3RvcmUgfTtcbi8vIFNpZ24taW4gT3B0aW9uc1xuZXhwb3J0IHsgTE9HSU5fSElOVF9TSUdOVVAgfTtcbi8vIE5ldHdvcmtzXG5leHBvcnQgeyBNYWlubmV0LCBSaW5rZWJ5LCBLb3ZhbiB9O1xuLy8gQ29ubmVjdCBCdXR0b25cbmV4cG9ydCB7IENvbm5lY3RCdXR0b25TaXplIH07XG4vLyBFcnJvcnNcbmV4cG9ydCB7IEF1dGhlbnRpY2F0aW9uRXJyb3IsIEF1dGhlbnRpY2F0aW9uRXJyb3JDb2RlIH0gZnJvbSAnLi9lcnJvcnMvYXV0aGVudGljYXRpb24tZXJyb3InO1xuZXhwb3J0IHsgUGFyc2VFcnJvciwgUGFyc2VFcnJvckNvZGUgfSBmcm9tICcuL2Vycm9ycy9wYXJzZS1lcnJvcic7XG5leHBvcnQgeyBTaWduZXJFcnJvciwgU2lnbmVyRXJyb3JDb2RlIH0gZnJvbSAnLi9lcnJvcnMvc2lnbmVyLWVycm9yJztcbi8qKlxuICogQml0c2tpIFNES1xuICovXG5leHBvcnQgY2xhc3MgQml0c2tpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gY2xpZW50SWQgT0F1dGggQ2xpZW50IElEXG4gICAgICogQHBhcmFtIHJlZGlyZWN0VXJpIFJlZGlyZWN0IHVyaSwgZGVmYXVsdHMgdG8gdGhlIGN1cnJlbnQgdXJsLiBUaGlzIHNob3VsZCBiZSB0aGUgbG9jYXRpb24gb2YgeW91ciBjYWxsYmFjayBodG1sIGZpbGUuXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxTY29wZXMgVG8gdXNlIGN1c3RvbSBzY29wZXMsIGFkZCB0aGVtIGhlcmUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIFsnb2ZmbGluZSddLlxuICAgICAqIE5vdGU6IE1ha2Ugc3VyZSB5b3VyIGFwcCBpcyBhcHByb3ZlZCBmb3IgdGhlIHNjb3BlcyB5b3UgYXJlIHJlcXVlc3RpbmcgZmlyc3QuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3RoZXIgT0F1dGggc2V0dGluZ3MuIERvbid0IGNoYW5nZSB0aGVzZSB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UgYXJlIGRvaW5nLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudElkLCByZWRpcmVjdFVyaSwgYWRkaXRpb25hbFNjb3Blcywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmVuZ2luZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc2lnbm91dEhhbmRsZXJzID0gW107XG4gICAgICAgIHRoaXMuY2xpZW50SWQgPSBjbGllbnRJZDtcbiAgICAgICAgdGhpcy5zZGtWZXJzaW9uID0gU0RLX1ZFUlNJT047XG4gICAgICAgIHRoaXMuYXV0aFByb3ZpZGVyID0gbmV3IE9wZW5pZEF1dGhQcm92aWRlcihjbGllbnRJZCwgcmVkaXJlY3RVcmkgfHwgd2luZG93LmxvY2F0aW9uLmhyZWYsIGFkZGl0aW9uYWxTY29wZXMsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoZG9jdW1lbnQgJiYgZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgdGhpcy5pbmplY3RTdHlsZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5qZWN0U3R5bGVzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF1dGhQcm92aWRlci5zaWduT3V0Q2FsbGJhY2sgPSB0aGlzLm9uU2lnbk91dC5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbHRlcm5hdGl2ZSB0byB1c2luZyBvdXIgc3RhdGljIGNhbGxiYWNrLmh0bWwgZmlsZS4gQ2FsbCB0aGlzIGZyb20geW91ciBvd24gcmVkaXJlY3QgcGFnZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgY2FsbGJhY2soKSB7XG4gICAgICAgIHByb2Nlc3NDYWxsYmFjaygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHdlYjMgcHJvdmlkZXIgZm9yIGEgZ2l2ZW4gbmV0d29yay5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBvcHRpb25zIGZvciB0aGUgcHJvdmlkZXIsIG9yIGEgbmV0d29yayBuYW1lXG4gICAgICovXG4gICAgZ2V0UHJvdmlkZXIob3B0aW9ucykge1xuICAgICAgICAvLyBDaGVjayBjYWNoZSBmb3IgZXhpc3RpbmcgcHJvdmlkZXJcbiAgICAgICAgY29uc3QgZXhpc3RpbmdQcm92aWRlciA9IHRoaXMuZW5naW5lcy5nZXQoSlNPTi5zdHJpbmdpZnkob3B0aW9ucykpO1xuICAgICAgICBpZiAoZXhpc3RpbmdQcm92aWRlcikge1xuICAgICAgICAgICAgZXhpc3RpbmdQcm92aWRlci5zdGFydCgpO1xuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nUHJvdmlkZXI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHByb3ZpZGVyIGlmIG9uZSBkb2VzIG5vdCBleGlzdFxuICAgICAgICBsZXQgbm9ybWFsaXplZE9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV0d29yayA9IHRoaXMubmV0d29ya0Zyb21Qcm92aWRlck9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGlmIChuZXR3b3JrID09PSBLb3ZhbiAmJiBub3JtYWxpemVkT3B0aW9ucy5taW5HYXNQcmljZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkT3B0aW9ucy5taW5HYXNQcmljZSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3UHJvdmlkZXIgPSB0aGlzLmNyZWF0ZVByb3ZpZGVyKG5ldHdvcmssIG5vcm1hbGl6ZWRPcHRpb25zKTtcbiAgICAgICAgbmV3UHJvdmlkZXIuc3RhcnQoKTtcbiAgICAgICAgdGhpcy5lbmdpbmVzLnNldChKU09OLnN0cmluZ2lmeShvcHRpb25zKSwgbmV3UHJvdmlkZXIpO1xuICAgICAgICByZXR1cm4gbmV3UHJvdmlkZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzaWduIGluIHdpdGggYml0c2tpIGJ1dHRvbiB0byBhZGQgdG8geW91ciBhcHAuIElmIGFuIEhUTUwgZWxlbWVudCBpcyBwYXNzZWQgaW4gYXMgdGhlXG4gICAgICogZmlyc3QgcGFyYW1ldGVyLCBpdCB3aWxsIGF1dG9tYXRpY2FsbHkgYWRkIGl0IHRvIHRoZSBET00gaW5zaWRlIHRoYXQgZWxlbWVudC4gTWFrZSBzdXJlIHRvIGFkZFxuICAgICAqIGEgY2FsbGJhY2sgdG8gZ2V0IG5vdGlmaWVkIG9mIGxvZ2luIGV2ZW50cy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyB7Q29ubmVjdEJ1dHRvbk9wdGlvbnN9IE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBidXR0b25cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgUG9zdC1sb2dpbiBjYWxsYmFjay4gQ2FsbGVkIHdoZW4gc2lnbiBpbiBpcyBjb21wbGV0ZS4gTm90IGFwcGxpY2FibGUgZm9yIHJlZGlyZWN0IGxvZ2luIG1ldGhvZC5cbiAgICAgKi9cbiAgICBnZXRDb25uZWN0QnV0dG9uKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29ubmVjdEJ1dHRvbih0aGlzLmF1dGhQcm92aWRlciwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWducyBpbiBvciBjb25uZWN0cyB0byBiaXRza2kgZGVwZW5kaW5nIG9uIHRoZSB1c2VyJ3MgYXV0aCBzdGF0ZS5cbiAgICAgKiBTaW5jZSBpdCBtYXkgb3BlbiBhIHBvcHVwLCB0aGlzIG1ldGhvZCBtdXN0IGJlIGNhbGxlZCBmcm9tIHVzZXIgaW50ZXJhY3Rpb24gaGFuZGxlcixcbiAgICAgKiBzdWNoIGFzIGEgY2xpY2sgb3IgdGFwIGhhbmRsZXIuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgUHJvdmlkZSBTaWduSW5PcHRpb25zIGZvciB0aGUgc2lnbiBpbiByZXF1ZXN0LiBTZWUgc2lnbkluKCkgZm9yIG1vcmUgaW5mby5cbiAgICAgKi9cbiAgICBzdGFydChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF1dGhQcm92aWRlci5zaWduSW5PckNvbm5lY3QodW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhlIGxvZ2dlZCBpbiBzdGF0ZSBvZiB0aGUgdXNlclxuICAgICAqL1xuICAgIGdldCBhdXRoU3RhdHVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdXRoUHJvdmlkZXIuYXV0aFN0YXR1cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIHRoZSBzaWduIGluIGZsb3cuIFdpbGwgdHJpZ2dlciBhIHBvcHVwIHdpbmRvdyBvdmVyIHlvdXIgYXBwLCBzbyBpdCBtdXN0IGJlIGNhbGxlZCB3aXRoaW4gYSB1c2VyIGludGVyYWN0aW9uIGhhbmRsZXIgc3VjaCBhcyBhIGNsaWNrLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbmFsbHkgcHJvdmlkZSBhZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSBzaWduIGluIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIHVzZSB0aGUgb3B0aW9ucyBwYXJhbWV0ZXIgdG8gcmVxdWVzdCB0aGF0IHdlIHNob3cgdGhlIHNpZ24gdXAgZm9ybSBpbnN0ZWFkIG9mIHRoZSBzaWduIGluIGZvcm06XG4gICAgICogYGBgamF2YXNjcmlwdFxuICAgICAqIGltcG9ydCB7IExPR0lOX0hJTlRfU0lHTlVQIH0gZnJvbSAnYml0c2tpJztcbiAgICAgKlxuICAgICAqIGF3YWl0IGJpdHNraS5zaWduSW4oeyBsb2dpbl9oaW50OiBMT0dJTl9ISU5UX1NJR05VUCB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzaWduSW4ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5hdXRoUHJvdmlkZXIuc2lnbkluKE9BdXRoU2lnbkluTWV0aG9kLlBvcHVwLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBzaWduZWQgaW4gdXNlci4gV2lsbCByZWplY3QgaWYgd2UgYXJlIG5vdCBzaWduZWQgaW4uXG4gICAgICovXG4gICAgZ2V0VXNlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXV0aFByb3ZpZGVyLmdldFVzZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29ubmVjdHMgdG8gYml0c2tpIHRvIGdldCBhIHZhbGlkIGFjY2VzcyB0b2tlbiBpZiBwb3NzaWJsZS5cbiAgICAgKi9cbiAgICBjb25uZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdXRoUHJvdmlkZXIuY29ubmVjdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgcmVkaXJlY3Qgc2lnbiBpbiBmbG93LiBUaGlzIGlzIGFuIGFsdGVybmF0aXZlIGZsb3cgdG8gdGhlIHBvcHVwIHRoYXQgYWxsIHRha2VzIHBsYWNlIGluIHRoZSBzYW1lIGJyb3dzZXIgd2luZG93LlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbmFsbHkgcHJvdmlkZSBhZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSBzaWduIGluIHJlcXVlc3QuIFNlZSBzaWduSW4oKSBmb3IgbW9yZSBpbmZvLlxuICAgICAqL1xuICAgIHNpZ25JblJlZGlyZWN0KG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5hdXRoUHJvdmlkZXIuc2lnbkluKE9BdXRoU2lnbkluTWV0aG9kLlJlZGlyZWN0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbCBmcm9tIHlvdXIgb2F1dGggcmVkaXJlY3QgcGFnZS5cbiAgICAgKi9cbiAgICByZWRpcmVjdENhbGxiYWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdXRoUHJvdmlkZXIucmVkaXJlY3RDYWxsYmFjaygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGN1cnJlbnQgYWNjZXNzIHRva2VuIGZvciB0aGUgdXNlciwgaWYgbG9nZ2VkIGluLlxuICAgICAqL1xuICAgIGdldEN1cnJlbnRBY2Nlc3NUb2tlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXV0aFByb3ZpZGVyLmdldEFjY2Vzc1Rva2VuKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgY3VycmVudCByZWZyZXNoIHRva2VuIGZvciB0aGUgdXNlciwgaWYgbG9nZ2VkIGluLlxuICAgICAqIFJlcXVpcmVzIHRoYXQgdGhlIHVzZXIgaGFzIGFwcHJvdmVkIHlvdXIgYXBwbGljYXRpb24gZm9yIG9mZmxpbmUgYWNjZXNzLlxuICAgICAqL1xuICAgIGdldEN1cnJlbnRSZWZyZXNoVG9rZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF1dGhQcm92aWRlci5nZXRSZWZyZXNoVG9rZW4oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gc2lnbiBvdXQuIFRoaXMgaXMgYSBnb29kIHByYWN0aWNlLFxuICAgICAqIHNpbmNlIHRoZXJlIG1heSBiZSBzaXR1YXRpb25zIHdoZXJlIHlvdSBhcmUgc2lnbmVkIG91dCB1bmV4cGVjdGVkbHkuXG4gICAgICogQHBhcmFtIGZuIFlvdXIgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBhZGRTaWduT3V0SGFuZGxlcihmbikge1xuICAgICAgICB0aGlzLnNpZ25vdXRIYW5kbGVycy5wdXNoKGZuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgcmVnaXN0ZXJlZCBzaWdub3V0IGNhbGxiYWNrXG4gICAgICogQHBhcmFtIGZuIFlvdXIgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKi9cbiAgICByZW1vdmVTaWduT3V0SGFuZGxlcihmbikge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuc2lnbm91dEhhbmRsZXJzLmZpbmRJbmRleCgoaXRlbSkgPT4gaXRlbSA9PT0gZm4pO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5zaWdub3V0SGFuZGxlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWduIHRoZSBjdXJyZW50IHVzZXIgb3V0IG9mIHlvdXIgYXBwbGljYXRpb24uXG4gICAgICovXG4gICAgc2lnbk91dCgpIHtcbiAgICAgICAgdGhpcy5lbmdpbmVzLmZvckVhY2goKGVuZ2luZSkgPT4gZW5naW5lLmVtaXQoJ3NpZ25PdXQnKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmF1dGhQcm92aWRlci5zaWduT3V0KCk7XG4gICAgfVxuICAgIGNyZWF0ZVByb3ZpZGVyKG5ldHdvcmssIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IEJpdHNraUJyb3dzZXJFbmdpbmUodGhpcy5jbGllbnRJZCwgdGhpcy5hdXRoUHJvdmlkZXIsIHRoaXMuc2RrVmVyc2lvbiwgbmV0d29yaywgb3B0aW9ucyk7XG4gICAgfVxuICAgIG5ldHdvcmtGcm9tTmFtZShuZXR3b3JrTmFtZSkge1xuICAgICAgICBzd2l0Y2ggKG5ldHdvcmtOYW1lKSB7XG4gICAgICAgICAgICBjYXNlICcnOlxuICAgICAgICAgICAgY2FzZSAnbWFpbm5ldCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1haW5uZXQ7XG4gICAgICAgICAgICBjYXNlICdyaW5rZWJ5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gUmlua2VieTtcbiAgICAgICAgICAgIGNhc2UgJ2tvdmFuJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gS292YW47XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbmV0d29yayBuYW1lICR7bmV0d29ya05hbWV9LiBUcnkgcGFzc2luZyBhIFxcYG5ldHdvcmtcXGAgaW4gdGhlIG9wdGlvbnMgaW5zdGVhZC5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZXR3b3JrRnJvbVByb3ZpZGVyT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIE1haW5uZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV0d29ya0Zyb21OYW1lKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLm5ldHdvcmspIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLm5ldHdvcms7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMubmV0d29ya05hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5ldHdvcmtGcm9tTmFtZShvcHRpb25zLm5ldHdvcmtOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWFpbm5ldDtcbiAgICB9XG4gICAgb25TaWduT3V0KCkge1xuICAgICAgICB0aGlzLnNpZ25vdXRIYW5kbGVycy5mb3JFYWNoKChjYikgPT4ge1xuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtYmVkcyBCaXRza2kncyBVSSBzdHlsZXNcbiAgICAgKi9cbiAgICBpbmplY3RTdHlsZXMoKSB7XG4gICAgICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnQml0c2tpRW1iZWRkZWRTdHlsZXMnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgc3R5bGUuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJyk7XG4gICAgICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgnaWQnLCAnQml0c2tpRW1iZWRkZWRTdHlsZXMnKTtcbiAgICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gICAgICAgIGNvbnN0IGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IE9BdXRoU2lnbkluTWV0aG9kIH0gZnJvbSAnLi4vYml0c2tpJztcbmltcG9ydCB7IEF1dGhlbnRpY2F0aW9uRXJyb3IsIEF1dGhlbnRpY2F0aW9uRXJyb3JDb2RlIH0gZnJvbSAnLi4vZXJyb3JzL2F1dGhlbnRpY2F0aW9uLWVycm9yJztcbi8qKlxuICogU2l6aW5nIG9wdGlvbnMgZm9yIHRoZSBCaXRza2kgY29ubmVjdCBidXR0b24uXG4gKi9cbmV4cG9ydCB2YXIgQ29ubmVjdEJ1dHRvblNpemU7XG4oZnVuY3Rpb24gKENvbm5lY3RCdXR0b25TaXplKSB7XG4gICAgQ29ubmVjdEJ1dHRvblNpemVbXCJTbWFsbFwiXSA9IFwiU01BTExcIjtcbiAgICBDb25uZWN0QnV0dG9uU2l6ZVtcIk1lZGl1bVwiXSA9IFwiTUVESVVNXCI7XG4gICAgQ29ubmVjdEJ1dHRvblNpemVbXCJMYXJnZVwiXSA9IFwiTEFSR0VcIjtcbn0pKENvbm5lY3RCdXR0b25TaXplIHx8IChDb25uZWN0QnV0dG9uU2l6ZSA9IHt9KSk7XG4vKipcbiAqIEEgYnV0dG9uIHVzZWQgdG8gY29ubmVjdCB0byBCaXRza2kuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb25uZWN0QnV0dG9uIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYXV0aFByb3ZpZGVyIEFuIGluc3RhbmNlIG9mIGFuIEF1dGhQcm92aWRlciB0byBwcm9jZXNzIHNpZ24gaW4gcmVxdWVzdHMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uYWwgQ29ubmVjdEJ1dHRvbk9wdGlvbnMgdG8gY29uZmlndXJlIHlvdXIgYnV0dG9uLlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBPcHRpb25hbCBjYWxsYmFjayB0byBiZSBjYWxsZWQgYWZ0ZXIgc3VjY2Vzc2Z1bCBvciBmYWlsZWQgbG9nIGluIGF0dGVtcHQuXG4gICAgICogWW91IGNhbiBhbHNvIHNldCB0aGlzIGRpcmVjdGx5IGxhdGVyIHdpdGggdGhlIGBjYWxsYmFja2AgcHJvcGVydHkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYXV0aFByb3ZpZGVyLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICAvLyBTZXQgb3B0aW9ucyB0byBvYmplY3QgaWYgdW5kZWZpbmVkXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAvLyBDb25maWd1cmUgaW5zdGFuY2VcbiAgICAgICAgdGhpcy5hdXRoUHJvdmlkZXIgPSBhdXRoUHJvdmlkZXI7XG4gICAgICAgIHRoaXMuc2l6ZSA9IG9wdGlvbnMuc2l6ZSB8fCBDb25uZWN0QnV0dG9uU2l6ZS5NZWRpdW07XG4gICAgICAgIHRoaXMuYXV0aEludGVncmF0aW9uVHlwZSA9IG9wdGlvbnMuYXV0aE1ldGhvZCB8fCBPQXV0aFNpZ25Jbk1ldGhvZC5Qb3B1cDtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLnNpZ25Jbk9wdGlvbnMgPSBvcHRpb25zLnNpZ25Jbk9wdGlvbnMgfHwge307XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgZWxlbWVudFxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmVFbGVtZW50KCk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuc2lnbmluLmJpbmQodGhpcykpO1xuICAgICAgICAvLyBFbWJlZCBpZiBuZWVkZWRcbiAgICAgICAgaWYgKG9wdGlvbnMuY29udGFpbmVyKSB7XG4gICAgICAgICAgICBvcHRpb25zLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGJ1dHRvbiBmcm9tIHRoZSBwYWdlXG4gICAgICovXG4gICAgcmVtb3ZlKCkge1xuICAgICAgICBpZiAodGhpcy5lbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2lnbmluKCkge1xuICAgICAgICB0aGlzLmF1dGhQcm92aWRlci5zaWduSW5PckNvbm5lY3QodGhpcy5hdXRoSW50ZWdyYXRpb25UeXBlLCB0aGlzLnNpZ25Jbk9wdGlvbnMpLnRoZW4oKHVzZXIpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFjayh1bmRlZmluZWQsIHVzZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBjYW5jZWxsYXRpb25cbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEF1dGhlbnRpY2F0aW9uRXJyb3IgJiYgZXJyb3IuY29kZSA9PT0gQXV0aGVudGljYXRpb25FcnJvckNvZGUuVXNlckNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgIC8vIE5vdCBhIHJlYWwgZXJyb3IsIHRoZSB1c2VyIGp1c3QgY2FuY2VsbGVkLiBUcmlnZ2VyIGNhbmNlbGxhdGlvbiBjYWxsYmFjay5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbkNhbmNlbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIC8vIFJlYWwgZXJyb3IuIEZvcndhcmQgdG8gbWFpbiBjYWxsYmFjay5cbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrKGVycm9yLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uZmlndXJlRWxlbWVudCgpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnRpdGxlID0gJ0NvbnRpbnVlIHdpdGggQml0c2tpJztcbiAgICAgICAgdGhpcy5lbGVtZW50LmlubmVyVGV4dCA9ICdDb250aW51ZSB3aXRoIEJpdHNraSc7XG4gICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc05hbWUgPSAnYml0c2tpLWNvbm5lY3QtYnV0dG9uJztcbiAgICAgICAgbGV0IHNpemVDbGFzcyA9ICcnO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgY2FzZSBDb25uZWN0QnV0dG9uU2l6ZS5TbWFsbDpcbiAgICAgICAgICAgICAgICBzaXplQ2xhc3MgPSAnc2l6ZS1zbWFsbCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENvbm5lY3RCdXR0b25TaXplLk1lZGl1bTpcbiAgICAgICAgICAgICAgICBzaXplQ2xhc3MgPSAnc2l6ZS1tZWRpdW0nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDb25uZWN0QnV0dG9uU2l6ZS5MYXJnZTpcbiAgICAgICAgICAgICAgICBzaXplQ2xhc3MgPSAnc2l6ZS1sYXJnZSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoc2l6ZUNsYXNzKTtcbiAgICB9XG59XG4iLCJjb25zdCBURU1QTEFURSA9IGBcbiAgPGRpdiBjbGFzcz0nYml0c2tpLWRpYWxvZyc+XG4gICAgICA8YnV0dG9uIGNsYXNzPSdiaXRza2ktY2xvc2UtYnV0dG9uJz5DbG9zZTwvYnV0dG9uPlxuICAgICAgPGRpdiBjbGFzcz0nYml0c2tpLWRpYWxvZy1ib2R5Jz48L2Rpdj5cbiAgPC9kaXY+XG5gO1xuLyoqXG4gKiBCYXNpYyBtb2RhbCBkaWFsb2dcbiAqL1xuZXhwb3J0IGNsYXNzIERpYWxvZyB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbmQgZGlzcGxheXMgYSBuZXcgZGlhbG9nXG4gICAgICogQHBhcmFtIGNvbnRlbnQgVGhlIGNvbnRlbnQgKEhUTUxFbGVtZW50LCBzZWxlY3Rvciwgb3IgdGV4dCkgdG8gZW1iZWQgaW4gdGhlIGRpYWxvZ1xuICAgICAqIEBwYXJhbSBkeW5hbWljQ29udGVudCBTZXQgdG8gdHJ1ZSB0byBzaG93IGxvYWRpbmcgc3RhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb250ZW50LCBkeW5hbWljQ29udGVudCA9IGZhbHNlKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBhbiBlbGVtZW50IHBhc3NlZCBhcyBjb250ZW50IG9yIGEgc2VsZWN0b3IgY29ycmVzcG9uZGluZyB0byBhbiBlbGVtZW50XG4gICAgICAgIHRoaXMuY29udGVudCA9IHRoaXMucGFyc2VDb250ZW50KGNvbnRlbnQpO1xuICAgICAgICAvLyBGaW5kIG9yIGNyZWF0ZSBkaWFsb2cgY29udGFpbmVyXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5jcmVhdGVDb250YWluZXIoKTtcbiAgICAgICAgLy8gSW5qZWN0IGRpYWxvZyBjb250ZW50XG4gICAgICAgIHRoaXMuaW5qZWN0VGVtcGxhdGUodGhpcy5jb250YWluZXIsIHRoaXMuY29udGVudCk7XG4gICAgICAgIC8vIFNob3cgYSBzcGlubmVyIGlmIGNvbnRlbnQgaXMgZHluYW1pY1xuICAgICAgICBpZiAoZHluYW1pY0NvbnRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TG9hZGluZyh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgY2xvc2UgaGFuZGxlcnNcbiAgICAgICAgdGhpcy5hZGRDbG9zZUhhbmRsZXJzKCk7XG4gICAgICAgIC8vIEEgc2hvcnQgZGVsYXkgaXMgcmVxdWlyZWQgYmVmb3JlIHRyaWdnZXJpbmcgYW5pbWF0aW9uc1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgdGhpcy5zaG93KCk7IH0sIDEwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvdyB0aGUgZGlhbG9nXG4gICAgICovXG4gICAgc2hvdygpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZCgnYml0c2tpLXZpc2libGUnLCAnYml0c2tpLWxvYWRlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIaWRlcyB0aGUgZGlhbG9nLCBidXQgZG9lcyBub3QgcmVtb3ZlXG4gICAgICovXG4gICAgaGlkZSgpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSgnYml0c2tpLXZpc2libGUnLCAnYml0c2tpLWxvYWRlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNtaXNzZXMgdGhlIGRpYWxvZyB3aXRob3V0IHRyaWdnZXJpbmcgdGhlIGNsb3NlIGhhbmRsZXIuXG4gICAgICovXG4gICAgZGlzbWlzcygpIHtcbiAgICAgICAgLy8gQWxsb3cgNTAwbXMgZm9yIHRoZSBhbmltYXRpb25zIHRvIGZpbmlzaCBiZWZvcmUgcmVtb3ZpbmcgZWxlbWVudHMgZnJvbSBET01cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IHRoaXMuY29udGFpbmVyLnJlbW92ZSgpOyB9LCA1MDApO1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FuY2VscyB0aGUgZGlhbG9nIGJ5IGRpc21pc3NpbmcgYW5kIHRyaWdnZXJpbmcgdGhlIGNsb3NlIGhhbmRsZXIuXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuZGlzbWlzcygpO1xuICAgICAgICBpZiAodGhpcy5vbkNsb3NlKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93IG9yIGhpZGUgdGhlIGxvYWRpbmcgaW5kaWNhdG9yXG4gICAgICogQHBhcmFtIGxvYWRpbmcgV2hldGhlciBvciBub3QgdG8gZGlzcGxheSB0aGUgc3Bpbm5lclxuICAgICAqL1xuICAgIHNldExvYWRpbmcobG9hZGluZykge1xuICAgICAgICBjb25zdCBib2R5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmJpdHNraS1kaWFsb2ctYm9keScpO1xuICAgICAgICBpZiAoYm9keSkge1xuICAgICAgICAgICAgaWYgKGxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICBib2R5LmNsYXNzTGlzdC5hZGQoJ2JpdHNraS1sb2FkaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBib2R5LmNsYXNzTGlzdC5yZW1vdmUoJ2JpdHNraS1sb2FkaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGF0IGNvbnRlbnQgdG8gZW1iZWRcbiAgICAgKiBAcGFyYW0gY29udGVudCBDb250ZW50IHRvIHBhcnNlXG4gICAgICovXG4gICAgcGFyc2VDb250ZW50KGNvbnRlbnQpIHtcbiAgICAgICAgLy8gY2hlY2sgZm9yIGFuIGVsZW1lbnQgcGFzc2VkIGFzIGNvbnRlbnRcbiAgICAgICAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGV0ZXJtaW5lIGlmIGNvbnRlbnQgaXMgYSBzZWxlY3RvclxuICAgICAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihjb250ZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3RoZXJ3aXNlIGNvbnRlbnQgaXMgdGV4dCB0byBiZSBhcHBlbmRlZCB0byB0aGUgZGlhbG9nIGJvZHlcbiAgICAgICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGRpdi5pbm5lclRleHQgPSBjb250ZW50O1xuICAgICAgICByZXR1cm4gZGl2O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuZCBpbmplY3RzIHRoZSBjb250YWluZXIgZWxlbWVudCBhdCB0aGUgZW5kIG9mIHRoZSBib2R5LFxuICAgICAqIHJlc3BvbnNpYmxlIGZvciBob3VzaW5nIGFsbCB0aGUgZGlhbG9nLXJlbGF0ZWQgY29udGVudC5cbiAgICAgKi9cbiAgICBjcmVhdGVDb250YWluZXIoKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQ29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2JpdHNraS1kaWFsb2ctY29udGFpbmVyJyk7XG4gICAgICAgIGlmIChleGlzdGluZ0NvbnRhaW5lcikge1xuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nQ29udGFpbmVyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb250YWluZXIuaWQgPSAnYml0c2tpLWRpYWxvZy1jb250YWluZXInO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluamVjdHMgdGhlIHByb3ZpZGVkIGNvbnRlbnQgaW50byB0aGUgdGVtcGxhdGUgcHJvdmlkZWRcbiAgICAgKiBAcGFyYW0gY29udGFpbmVyIFRoZSBjb250YWluZXIgZWxlbWVudFxuICAgICAqIEBwYXJhbSBjb250ZW50IFRoZSBjb250ZW50IHRvIGluamVjdCBpbiB0aGUgdGVtcGxhdGVcbiAgICAgKi9cbiAgICBpbmplY3RUZW1wbGF0ZShjb250YWluZXIsIGNvbnRlbnQpIHtcbiAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9IFRFTVBMQVRFO1xuICAgICAgICBjb25zdCBib2R5ID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5iaXRza2ktZGlhbG9nLWJvZHknKTtcbiAgICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgICAgIGJvZHkuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBldmVudCBsaXN0ZW5lcnMgZm9yIGV2ZW50cyB0aGF0IHNob3VsZCB0cmlnZ2VyIGNsb3NpbmcgdGhlIGRpYWxvZ1xuICAgICAqL1xuICAgIGFkZENsb3NlSGFuZGxlcnMoKSB7XG4gICAgICAgIC8vIENsb3NlIG9uIGNsaWNrIG91dHNpZGUgb2YgdGhlIGRpYWxvZ1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcy5jb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDbG9zZSBvbiBlc2NhcGUgcHJlc3NcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUua2V5ID09PSAnRXNjYXBlJykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENsb3NlIG9uIGNsb3NlIGJ1dHRvbiBjbGlja1xuICAgICAgICBjb25zdCBjbG9zZUJ1dHRvbiA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5iaXRza2ktY2xvc2UtYnV0dG9uJyk7XG4gICAgICAgIGlmIChjbG9zZUJ1dHRvbikge1xuICAgICAgICAgICAgY2xvc2VCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmNsb3NlLmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLy8gU0RLXG5leHBvcnQgY29uc3QgU0RLX1ZFUlNJT04gPSAnMC4xMC45Jztcbi8vIFVSTHNcbmV4cG9ydCBjb25zdCBCSVRTS0lfVVNFUl9BUElfSE9TVCA9ICdodHRwczovL3d3dy5iaXRza2kuY29tL3YxJztcbmV4cG9ydCBjb25zdCBCSVRTS0lfVFJBTlNBQ1RJT05fQVBJX0JBU0VfVVJMID0gJ2h0dHBzOi8vYXBpLmJpdHNraS5jb20vdjEnO1xuZXhwb3J0IGNvbnN0IEJJVFNLSV9SUENfQkFTRV9VUkwgPSAnaHR0cHM6Ly9hcGkuYml0c2tpLmNvbS92MS93ZWIzJztcbmV4cG9ydCBjb25zdCBCSVRTS0lfV0VCX0JBU0VfVVJMID0gJ2h0dHBzOi8vc2lnbi5iaXRza2kuY29tJztcbmV4cG9ydCBjb25zdCBJRlJBTUVfTUVTU0FHRV9PUklHSU5fSU5DTFVERVMgPSAnLmJpdHNraS5jb20nO1xuLy8gT0F1dGhcbmV4cG9ydCBjb25zdCBERUZBVUxUX09BVVRIX0NPTkZJR1VSQVRJT04gPSB7XG4gICAgYXV0aG9yaXphdGlvbl9lbmRwb2ludDogJ2h0dHBzOi8vYWNjb3VudC5iaXRza2kuY29tL29hdXRoMi9hdXRoJyxcbiAgICByZXZvY2F0aW9uX2VuZHBvaW50OiAnJyxcbiAgICB0b2tlbl9lbmRwb2ludDogJ2h0dHBzOi8vYWNjb3VudC5iaXRza2kuY29tL29hdXRoMi90b2tlbicsXG4gICAgdXNlcmluZm9fZW5kcG9pbnQ6ICdodHRwczovL2FjY291bnQuYml0c2tpLmNvbS91c2VyaW5mbycsXG59O1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfU0NPUEVTID0gWydvcGVuaWQnXTsgLy8gc2NvcGVzIHRoYXQgYXJlIGFsd2F5cyBpbmNsdWRlZFxuZXhwb3J0IGNvbnN0IERFRkFVTFRfT1BUSU9OQUxfU0NPUEVTID0gWydvZmZsaW5lJ107IC8vIHNjb3BlcyB0aGF0IGFyZSBpbmNsdWRlZCBieSBkZWZhdWx0LCBidXQgY2FuIGJlIG92ZXJyaWRkZW5cbi8vIFBvcHVwIFdpbmRvd1xuZXhwb3J0IGNvbnN0IENIRUNLX0ZPUl9QT1BVUF9DTE9TRV9JTlRFUlZBTCA9IDUwMDtcbmV4cG9ydCBjb25zdCBERUZBVUxUX1BPUFVQX0ZFQVRVUkVTID0ge1xuICAgIGxvY2F0aW9uOiAnbm8nLFxuICAgIHRvb2xiYXI6ICdubycsXG4gICAgd2lkdGg6IDUwMCxcbiAgICBoZWlnaHQ6IDUwMCxcbiAgICBsZWZ0OiAxMDAsXG4gICAgdG9wOiAxMDAsXG59O1xuLy8gU3RvcmFnZVxuZXhwb3J0IGNvbnN0IFJFRlJFU0hfVE9LRU5fS0VZID0gJ2JpdHNraS5yZWZyZXNoX3Rva2VuJztcbmV4cG9ydCBjb25zdCBBQ0NFU1NfVE9LRU5fS0VZID0gJ2JpdHNraS5hY2Nlc3NfdG9rZW4nO1xuZXhwb3J0IGNvbnN0IFVTRVJfS0VZID0gJ2JpdHNraS51c2VyJztcbi8vIE1ldGhvZHNcbmV4cG9ydCBjb25zdCBDQUNIRURfTUVUSE9EUyA9IFsnZXRoX2FjY291bnRzJ107XG5leHBvcnQgY29uc3QgREVGQVVMVF9BVVRIT1JJWkVEX01FVEhPRFMgPSBbXG4gICAgJ2V0aF9zZW5kVHJhbnNhY3Rpb24nLFxuICAgICdldGhfc2lnblRyYW5zYWN0aW9uJyxcbiAgICAnZXRoX3NpZ24nLFxuICAgICdwZXJzb25hbF9zaWduJyxcbiAgICAnZXRoX3NpZ25UeXBlZERhdGEnLFxuICAgICdldGhfc2lnblR5cGVkRGF0YV92MycsXG5dO1xuIiwiZXhwb3J0IHZhciBBdXRoZW50aWNhdGlvbkVycm9yQ29kZTtcbihmdW5jdGlvbiAoQXV0aGVudGljYXRpb25FcnJvckNvZGUpIHtcbiAgICAvLyBUaGUgdXNlciBpcyBub3QgY3VycmVudGx5IHNpZ25lZCBpblxuICAgIEF1dGhlbnRpY2F0aW9uRXJyb3JDb2RlW0F1dGhlbnRpY2F0aW9uRXJyb3JDb2RlW1wiTm90U2lnbmVkSW5cIl0gPSAxMDAwXSA9IFwiTm90U2lnbmVkSW5cIjtcbiAgICAvLyBUaGUgdXNlciBjYW5jZWxsZWQgdGhlIGF1dGggcmVxdWVzdFxuICAgIEF1dGhlbnRpY2F0aW9uRXJyb3JDb2RlW0F1dGhlbnRpY2F0aW9uRXJyb3JDb2RlW1wiVXNlckNhbmNlbGxlZFwiXSA9IDEwMDFdID0gXCJVc2VyQ2FuY2VsbGVkXCI7XG4gICAgLy8gRWl0aGVyIHlvdSBkaWQgbm90IHJlcXVlc3Qgb2ZmbGluZSBhY2Nlc3MsIG9yIHRoZSB1c2VyIGRpZCBub3QgYXBwcm92ZSB5b3VyIGFwcCBmb3Igb2ZmbGluZSBhY2Nlc3NcbiAgICBBdXRoZW50aWNhdGlvbkVycm9yQ29kZVtBdXRoZW50aWNhdGlvbkVycm9yQ29kZVtcIk5vUmVmcmVzaFRva2VuXCJdID0gMTAwMl0gPSBcIk5vUmVmcmVzaFRva2VuXCI7XG4gICAgLy8gWW91IHJlcXVlc3RlZCBzaWxlbnQgc2lnbiBpbiwgd2hpY2ggaXMgZGVwcmVjYXRlZFxuICAgIEF1dGhlbnRpY2F0aW9uRXJyb3JDb2RlW0F1dGhlbnRpY2F0aW9uRXJyb3JDb2RlW1wiVW5zdXBwb3J0ZWRBdXRoZW50aWNhdGlvbk1ldGhvZFwiXSA9IDEwMDNdID0gXCJVbnN1cHBvcnRlZEF1dGhlbnRpY2F0aW9uTWV0aG9kXCI7XG4gICAgLy8gV2UgcmVjZWl2ZWQgYW4gZXJyb3IgZnJvbSB0aGUgb2F1dGggc2VydmVyXG4gICAgQXV0aGVudGljYXRpb25FcnJvckNvZGVbQXV0aGVudGljYXRpb25FcnJvckNvZGVbXCJTZXJ2ZXJFcnJvclwiXSA9IDEwMDRdID0gXCJTZXJ2ZXJFcnJvclwiO1xuICAgIC8vIFRoZSBTREsgaXMgY29uZmlndXJlZCBpbmNvcnJlY3RseVxuICAgIEF1dGhlbnRpY2F0aW9uRXJyb3JDb2RlW0F1dGhlbnRpY2F0aW9uRXJyb3JDb2RlW1wiSW52YWxpZENvbmZpZ3VyYXRpb25cIl0gPSAxMDA1XSA9IFwiSW52YWxpZENvbmZpZ3VyYXRpb25cIjtcbiAgICAvLyBQb3B1cCBibG9ja2VkXG4gICAgQXV0aGVudGljYXRpb25FcnJvckNvZGVbQXV0aGVudGljYXRpb25FcnJvckNvZGVbXCJQb3B1cEJsb2NrZWRcIl0gPSAxMDA2XSA9IFwiUG9wdXBCbG9ja2VkXCI7XG59KShBdXRoZW50aWNhdGlvbkVycm9yQ29kZSB8fCAoQXV0aGVudGljYXRpb25FcnJvckNvZGUgPSB7fSkpO1xuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGVycm9yIHRoYXQgaXMgdGhyb3duIGR1cmluZyB0aGUgYXV0aGVudGljYXRpb24gcHJvY2Vzc1xuICovXG5leHBvcnQgY2xhc3MgQXV0aGVudGljYXRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjb2RlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQXV0aGVudGljYXRpb25FcnJvcic7XG4gICAgICAgIC8vIE1haW50YWlucyBwcm9wZXIgc3RhY2sgdHJhY2UgZm9yIHdoZXJlIG91ciBlcnJvciB3YXMgdGhyb3duIChvbmx5IGF2YWlsYWJsZSBvbiBWOClcbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBBdXRoZW50aWNhdGlvbkVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIH1cbiAgICAvLyB0aHJvdyBBdXRoZW50aWNhdGlvbkVycm9yLk5vdFNpZ25lZEluKClcbiAgICBzdGF0aWMgTm90U2lnbmVkSW4oKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXV0aGVudGljYXRpb25FcnJvcignTm90IHNpZ25lZCBpbi4nLCBBdXRoZW50aWNhdGlvbkVycm9yQ29kZS5Ob3RTaWduZWRJbik7XG4gICAgfVxuICAgIC8vIHRocm93IEF1dGhlbnRpY2F0aW9uRXJyb3IuVXNlckNhbmNlbGxlZCgpXG4gICAgc3RhdGljIFVzZXJDYW5jZWxsZWQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXV0aGVudGljYXRpb25FcnJvcignU2lnbiBpbiByZXF1ZXN0IHdhcyBjYW5jZWxsZWQuJywgQXV0aGVudGljYXRpb25FcnJvckNvZGUuVXNlckNhbmNlbGxlZCk7XG4gICAgfVxuICAgIC8vIHRocm93IEF1dGhlbnRpY2F0aW9uRXJyb3IuTm9SZWZyZXNoVG9rZW4oKVxuICAgIHN0YXRpYyBOb1JlZnJlc2hUb2tlbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKCdSZWZyZXNoIHRva2VuIGlzIG5vdCBhdmFpbGFibGUuJywgQXV0aGVudGljYXRpb25FcnJvckNvZGUuTm9SZWZyZXNoVG9rZW4pO1xuICAgIH1cbiAgICAvLyB0aHJvdyBBdXRoZW50aWNhdGlvbkVycm9yLlVuc3VwcG9ydGVkQXV0aGVudGljYXRpb25NZXRob2QoKVxuICAgIHN0YXRpYyBVbnN1cHBvcnRlZEF1dGhlbnRpY2F0aW9uTWV0aG9kKCkge1xuICAgICAgICByZXR1cm4gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoJ1NpZ24gaW4gbWV0aG9kIG5vdCBzdXBwb3J0ZWQuJywgQXV0aGVudGljYXRpb25FcnJvckNvZGUuVW5zdXBwb3J0ZWRBdXRoZW50aWNhdGlvbk1ldGhvZCk7XG4gICAgfVxuICAgIC8vIHRocm93IEF1dGhlbnRpY2F0aW9uRXJyb3IuUG9wdXBCbG9ja2VkKClcbiAgICBzdGF0aWMgUG9wdXBCbG9ja2VkKGJhc2VVcmwpIHtcbiAgICAgICAgY29uc3QgbXNnID0gYFRoZSBwb3B1cCB3YXMgYmxvY2tlZC4gUGxlYXNlIG1ha2Ugc3VyZSAke2Jhc2VVcmx9IGlzIGFsbG93ZWQgdG8gb3BlbiBwb3B1cHMuYDtcbiAgICAgICAgcmV0dXJuIG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKG1zZywgQXV0aGVudGljYXRpb25FcnJvckNvZGUuUG9wdXBCbG9ja2VkKTtcbiAgICB9XG4gICAgLy8gdGhyb3cgQXV0aGVudGljYXRpb24gRXJyb3IuU2VydmVyRXJyb3IobWVzc2FnZSwgZGVzY3JpcHRpb24pXG4gICAgc3RhdGljIFNlcnZlckVycm9yKG1lc3NhZ2UsIGRlc2NyaXB0aW9uKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKGBFcnJvciBmcm9tIHRoZSBzZXJ2ZXI6ICR7bWVzc2FnZX1gLCBBdXRoZW50aWNhdGlvbkVycm9yQ29kZS5TZXJ2ZXJFcnJvcik7XG4gICAgICAgIGVyci5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICByZXR1cm4gZXJyO1xuICAgIH1cbiAgICAvLyB0aHJvdyBBdXRoZW50aWNhdGlvbkVycm9yLkludmFsaWRDb25maWd1cmF0aW9uKClcbiAgICBzdGF0aWMgSW52YWxpZENvbmZpZ3VyYXRpb24ocmVhc29uKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXV0aGVudGljYXRpb25FcnJvcihgVGhlIE9BdXRoIENvbmZpZ3VyYXRpb24gaXMgaW52YWxpZDogJHtyZWFzb259YCwgQXV0aGVudGljYXRpb25FcnJvckNvZGUuSW52YWxpZENvbmZpZ3VyYXRpb24pO1xuICAgIH1cbn1cbiIsImV4cG9ydCB2YXIgUGFyc2VFcnJvckNvZGU7XG4oZnVuY3Rpb24gKFBhcnNlRXJyb3JDb2RlKSB7XG4gICAgLy8gQ291bGQgbm90IHBhcnNlIHJlc3BvbnNlIGFzIEpTT05cbiAgICBQYXJzZUVycm9yQ29kZVtQYXJzZUVycm9yQ29kZVtcIkludmFsaWRKU09OXCJdID0gMjAwMF0gPSBcIkludmFsaWRKU09OXCI7XG4gICAgLy8gUmVjZWl2ZWQgYW4gZXJyb3IgcmVzcG9uc2Ugc3RhdHVzLFxuICAgIC8vIGJ1dCBub3QgZXJyb3IgYm9keSB3YXMgcHJvdmlkZWQuXG4gICAgUGFyc2VFcnJvckNvZGVbUGFyc2VFcnJvckNvZGVbXCJOb0Vycm9yQm9keVwiXSA9IDIwMDFdID0gXCJOb0Vycm9yQm9keVwiO1xufSkoUGFyc2VFcnJvckNvZGUgfHwgKFBhcnNlRXJyb3JDb2RlID0ge30pKTtcbi8qKlxuICogUmVwcmVzZW50cyBhbiBlcnJvciB0aGF0IGlzIHRocm93biBkdXJpbmcgZGVjb2RpbmdcbiAqL1xuZXhwb3J0IGNsYXNzIFBhcnNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgY29kZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1BhcnNlRXJyb3InO1xuICAgICAgICAvLyBNYWludGFpbnMgcHJvcGVyIHN0YWNrIHRyYWNlIGZvciB3aGVyZSBvdXIgZXJyb3Igd2FzIHRocm93biAob25seSBhdmFpbGFibGUgb24gVjgpXG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgUGFyc2VFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB9XG4gICAgc3RhdGljIEludmFsaWRKU09OKCkge1xuICAgICAgICByZXR1cm4gbmV3IFBhcnNlRXJyb3IoJ0NvdWxkIG5vdCBkZWNvZGUgcmVzcG9uc2UgYXMgSlNPTicsIFBhcnNlRXJyb3JDb2RlLkludmFsaWRKU09OKTtcbiAgICB9XG4gICAgc3RhdGljIFVua25vd25FcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZUVycm9yKCdBbiB1bmtub3duIGVycm9yIG9jY3VycmVkLicsIFBhcnNlRXJyb3JDb2RlLk5vRXJyb3JCb2R5KTtcbiAgICB9XG59XG4iLCJleHBvcnQgdmFyIFNpZ25lckVycm9yQ29kZTtcbihmdW5jdGlvbiAoU2lnbmVyRXJyb3JDb2RlKSB7XG4gICAgLy8gVGhlIHNpZ25lciBtb2R1bGUgcmVjZWl2ZWQgYSByZXF1ZXN0IHRvIHNpZ24gdmlhIGFuIHVuc3VwcG9ydGVkIFJQQyBtZXRob2RcbiAgICBTaWduZXJFcnJvckNvZGVbU2lnbmVyRXJyb3JDb2RlW1wiVW5zdXBwb3J0ZWRNZXRob2RcIl0gPSAzMDAwXSA9IFwiVW5zdXBwb3J0ZWRNZXRob2RcIjtcbiAgICAvLyBUaGUgdXNlciBjYW5jZWxsZWQgb3IgcmVqZWN0ZWQgdGhlIHRyYW5zYWN0aW9uXG4gICAgU2lnbmVyRXJyb3JDb2RlW1NpZ25lckVycm9yQ29kZVtcIlVzZXJDYW5jZWxsZWRcIl0gPSAzMDAxXSA9IFwiVXNlckNhbmNlbGxlZFwiO1xuICAgIC8vIFRoZSByZXF1ZXN0IGlzIG1pc3NpbmcgcGFyYW1zIGZvciB0aGUgdHJhbnNhY3Rpb24uXG4gICAgLy8gQ2hlY2sgdGhhdCBwYXJhbXMgaXMgYW4gYXJyYXksIGFuZCB0aGUgdHJhbnNhY3Rpb24gaXMgdGhlIGZpcnN0IG9iamVjdC5cbiAgICBTaWduZXJFcnJvckNvZGVbU2lnbmVyRXJyb3JDb2RlW1wiTWlzc2luZ1RyYW5zYWN0aW9uXCJdID0gMzAwMl0gPSBcIk1pc3NpbmdUcmFuc2FjdGlvblwiO1xuICAgIC8vIFRoZSBtZXNzYWdlIHNpZ25hdHVyZSByZXF1ZXN0IGlzIG1pc3NpbmcgZXhwZWN0ZWQgcGFyYW1zLlxuICAgIC8vIENoZWNrIHRoYXQgcGFyYW1zIGlzIGFuIGFycmF5LCBhbmQgdGhhdCB0aGV5IGluY2x1ZGUgYm90aCBhIGZyb20gYWRkcmVzcywgYW5kIGEgbWVzc2FnZSB0byBzaWduLlxuICAgIFNpZ25lckVycm9yQ29kZVtTaWduZXJFcnJvckNvZGVbXCJNaXNzaW5nTWVzc2FnZVwiXSA9IDMwMDNdID0gXCJNaXNzaW5nTWVzc2FnZVwiO1xuICAgIC8vIE1pc3NpbmcgZnJvbSBhZGRyZXNzIGluIHR5cGVkIGRhdGEgcmVxdWVzdFxuICAgIFNpZ25lckVycm9yQ29kZVtTaWduZXJFcnJvckNvZGVbXCJNaXNzaW5nRnJvbVwiXSA9IDMwMDRdID0gXCJNaXNzaW5nRnJvbVwiO1xuICAgIC8vIE1pc3NpbmcgdHlwZWQgZGF0YSBwYXJhbXMuIE1ha2Ugc3VyZSBwYXJhbXMgaXMgYW4gYXJyYXkgYW5kIGluY2x1ZGVzXG4gICAgLy8gYm90aCBhIGZyb20gYWRkcmVzcywgYW5kIGEgdHlwZWQgZGF0YSBwYXlsb2FkLlxuICAgIFNpZ25lckVycm9yQ29kZVtTaWduZXJFcnJvckNvZGVbXCJNaXNzaW5nVHlwZWREYXRhXCJdID0gMzAwNV0gPSBcIk1pc3NpbmdUeXBlZERhdGFcIjtcbn0pKFNpZ25lckVycm9yQ29kZSB8fCAoU2lnbmVyRXJyb3JDb2RlID0ge30pKTtcbmV4cG9ydCBjbGFzcyBTaWduZXJFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjb2RlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnVHJhbnNhY3Rpb25FcnJvcic7XG4gICAgICAgIC8vIE1haW50YWlucyBwcm9wZXIgc3RhY2sgdHJhY2UgZm9yIHdoZXJlIG91ciBlcnJvciB3YXMgdGhyb3duIChvbmx5IGF2YWlsYWJsZSBvbiBWOClcbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBTaWduZXJFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB9XG4gICAgc3RhdGljIFVuc3VwcG9ydGVkTWV0aG9kKCkge1xuICAgICAgICByZXR1cm4gbmV3IFNpZ25lckVycm9yKCdUaGUgbWV0aG9kIHJlcXVlc3RlZCBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZC4nLCBTaWduZXJFcnJvckNvZGUuVW5zdXBwb3J0ZWRNZXRob2QpO1xuICAgIH1cbiAgICBzdGF0aWMgVXNlckNhbmNlbGxlZCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTaWduZXJFcnJvcignVGhlIHVzZXIgY2FuY2VsbGVkIHRoaXMgdHJhbnNhY3Rpb24nLCBTaWduZXJFcnJvckNvZGUuVXNlckNhbmNlbGxlZCk7XG4gICAgfVxuICAgIHN0YXRpYyBNaXNzaW5nVHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2lnbmVyRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIHRyYW5zYWN0aW9uIGluIHJlcXVlc3QnLCBTaWduZXJFcnJvckNvZGUuTWlzc2luZ1RyYW5zYWN0aW9uKTtcbiAgICB9XG4gICAgc3RhdGljIE1pc3NpbmdNZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFNpZ25lckVycm9yKCdDb3VsZCBub3QgZmluZCBtZXNzYWdlIHBhcmFtcyBpbiByZXF1ZXN0JywgU2lnbmVyRXJyb3JDb2RlLk1pc3NpbmdNZXNzYWdlKTtcbiAgICB9XG4gICAgc3RhdGljIE1pc3NpbmdGcm9tKCkge1xuICAgICAgICByZXR1cm4gbmV3IFNpZ25lckVycm9yKCdDb3VsZCBub3QgZmluZCBmcm9tIGFkZHJlc3MgaW4gcmVxdWVzdCBwYXJhbXMuJywgU2lnbmVyRXJyb3JDb2RlLk1pc3NpbmdGcm9tKTtcbiAgICB9XG4gICAgc3RhdGljIE1pc3NpbmdUeXBlZERhdGEoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2lnbmVyRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGRhdGEgdG8gc2lnbiBpbiByZXF1ZXN0IHBhcmFtcy4nLCBTaWduZXJFcnJvckNvZGUuTWlzc2luZ1R5cGVkRGF0YSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQXV0aGVudGljYXRlZEZldGNoU3VicHJvdmlkZXIsIEJpdHNraUVuZ2luZSB9IGZyb20gJ2JpdHNraS1wcm92aWRlcic7XG5pbXBvcnQgeyBCSVRTS0lfUlBDX0JBU0VfVVJMLCBCSVRTS0lfVFJBTlNBQ1RJT05fQVBJX0JBU0VfVVJMLCBCSVRTS0lfV0VCX0JBU0VfVVJMIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IEJpdHNraVRyYW5zYWN0aW9uU2lnbmVyIH0gZnJvbSAnLi4vc2lnbmluZy90cmFuc2FjdGlvbi1zaWduZXInO1xuaW1wb3J0IHsgQXV0aGVudGljYXRlZENhY2hlU3VicHJvdmlkZXIgfSBmcm9tICcuLi9zdWJwcm92aWRlcnMvYXV0aGVudGljYXRlZC1jYWNoZSc7XG5pbXBvcnQgeyBSZW1vdGVBY2NvdW50U3VicHJvdmlkZXIgfSBmcm9tICcuLi9zdWJwcm92aWRlcnMvcmVtb3RlLWFjY291bnRzJztcbmltcG9ydCB7IFJlc3RGZXRjaFN1YnByb3ZpZGVyIH0gZnJvbSAnLi4vc3VicHJvdmlkZXJzL3Jlc3QtZmV0Y2gnO1xuaW1wb3J0IHsgU2lnbmF0dXJlU3VicHJvdmlkZXIgfSBmcm9tICcuLi9zdWJwcm92aWRlcnMvc2lnbmF0dXJlJztcbi8vIFByZWRpY2F0ZSB0byBkZXRlcm1pbmUgaWYgdGhlIHRva2VuIHByb3ZpZGVyIGlzIGFuIEF1dGhQcm92aWRlclxuZnVuY3Rpb24gaXNBdXRoUHJvdmlkZXIob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdC5nZXRVc2VyICE9PSB1bmRlZmluZWQ7XG59XG5leHBvcnQgY2xhc3MgQml0c2tpQnJvd3NlckVuZ2luZSBleHRlbmRzIEJpdHNraUVuZ2luZSB7XG4gICAgY29uc3RydWN0b3IoY2xpZW50SWQsIHRva2VuUHJvdmlkZXIsIHNka1ZlcnNpb24sIG5ldHdvcmssIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMubmV0d29yayA9IG5ldHdvcms7XG4gICAgICAgIHRoaXMuY2xpZW50SWQgPSBjbGllbnRJZDtcbiAgICAgICAgdGhpcy5zZGtWZXJzaW9uID0gc2RrVmVyc2lvbjtcbiAgICAgICAgdGhpcy5hcGlCYXNlVXJsID0gb3B0aW9ucy5hcGlCYXNlVXJsIHx8IEJJVFNLSV9UUkFOU0FDVElPTl9BUElfQkFTRV9VUkw7XG4gICAgICAgIHRoaXMud2ViQmFzZVVybCA9IG9wdGlvbnMud2ViQmFzZVVybCB8fCBCSVRTS0lfV0VCX0JBU0VfVVJMO1xuICAgICAgICB0aGlzLnRva2VuUHJvdmlkZXIgPSB0b2tlblByb3ZpZGVyO1xuICAgICAgICBjb25zdCBkZWZhdWx0Qml0c2tpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdYLUFQSS1LRVknOiB0aGlzLmNsaWVudElkLFxuICAgICAgICAgICAgJ1gtQ0xJRU5ULUlEJzogdGhpcy5jbGllbnRJZCxcbiAgICAgICAgICAgICdYLUNMSUVOVC1WRVJTSU9OJzogdGhpcy5zZGtWZXJzaW9uLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBkZWZhdWx0Qml0c2tpSGVhZGVycztcbiAgICAgICAgdGhpcy5ycGNIZWFkZXJzID0ge307XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWRkaXRpb25hbEhlYWRlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMuYWRkaXRpb25hbEhlYWRlcnMsIHRoaXMuaGVhZGVycyk7XG4gICAgICAgICAgICB0aGlzLnJwY0hlYWRlcnMgPSBvcHRpb25zLmFkZGl0aW9uYWxIZWFkZXJzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5ldHdvcmsgJiYgdGhpcy5uZXR3b3JrLnJwY1VybC5pbmNsdWRlcygnYml0c2tpLmNvbScpKSB7XG4gICAgICAgICAgICB0aGlzLnJwY0hlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnJwY0hlYWRlcnMsIGRlZmF1bHRCaXRza2lIZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNpZ25lciA9IG5ldyBCaXRza2lUcmFuc2FjdGlvblNpZ25lcih0aGlzLndlYkJhc2VVcmwsIHRoaXMuYXBpQmFzZVVybCwgdGhpcy5oZWFkZXJzLCBvcHRpb25zLmNhbGxiYWNrVVJMKTtcbiAgICAgICAgdGhpcy5hZGRTdWJwcm92aWRlcnMoKTtcbiAgICB9XG4gICAgYWRkU3VicHJvdmlkZXJzKCkge1xuICAgICAgICAvLyBVc2VkIGZvciBldGhfYWNjb3VudHMgY2FsbHNcbiAgICAgICAgY29uc3QgYWNjb3VudHNQcm92aWRlciA9IG5ldyBSZW1vdGVBY2NvdW50U3VicHJvdmlkZXIoYCR7QklUU0tJX1JQQ19CQVNFX1VSTH0vbWFpbm5ldGAsIGZhbHNlLCB0aGlzLnRva2VuUHJvdmlkZXIsIHRoaXMuaGVhZGVycyk7XG4gICAgICAgIC8vIFVzZWQgZm9yIGFsbCBvdGhlciBjYWxsc1xuICAgICAgICBjb25zdCBmZXRjaFN1YnByb3ZpZGVyID0gbmV3IEF1dGhlbnRpY2F0ZWRGZXRjaFN1YnByb3ZpZGVyKHRoaXMubmV0d29yay5ycGNVcmwsIGZhbHNlLCB0aGlzLnRva2VuUHJvdmlkZXIsIHRoaXMucnBjSGVhZGVycyk7XG4gICAgICAgIC8vIFJlc3BvbmQgdG8gc29tZSByZXF1ZXN0cyB2aWEgdXNlcmluZm8gb2JqZWN0IGlmIGF2YWlsYWJsZVxuICAgICAgICBpZiAoaXNBdXRoUHJvdmlkZXIodGhpcy50b2tlblByb3ZpZGVyKSkge1xuICAgICAgICAgICAgY29uc3QgY2FjaGVTdWJwcm92aWRlciA9IG5ldyBBdXRoZW50aWNhdGVkQ2FjaGVTdWJwcm92aWRlcih0aGlzLnRva2VuUHJvdmlkZXIsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5hZGRQcm92aWRlcihjYWNoZVN1YnByb3ZpZGVyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbnN1cmUgdGhhdCB3aGVuZXZlciBhY2NvdW50cyBhcmUgcmVxdWVzdGVkLCB0aGV5IGdvIHRocm91Z2ggQml0c2tpXG4gICAgICAgIHRoaXMuYWRkUHJvdmlkZXIoYWNjb3VudHNQcm92aWRlcik7XG4gICAgICAgIC8vIFJlc3BvbmQgdG8gcmVxdWVzdHMgdGhhdCBuZWVkIHNpZ25lZCB3aXRoIGFuIGlmcmFtZVxuICAgICAgICBjb25zdCBzaWduYXR1cmVTdWJwcm92aWRlciA9IG5ldyBTaWduYXR1cmVTdWJwcm92aWRlcih0aGlzLm5ldHdvcmssIHRoaXMuc2lnbmVyLCB0aGlzLnRva2VuUHJvdmlkZXIpO1xuICAgICAgICB0aGlzLmFkZFByb3ZpZGVyKHNpZ25hdHVyZVN1YnByb3ZpZGVyKTtcbiAgICAgICAgLy8gUmVzcG9uZCB0byBibG9jayByZXF1ZXN0IHZpYSBSRVNUIGlzIHVzaW5nIEJpdHNraSBSUEMgZW5kcG9pbnRcbiAgICAgICAgaWYgKHRoaXMubmV0d29yay5ycGNVcmwuc3RhcnRzV2l0aCgnaHR0cHM6Ly9hcGkuYml0c2tpLmNvbScpKSB7XG4gICAgICAgICAgICBjb25zdCBibG9ja1Byb3ZpZGVyID0gbmV3IFJlc3RGZXRjaFN1YnByb3ZpZGVyKHsgcnBjVXJsOiB0aGlzLm5ldHdvcmsucnBjVXJsLCBkZWZhdWx0SGVhZGVyczogdGhpcy5oZWFkZXJzIH0pO1xuICAgICAgICAgICAgdGhpcy5hZGRQcm92aWRlcihibG9ja1Byb3ZpZGVyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5hbGx5LCBhZGQgb3VyIGJhc2ljIEhUVFAgcHJvdmlkZXJcbiAgICAgICAgdGhpcy5hZGRQcm92aWRlcihmZXRjaFN1YnByb3ZpZGVyKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBEaWFsb2cgfSBmcm9tICcuLi9jb21wb25lbnRzL2RpYWxvZyc7XG5pbXBvcnQgeyBJRlJBTUVfTUVTU0FHRV9PUklHSU5fSU5DTFVERVMgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgU2lnbmVyRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvc2lnbmVyLWVycm9yJztcbmltcG9ydCB7IHBhcnNlUmVzcG9uc2UgfSBmcm9tICcuLi91dGlscy9yZXF1ZXN0LXV0aWxzJztcbi8qKlxuICogVGhpcyBjbGFzcyBpcyByZXNwb25zaWJsZSBmb3Igc2lnbmluZyB0cmFuc2FjdGlvbnMuIEl0IG9ubHkga25vd3MgYWJvdXQgQml0c2tpJ3MgcHJvcHJpZXRhcnkgdHJhbnNhY3Rpb24gb2JqZWN0cy5cbiAqIEl0IGlzIGFsc28gdGhlIG9ubHkgY2xhc3MgdGhhdCBrbm93cyBhYm91dCB0aGUgaWZyYW1lIHNpZ25pbmcgaW1wbGVtZW50YXRpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBCaXRza2lUcmFuc2FjdGlvblNpZ25lciB7XG4gICAgY29uc3RydWN0b3Iod2ViQmFzZVVybCwgYXBpQmFzZVVybCwgZGVmYXVsdEhlYWRlcnMsIGNhbGxiYWNrVVJMKSB7XG4gICAgICAgIHRoaXMud2ViQmFzZVVybCA9IHdlYkJhc2VVcmw7XG4gICAgICAgIHRoaXMuYXBpQmFzZVVybCA9IGFwaUJhc2VVcmw7XG4gICAgICAgIHRoaXMuZGVmYXVsdEhlYWRlcnMgPSBkZWZhdWx0SGVhZGVycztcbiAgICAgICAgdGhpcy5jYWxsYmFja1VSTCA9IGNhbGxiYWNrVVJMO1xuICAgICAgICAvLyBXYXRjaCBmb3IgbmV3IG1lc3NhZ2VzIG9uIHRoZSB3aW5kb3cuXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5yZWNlaXZlTWVzc2FnZS5iaW5kKHRoaXMpLCBmYWxzZSk7XG4gICAgfVxuICAgIGFzeW5jIHNpZ24odHJhbnNhY3Rpb24sIGFjY2Vzc1Rva2VuKSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSBjYWxsYmFjayBVUkwsIHVzZSB0aGUgcmVkaXJlY3QgZmxvd1xuICAgICAgICBpZiAodGhpcy5jYWxsYmFja1VSTCkge1xuICAgICAgICAgICAgY29uc3QgcGVyc2lzdGVkID0gYXdhaXQgdGhpcy5zdWJtaXRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgYWNjZXNzVG9rZW4pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVkaXJlY3RUb0NhbGxiYWNrVVJMKHBlcnNpc3RlZC50cmFuc2FjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJtaXRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgYWNjZXNzVG9rZW4pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlQ2FsbGJhY2soeyBlcnJvciB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFNob3cgdGhlIG1vZGFsIChhd2FpdCByZXNwb25zZSlcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hvd0F1dGhvcml6YXRpb25Nb2RhbCh0cmFuc2FjdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2ZW50IGxpc3RlbmVyIGZvciBjYWxsYmFja3MgZnJvbSB0aGUgaWZyYW1lXG4gICAgICogQHBhcmFtIGV2ZW50IE1lc3NhZ2VFdmVudCByZWNlaXZlZCBmcm9tIHRoZSBicm93c2VyXG4gICAgICovXG4gICAgcmVjZWl2ZU1lc3NhZ2UoZXZlbnQpIHtcbiAgICAgICAgLy8gSWdub3JlIG1lc3NhZ2VzIGZyb20gdGhlIGN1cnJlbnQgd2luZG93LCBhbmQgZnJvbSBmcmFtZXMgdGhhdCBhcmVuJ3Qgb24gQml0c2tpLmNvbVxuICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSB3aW5kb3cgfHwgIWV2ZW50Lm9yaWdpbi5pbmNsdWRlcyhJRlJBTUVfTUVTU0FHRV9PUklHSU5fSU5DTFVERVMpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgICAgIC8vIElnbm9yZSBtZXNzYWdlIGV2ZW50cyB0aGF0IGRvbid0IGFjdHVhbGx5IGhhdmUgZGF0YVxuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkIHx8IGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhbmRsZUNhbGxiYWNrKGRhdGEpO1xuICAgIH1cbiAgICBoYW5kbGVDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgICAvLyBJZ25vcmUgbWVzc2FnZXMgd2hlbiB3ZSBkb24ndCBoYXZlIGEgY3VycmVudCByZXF1ZXN0IGluIGZsaWdodFxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW2Z1bGZpbGwsIHJlamVjdF0gPSB0aGlzLmN1cnJlbnRSZXF1ZXN0O1xuICAgICAgICAvLyBEaXNtaXNzIGN1cnJlbnQgZGlhbG9nXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRSZXF1ZXN0RGlhbG9nKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRSZXF1ZXN0RGlhbG9nLmRpc21pc3MoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYWxsIHRoZSBjYWxsYmFjayB0byBjb21wbGV0ZSB0aGUgcmVxdWVzdFxuICAgICAgICBpZiAoY2FsbGJhY2suZXJyb3IpIHtcbiAgICAgICAgICAgIHJlamVjdChjYWxsYmFjay5lcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmdWxmaWxsKGNhbGxiYWNrLnJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xlYXIgc3RhdGVcbiAgICAgICAgdGhpcy5jdXJyZW50UmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jdXJyZW50UmVxdWVzdERpYWxvZyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzcG9uc2libGUgZm9yIHN1Ym1pdHRpbmcgdGhlIFRyYW5zYWN0aW9uIG9iamVjdCB0byB0aGUgQVBJXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIFRoZSBUcmFuc2FjdGlvbiBvYmplY3QgdG8gc3VibWl0XG4gICAgICogQHBhcmFtIGFjY2Vzc1Rva2VuIFRoZSBjdXJyZW50IHVzZXIncyBhY2Nlc3MgdG9rZW5cbiAgICAgKi9cbiAgICBhc3luYyBzdWJtaXRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdEJvZHkgPSB7IHRyYW5zYWN0aW9uIH07XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmRlZmF1bHRIZWFkZXJzLCB7XG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHthY2Nlc3NUb2tlbn1gLFxuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5hcGlCYXNlVXJsfS90cmFuc2FjdGlvbnNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3RCb2R5KSxcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGFyc2VSZXNwb25zZShyZXNwb25zZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3BsYXlzIHRoZSBhdXRob3JpemF0aW9uIGZvcm0gaW4gYSBtb2RhbCB3aW5kb3dcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gVGhlIHRyYW5zYWN0aW9uIHRoYXQgaGFzIGJlZW4gc3VibWl0dGVkXG4gICAgICovXG4gICAgc2hvd0F1dGhvcml6YXRpb25Nb2RhbCh0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKGZ1bGZpbGwsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy53ZWJCYXNlVXJsfS90cmFuc2FjdGlvbnMvJHt0cmFuc2FjdGlvbi5pZH1gO1xuICAgICAgICAgICAgY29uc3QgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICAgICAgICBpZnJhbWUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgICAgaWZyYW1lLnN0eWxlLnRvcCA9ICcwJztcbiAgICAgICAgICAgIGlmcmFtZS5zdHlsZS5sZWZ0ID0gJzAnO1xuICAgICAgICAgICAgaWZyYW1lLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICAgICAgaWZyYW1lLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgICAgIGlmcmFtZS5mcmFtZUJvcmRlciA9ICcwJztcbiAgICAgICAgICAgIGlmcmFtZS5zcmMgPSB1cmw7XG4gICAgICAgICAgICAvLyBEaXNtaXNzIGFueSBleGlzdGluZyBkaWFsb2dzIHRvIHByZXZlbnQgVUkgZ2xpdGNoZXMuXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50UmVxdWVzdERpYWxvZykge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFJlcXVlc3REaWFsb2cuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY3VycmVudFJlcXVlc3QgPSBbZnVsZmlsbCwgcmVqZWN0XTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFJlcXVlc3REaWFsb2cgPSBuZXcgRGlhbG9nKGlmcmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRSZXF1ZXN0RGlhbG9nLm9uQ2xvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gQ2FwdHVyZSByZWplY3QgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICByZWplY3QoU2lnbmVyRXJyb3IuVXNlckNhbmNlbGxlZCgpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZWRpcmVjdFRvQ2FsbGJhY2tVUkwodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy53ZWJCYXNlVXJsfS90cmFuc2FjdGlvbnMvJHt0cmFuc2FjdGlvbi5pZH0/cmVkaXJlY3RVUkk9JHt0aGlzLmNhbGxiYWNrVVJMfWA7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCcnKTtcbiAgICB9XG59XG4iLCIvKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuY29uc3QgY3NzID0gYFxuLmJpdHNraS1jb25uZWN0LWJ1dHRvbiB7XG4gIGZvbnQtZmFtaWx5OiAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsICdTZWdvZSBVSScsIFJvYm90bywgT3h5Z2VuLCAnSGVsdmV0aWNhIE5ldWUnLCBzYW5zLXNlcmlmO1xuICBmb250LXdlaWdodDogNTAwO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMUMxMUQ5O1xuICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAwcHggMHB4O1xuICBib3JkZXI6IG5vbmU7XG4gIGNvbG9yOiAjZmZmO1xuICBtYXJnaW46IDA7XG4gIHBhZGRpbmc6IDA7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgdGV4dC1zaGFkb3c6IDFweCAwIDFweCByZ2JhKDAsIDAsIDAsIDAuMDMpO1xuICBib3gtc2hhZG93OiAwIDFweCAxcHggcmdiYSgwLCAwLCAwLCAwLjE0KTtcbiAgdHJhbnNpdGlvbjogYmFja2dyb3VuZCAyMDBtcyBsaW5lYXIsIHRyYW5zZm9ybSAyMDBtcyBlYXNlLW91dDtcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcbiAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcbiAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xuICB1c2VyLXNlbGVjdDogbm9uZTtcbn1cbi5iaXRza2ktY29ubmVjdC1idXR0b246Zm9jdXMsXG4uYml0c2tpLWNvbm5lY3QtYnV0dG9uOmFjdGl2ZSB7XG4gIGJhY2tncm91bmQtY29sb3I6ICMyMTE3Qzc7XG4gIHRyYW5zZm9ybTogc2NhbGUoMC45OSwgMC45OSk7XG4gIGNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOCk7XG59XG4uYml0c2tpLWNvbm5lY3QtYnV0dG9uLnNpemUtc21hbGwge1xuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2h0dHBzOi8vY2RuLmJpdHNraXN0YXRpYy5jb20vc2RrL2J0bi12Mi1iZy1zbS5zdmcnKTtcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xuICBmb250LXNpemU6IDEwcHg7XG4gIGhlaWdodDogMjJweDtcbiAgbGluZS1oZWlnaHQ6IDE5cHg7XG4gIHBhZGRpbmctbGVmdDogMzBweDtcbiAgcGFkZGluZy1yaWdodDogOHB4O1xufVxuLmJpdHNraS1jb25uZWN0LWJ1dHRvbi5zaXplLW1lZGl1bSB7XG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnaHR0cHM6Ly9jZG4uYml0c2tpc3RhdGljLmNvbS9zZGsvYnRuLXYyLWJnLW1kLnN2ZycpO1xuICBib3JkZXItcmFkaXVzOiA0cHg7XG4gIGZvbnQtc2l6ZTogMTFweDtcbiAgaGVpZ2h0OiAzMHB4O1xuICBsaW5lLWhlaWdodDogMjlweDtcbiAgcGFkZGluZy1sZWZ0OiA0MHB4O1xuICBwYWRkaW5nLXJpZ2h0OiAxMnB4O1xufVxuLmJpdHNraS1jb25uZWN0LWJ1dHRvbi5zaXplLWxhcmdlIHtcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdodHRwczovL2Nkbi5iaXRza2lzdGF0aWMuY29tL3Nkay9idG4tdjItYmctbGcuc3ZnJyk7XG4gIGJvcmRlci1yYWRpdXM6IDVweDtcbiAgZm9udC1zaXplOiAxNHB4O1xuICBoZWlnaHQ6IDQ0cHg7XG4gIGxpbmUtaGVpZ2h0OiA0NHB4O1xuICBwYWRkaW5nLWxlZnQ6IDU3cHg7XG4gIHBhZGRpbmctcmlnaHQ6IDE1cHg7XG59XG5gO1xuZXhwb3J0IGRlZmF1bHQgY3NzO1xuIiwiLyogdHNsaW50OmRpc2FibGUgKi9cbmNvbnN0IGNzcyA9IGBcbiNiaXRza2ktZGlhbG9nLWNvbnRhaW5lciB7XG4gIHBvc2l0aW9uOiBmaXhlZDtcbiAgbGVmdDogMDtcbiAgcmlnaHQ6IDA7XG4gIHRvcDogMDtcbiAgYm90dG9tOiAwO1xuICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDApO1xuICB6LWluZGV4OiAxMDAwO1xuICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kIGxpbmVhciAwLjJzO1xuICBwb2ludGVyLWV2ZW50czogbm9uZTtcbn1cbiNiaXRza2ktZGlhbG9nLWNvbnRhaW5lci5iaXRza2ktdmlzaWJsZSB7XG4gIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC41KTtcbiAgcG9pbnRlci1ldmVudHM6IGF1dG87XG59XG4uYml0c2tpLWRpYWxvZyB7XG4gIG9wYWNpdHk6IDA7XG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgxMDB2aCk7XG4gIHRyYW5zaXRpb246IG9wYWNpdHkgMzAwbXMgbGluZWFyLCB0cmFuc2Zvcm0gNDAwbXMgY3ViaWMtYmV6aWVyKDAuMTksIDEsIDAuMjIsIDEpO1xuICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6IDA7XG4gIGxlZnQ6IDA7XG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IDEwMCU7XG59XG4jYml0c2tpLWRpYWxvZy1jb250YWluZXIuYml0c2tpLXZpc2libGUgLmJpdHNraS1kaWFsb2cge1xuICBvcGFjaXR5OiAxO1xuICB0cmFuc2Zvcm06IG5vbmU7XG4gIHRyYW5zaXRpb246IG9wYWNpdHkgMzAwbXMgbGluZWFyLCB0cmFuc2Zvcm0gNjAwbXMgY3ViaWMtYmV6aWVyKDAuMTksIDEsIDAuMjIsIDEpO1xuICBwb2ludGVyLWV2ZW50czogYXV0bztcbn1cbi5iaXRza2ktZGlhbG9nIC5iaXRza2ktY2xvc2UtYnV0dG9uIHtcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQgdXJsKCdodHRwczovL2Nkbi5iaXRza2lzdGF0aWMuY29tL3Nkay9jbG9zZS5zdmcnKSBuby1yZXBlYXQgNTAlIDUwJTtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICByaWdodDogMTJweDtcbiAgdG9wOiAxMnB4O1xuICBib3JkZXI6IG5vbmU7XG4gIG91dGxpbmU6IG5vbmU7XG4gIG1hcmdpbjogMDtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICBwYWRkaW5nOiAwO1xuICB3aWR0aDogMjhweDtcbiAgaGVpZ2h0OiAyOHB4O1xuICB6LWluZGV4OiAxMDA7XG4gIG92ZXJmbG93OiBoaWRkZW47XG4gIHRleHQtaW5kZW50OiAtMTAwMHB4O1xufVxuLmJpdHNraS1kaWFsb2ctYm9keSB7XG4gIGJhY2tncm91bmQ6ICNmZmY7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgdG9wOiAwO1xuICBib3R0b206IDA7XG4gIGxlZnQ6IDA7XG4gIHJpZ2h0OiAwO1xuICB6LWluZGV4OiA1O1xuICBtYXgtd2lkdGg6IDEwMCU7XG59XG4uYml0c2tpLWRpYWxvZy1ib2R5LmJpdHNraS1sb2FkaW5nOjphZnRlciB7XG4gIGNvbnRlbnQ6IFwiXCI7XG4gIGJhY2tncm91bmQ6IHVybCgnaHR0cHM6Ly9jZG4uYml0c2tpc3RhdGljLmNvbS9zZGsvbG9hZGluZy5zdmcnKSBuby1yZXBlYXQgNTAlIDUwJTtcbiAgYW5pbWF0aW9uOiByb3RhdGUgNjAwbXMgbGluZWFyIGluZmluaXRlO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogNTAlO1xuICBsZWZ0OiA1MCU7XG4gIG9wYWNpdHk6IDAuMztcbiAgd2lkdGg6IDM4cHg7XG4gIGhlaWdodDogMzhweDtcbiAgbWFyZ2luLWxlZnQ6IC0xOXB4O1xuICBtYXJnaW4tdG9wOiAtMTlweDtcbiAgei1pbmRleDogLTE7XG59XG5AbWVkaWEgKG1pbi13aWR0aDogNjAwcHgpIHtcbiAgI2JpdHNraS1kaWFsb2ctY29udGFpbmVyIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gIH1cbiAgLmJpdHNraS1kaWFsb2cge1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICB3aWR0aDogNDAwcHg7XG4gICAgaGVpZ2h0OiA0MjBweDtcbiAgfVxuICAuYml0c2tpLWRpYWxvZy1ib2R5IHtcbiAgICBib3JkZXItcmFkaXVzOiAxNnB4O1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgYm94LXNoYWRvdzogMHB4IDBweCAwcHggMXB4IHJnYmEoMCwwLDAsMC4xKSwgMHB4IDEwcHggNTBweCByZ2JhKDAsMCwwLDAuNCk7XG4gIH1cbn1cblxuQGtleWZyYW1lcyByb3RhdGUge1xuICAwJSB7XG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XG4gIH1cbiAgNTAlIHtcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgxODBkZWcpO1xuICB9XG4gIDEwMCUge1xuICAgIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XG4gIH1cbn1cbmA7XG5leHBvcnQgZGVmYXVsdCBjc3M7XG4iLCIvKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuaW1wb3J0IGNvbm5lY3RCdG5TdHlsZXMgZnJvbSAnLi9jb25uZWN0LWJ1dHRvbic7XG5pbXBvcnQgZGlhbG9nU3R5bGVzIGZyb20gJy4vZGlhbG9nJztcbmNvbnN0IGNzcyA9IGBcbiAgJHtkaWFsb2dTdHlsZXN9XG4gICR7Y29ubmVjdEJ0blN0eWxlc31cbmA7XG5leHBvcnQgZGVmYXVsdCBjc3M7XG4iLCJpbXBvcnQgeyBTdWJwcm92aWRlciB9IGZyb20gJ0BiaXRza2kvcHJvdmlkZXItZW5naW5lJztcbmltcG9ydCB7IENBQ0hFRF9NRVRIT0RTIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbi8qXG4gKiBTdWJwcm92aWRlciB0aGF0IGNhY2hlcyB2YWx1ZXMgcmVsYXRlZCB0byB0aGUgdXNlci5cbiAqL1xuZXhwb3J0IGNsYXNzIEF1dGhlbnRpY2F0ZWRDYWNoZVN1YnByb3ZpZGVyIGV4dGVuZHMgU3VicHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKGF1dGhQcm92aWRlciwgZW5naW5lKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXV0aFByb3ZpZGVyID0gYXV0aFByb3ZpZGVyO1xuICAgICAgICB0aGlzLmNhY2hlZFZhbHVlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKGVuZ2luZSkge1xuICAgICAgICAgICAgZW5naW5lLm9uKCdzaWduT3V0JywgKCkgPT4gdGhpcy5jYWNoZWRWYWx1ZXMuY2xlYXIoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlUmVxdWVzdChwYXlsb2FkLCBuZXh0LCBlbmQpIHtcbiAgICAgICAgLy8gT25seSBldmFsdWF0ZSBtYXRjaGluZyBtZXRob2RzXG4gICAgICAgIGlmICh0aGlzLnN1cHBvcnRzQ2FjaGUocGF5bG9hZC5tZXRob2QpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbGxvdyBvdmVycmlkaW5nIHRoZSBjYWNoZVxuICAgICAgICBpZiAocGF5bG9hZC5za2lwQ2FjaGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTG9hZCBmcm9tIGNhY2hlXG4gICAgICAgIHRoaXMuY2hlY2tDYWNoZWRWYWx1ZXMocGF5bG9hZC5tZXRob2QpLnRoZW4oKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIFZhbHVlIGZvciBtZXRob2QgaXMgY2FjaGVkLCByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgICAgICBlbmQodW5kZWZpbmVkLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBWYWx1ZSBmb3IgbWV0aG9kIGlzIG5vdCBjYWNoZWQsIGZhbGxiYWNrIHRvIGZldGNoXG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAvLyBJZiBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCwgb3Igd2UgZW5jb3VudGVyIGFuIGVycm9yLCBmYWxsYmFjayB0byBmZXRjaCBwcm92aWRlclxuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN1cHBvcnRzQ2FjaGUobWV0aG9kTmFtZSkge1xuICAgICAgICByZXR1cm4gQ0FDSEVEX01FVEhPRFMuaW5jbHVkZXMobWV0aG9kTmFtZSk7XG4gICAgfVxuICAgIGNoZWNrQ2FjaGVkVmFsdWVzKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgLy8gRmlyc3QsIGNoZWNrIGluLW1lbW9yeSBjYWNoZVxuICAgICAgICBpZiAodGhpcy5jYWNoZWRWYWx1ZXMuaGFzKG1ldGhvZE5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuY2FjaGVkVmFsdWVzLmdldChtZXRob2ROYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFsbGJhY2sgdG8gbG9jYWwtc3RvcmFnZSBjYWNoZVxuICAgICAgICBzd2l0Y2ggKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2V0aF9hY2NvdW50cyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWNjb3VudHMoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignTWV0aG9kIG5vdCBzdXBwb3J0ZWQnKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0QWNjb3VudHMoKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyB0byBhIHN1YnNjcmlwdGlvbiBtb2RlbCBhbmQgbG9hZCBpbnRvIG1lbW9yeSBhdXRvbWF0aWNhbGx5XG4gICAgICAgIHJldHVybiB0aGlzLmF1dGhQcm92aWRlci5nZXRVc2VyKCkudGhlbigodXNlcikgPT4ge1xuICAgICAgICAgICAgaWYgKHVzZXIuYWNjb3VudHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlZFZhbHVlcy5zZXQoJ2V0aF9hY2NvdW50cycsIHVzZXIuYWNjb3VudHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB1c2VyLmFjY291bnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY2NvdW50cyBub3QgZm91bmQgb24gdXNlcicpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBBdXRoZW50aWNhdGVkRmV0Y2hTdWJwcm92aWRlciB9IGZyb20gJ2JpdHNraS1wcm92aWRlcic7XG4vLyBBIHN1YnByb3ZpZGVyIHRoYXQgbG9hZHMgYWNjb3VudHMgZnJvbSBhIGN1c3RvbSBycGMgZW5kcG9pbnQuXG4vLyBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHRvIGd1YXJhbnRlZSB0aGF0IGFjY291bnQgcmVsYXRlZCBjYWxscyBnbyB0aHJvdWdoIEJpdHNraVxuZXhwb3J0IGNsYXNzIFJlbW90ZUFjY291bnRTdWJwcm92aWRlciBleHRlbmRzIEF1dGhlbnRpY2F0ZWRGZXRjaFN1YnByb3ZpZGVyIHtcbiAgICBoYW5kbGVSZXF1ZXN0KHBheWxvYWQsIG5leHQsIGVuZCkge1xuICAgICAgICBpZiAocGF5bG9hZC5tZXRob2QgPT09ICdldGhfYWNjb3VudHMnKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUF1dGhlbnRpY2F0ZWRSZXF1ZXN0KHBheWxvYWQsIG5leHQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBTdWJwcm92aWRlciB9IGZyb20gJ0BiaXRza2kvcHJvdmlkZXItZW5naW5lJztcbmltcG9ydCBhc3luY2lmeSBmcm9tICdhc3luYy9hc3luY2lmeSc7XG5pbXBvcnQgcmV0cnkgZnJvbSAnYXN5bmMvcmV0cnknO1xuaW1wb3J0IHdhdGVyZmFsbCBmcm9tICdhc3luYy93YXRlcmZhbGwnO1xuaW1wb3J0IGZldGNoIGZyb20gJ2Nyb3NzLWZldGNoJztcbmltcG9ydCBKc29uUnBjRXJyb3IgZnJvbSAnanNvbi1ycGMtZXJyb3InO1xuaW1wb3J0IHByb21pc2VUb0NhbGxiYWNrIGZyb20gJ3Byb21pc2UtdG8tY2FsbGJhY2snO1xuY29uc3QgUkVUUklBQkxFX0VSUk9SUyA9IFtcbiAgICAvLyBpZ25vcmUgc2VydmVyIG92ZXJsb2FkIGVycm9yc1xuICAgICdHYXRld2F5IHRpbWVvdXQnLFxuICAgICdFVElNRURPVVQnLFxuICAgIC8vIGlnbm9yZSBzZXJ2ZXIgc2VudCBodG1sIGVycm9yIHBhZ2VzXG4gICAgLy8gb3IgdHJ1bmNhdGVkIGpzb24gcmVzcG9uc2VzXG4gICAgJ1N5bnRheEVycm9yJyxcbl07XG5jb25zdCBNQVRDSElOR19NRVRIT0RTID0gWydldGhfZ2V0QmxvY2tCeU51bWJlcicsICdldGhfYmxvY2tOdW1iZXInLCAnbmV0X1ZlcnNpb24nLCAnZXRoX2dldExvZ3MnXTtcbmV4cG9ydCBjbGFzcyBSZXN0RmV0Y2hTdWJwcm92aWRlciBleHRlbmRzIFN1YnByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucnBjVXJsID0gb3B0cy5ycGNVcmw7XG4gICAgICAgIHRoaXMuZGVmYXVsdEhlYWRlcnMgPSBvcHRzLmRlZmF1bHRIZWFkZXJzO1xuICAgICAgICB0aGlzLm9yaWdpbkh0dHBIZWFkZXJLZXkgPSBvcHRzLm9yaWdpbkh0dHBIZWFkZXJLZXk7XG4gICAgfVxuICAgIGhhbmRsZVJlcXVlc3QocGF5bG9hZCwgbmV4dCwgZW5kKSB7XG4gICAgICAgIGlmIChNQVRDSElOR19NRVRIT0RTLmluY2x1ZGVzKHBheWxvYWQubWV0aG9kKSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVSZXN0UmVxdWVzdChwYXlsb2FkLCBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZVJlc3RSZXF1ZXN0KHBheWxvYWQsIGVuZCkge1xuICAgICAgICBjb25zdCBvcmlnaW5Eb21haW4gPSBwYXlsb2FkLm9yaWdpbjtcbiAgICAgICAgY29uc3QgcXVlcnkgPSBwYXlsb2FkLnBhcmFtcy5sZW5ndGggPiAwID8gYD9wYXJhbXM9JHtlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkocGF5bG9hZC5wYXJhbXMpKX1gIDogJyc7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMucnBjVXJsfS8ke3BheWxvYWQubWV0aG9kfSR7cXVlcnl9YDtcbiAgICAgICAgY29uc3QgcmVxUGFyYW1zID0ge1xuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sIHRoaXMuZGVmYXVsdEhlYWRlcnMpLFxuICAgICAgICAgICAgY3JlZGVudGlhbHM6ICdvbWl0JyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMub3JpZ2luSHR0cEhlYWRlcktleSAmJiBvcmlnaW5Eb21haW4pIHtcbiAgICAgICAgICAgIHJlcVBhcmFtcy5oZWFkZXJzW3RoaXMub3JpZ2luSHR0cEhlYWRlcktleV0gPSBvcmlnaW5Eb21haW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0cnkoe1xuICAgICAgICAgICAgdGltZXM6IDUsXG4gICAgICAgICAgICBpbnRlcnZhbDogMTAwMCxcbiAgICAgICAgICAgIGVycm9yRmlsdGVyOiBpc0Vycm9yUmV0cmlhYmxlLFxuICAgICAgICB9LCAoY2IpID0+IHRoaXMuX3N1Ym1pdFJlcXVlc3QodXJsLCByZXFQYXJhbXMsIGNiKSwgKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAvLyBlbmRzIG9uIHJldHJpYWJsZSBlcnJvclxuICAgICAgICAgICAgaWYgKGVyciAmJiBpc0Vycm9yUmV0cmlhYmxlKGVycikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJNc2cgPSBgRmV0Y2hTdWJwcm92aWRlciAtIGNhbm5vdCBjb21wbGV0ZSByZXF1ZXN0LiBBbGwgcmV0cmllcyBleGhhdXN0ZWQuXFxuT3JpZ2luYWwgRXJyb3I6XFxuJHtlcnIudG9TdHJpbmcoKX1cXG5cXG5gO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldHJpZXNFeGhhdXN0ZWRFcnIgPSBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kKHJldHJpZXNFeGhhdXN0ZWRFcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGNvbnRpbnVlIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gZW5kKGVyciwgcmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9zdWJtaXRSZXF1ZXN0KHRhcmdldFVybCwgcmVxUGFyYW1zLCBkb25lKSB7XG4gICAgICAgIHByb21pc2VUb0NhbGxiYWNrKGZldGNoKHRhcmdldFVybCwgcmVxUGFyYW1zKSkoKGVyciwgcmVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbmUoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbnRpbnVlIHBhcnNpbmcgcmVzdWx0XG4gICAgICAgICAgICB3YXRlcmZhbGwoW1xuICAgICAgICAgICAgICAgIGNoZWNrRm9ySHR0cEVycm9ycyxcbiAgICAgICAgICAgICAgICAvLyBidWZmZXIgYm9keVxuICAgICAgICAgICAgICAgIChjYikgPT4gcHJvbWlzZVRvQ2FsbGJhY2socmVzLnRleHQoKSkoY2IpLFxuICAgICAgICAgICAgICAgIC8vIHBhcnNlIGJvZHlcbiAgICAgICAgICAgICAgICBhc3luY2lmeSgocmF3Qm9keSkgPT4gSlNPTi5wYXJzZShyYXdCb2R5KSksXG4gICAgICAgICAgICAgICAgcGFyc2VSZXNwb25zZSxcbiAgICAgICAgICAgIF0sIGRvbmUpO1xuICAgICAgICAgICAgZnVuY3Rpb24gY2hlY2tGb3JIdHRwRXJyb3JzKGNiKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGVycm9yc1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocmVzLnN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQwNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYihuZXcgSnNvblJwY0Vycm9yLk1ldGhvZE5vdEZvdW5kKCkpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQxODpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYihjcmVhdGVSYXRlbGltaXRFcnJvcigpKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1MDM6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKGNyZWF0ZVRpbWVvdXRFcnJvcigpKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlUmVzcG9uc2UoYm9keSwgY2IpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgZXJyb3IgY29kZVxuICAgICAgICAgICAgICAgIGlmIChyZXMuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKG5ldyBKc29uUnBjRXJyb3IuSW50ZXJuYWxFcnJvcihib2R5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNiKG51bGwsIGJvZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0Vycm9yUmV0cmlhYmxlKGVycikge1xuICAgIGNvbnN0IGVyck1zZyA9IGVyci50b1N0cmluZygpO1xuICAgIHJldHVybiBSRVRSSUFCTEVfRVJST1JTLnNvbWUoKHBocmFzZSkgPT4gZXJyTXNnLmluY2x1ZGVzKHBocmFzZSkpO1xufVxuZnVuY3Rpb24gY3JlYXRlUmF0ZWxpbWl0RXJyb3IoKSB7XG4gICAgY29uc3QgbXNnID0gJ1JlcXVlc3QgaXMgYmVpbmcgcmF0ZSBsaW1pdGVkLic7XG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gICAgcmV0dXJuIG5ldyBKc29uUnBjRXJyb3IuSW50ZXJuYWxFcnJvcihlcnIpO1xufVxuZnVuY3Rpb24gY3JlYXRlVGltZW91dEVycm9yKCkge1xuICAgIGxldCBtc2cgPSAnR2F0ZXdheSB0aW1lb3V0LiBUaGUgcmVxdWVzdCB0b29rIHRvbyBsb25nIHRvIHByb2Nlc3MuICc7XG4gICAgbXNnICs9ICdUaGlzIGNhbiBoYXBwZW4gd2hlbiBxdWVyeWluZyBsb2dzIG92ZXIgdG9vIHdpZGUgYSBibG9jayByYW5nZS4nO1xuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICAgIHJldHVybiBuZXcgSnNvblJwY0Vycm9yLkludGVybmFsRXJyb3IoZXJyKTtcbn1cbiIsImltcG9ydCB7IFN1YnByb3ZpZGVyIH0gZnJvbSAnQGJpdHNraS9wcm92aWRlci1lbmdpbmUnO1xuaW1wb3J0IHsgdjQgYXMgdXVpZHY0IH0gZnJvbSAndXVpZCc7XG5pbXBvcnQgeyBERUZBVUxUX0FVVEhPUklaRURfTUVUSE9EUyBhcyBERUZBVUxUX1NJR05BVFVSRV9NRVRIT0RTIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IFNpZ25lckVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL3NpZ25lci1lcnJvcic7XG5leHBvcnQgdmFyIFRyYW5zYWN0aW9uS2luZDtcbihmdW5jdGlvbiAoVHJhbnNhY3Rpb25LaW5kKSB7XG4gICAgVHJhbnNhY3Rpb25LaW5kW1wiU2VuZFRyYW5zYWN0aW9uXCJdID0gXCJFVEhfU0VORF9UUkFOU0FDVElPTlwiO1xuICAgIFRyYW5zYWN0aW9uS2luZFtcIlNpZ25UcmFuc2FjdGlvblwiXSA9IFwiRVRIX1NJR05fVFJBTlNBQ1RJT05cIjtcbiAgICBUcmFuc2FjdGlvbktpbmRbXCJTaWduXCJdID0gXCJFVEhfU0lHTlwiO1xuICAgIFRyYW5zYWN0aW9uS2luZFtcIlNpZ25UeXBlZERhdGFcIl0gPSBcIkVUSF9TSUdOX1RZUEVEX0RBVEFcIjtcbn0pKFRyYW5zYWN0aW9uS2luZCB8fCAoVHJhbnNhY3Rpb25LaW5kID0ge30pKTtcbi8qKlxuICogQSBTdWJwcm92aWRlciB0aGF0IG1hbmFnZXMgdGhlIGludGVyZmFjZSBiZXR3ZWVuIEpTT04tUlBDIGFuZCBCaXRza2kncyBwcm9wcmlldGFyeSB0cmFuc2FjdGlvbiBzaWduaW5nIGZsb3cuXG4gKiBUaGlzIGNsYXNzIGlzIHJlc3BvbnNpYmxlIGZvciB0cmFuc2Zvcm1pbmcgdGhlIEpTT04tUlBDIHJlcXVlc3QgaW50byBhIFRyYW5zYWN0aW9uIG9iamVjdCB0aGF0IHRoZSBCaXRza2kgc2lnbmVyIHVuZGVyc3RhbmRzLlxuICogQWxzbyByZXNwb25zaWJsZSBmb3Igc3VibWl0dGluZyB0aGUgdHJhbnNhY3Rpb24gdG8gdGhlIG5ldHdvcmssIGFuZCBjb252ZXJ0aW5nIHRoZSByZXNwb25zZSBiYWNrIGludG8gYW4gUlBDIHJlc3BvbnNlLlxuICpcbiAqIEltcG9ydGFudDogdGhpcyBjbGFzcyBhc3N1bWVzIHRoZSB0cmFuc2FjdGlvbiBoYXMgYWxsIHRoZSBuZWNlc3NhcnkgZmllbGRzIHBvcHVsYXRlZC4gVGhlIFRyYW5zYWN0aW9uVmFsaWRhdG9yU3VicHJvdmlkZXJcbiAqIHNob3VsZCBiZSBwbGFjZWQgaW4gZnJvbnQgb2YgdGhpcyBzdWJwcm92aWRlci5cbiAqL1xuZXhwb3J0IGNsYXNzIFNpZ25hdHVyZVN1YnByb3ZpZGVyIGV4dGVuZHMgU3VicHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKG5ldHdvcmssIHNpZ25lciwgdG9rZW5Qcm92aWRlciwgc2lnbmF0dXJlTWV0aG9kcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5ldHdvcmsgPSBuZXR3b3JrO1xuICAgICAgICB0aGlzLnRva2VuUHJvdmlkZXIgPSB0b2tlblByb3ZpZGVyO1xuICAgICAgICB0aGlzLnNpZ25lciA9IHNpZ25lcjtcbiAgICAgICAgdGhpcy5zaWduYXR1cmVNZXRob2RzID0gc2lnbmF0dXJlTWV0aG9kcyB8fCBERUZBVUxUX1NJR05BVFVSRV9NRVRIT0RTO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgUlBDIHJlcXVlc3QgZnJvbSBlbmdpbmUgKGNhbGxlZCBieSlcbiAgICAgKiBAcGFyYW0gcGF5bG9hZCBSUEMgcmVxdWVzdCBwYXlsb2FkXG4gICAgICogQHBhcmFtIG5leHQgQ2FsbGJhY2sgdG8gc2tpcCBoYW5kbGluZyB0aGlzIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0gZW5kIENvbXBsZXRpb24gaGFuZGxlclxuICAgICAqL1xuICAgIGhhbmRsZVJlcXVlc3QocGF5bG9hZCwgbmV4dCwgZW5kKSB7XG4gICAgICAgIGlmICh0aGlzLnJlcXVpcmVzU2lnbmF0dXJlKHBheWxvYWQubWV0aG9kKSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVTaWduYXR1cmVSZXF1ZXN0KHBheWxvYWQsIGVuZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBhIHBheWxvYWQgaXMgcmVjZWl2ZWQgdGhhdCBuZWVkcyBhIHNpZ25hdHVyZVxuICAgICAqIEBwYXJhbSBwYXlsb2FkIFRoZSBKU09OLVJQQyByZXF1ZXN0XG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW4gdGhlIHJlcXVlc3QgaGFzIGJlZW4gaGFuZGxlZFxuICAgICAqL1xuICAgIGFzeW5jIGhhbmRsZVNpZ25hdHVyZVJlcXVlc3QocGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEdldCBhY2Nlc3MgdG9rZW5cbiAgICAgICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gYXdhaXQgdGhpcy50b2tlblByb3ZpZGVyLmdldEFjY2Vzc1Rva2VuKCk7XG4gICAgICAgICAgICAvLyBQcmVwYXJlIGEgdHJhbnNhY3Rpb24gb2JqZWN0XG4gICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGF3YWl0IHRoaXMuY3JlYXRlQml0c2tpVHJhbnNhY3Rpb24ocGF5bG9hZCk7XG4gICAgICAgICAgICAvLyBTaWduIHRoZSB0cmFuc2FjdGlvbiBvYmplY3RcbiAgICAgICAgICAgIGNvbnN0IHNpZ25lZFJlc3BvbnNlID0gYXdhaXQgdGhpcy5zaWduZXIuc2lnbih0cmFuc2FjdGlvbiwgYWNjZXNzVG9rZW4pO1xuICAgICAgICAgICAgLy8gU2VuZCB0aGUgdHJhbnNhY3Rpb24gaWYgbmVlZGVkXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnNlbmRJZk5lZWRlZChwYXlsb2FkLCBzaWduZWRSZXNwb25zZSk7XG4gICAgICAgICAgICAvLyBDYWxsIHRoZSBjYWxsYmFjayB3aXRoIHRoZSByZXN1bHRcbiAgICAgICAgICAgIGNhbGxiYWNrKHVuZGVmaW5lZCwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIENhbGwgd2l0aCB0aGUgZXJyb3IgaWYgYW55IG9mIHRoZSBzdGVwcyBmYWlsXG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvciwgdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogU2hvdWxkIHRoaXMgc3VicHJvdmlkZXIgaGFuZGxlIHRoZSByZXF1ZXN0P1xuICAgICAqIEBwYXJhbSBtZXRob2QgVGhlIFJQQyBtZXRob2Qgb2YgdGhlIHJlcXVlc3RcbiAgICAgKi9cbiAgICByZXF1aXJlc1NpZ25hdHVyZShtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbmF0dXJlTWV0aG9kcy5pbmNsdWRlcyhtZXRob2QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIHdpbGwgZm9yd2FyZCB0cmFuc2FjdGlvbnMgdGhhdCBzaG91bGQgYmUgYXV0b21hdGljYWxseSBzdWJtaXR0ZWQgdG8gdGhlIG5ldHdvcmssIG90aGVyd2lzZVxuICAgICAqIHJlc29sdmUgd2l0aCB0aGUgb3JpZ2luYWwgdmFsdWUuXG4gICAgICogQHBhcmFtIHBheWxvYWQgVGhlIG9yaWdpbmFsIHJlcXVlc3QgcGF5bG9hZFxuICAgICAqIEBwYXJhbSBzaWduZWREYXRhIHNpZ25lZCBkYXRhIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKi9cbiAgICBzZW5kSWZOZWVkZWQocGF5bG9hZCwgc2lnbmVkRGF0YSkge1xuICAgICAgICBpZiAocGF5bG9hZC5tZXRob2QgPT09ICdldGhfc2VuZFRyYW5zYWN0aW9uJykge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgc2VuZCByYXcgdHJhbnNhY3Rpb24gcGF5bG9hZFxuICAgICAgICAgICAgY29uc3Qgc2VuZFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgaWQ6IDAsXG4gICAgICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnZXRoX3NlbmRSYXdUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBbc2lnbmVkRGF0YV0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGVyZm9ybVJlcXVlc3Qoc2VuZFBheWxvYWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc2lnbmVkRGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvYWQgdGhlIGJhbGFuY2Ugc28gdGhlIHdlYiBhcHByb3ZhbCBkaWFsb2cgY2FuIGdpdmUgdGhlIHVzZXIgYmV0dGVyIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gcGF5bG9hZCBQYXlsb2FkIGZvciB0aGUgcmVxdWVzdFxuICAgICAqL1xuICAgIGxvYWRCYWxhbmNlSWZOZWVkZWQocGF5bG9hZCkge1xuICAgICAgICAvLyBPbmx5IG5lY2Vzc2FyeSBpZiB0aGlzIGlzIGEgdHJhbnNhY3Rpb25cbiAgICAgICAgY29uc3QgaXNUcmFuc2FjdGlvbiA9IHBheWxvYWQubWV0aG9kID09PSAnZXRoX3NlbmRUcmFuc2FjdGlvbicgfHwgcGF5bG9hZC5tZXRob2QgPT09ICdldGhfc2lnblRyYW5zYWN0aW9uJztcbiAgICAgICAgY29uc3QgaXNDdXN0b21SUEMgPSAhdGhpcy5uZXR3b3JrLnJwY1VybC5pbmNsdWRlcygnYXBpLmJpdHNraS5jb20nKTtcbiAgICAgICAgaWYgKGlzVHJhbnNhY3Rpb24gJiYgaXNDdXN0b21SUEMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gcGF5bG9hZC5wYXJhbXNbMF07XG4gICAgICAgICAgICBjb25zdCBiYWxhbmNlUGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICBpZDogMCxcbiAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdldGhfZ2V0QmFsYW5jZScsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBbdHJhbnNhY3Rpb24uZnJvbSwgJ2xhdGVzdCddLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBlcmZvcm1SZXF1ZXN0KGJhbGFuY2VQYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGUgVHJhbnNhY3Rpb24gb2JqZWN0IGZyb20gYSBnaXZlbiBSUEMgcGF5bG9hZFxuICAgICAqIEBwYXJhbSBwYXlsb2FkIEpTT04tUlBDIHBheWxvYWQgdG8gZXh0cmFjdCB0aGUgdmFsdWVzIGZyb21cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVCaXRza2lUcmFuc2FjdGlvbihwYXlsb2FkKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBhd2FpdCB0aGlzLmNyZWF0ZUNvbnRleHQocGF5bG9hZCk7XG4gICAgICAgIGNvbnN0IGtpbmQgPSB0aGlzLmtpbmRGb3JNZXRob2QocGF5bG9hZC5tZXRob2QpO1xuICAgICAgICBjb25zdCBleHRyYWN0ZWRQYXlsb2FkID0gdGhpcy5jcmVhdGVQYXlsb2FkKHBheWxvYWQpO1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHtcbiAgICAgICAgICAgIGlkOiB1dWlkdjQoKSxcbiAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICBwYXlsb2FkOiBleHRyYWN0ZWRQYXlsb2FkLFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVDb250ZXh0KHJlcXVlc3QpIHtcbiAgICAgICAgc3dpdGNoIChyZXF1ZXN0Lm1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSAnZXRoX3NlbmRUcmFuc2FjdGlvbic6XG4gICAgICAgICAgICBjYXNlICdldGhfc2lnblRyYW5zYWN0aW9uJzpcbiAgICAgICAgICAgICAgICBjb25zdCBiYWxhbmNlID0gYXdhaXQgdGhpcy5sb2FkQmFsYW5jZUlmTmVlZGVkKHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGNoYWluSWQ6IHRoaXMubmV0d29yay5jaGFpbklkLCBjdXJyZW50QmFsYW5jZTogYmFsYW5jZSB9O1xuICAgICAgICAgICAgY2FzZSAnZXRoX3NpZ25UeXBlZERhdGEnOlxuICAgICAgICAgICAgY2FzZSAnZXRoX3NpZ25UeXBlZERhdGFfdjMnOlxuICAgICAgICAgICAgICAgIC8vIFRoZSBmcm9tIGFkZHJlc3Mgc2hvdWxkIGJlIHRoZSBmaXJzdCBwYXJhbWV0ZXIgYXMgYSAyMCBieXRlIGhleCBzdHJpbmdcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5wYXJhbXMgJiYgcmVxdWVzdC5wYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBmcm9tOiByZXF1ZXN0LnBhcmFtc1swXSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBTaWduZXJFcnJvci5NaXNzaW5nRnJvbSgpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBPdGhlciB0cmFuc2FjdGlvbiB0eXBlcyBkbyBub3QgbmVlZCBjb250ZXh0XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGUgcGF5bG9hZCBmcm9tIGEgZ2l2ZW4gUlBDIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0gcmVxdWVzdCBKU09OLVJQQyByZXF1ZXN0IHRvIGV4dHJhY3QgcGFyYW1zIGZyb21cbiAgICAgKi9cbiAgICBjcmVhdGVQYXlsb2FkKHJlcXVlc3QpIHtcbiAgICAgICAgc3dpdGNoIChyZXF1ZXN0Lm1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSAnZXRoX3NlbmRUcmFuc2FjdGlvbic6XG4gICAgICAgICAgICBjYXNlICdldGhfc2lnblRyYW5zYWN0aW9uJzpcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5wYXJhbXMgJiYgcmVxdWVzdC5wYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdC5wYXJhbXNbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBTaWduZXJFcnJvci5NaXNzaW5nVHJhbnNhY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdldGhfc2lnbic6XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QucGFyYW1zICYmIHJlcXVlc3QucGFyYW1zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogcmVxdWVzdC5wYXJhbXNbMF0sIG1lc3NhZ2U6IHJlcXVlc3QucGFyYW1zWzFdIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBTaWduZXJFcnJvci5NaXNzaW5nTWVzc2FnZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3BlcnNvbmFsX3NpZ24nOlxuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnBhcmFtcyAmJiByZXF1ZXN0LnBhcmFtcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGZyb206IHJlcXVlc3QucGFyYW1zWzFdLCBtZXNzYWdlOiByZXF1ZXN0LnBhcmFtc1swXSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgU2lnbmVyRXJyb3IuTWlzc2luZ01lc3NhZ2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdldGhfc2lnblR5cGVkRGF0YSc6XG4gICAgICAgICAgICBjYXNlICdldGhfc2lnblR5cGVkRGF0YV92Myc6XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QucGFyYW1zICYmIHJlcXVlc3QucGFyYW1zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3QucGFyYW1zWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgU2lnbmVyRXJyb3IuTWlzc2luZ1R5cGVkRGF0YSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgU2lnbmVyRXJyb3IuVW5zdXBwb3J0ZWRNZXRob2QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGEgQml0c2tpVHJhbnNhY3Rpb24uS2luZCB2YWx1ZSBmcm9tIGEgZ2l2ZW4gUlBDIG1ldGhvZCBuYW1lXG4gICAgICogQHBhcmFtIG1ldGhvZCBUaGUgSlNPTi1SUEMgbWV0aG9kIGJlaW5nIHJlcXVlc3RlZFxuICAgICAqL1xuICAgIGtpbmRGb3JNZXRob2QobWV0aG9kKSB7XG4gICAgICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgICAgICBjYXNlICdldGhfc2VuZFRyYW5zYWN0aW9uJzpcbiAgICAgICAgICAgIGNhc2UgJ2V0aF9zaWduVHJhbnNhY3Rpb24nOlxuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgYm90aCAqc2lnbiogYW5kICpzZW5kKiBtZXRob2RzIGludG8gYSBzaWduIHRyYW5zYWN0aW9uLlxuICAgICAgICAgICAgICAgIC8vICh3ZSB3aWxsIGZvcndhcmQgdGhlIHRyYW5zYWN0aW9uIGxvY2FsbHkgaWYgbmVlZGVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBUcmFuc2FjdGlvbktpbmQuU2lnblRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgY2FzZSAnZXRoX3NpZ24nOlxuICAgICAgICAgICAgY2FzZSAncGVyc29uYWxfc2lnbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uS2luZC5TaWduO1xuICAgICAgICAgICAgY2FzZSAnZXRoX3NpZ25UeXBlZERhdGEnOlxuICAgICAgICAgICAgY2FzZSAnZXRoX3NpZ25UeXBlZERhdGFfdjMnOlxuICAgICAgICAgICAgICAgIHJldHVybiBUcmFuc2FjdGlvbktpbmQuU2lnblR5cGVkRGF0YTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgU2lnbmVyRXJyb3IuVW5zdXBwb3J0ZWRNZXRob2QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBXcmFwcyBlbWl0UGF5bG9hZCBpbiBhIHByb21pc2VcbiAgICBwZXJmb3JtUmVxdWVzdChwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoZnVsZmlsbCwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXRQYXlsb2FkKHBheWxvYWQsIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKHJlc3VsdC5yZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCIvKipcbiAqIEF1dG9tYXRpY2FsbHkgaGFuZGxlcyBmaW5hbGl6aW5nIHRoZSBvYXV0aCBzaWduIGluIHByb2Nlc3Mgd2l0aCB0aGUgQml0c2tpIFNES1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc0NhbGxiYWNrKCkge1xuICAgIGlmICh3aW5kb3cub3BlbmVyKSB7XG4gICAgICAgIG5vdGlmeU9wZW5lcih3aW5kb3cubG9jYXRpb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJlbnQgd2luZG93IGNvdWxkIG5vdCBiZSBmb3VuZCcpO1xuICAgIH1cbn1cbi8qKlxuICogTm90aWZpZXMgdGhlIG9wZW5lciB3aGVuIGluIGEgcG9wdXBcbiAqIEBwYXJhbSB1cmwgdGhlIHVybCB0aGF0IGNvbnRhaW5zIHRoZSBxdWVyeSBwYXJhbXNcbiAqL1xuZnVuY3Rpb24gbm90aWZ5T3BlbmVyKHVybCkge1xuICAgIGlmICh3aW5kb3cub3BlbmVyKSB7XG4gICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICAgIC8vIHBhcnNlIHVybCB0byBnZXQgc3RhdGVcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBwYXJzZVVybFBhcmFtcyh1cmwpO1xuICAgICAgICAgICAgaWYgKGRhdGEuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gYHBvcHVwQ2FsbGJhY2tfJHtkYXRhLnN0YXRlfWA7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB3aW5kb3cub3BlbmVyW25hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh1cmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjYWxsYmFjayBmb3VuZCBvbiBvcGVuZXInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHN0YXRlIGZvdW5kIGluIHJlc3BvbnNlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gd2luZG93Lm9wZW5lcicpO1xuICAgIH1cbn1cbi8qKlxuICogRXh0cmFjdHMgcXVlcnkgcGFyYW1zIGZyb20gdGhlIGhhc2ggb2YgdGhlIHVybFxuICogQHBhcmFtIHVybCB0aGUgdXJsIHRvIHBhcnNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVVybFBhcmFtcyh1cmwpIHtcbiAgICBsZXQgcGFyYW1zO1xuICAgIGlmICh1cmwuaHJlZi5pbmNsdWRlcygnIycpKSB7XG4gICAgICAgIHBhcmFtcyA9IGV4dHJhY3RRdWVyeSh1cmwuaGFzaCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHVybC5ocmVmLmluY2x1ZGVzKCc/JykpIHtcbiAgICAgICAgcGFyYW1zID0gdXJsLnNlYXJjaC5zcGxpdCgnPycpLnBvcCgpO1xuICAgIH1cbiAgICBpZiAoIXBhcmFtcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHBhcmFtcyBmb3VuZCBpbiByZXN1bHQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtcy5zcGxpdCgnJicpLnJlZHVjZSgocHJldiwgaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBpdGVtLnNwbGl0KCc9Jyk7XG4gICAgICAgIGlmIChrZXkgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIHByZXZbZGVjb2RlVVJJQ29tcG9uZW50KGtleSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJldjtcbiAgICB9LCB7fSk7XG59XG5mdW5jdGlvbiBleHRyYWN0UXVlcnkodXJsKSB7XG4gICAgaWYgKCF1cmwuaW5jbHVkZXMoJyMnKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHBhcmFtcyBmb3VuZCBpbiByZXN1bHQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHVybC5zcGxpdCgnIycpLnBvcCgpO1xufVxuIiwiLy8gRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBnZW5lcmljIHN0b3JlIGludGVyZmFjZS5cbi8vIFVzZXMgbG9jYWxTdG9yYWdlIG9yIHNlc3Npb25TdG9yYWdlIChwYXNzIHdoaWNoIG9uZSB5b3Ugd2FudCBpbiBjb25zdHJ1Y3RvcikuXG5leHBvcnQgY2xhc3MgTG9jYWxTdG9yYWdlU3RvcmUge1xuICAgIGNvbnN0cnVjdG9yKHN0b3JhZ2UgPSBsb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuc3RvcmFnZS5jbGVhcigpO1xuICAgIH1cbiAgICBnZXRJdGVtKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICB9XG4gICAgc2V0SXRlbShrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICBjbGVhckl0ZW0oa2V5KSB7XG4gICAgICAgIHRoaXMuc3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQmFzaWNRdWVyeVN0cmluZ1V0aWxzLCB9IGZyb20gJ0BvcGVuaWQvYXBwYXV0aCc7XG5leHBvcnQgY2xhc3MgTm9IYXNoUXVlcnlTdHJpbmdVdGlscyBleHRlbmRzIEJhc2ljUXVlcnlTdHJpbmdVdGlscyB7XG4gICAgcGFyc2UoaW5wdXQsIHVzZUhhc2gpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnBhcnNlKGlucHV0LCBmYWxzZSAvKiBuZXZlciB1c2UgaGFzaCAqLyk7XG4gICAgfVxufVxuIiwiLyoqXG4gKiBBIHNpbXBsZSB1dGlsaXR5IGNsYXNzIHRoYXQgd2lsbCBjaGVjayB0byBzZWUgaWYgYSBwb3B1cCBpcyBibG9ja2VkLlxuICogRGVyaXZlZCBmcm9tIGluZm8gYW5kIGV4YW1wbGVzIG9uIHRoaXMgcGFnZTpcbiAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI5MTQvaG93LWNhbi1pLWRldGVjdC1pZi1hLWJyb3dzZXItaXMtYmxvY2tpbmctYS1wb3B1cFxuICovXG5leHBvcnQgY2xhc3MgUG9wdXBWYWxpZGF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGVycm9ySGFuZGxlcikge1xuICAgICAgICB0aGlzLmVycm9ySGFuZGxlciA9IGVycm9ySGFuZGxlcjtcbiAgICB9XG4gICAgLy8gQ2hlY2sgYSBwb3B1cCB3aW5kb3cgdG8gc2VlIGlmIGl0IGhhcyBiZWVuIGJsb2NrZWQuXG4gICAgLy8gVGhlIGVycm9yIGhhbmRsZXIgd2lsbCBiZSBjYWxsZWQgYXN5bmNocm9ub3VzbHkgaWZcbiAgICAvLyB0aGUgd2luZG93IGhhcyBiZWVuIGRldGVjdGVkIHRvIGhhdmUgYmVlbiBibG9ja2VkLlxuICAgIGNoZWNrKHBvcHVwKSB7XG4gICAgICAgIGlmIChwb3B1cCkge1xuICAgICAgICAgICAgaWYgKC9jaHJvbWUvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzUG9wdXBCbG9ja2VkKHBvcHVwKTtcbiAgICAgICAgICAgICAgICB9LCAyMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9wdXAub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzUG9wdXBCbG9ja2VkKHBvcHVwKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVCbG9ja2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNQb3B1cEJsb2NrZWQocG9wdXApIHtcbiAgICAgICAgaWYgKChwb3B1cC5pbm5lckhlaWdodCA+IDApID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVCbG9ja2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlQmxvY2tlZCgpIHtcbiAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIoKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBTZXJ2ZXJFcnJvciB9IGZyb20gJ2JpdHNraS1wcm92aWRlcic7XG5pbXBvcnQgeyBQYXJzZUVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL3BhcnNlLWVycm9yJztcbi8qKlxuICogUGFyc2VzIGEgRmV0Y2ggUmVzcG9uc2UgdG8gZXh0cmFjdCBlaXRoZXIgdGhlIHJlc3VsdCBvciB0aGUgZXJyb3JcbiAqIEBwYXJhbSByZXNwb25zZSB0aGUgZmV0Y2ggcmVzcG9uc2UgdG8gcGFyc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+IHtcbiAgICAgICAgdGhyb3cgUGFyc2VFcnJvci5JbnZhbGlkSlNPTigpO1xuICAgIH0pLnRoZW4oKGpzb24pID0+IHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA+PSAyMDAgJiYgcmVzcG9uc2Uuc3RhdHVzIDwgMzAwKSB7XG4gICAgICAgICAgICByZXR1cm4ganNvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChqc29uICYmIGpzb24uZXJyb3IgJiYganNvbi5lcnJvci5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNlcnZlckVycm9yKGpzb24uZXJyb3IubWVzc2FnZSwgcmVzcG9uc2Uuc3RhdHVzLCByZXNwb25zZS51cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoanNvbiAmJiBqc29uLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNlcnZlckVycm9yKGpzb24uZXJyb3IsIHJlc3BvbnNlLnN0YXR1cywgcmVzcG9uc2UudXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IFBhcnNlRXJyb3IuVW5rbm93bkVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbiIsImZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgXCJkZWZhdWx0XCI6IG9ialxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG52YXIgcHJvdmlkZXJfZW5naW5lX2Vycm9yXzEgPSByZXF1aXJlKFwiLi9lcnJvcnMvcHJvdmlkZXItZW5naW5lLWVycm9yXCIpO1xudmFyIGNyZWF0ZV9wYXlsb2FkXzEgPSByZXF1aXJlKFwiLi91dGlsL2NyZWF0ZS1wYXlsb2FkXCIpO1xuLy8gVGhlIGJhc2UgY2xhc3Mgd2hpY2ggUHJvdmlkZXJFbmdpbmUgd2lsbCBleHRlbmQgZnJvbSB0aGF0IHByb3ZpZGVzIHRoZSBiYXNpYyBXZWIzIFByb3ZpZGVyIGludGVyZmFjZVxudmFyIEJhc2VQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmFzZVByb3ZpZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJhc2VQcm92aWRlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvLyBNb2Rlcm4gc2VuZCBtZXRob2RcbiAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgdmFyIHBheWxvYWQgPSBjcmVhdGVfcGF5bG9hZF8xLmNyZWF0ZVBheWxvYWQoeyBtZXRob2Q6IG1ldGhvZCwgcGFyYW1zOiBwYXJhbXMgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmRQYXlsb2FkKHBheWxvYWQpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UucmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIExlZ2FjeSBzZW5kQXN5bmMgbWV0aG9kXG4gICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5zZW5kQXN5bmMgPSBmdW5jdGlvbiAocGF5bG9hZCwgY2IpIHtcbiAgICAgICAgdGhpcy5zZW5kUGF5bG9hZChwYXlsb2FkKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgY2IobnVsbCwgcmVzcG9uc2UpO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNiKGVycm9yLCBudWxsKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBXaGV0aGVyIG9yIG5vdCB0aGlzIHByb3ZpZGVyIHN1cHBvcnRzIHN1YnNjcmlwdGlvbnNcbiAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLnN1cHBvcnRzU3Vic2NyaXB0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gT3ZlcnJpZGUgdGhpcyBpbiB5b3VyIHN1YmNsYXNzIGlmIHlvdSBzdXBwb3J0IHN1YnNjcmlwdGlvbnNcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLy8gTWV0aG9kIHRvIHN1YnNjcmliZSB0byBhIGdpdmVuIHN1YnNjcmlwdGlvbiB0eXBlXG4gICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlTWV0aG9kLCBzdWJzY3JpcHRpb25NZXRob2QsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgLy8gT3ZlcnJpZGUgdGhpcyB3aXRoIHN1YnNjcmlwdGlvbiBpbXBsZW1lbnRhdGlvblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IHByb3ZpZGVyX2VuZ2luZV9lcnJvcl8xLlByb3ZpZGVyRW5naW5lRXJyb3IoJ1N1YnNjcmlwdGlvbnMgYXJlIG5vdCBzdXBwb3J0ZWQnLCBwcm92aWRlcl9lbmdpbmVfZXJyb3JfMS5Qcm92aWRlckVuZ2luZUVycm9yQ29kZS5VbnN1cHBvcnRlZEZlYXR1cmUpKTtcbiAgICB9O1xuICAgIC8vIE1ldGhvZCB0byB1bnN1YnNjcmliZVxuICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uSWQsIHVuc3Vic2NyaWJlTWV0aG9kKSB7XG4gICAgICAgIC8vIE92ZXJyaWRlIHRoaXMgd2l0aCB1bnN1YnNjcmliZSBpbXBsZW1lbnRhdGlvblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IHByb3ZpZGVyX2VuZ2luZV9lcnJvcl8xLlByb3ZpZGVyRW5naW5lRXJyb3IoJ1N1YnNjcmlwdGlvbnMgYXJlIG5vdCBzdXBwb3J0ZWQnLCBwcm92aWRlcl9lbmdpbmVfZXJyb3JfMS5Qcm92aWRlckVuZ2luZUVycm9yQ29kZS5VbnN1cHBvcnRlZEZlYXR1cmUpKTtcbiAgICB9O1xuICAgIHJldHVybiBCYXNlUHJvdmlkZXI7XG59KGV2ZW50c18xLkV2ZW50RW1pdHRlcikpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQmFzZVByb3ZpZGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBCbG9ja1RyYWNrZXJFcnJvckNvZGU7XG4oZnVuY3Rpb24gKEJsb2NrVHJhY2tlckVycm9yQ29kZSkge1xuICAgIC8vIEJsb2NrIGRhdGEgd2FzIG5vdCBmb3VuZCBhZnRlciByZXRyaWVzXG4gICAgQmxvY2tUcmFja2VyRXJyb3JDb2RlW0Jsb2NrVHJhY2tlckVycm9yQ29kZVtcIkJsb2NrTm90Rm91bmRcIl0gPSAzMDAwXSA9IFwiQmxvY2tOb3RGb3VuZFwiO1xufSkoQmxvY2tUcmFja2VyRXJyb3JDb2RlID0gZXhwb3J0cy5CbG9ja1RyYWNrZXJFcnJvckNvZGUgfHwgKGV4cG9ydHMuQmxvY2tUcmFja2VyRXJyb3JDb2RlID0ge30pKTtcbi8qKlxuICogUmVwcmVzZW50cyBlcnJvcnMgdGhhdCBvY2N1ciBpbiB0aGUgYmxvY2sgdHJhY2tlclxuICovXG52YXIgQmxvY2tUcmFja2VyRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJsb2NrVHJhY2tlckVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJsb2NrVHJhY2tlckVycm9yKG1lc3NhZ2UsIGNvZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgLy8gTWFpbnRhaW5zIHByb3BlciBzdGFjayB0cmFjZSBmb3Igd2hlcmUgb3VyIGVycm9yIHdhcyB0aHJvd24gKG9ubHkgYXZhaWxhYmxlIG9uIFY4KVxuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKF90aGlzLCBCbG9ja1RyYWNrZXJFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQmxvY2tUcmFja2VyRXJyb3IuQmxvY2tOb3RGb3VuZCA9IGZ1bmN0aW9uIChibG9ja051bWJlcikge1xuICAgICAgICByZXR1cm4gbmV3IEJsb2NrVHJhY2tlckVycm9yKFwiQ291bGQgbm90IGxvYWQgYmxvY2sgXCIgKyBibG9ja051bWJlciwgQmxvY2tUcmFja2VyRXJyb3JDb2RlLkJsb2NrTm90Rm91bmQpO1xuICAgIH07XG4gICAgcmV0dXJuIEJsb2NrVHJhY2tlckVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5CbG9ja1RyYWNrZXJFcnJvciA9IEJsb2NrVHJhY2tlckVycm9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBHYXNQcmljZUVycm9yQ29kZTtcbihmdW5jdGlvbiAoR2FzUHJpY2VFcnJvckNvZGUpIHtcbiAgICBHYXNQcmljZUVycm9yQ29kZVtHYXNQcmljZUVycm9yQ29kZVtcIkJsb2NrTm90Rm91bmRcIl0gPSA0MDAwXSA9IFwiQmxvY2tOb3RGb3VuZFwiO1xufSkoR2FzUHJpY2VFcnJvckNvZGUgPSBleHBvcnRzLkdhc1ByaWNlRXJyb3JDb2RlIHx8IChleHBvcnRzLkdhc1ByaWNlRXJyb3JDb2RlID0ge30pKTtcbi8qKlxuICogUmVwcmVzZW50cyBlcnJvcnMgdGhhdCBvY2N1ciBpbiB0aGUgZ2FzIHByaWNlIHN1YnByb3ZpZGVyXG4gKi9cbnZhciBHYXNQcmljZUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhHYXNQcmljZUVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdhc1ByaWNlRXJyb3IobWVzc2FnZSwgY29kZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICAvLyBNYWludGFpbnMgcHJvcGVyIHN0YWNrIHRyYWNlIGZvciB3aGVyZSBvdXIgZXJyb3Igd2FzIHRocm93biAob25seSBhdmFpbGFibGUgb24gVjgpXG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoX3RoaXMsIEdhc1ByaWNlRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEdhc1ByaWNlRXJyb3IuQmxvY2tOb3RGb3VuZCA9IGZ1bmN0aW9uIChibG9ja051bWJlcikge1xuICAgICAgICB2YXIgbXNnID0gXCJDb3VsZCBub3QgY2FsY3VsYXRlIGdhcy4gQmxvY2sgXCIgKyBibG9ja051bWJlciArIFwiIHdhcyBub3QgZm91bmRcIjtcbiAgICAgICAgcmV0dXJuIG5ldyBHYXNQcmljZUVycm9yKG1zZywgR2FzUHJpY2VFcnJvckNvZGUuQmxvY2tOb3RGb3VuZCk7XG4gICAgfTtcbiAgICByZXR1cm4gR2FzUHJpY2VFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuR2FzUHJpY2VFcnJvciA9IEdhc1ByaWNlRXJyb3I7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFByb3ZpZGVyRW5naW5lRXJyb3JDb2RlO1xuKGZ1bmN0aW9uIChQcm92aWRlckVuZ2luZUVycm9yQ29kZSkge1xuICAgIFByb3ZpZGVyRW5naW5lRXJyb3JDb2RlW1Byb3ZpZGVyRW5naW5lRXJyb3JDb2RlW1wiVW5oYW5kbGVkUmVxdWVzdFwiXSA9IDEwMDBdID0gXCJVbmhhbmRsZWRSZXF1ZXN0XCI7XG4gICAgUHJvdmlkZXJFbmdpbmVFcnJvckNvZGVbUHJvdmlkZXJFbmdpbmVFcnJvckNvZGVbXCJNaXNzaW5nSW1wbGVtZW50YXRpb25cIl0gPSAxMDAxXSA9IFwiTWlzc2luZ0ltcGxlbWVudGF0aW9uXCI7XG4gICAgUHJvdmlkZXJFbmdpbmVFcnJvckNvZGVbUHJvdmlkZXJFbmdpbmVFcnJvckNvZGVbXCJVbnN1cHBvcnRlZEZlYXR1cmVcIl0gPSAxMDAyXSA9IFwiVW5zdXBwb3J0ZWRGZWF0dXJlXCI7XG59KShQcm92aWRlckVuZ2luZUVycm9yQ29kZSA9IGV4cG9ydHMuUHJvdmlkZXJFbmdpbmVFcnJvckNvZGUgfHwgKGV4cG9ydHMuUHJvdmlkZXJFbmdpbmVFcnJvckNvZGUgPSB7fSkpO1xuLyoqXG4gKiBSZXByZXNlbnRzIGVycm9ycyBzcGVjaWZpYyB0byBQcm92aWRlckVuZ2luZVxuICovXG52YXIgUHJvdmlkZXJFbmdpbmVFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUHJvdmlkZXJFbmdpbmVFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQcm92aWRlckVuZ2luZUVycm9yKG1lc3NhZ2UsIGNvZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgLy8gTWFpbnRhaW5zIHByb3BlciBzdGFjayB0cmFjZSBmb3Igd2hlcmUgb3VyIGVycm9yIHdhcyB0aHJvd24gKG9ubHkgYXZhaWxhYmxlIG9uIFY4KVxuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKF90aGlzLCBQcm92aWRlckVuZ2luZUVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUHJvdmlkZXJFbmdpbmVFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuUHJvdmlkZXJFbmdpbmVFcnJvciA9IFByb3ZpZGVyRW5naW5lRXJyb3I7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFN1YnNjcmlwdGlvbkVycm9yQ29kZTtcbihmdW5jdGlvbiAoU3Vic2NyaXB0aW9uRXJyb3JDb2RlKSB7XG4gICAgU3Vic2NyaXB0aW9uRXJyb3JDb2RlW1N1YnNjcmlwdGlvbkVycm9yQ29kZVtcIlVuc3VwcG9ydGVkVHlwZVwiXSA9IDIwMDBdID0gXCJVbnN1cHBvcnRlZFR5cGVcIjtcbiAgICBTdWJzY3JpcHRpb25FcnJvckNvZGVbU3Vic2NyaXB0aW9uRXJyb3JDb2RlW1wiTm90Rm91bmRcIl0gPSAyMDAxXSA9IFwiTm90Rm91bmRcIjtcbn0pKFN1YnNjcmlwdGlvbkVycm9yQ29kZSA9IGV4cG9ydHMuU3Vic2NyaXB0aW9uRXJyb3JDb2RlIHx8IChleHBvcnRzLlN1YnNjcmlwdGlvbkVycm9yQ29kZSA9IHt9KSk7XG4vKipcbiAqIFJlcHJlc2VudHMgYW4gZXJyb3IgdGhhdCBvY2N1cnMgaW4gdGhlIHN1YnNjcmlwdGlvbnMgc3VicHJvdmlkZXJcbiAqL1xudmFyIFN1YnNjcmlwdGlvbkVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWJzY3JpcHRpb25FcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdWJzY3JpcHRpb25FcnJvcihtZXNzYWdlLCBjb2RlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgICAgIC8vIE1haW50YWlucyBwcm9wZXIgc3RhY2sgdHJhY2UgZm9yIHdoZXJlIG91ciBlcnJvciB3YXMgdGhyb3duIChvbmx5IGF2YWlsYWJsZSBvbiBWOClcbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShfdGhpcywgU3Vic2NyaXB0aW9uRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFN1YnNjcmlwdGlvbkVycm9yLlVuc3VwcG9ydGVkVHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uRXJyb3IoXCJVbnN1cHBvcnRlZCBzdWJzY3JpcHRpb24gdHlwZTogXCIgKyB0eXBlLCBTdWJzY3JpcHRpb25FcnJvckNvZGUuVW5zdXBwb3J0ZWRUeXBlKTtcbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbkVycm9yLk5vdEZvdW5kID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbklkKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uRXJyb3IoXCJTdWJzY3JpcHRpb24gd2l0aCBpZCBcIiArIHN1YnNjcmlwdGlvbklkICsgXCIgbm90IGZvdW5kXCIsIFN1YnNjcmlwdGlvbkVycm9yQ29kZS5Ob3RGb3VuZCk7XG4gICAgfTtcbiAgICByZXR1cm4gU3Vic2NyaXB0aW9uRXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLlN1YnNjcmlwdGlvbkVycm9yID0gU3Vic2NyaXB0aW9uRXJyb3I7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcHJvdmlkZXJfZW5naW5lXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcHJvdmlkZXItZW5naW5lXCIpKTtcbnZhciBzdWJwcm92aWRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3N1YnByb3ZpZGVyXCIpKTtcbmV4cG9ydHMuU3VicHJvdmlkZXIgPSBzdWJwcm92aWRlcl8xLmRlZmF1bHQ7XG5leHBvcnRzLmRlZmF1bHQgPSBwcm92aWRlcl9lbmdpbmVfMS5kZWZhdWx0O1xuLy8gRXJyb3JzXG52YXIgYmxvY2tfdHJhY2tlcl9lcnJvcl8xID0gcmVxdWlyZShcIi4vZXJyb3JzL2Jsb2NrLXRyYWNrZXItZXJyb3JcIik7XG5leHBvcnRzLkJsb2NrVHJhY2tlckVycm9yID0gYmxvY2tfdHJhY2tlcl9lcnJvcl8xLkJsb2NrVHJhY2tlckVycm9yO1xuZXhwb3J0cy5CbG9ja1RyYWNrZXJFcnJvckNvZGUgPSBibG9ja190cmFja2VyX2Vycm9yXzEuQmxvY2tUcmFja2VyRXJyb3JDb2RlO1xudmFyIGdhc19wcmljZV9lcnJvcl8xID0gcmVxdWlyZShcIi4vZXJyb3JzL2dhcy1wcmljZS1lcnJvclwiKTtcbmV4cG9ydHMuR2FzUHJpY2VFcnJvciA9IGdhc19wcmljZV9lcnJvcl8xLkdhc1ByaWNlRXJyb3I7XG5leHBvcnRzLkdhc1ByaWNlRXJyb3JDb2RlID0gZ2FzX3ByaWNlX2Vycm9yXzEuR2FzUHJpY2VFcnJvckNvZGU7XG52YXIgcHJvdmlkZXJfZW5naW5lX2Vycm9yXzEgPSByZXF1aXJlKFwiLi9lcnJvcnMvcHJvdmlkZXItZW5naW5lLWVycm9yXCIpO1xuZXhwb3J0cy5Qcm92aWRlckVuZ2luZUVycm9yID0gcHJvdmlkZXJfZW5naW5lX2Vycm9yXzEuUHJvdmlkZXJFbmdpbmVFcnJvcjtcbmV4cG9ydHMuUHJvdmlkZXJFbmdpbmVFcnJvckNvZGUgPSBwcm92aWRlcl9lbmdpbmVfZXJyb3JfMS5Qcm92aWRlckVuZ2luZUVycm9yQ29kZTtcbnZhciBzdWJzY3JpcHRpb25fZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2Vycm9ycy9zdWJzY3JpcHRpb24tZXJyb3JcIik7XG5leHBvcnRzLlN1YnNjcmlwdGlvbkVycm9yID0gc3Vic2NyaXB0aW9uX2Vycm9yXzEuU3Vic2NyaXB0aW9uRXJyb3I7XG5leHBvcnRzLlN1YnNjcmlwdGlvbkVycm9yQ29kZSA9IHN1YnNjcmlwdGlvbl9lcnJvcl8xLlN1YnNjcmlwdGlvbkVycm9yQ29kZTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3N1YnByb3ZpZGVycy9pbmRleFwiKSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVhY2hTZXJpZXNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYXN5bmMvZWFjaFNlcmllc1wiKSk7XG52YXIgYmFzZV9wcm92aWRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2Jhc2UtcHJvdmlkZXJcIikpO1xudmFyIHByb3ZpZGVyX2VuZ2luZV9lcnJvcl8xID0gcmVxdWlyZShcIi4vZXJyb3JzL3Byb3ZpZGVyLWVuZ2luZS1lcnJvclwiKTtcbnZhciBibG9ja190cmFja2VyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9ibG9jay10cmFja2VyXCIpKTtcbnZhciBzdG9wbGlnaHRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL3N0b3BsaWdodFwiKSk7XG52YXIgV2ViM1Byb3ZpZGVyRW5naW5lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhXZWIzUHJvdmlkZXJFbmdpbmUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gV2ViM1Byb3ZpZGVyRW5naW5lKG9wdHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3BvbGxGb3JCbG9ja3MgPSB0cnVlO1xuICAgICAgICBfdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5zZXRNYXhMaXN0ZW5lcnMoMzApO1xuICAgICAgICAvLyBwYXJzZSBvcHRpb25zXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICAvLyBibG9jayBwb2xsaW5nXG4gICAgICAgIHZhciBkaXJlY3RQcm92aWRlciA9IHtcbiAgICAgICAgICAgIHNlbmRBc3luYzogZnVuY3Rpb24gKHJlcSwgY2IpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZW5kUGF5bG9hZChyZXEpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgICAgICBjYihudWxsLCByZXMpO1xuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRzLmRpc2FibGVCbG9ja1RyYWNraW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgICBfdGhpcy5fcG9sbEZvckJsb2NrcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBibG9ja1RyYWNrZXJQcm92aWRlciA9IG9wdHMuYmxvY2tUcmFja2VyUHJvdmlkZXIgfHwgZGlyZWN0UHJvdmlkZXI7XG4gICAgICAgIF90aGlzLl9ibG9ja1RyYWNrZXIgPSBuZXcgYmxvY2tfdHJhY2tlcl8xLmRlZmF1bHQoe1xuICAgICAgICAgICAgcHJvdmlkZXI6IGJsb2NrVHJhY2tlclByb3ZpZGVyLFxuICAgICAgICAgICAgYmxvY2tUcmFja2VyOiBvcHRzLmJsb2NrVHJhY2tlcixcbiAgICAgICAgICAgIHBvbGxpbmdJbnRlcnZhbDogb3B0cy5wb2xsaW5nSW50ZXJ2YWwgfHwgNDAwMCxcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLl9ibG9ja1RyYWNrZXIub24oJ2Jsb2NrJywgX3RoaXMuX3NldEN1cnJlbnRCbG9jay5iaW5kKF90aGlzKSk7XG4gICAgICAgIF90aGlzLl9ibG9ja1RyYWNrZXIub24oJ3N5bmMnLCBfdGhpcy5lbWl0LmJpbmQoX3RoaXMsICdzeW5jJykpO1xuICAgICAgICBfdGhpcy5fYmxvY2tUcmFja2VyLm9uKCdyYXdCbG9jaycsIF90aGlzLmVtaXQuYmluZChfdGhpcywgJ3Jhd0Jsb2NrJykpO1xuICAgICAgICBfdGhpcy5fYmxvY2tUcmFja2VyLm9uKCdsYXRlc3QnLCBfdGhpcy5lbWl0LmJpbmQoX3RoaXMsICdsYXRlc3QnKSk7XG4gICAgICAgIC8vIEhhbmRsZSBlcnJvcnMgaW5zdGVhZCBvZiByZS1lbWl0dGluZywgc2luY2UgdGhleSB3aWxsIHRocm93IG90aGVyd2lzZVxuICAgICAgICBfdGhpcy5fYmxvY2tUcmFja2VyLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgLy8gSWdub3JlIGVycm9ycyBmcm9tIHRoZSBibG9jayB0cmFja2VyIHVubGVzcyBkZWJ1ZyBpcyBlbmFibGVkXG4gICAgICAgICAgICBpZiAob3B0cy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdERUJVRzogJyArIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gc2V0IGluaXRpYWxpemF0aW9uIGJsb2NrZXJcbiAgICAgICAgX3RoaXMuX3JlYWR5ID0gbmV3IHN0b3BsaWdodF8xLmRlZmF1bHQoKTtcbiAgICAgICAgX3RoaXMuX3Byb3ZpZGVycyA9IFtdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFdlYjNQcm92aWRlckVuZ2luZS5wcm90b3R5cGUuaXNSdW5uaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcnVubmluZztcbiAgICB9O1xuICAgIFdlYjNQcm92aWRlckVuZ2luZS5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHRyaWdnZXIgc3RhcnRcbiAgICAgICAgdGhpcy5fcmVhZHkuZ28oKTtcbiAgICAgICAgaWYgKHRoaXMuX3BvbGxGb3JCbG9ja3MpIHtcbiAgICAgICAgICAgIC8vIHN0YXJ0IHRyYWNraW5nIGJsb2Nrc1xuICAgICAgICAgICAgdGhpcy5fYmxvY2tUcmFja2VyLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXBkYXRlIHN0YXRlXG4gICAgICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuICAgICAgICAvLyBzaWduYWwgdGhhdCB3ZSBzdGFydGVkXG4gICAgICAgIHRoaXMuZW1pdCgnc3RhcnQnKTtcbiAgICB9O1xuICAgIFdlYjNQcm92aWRlckVuZ2luZS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gc3RvcCBibG9jayB0cmFja2luZ1xuICAgICAgICB0aGlzLl9ibG9ja1RyYWNrZXIuc3RvcCgpO1xuICAgICAgICAvLyB1cGRhdGUgc3RhdGVcbiAgICAgICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgICAgICAvLyBzaWduYWwgdGhhdCB3ZSBzdG9wcGVkXG4gICAgICAgIHRoaXMuZW1pdCgnc3RvcCcpO1xuICAgIH07XG4gICAgV2ViM1Byb3ZpZGVyRW5naW5lLnByb3RvdHlwZS5hZGRQcm92aWRlciA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgdGhpcy5fcHJvdmlkZXJzLnB1c2goc291cmNlKTtcbiAgICAgICAgc291cmNlLnNldEVuZ2luZSh0aGlzKTtcbiAgICB9O1xuICAgIFdlYjNQcm92aWRlckVuZ2luZS5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBXcmFwIGJhc2UgY2xhc3Mgd2l0aCBTdG9wbGlnaHRcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcbiAgICAgICAgICAgIF90aGlzLl9yZWFkeS5hd2FpdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5zZW5kLmNhbGwoX3RoaXMsIG1ldGhvZCwgcGFyYW1zKS50aGVuKGZ1bGZpbGwsIHJlamVjdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBXZWIzUHJvdmlkZXJFbmdpbmUucHJvdG90eXBlLnNlbmRBc3luYyA9IGZ1bmN0aW9uIChwYXlsb2FkLCBjYikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBXcmFwIGJhc2UgY2xhc3Mgd2l0aCBTdG9wbGlnaHRcbiAgICAgICAgdGhpcy5fcmVhZHkuYXdhaXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5zZW5kQXN5bmMuY2FsbChfdGhpcywgcGF5bG9hZCwgY2IpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIEFjdHVhbGx5IHBlcmZvcm0gdGhlIHJlcXVlc3RcbiAgICBXZWIzUHJvdmlkZXJFbmdpbmUucHJvdG90eXBlLnNlbmRQYXlsb2FkID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50UHJvdmlkZXIgPSAtMTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIC8vIFN0YWNrIG9mIHN1YnByb3ZpZGVyIG5leHQgY2FsbGJhY2tzXG4gICAgICAgICAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFByb3ZpZGVyICs9IDE7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluc2VydCBpbiBmcm9udCBzaW5jZSBlYWNoU2VyaWVzIHRyYXZlcnNlcyBmcm9tIGZyb250XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnVuc2hpZnQoY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBCdWJibGVkIGRvd24gYXMgZmFyIGFzIHdlIGNvdWxkIGdvLCBhbmQgdGhlIHJlcXVlc3Qgd2Fzbid0XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlZC4gUmV0dXJuIGFuIGVycm9yLlxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UHJvdmlkZXIgPj0gX3RoaXMuX3Byb3ZpZGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBtYXgtbGluZS1sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9IFwiUmVxdWVzdCBmb3IgbWV0aG9kIFxcXCJcIiArIHBheWxvYWQubWV0aG9kICsgXCJcXFwiIG5vdCBoYW5kbGVkIGJ5IGFueSBzdWJwcm92aWRlci5cIjtcbiAgICAgICAgICAgICAgICAgICAgZW5kKG5ldyBwcm92aWRlcl9lbmdpbmVfZXJyb3JfMS5Qcm92aWRlckVuZ2luZUVycm9yKG1zZywgcHJvdmlkZXJfZW5naW5lX2Vycm9yXzEuUHJvdmlkZXJFbmdpbmVFcnJvckNvZGUuVW5oYW5kbGVkUmVxdWVzdCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSByZXF1ZXN0IGluIG5leHQgc3VicHJvdmlkZXJcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvdmlkZXIgPSBfdGhpcy5fcHJvdmlkZXJzW2N1cnJlbnRQcm92aWRlcl07XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyLmhhbmRsZVJlcXVlc3QocGF5bG9hZCwgbmV4dCwgZW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgbm90aWZ5U3VicHJvdmlkZXIgPSBmdW5jdGlvbiAoZm4sIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIGZuKGVycm9yLCByZXN1bHQsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBmdW5jdGlvbiAoZSwgcikge1xuICAgICAgICAgICAgICAgIGVycm9yID0gZTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByO1xuICAgICAgICAgICAgICAgIC8vIENhbGwgYW55IGNhbGxiYWNrcyBmcm9tIHN1YnByb3ZpZGVyc1xuICAgICAgICAgICAgICAgIGVhY2hTZXJpZXNfMS5kZWZhdWx0KHN0YWNrLCBub3RpZnlTdWJwcm92aWRlcikudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlY29uc3RydWN0IEpTT05SUENSZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0T2JqID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHBheWxvYWQuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBqc29ucnBjOiBwYXlsb2FkLmpzb25ycGMsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tcGxldGUgcHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKHJlc3VsdE9iaik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBDYWxsIG5leHQoKSB0byBraWNrIHRoaW5ncyBvZmZcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBXZWIzUHJvdmlkZXJFbmdpbmUucHJvdG90eXBlLl9zZXRDdXJyZW50QmxvY2sgPSBmdW5jdGlvbiAoYnVmZmVyQmxvY2spIHtcbiAgICAgICAgdGhpcy5jdXJyZW50QmxvY2sgPSBidWZmZXJCbG9jaztcbiAgICAgICAgdGhpcy5lbWl0KCdibG9jaycsIGJ1ZmZlckJsb2NrKTtcbiAgICB9O1xuICAgIHJldHVybiBXZWIzUHJvdmlkZXJFbmdpbmU7XG59KGJhc2VfcHJvdmlkZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBXZWIzUHJvdmlkZXJFbmdpbmU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbnZhciBjcmVhdGVfcGF5bG9hZF8xID0gcmVxdWlyZShcIi4vdXRpbC9jcmVhdGUtcGF5bG9hZFwiKTtcbi8vIHRoaXMgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGEgc3VicHJvdmlkZXIgLS0gbW9zdGx5IGhlbHBlcnNcbnZhciBTdWJwcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3VicHJvdmlkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3VicHJvdmlkZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgU3VicHJvdmlkZXIucHJvdG90eXBlLnNldEVuZ2luZSA9IGZ1bmN0aW9uIChlbmdpbmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5lbmdpbmUgPSBlbmdpbmU7XG4gICAgICAgIGVuZ2luZS5vbignYmxvY2snLCBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgICAgIF90aGlzLmN1cnJlbnRCbG9jayA9IGJsb2NrO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFN1YnByb3ZpZGVyLnByb3RvdHlwZS5lbWl0UGF5bG9hZCA9IGZ1bmN0aW9uIChwYXlsb2FkLCBjYikge1xuICAgICAgICB0aGlzLmVuZ2luZS5zZW5kQXN5bmMoY3JlYXRlX3BheWxvYWRfMS5jcmVhdGVQYXlsb2FkKHBheWxvYWQpLCBjYik7XG4gICAgfTtcbiAgICByZXR1cm4gU3VicHJvdmlkZXI7XG59KGV2ZW50c18xLkV2ZW50RW1pdHRlcikpO1xuZXhwb3J0cy5kZWZhdWx0ID0gU3VicHJvdmlkZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNsb25lXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImNsb25lXCIpKTtcbnZhciBldGhfdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvZXRoLXV0aWxcIik7XG52YXIgcnBjX2NhY2hlX3V0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9ycGMtY2FjaGUtdXRpbHNcIik7XG52YXIgY2FjaGVfc3RyYXRlZ3lfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jYWNoZS1zdHJhdGVneVwiKSk7XG4vL1xuLy8gQmxvY2tDYWNoZVN0cmF0ZWd5XG4vL1xudmFyIEJsb2NrQ2FjaGVTdHJhdGVneSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmxvY2tDYWNoZVN0cmF0ZWd5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJsb2NrQ2FjaGVTdHJhdGVneSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY2FjaGUgPSB7fTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBCbG9ja0NhY2hlU3RyYXRlZ3kucHJvdG90eXBlLmdldEJsb2NrQ2FjaGVGb3JQYXlsb2FkID0gZnVuY3Rpb24gKHBheWxvYWQsIGJsb2NrTnVtYmVySGV4KSB7XG4gICAgICAgIHZhciBibG9ja051bWJlciA9IHBhcnNlSW50KGJsb2NrTnVtYmVySGV4LCAxNik7XG4gICAgICAgIHZhciBibG9ja0NhY2hlID0gdGhpcy5jYWNoZVtibG9ja051bWJlcl07XG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgY2FjaGUgaWYgbmVjZXNhcnlcbiAgICAgICAgaWYgKCFibG9ja0NhY2hlKSB7XG4gICAgICAgICAgICB2YXIgbmV3Q2FjaGUgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVbYmxvY2tOdW1iZXJdID0gbmV3Q2FjaGU7XG4gICAgICAgICAgICBibG9ja0NhY2hlID0gbmV3Q2FjaGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJsb2NrQ2FjaGU7XG4gICAgfTtcbiAgICBCbG9ja0NhY2hlU3RyYXRlZ3kucHJvdG90eXBlLmhpdENoZWNrID0gZnVuY3Rpb24gKHBheWxvYWQsIHJlcXVlc3RlZEJsb2NrTnVtYmVyLCBoaXQsIG1pc3MpIHtcbiAgICAgICAgdmFyIGJsb2NrQ2FjaGUgPSB0aGlzLmdldEJsb2NrQ2FjaGVGb3JQYXlsb2FkKHBheWxvYWQsIHJlcXVlc3RlZEJsb2NrTnVtYmVyKTtcbiAgICAgICAgaWYgKCFibG9ja0NhY2hlKSB7XG4gICAgICAgICAgICByZXR1cm4gbWlzcygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpZGVudGlmaWVyID0gcnBjX2NhY2hlX3V0aWxzXzEuY2FjaGVJZGVudGlmaWVyRm9yUGF5bG9hZChwYXlsb2FkKTtcbiAgICAgICAgdmFyIGNhY2hlZCA9IGJsb2NrQ2FjaGVbaWRlbnRpZmllcl07XG4gICAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgICAgIHZhciBjbG9uZWRWYWx1ZSA9IGNsb25lXzEuZGVmYXVsdChjYWNoZWQpO1xuICAgICAgICAgICAgcmV0dXJuIGhpdChudWxsLCBjbG9uZWRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbWlzcygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCbG9ja0NhY2hlU3RyYXRlZ3kucHJvdG90eXBlLmNhY2hlUmVzdWx0ID0gZnVuY3Rpb24gKHBheWxvYWQsIHJlc3VsdCwgcmVxdWVzdGVkQmxvY2tOdW1iZXIsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHZhciBibG9ja0NhY2hlID0gdGhpcy5nZXRCbG9ja0NhY2hlRm9yUGF5bG9hZChwYXlsb2FkLCByZXF1ZXN0ZWRCbG9ja051bWJlcik7XG4gICAgICAgICAgICB2YXIgaWRlbnRpZmllciA9IHJwY19jYWNoZV91dGlsc18xLmNhY2hlSWRlbnRpZmllckZvclBheWxvYWQocGF5bG9hZCk7XG4gICAgICAgICAgICB2YXIgY2xvbmVkVmFsdWUgPSBjbG9uZV8xLmRlZmF1bHQocmVzdWx0KTtcbiAgICAgICAgICAgIGJsb2NrQ2FjaGVbaWRlbnRpZmllcl0gPSBjbG9uZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH07XG4gICAgQmxvY2tDYWNoZVN0cmF0ZWd5LnByb3RvdHlwZS5jYW5DYWNoZSA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgIGlmICghcnBjX2NhY2hlX3V0aWxzXzEuY2FuQ2FjaGUocGF5bG9hZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmxvY2tUYWcgPSBycGNfY2FjaGVfdXRpbHNfMS5ibG9ja1RhZ0ZvclBheWxvYWQocGF5bG9hZCk7XG4gICAgICAgIHJldHVybiAoYmxvY2tUYWcgIT09ICdwZW5kaW5nJyk7XG4gICAgfTtcbiAgICAvLyBuYWl2ZWx5IHJlbW92ZXMgb2xkZXIgYmxvY2sgY2FjaGVzXG4gICAgQmxvY2tDYWNoZVN0cmF0ZWd5LnByb3RvdHlwZS5jYWNoZVJvbGxPZmYgPSBmdW5jdGlvbiAocHJldmlvdXNCbG9jaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcHJldmlvdXNIZXggPSBldGhfdXRpbF8xLmJ1ZmZlclRvSGV4KHByZXZpb3VzQmxvY2subnVtYmVyKTtcbiAgICAgICAgdmFyIG9sZEJsb2NrTnVtYmVyID0gcGFyc2VJbnQocHJldmlvdXNIZXgsIDE2KTtcbiAgICAgICAgLy8gY2xlYXIgb2xkIGNhY2hlc1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmNhY2hlKVxuICAgICAgICAgICAgLm1hcChOdW1iZXIpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChudW0pIHsgcmV0dXJuIG51bSA8PSBvbGRCbG9ja051bWJlcjsgfSlcbiAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChudW0pIHsgcmV0dXJuIGRlbGV0ZSBfdGhpcy5jYWNoZVtudW1dOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBCbG9ja0NhY2hlU3RyYXRlZ3k7XG59KGNhY2hlX3N0cmF0ZWd5XzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQmxvY2tDYWNoZVN0cmF0ZWd5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQ2FjaGVTdHJhdGVneSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYWNoZVN0cmF0ZWd5KCkge1xuICAgIH1cbiAgICByZXR1cm4gQ2FjaGVTdHJhdGVneTtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDYWNoZVN0cmF0ZWd5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjYWNoZV9zdHJhdGVneV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NhY2hlLXN0cmF0ZWd5XCIpKTtcbnZhciBwZXJtYV9jYWNoZV9zdHJhdGVneV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3Blcm1hLWNhY2hlLXN0cmF0ZWd5XCIpKTtcbi8vXG4vLyBDb25kaXRpb25hbFBlcm1hQ2FjaGVTdHJhdGVneVxuLy9cbnZhciBDb25kaXRpb25hbFBlcm1hQ2FjaGVTdHJhdGVneSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29uZGl0aW9uYWxQZXJtYUNhY2hlU3RyYXRlZ3ksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29uZGl0aW9uYWxQZXJtYUNhY2hlU3RyYXRlZ3koY29uZGl0aW9uYWxzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0cmF0ZWd5ID0gbmV3IHBlcm1hX2NhY2hlX3N0cmF0ZWd5XzEuZGVmYXVsdCgpO1xuICAgICAgICBfdGhpcy5jb25kaXRpb25hbHMgPSBjb25kaXRpb25hbHM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ29uZGl0aW9uYWxQZXJtYUNhY2hlU3RyYXRlZ3kucHJvdG90eXBlLmhpdENoZWNrID0gZnVuY3Rpb24gKHBheWxvYWQsIHJlcXVlc3RlZEJsb2NrTnVtYmVyLCBoaXQsIG1pc3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyYXRlZ3kuaGl0Q2hlY2socGF5bG9hZCwgcmVxdWVzdGVkQmxvY2tOdW1iZXIsIGhpdCwgbWlzcyk7XG4gICAgfTtcbiAgICBDb25kaXRpb25hbFBlcm1hQ2FjaGVTdHJhdGVneS5wcm90b3R5cGUuY2FjaGVSZXN1bHQgPSBmdW5jdGlvbiAocGF5bG9hZCwgcmVzdWx0LCByZXF1ZXN0ZWRCbG9ja051bWJlciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGNvbmRpdGlvbmFsID0gdGhpcy5jb25kaXRpb25hbHNbcGF5bG9hZC5tZXRob2RdO1xuICAgICAgICBpZiAoY29uZGl0aW9uYWwpIHtcbiAgICAgICAgICAgIGlmIChjb25kaXRpb25hbChyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJhdGVneS5jYWNoZVJlc3VsdChwYXlsb2FkLCByZXN1bHQsIHJlcXVlc3RlZEJsb2NrTnVtYmVyLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2FjaGUgYWxsIHJlcXVlc3RzIHRoYXQgZG9uJ3QgaGF2ZSBhIGNvbmRpdGlvbmFsXG4gICAgICAgICAgICB0aGlzLnN0cmF0ZWd5LmNhY2hlUmVzdWx0KHBheWxvYWQsIHJlc3VsdCwgcmVxdWVzdGVkQmxvY2tOdW1iZXIsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29uZGl0aW9uYWxQZXJtYUNhY2hlU3RyYXRlZ3kucHJvdG90eXBlLmNhbkNhY2hlID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyYXRlZ3kuY2FuQ2FjaGUocGF5bG9hZCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29uZGl0aW9uYWxQZXJtYUNhY2hlU3RyYXRlZ3k7XG59KGNhY2hlX3N0cmF0ZWd5XzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ29uZGl0aW9uYWxQZXJtYUNhY2hlU3RyYXRlZ3k7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNsb25lXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImNsb25lXCIpKTtcbnZhciBycGNfY2FjaGVfdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL3JwYy1jYWNoZS11dGlsc1wiKTtcbnZhciBjYWNoZV9zdHJhdGVneV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NhY2hlLXN0cmF0ZWd5XCIpKTtcbnZhciBQZXJtYUNhY2hlU3RyYXRlZ3kgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBlcm1hQ2FjaGVTdHJhdGVneSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQZXJtYUNhY2hlU3RyYXRlZ3koKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmNhY2hlID0ge307XG4gICAgICAgIC8vIGNsZWFyIGNhY2hlIGV2ZXJ5IHRlbiBtaW51dGVzXG4gICAgICAgIHZhciB0aW1lb3V0ID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuY2FjaGUgPSB7fTtcbiAgICAgICAgfSwgMTAgKiA2MCAqIDFlMyk7XG4gICAgICAgIC8vIGRvIG5vdCByZXF1aXJlIHRoZSBOb2RlLmpzIGV2ZW50IGxvb3AgdG8gcmVtYWluIGFjdGl2ZVxuICAgICAgICBpZiAodGltZW91dC51bnJlZikge1xuICAgICAgICAgICAgdGltZW91dC51bnJlZigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUGVybWFDYWNoZVN0cmF0ZWd5LnByb3RvdHlwZS5oaXRDaGVjayA9IGZ1bmN0aW9uIChwYXlsb2FkLCByZXF1ZXN0ZWRCbG9ja051bWJlciwgaGl0LCBtaXNzKSB7XG4gICAgICAgIHZhciBpZGVudGlmaWVyID0gcnBjX2NhY2hlX3V0aWxzXzEuY2FjaGVJZGVudGlmaWVyRm9yUGF5bG9hZChwYXlsb2FkKTtcbiAgICAgICAgdmFyIGNhY2hlZCA9IHRoaXMuY2FjaGVbaWRlbnRpZmllcl07XG4gICAgICAgIGlmICghY2FjaGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbWlzcygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBibG9jayBudW1iZXIgd2UncmUgcmVxdWVzdGluZyBhdCBpcyBncmVhdGVyIHRoYW4gb3JcbiAgICAgICAgLy8gZXF1YWwgdG8gdGhlIGJsb2NrIHdoZXJlIHdlIGNhY2hlZCBhIHByZXZpb3VzIHJlc3BvbnNlLFxuICAgICAgICAvLyB0aGUgY2FjaGUgaXMgdmFsaWQuIElmIGl0J3MgZnJvbSBlYXJsaWVyIHRoYW4gdGhlIGNhY2hlLFxuICAgICAgICAvLyBzZW5kIGl0IGJhY2sgZG93biB0byB0aGUgY2xpZW50ICh3aGVyZSBpdCB3aWxsIGJlIHJlY2FjaGVkLilcbiAgICAgICAgdmFyIGNhY2hlSXNFYXJseUVub3VnaCA9IGNvbXBhcmVIZXgocmVxdWVzdGVkQmxvY2tOdW1iZXIsIGNhY2hlZC5ibG9ja051bWJlcikgPj0gMDtcbiAgICAgICAgaWYgKGNhY2hlSXNFYXJseUVub3VnaCkge1xuICAgICAgICAgICAgdmFyIGNsb25lZFZhbHVlID0gY2xvbmVfMS5kZWZhdWx0KGNhY2hlZC5yZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuIGhpdChudWxsLCBjbG9uZWRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbWlzcygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQZXJtYUNhY2hlU3RyYXRlZ3kucHJvdG90eXBlLmNhY2hlUmVzdWx0ID0gZnVuY3Rpb24gKHBheWxvYWQsIHJlc3VsdCwgcmVxdWVzdGVkQmxvY2tOdW1iZXIsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBpZGVudGlmaWVyID0gcnBjX2NhY2hlX3V0aWxzXzEuY2FjaGVJZGVudGlmaWVyRm9yUGF5bG9hZChwYXlsb2FkKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgdmFyIGNsb25lZFZhbHVlID0gY2xvbmVfMS5kZWZhdWx0KHJlc3VsdCk7XG4gICAgICAgICAgICB0aGlzLmNhY2hlW2lkZW50aWZpZXJdID0ge1xuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiByZXF1ZXN0ZWRCbG9ja051bWJlcixcbiAgICAgICAgICAgICAgICByZXN1bHQ6IGNsb25lZFZhbHVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH07XG4gICAgUGVybWFDYWNoZVN0cmF0ZWd5LnByb3RvdHlwZS5jYW5DYWNoZSA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiBycGNfY2FjaGVfdXRpbHNfMS5jYW5DYWNoZShwYXlsb2FkKTtcbiAgICB9O1xuICAgIHJldHVybiBQZXJtYUNhY2hlU3RyYXRlZ3k7XG59KGNhY2hlX3N0cmF0ZWd5XzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUGVybWFDYWNoZVN0cmF0ZWd5O1xuZnVuY3Rpb24gY29tcGFyZUhleChoZXhBLCBoZXhCKSB7XG4gICAgdmFyIG51bUEgPSBwYXJzZUludChoZXhBLCAxNik7XG4gICAgdmFyIG51bUIgPSBwYXJzZUludChoZXhCLCAxNik7XG4gICAgcmV0dXJuIG51bUEgPT09IG51bUIgPyAwIDogKG51bUEgPiBudW1CID8gMSA6IC0xKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYm5fanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYm4uanNcIikpO1xudmFyIHN1YnByb3ZpZGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3N1YnByb3ZpZGVyXCIpKTtcbnZhciBldGhfdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWwvZXRoLXV0aWxcIik7XG52YXIgcnBjX2NhY2hlX3V0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9ycGMtY2FjaGUtdXRpbHNcIik7XG52YXIgYmxvY2tfc3RyYXRlZ3lfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jYWNoZS1zdHJhdGVnaWVzL2Jsb2NrLXN0cmF0ZWd5XCIpKTtcbnZhciBjb25kaXRpb25hbF9wZXJtYV9zdHJhdGVneV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NhY2hlLXN0cmF0ZWdpZXMvY29uZGl0aW9uYWwtcGVybWEtc3RyYXRlZ3lcIikpO1xudmFyIEJsb2NrQ2FjaGVQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmxvY2tDYWNoZVByb3ZpZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJsb2NrQ2FjaGVQcm92aWRlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaXNFbmFibGVkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnN0cmF0ZWdpZXMgPSB7XG4gICAgICAgICAgICBwZXJtYTogbmV3IGNvbmRpdGlvbmFsX3Blcm1hX3N0cmF0ZWd5XzEuZGVmYXVsdCh7XG4gICAgICAgICAgICAgICAgZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoOiBjb250YWluc0Jsb2NraGFzaCxcbiAgICAgICAgICAgICAgICBldGhfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0OiBjb250YWluc0Jsb2NraGFzaCxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgYmxvY2s6IG5ldyBibG9ja19zdHJhdGVneV8xLmRlZmF1bHQoKSxcbiAgICAgICAgICAgIGZvcms6IG5ldyBibG9ja19zdHJhdGVneV8xLmRlZmF1bHQoKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvLyBzZXR1cCBhIGJsb2NrIGxpc3RlbmVyIG9uICdzZXRFbmdpbmUnXG4gICAgQmxvY2tDYWNoZVByb3ZpZGVyLnByb3RvdHlwZS5zZXRFbmdpbmUgPSBmdW5jdGlvbiAoZW5naW5lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuc2V0RW5naW5lLmNhbGwodGhpcywgZW5naW5lKTtcbiAgICAgICAgLy8gdW5ibG9jayBpbml0aWFsaXphdGlvbiBhZnRlciBmaXJzdCBibG9ja1xuICAgICAgICBlbmdpbmUub25jZSgnYmxvY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5pc0VuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgLy8gZnJvbSBub3cgb24sIGVtcHR5IG9sZCBjYWNoZSBldmVyeSBibG9ja1xuICAgICAgICAgICAgZW5naW5lLm9uKCdibG9jaycsIF90aGlzLmNsZWFyT2xkQ2FjaGUuYmluZChfdGhpcykpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJsb2NrQ2FjaGVQcm92aWRlci5wcm90b3R5cGUuaGFuZGxlUmVxdWVzdCA9IGZ1bmN0aW9uIChwYXlsb2FkLCBuZXh0LCBlbmQpIHtcbiAgICAgICAgLy8gc2tpcCBjYWNoZSBpZiB0b2xkIHRvIGRvIHNvXG4gICAgICAgIGlmIChwYXlsb2FkLnNraXBDYWNoZSkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0NBQ0hFIFNLSVAgLSBza2lwIGNhY2hlIGlmIHRvbGQgdG8gZG8gc28nKVxuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZ25vcmUgcmVxdWVzdHMgZm9yIHRoZSBsYXRlc3QgYmxvY2tcbiAgICAgICAgaWYgKHBheWxvYWQubWV0aG9kID09PSAnZXRoX2dldEJsb2NrQnlOdW1iZXInICYmIHBheWxvYWQucGFyYW1zWzBdID09PSAnbGF0ZXN0Jykge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0NBQ0hFIFNLSVAgLSBJZ25vcmUgYmxvY2sgcG9sbGluZyByZXF1ZXN0cy4nKVxuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCbG9jayBjYWNoZSBzaG91bGQgbm90IHN0YXJ0IGhhbmRsaW5nIHJlcXVlc3RzIHVudGlsIGJsb2NrcyBoYXZlIGJlZW4gcmVjZWl2ZWQuXG4gICAgICAgIGlmICghdGhpcy5pc0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWN0dWFsbHkgaGFuZGxlIHRoZSByZXF1ZXN0XG4gICAgICAgIHRoaXMuX2hhbmRsZVJlcXVlc3QocGF5bG9hZCwgbmV4dCwgZW5kKTtcbiAgICB9O1xuICAgIEJsb2NrQ2FjaGVQcm92aWRlci5wcm90b3R5cGUuX2hhbmRsZVJlcXVlc3QgPSBmdW5jdGlvbiAocGF5bG9hZCwgbmV4dCwgZW5kKSB7XG4gICAgICAgIHZhciB0eXBlID0gcnBjX2NhY2hlX3V0aWxzXzEuY2FjaGVUeXBlRm9yUGF5bG9hZChwYXlsb2FkKTtcbiAgICAgICAgdmFyIHN0cmF0ZWd5ID0gdGhpcy5zdHJhdGVnaWVzW3R5cGVdO1xuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIHN0cmF0ZWd5IGluIHBsYWNlLCBwYXNzIGl0IGRvd24gdGhlIGNoYWluLlxuICAgICAgICBpZiAoIXN0cmF0ZWd5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBzdHJhdGVneSBjYW4ndCBjYWNoZSB0aGlzIHJlcXVlc3QsIGlnbm9yZSBpdC5cbiAgICAgICAgaWYgKCFzdHJhdGVneS5jYW5DYWNoZShwYXlsb2FkKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmxvY2tUYWcgPSBycGNfY2FjaGVfdXRpbHNfMS5ibG9ja1RhZ0ZvclBheWxvYWQocGF5bG9hZCk7XG4gICAgICAgIGlmICghYmxvY2tUYWcpIHtcbiAgICAgICAgICAgIGJsb2NrVGFnID0gJ2xhdGVzdCc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcXVlc3RlZEJsb2NrTnVtYmVyO1xuICAgICAgICBpZiAoYmxvY2tUYWcgPT09ICdlYXJsaWVzdCcpIHtcbiAgICAgICAgICAgIHJlcXVlc3RlZEJsb2NrTnVtYmVyID0gJzB4MDAnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJsb2NrVGFnID09PSAnbGF0ZXN0Jykge1xuICAgICAgICAgICAgcmVxdWVzdGVkQmxvY2tOdW1iZXIgPSBldGhfdXRpbF8xLmJ1ZmZlclRvSGV4KHRoaXMuY3VycmVudEJsb2NrLm51bWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIGEgaGV4IG51bWJlclxuICAgICAgICAgICAgcmVxdWVzdGVkQmxvY2tOdW1iZXIgPSBibG9ja1RhZztcbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLmxvZygnUkVRVUVTVCBhdCBibG9jayAweCcgKyByZXF1ZXN0ZWRCbG9ja051bWJlci50b1N0cmluZygnaGV4JykpXG4gICAgICAgIC8vIGVuZCBvbiBhIGhpdCwgY29udGludWUgb24gYSBtaXNzXG4gICAgICAgIHN0cmF0ZWd5LmhpdENoZWNrKHBheWxvYWQsIHJlcXVlc3RlZEJsb2NrTnVtYmVyLCBlbmQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIG1pc3MgZmFsbHRocm91Z2ggdG8gcHJvdmlkZXIgY2hhaW4sIGNhY2hpbmcgdGhlIHJlc3VsdCBvbiB0aGUgd2F5IGJhY2sgdXAuXG4gICAgICAgICAgICBuZXh0KGZ1bmN0aW9uIChlcnIsIHJlc3VsdCwgY2IpIHtcbiAgICAgICAgICAgICAgICAvLyBlcnIgaXMgYWxyZWFkeSBoYW5kbGVkIGJ5IGVuZ2luZVxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0cmF0ZWd5LmNhY2hlUmVzdWx0KHBheWxvYWQsIHJlc3VsdCwgcmVxdWVzdGVkQmxvY2tOdW1iZXIsIGNiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJsb2NrQ2FjaGVQcm92aWRlci5wcm90b3R5cGUuY2xlYXJPbGRDYWNoZSA9IGZ1bmN0aW9uIChuZXdCbG9jaykge1xuICAgICAgICB2YXIgcHJldmlvdXNCbG9jayA9IHRoaXMuY3VycmVudEJsb2NrO1xuICAgICAgICB0aGlzLmN1cnJlbnRCbG9jayA9IG5ld0Jsb2NrO1xuICAgICAgICBpZiAoIXByZXZpb3VzQmxvY2spIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0cmF0ZWdpZXMuYmxvY2suY2FjaGVSb2xsT2ZmKHByZXZpb3VzQmxvY2spO1xuICAgICAgICB0aGlzLnN0cmF0ZWdpZXMuZm9yay5jYWNoZVJvbGxPZmYocHJldmlvdXNCbG9jayk7XG4gICAgfTtcbiAgICByZXR1cm4gQmxvY2tDYWNoZVByb3ZpZGVyO1xufShzdWJwcm92aWRlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEJsb2NrQ2FjaGVQcm92aWRlcjtcbmZ1bmN0aW9uIGhleFRvQk4oaGV4KSB7XG4gICAgcmV0dXJuIG5ldyBibl9qc18xLmRlZmF1bHQoZXRoX3V0aWxfMS50b0J1ZmZlcihoZXgpKTtcbn1cbmZ1bmN0aW9uIGNvbnRhaW5zQmxvY2toYXNoKHJlc3VsdCkge1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFyZXN1bHQuYmxvY2tIYXNoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGhhc05vblplcm9IYXNoID0gaGV4VG9CTihyZXN1bHQuYmxvY2tIYXNoKS5ndChuZXcgYm5fanNfMS5kZWZhdWx0KDApKTtcbiAgICByZXR1cm4gaGFzTm9uWmVyb0hhc2g7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHh0ZW5kXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInh0ZW5kXCIpKTtcbnZhciBmaXh0dXJlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vZml4dHVyZVwiKSk7XG52YXIgRGVmYXVsdEZpeHR1cmVzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEZWZhdWx0Rml4dHVyZXMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGVmYXVsdEZpeHR1cmVzKG9wdHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIHZhciByZXNwb25zZXMgPSB4dGVuZF8xLmRlZmF1bHQoe1xuICAgICAgICAgICAgd2ViM19jbGllbnRWZXJzaW9uOiAnUHJvdmlkZXJFbmdpbmUnICsgJy9qYXZhc2NyaXB0JyxcbiAgICAgICAgICAgIG5ldF9saXN0ZW5pbmc6IHRydWUsXG4gICAgICAgICAgICBldGhfaGFzaHJhdGU6ICcweDAwJyxcbiAgICAgICAgICAgIGV0aF9taW5pbmc6IGZhbHNlLFxuICAgICAgICB9LCBvcHRzKTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCByZXNwb25zZXMpIHx8IHRoaXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIERlZmF1bHRGaXh0dXJlcztcbn0oZml4dHVyZV8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IERlZmF1bHRGaXh0dXJlcztcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYXN5bmNpZnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYXN5bmMvYXN5bmNpZnlcIikpO1xudmFyIHJldHJ5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImFzeW5jL3JldHJ5XCIpKTtcbnZhciB3YXRlcmZhbGxfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYXN5bmMvd2F0ZXJmYWxsXCIpKTtcbnZhciBjcm9zc19mZXRjaF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjcm9zcy1mZXRjaFwiKSk7XG52YXIganNvbl9ycGNfZXJyb3JfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwianNvbi1ycGMtZXJyb3JcIikpO1xudmFyIHByb21pc2VfdG9fY2FsbGJhY2tfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicHJvbWlzZS10by1jYWxsYmFja1wiKSk7XG52YXIgc3VicHJvdmlkZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vc3VicHJvdmlkZXJcIikpO1xudmFyIGNyZWF0ZV9wYXlsb2FkXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9jcmVhdGUtcGF5bG9hZFwiKTtcbnZhciBSRVRSSUFCTEVfRVJST1JTID0gW1xuICAgIC8vIGlnbm9yZSBzZXJ2ZXIgb3ZlcmxvYWQgZXJyb3JzXG4gICAgJ0dhdGV3YXkgdGltZW91dCcsXG4gICAgJ0VUSU1FRE9VVCcsXG4gICAgLy8gaWdub3JlIHNlcnZlciBzZW50IGh0bWwgZXJyb3IgcGFnZXNcbiAgICAvLyBvciB0cnVuY2F0ZWQganNvbiByZXNwb25zZXNcbiAgICAnU3ludGF4RXJyb3InLFxuXTtcbnZhciBGZXRjaFN1YnByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGZXRjaFN1YnByb3ZpZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZldGNoU3VicHJvdmlkZXIob3B0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5ycGNVcmwgPSBvcHRzLnJwY1VybDtcbiAgICAgICAgX3RoaXMub3JpZ2luSHR0cEhlYWRlcktleSA9IG9wdHMub3JpZ2luSHR0cEhlYWRlcktleTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBGZXRjaFN1YnByb3ZpZGVyLnByb3RvdHlwZS5oYW5kbGVSZXF1ZXN0ID0gZnVuY3Rpb24gKHBheWxvYWQsIG5leHQsIGVuZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgb3JpZ2luRG9tYWluID0gcGF5bG9hZC5vcmlnaW47XG4gICAgICAgIC8vIG92ZXJ3cml0ZSBpZCB0byBub3QgY29uZmxpY3Qgd2l0aCBvdGhlciBjb25jdXJyZW50IHVzZXJzXG4gICAgICAgIHZhciBuZXdQYXlsb2FkID0gdGhpcy5jcmVhdGVQYXlsb2FkKHBheWxvYWQpO1xuICAgICAgICAvLyByZW1vdmUgZXh0cmEgcGFyYW1ldGVyIGZyb20gcmVxdWVzdFxuICAgICAgICBkZWxldGUgbmV3UGF5bG9hZC5vcmlnaW47XG4gICAgICAgIHZhciByZXFQYXJhbXMgPSB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkobmV3UGF5bG9hZCksXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLm9yaWdpbkh0dHBIZWFkZXJLZXkgJiYgb3JpZ2luRG9tYWluKSB7XG4gICAgICAgICAgICByZXFQYXJhbXMuaGVhZGVyc1t0aGlzLm9yaWdpbkh0dHBIZWFkZXJLZXldID0gb3JpZ2luRG9tYWluO1xuICAgICAgICB9XG4gICAgICAgIHJldHJ5XzEuZGVmYXVsdCh7XG4gICAgICAgICAgICB0aW1lczogNSxcbiAgICAgICAgICAgIGludGVydmFsOiAxMDAwLFxuICAgICAgICAgICAgZXJyb3JGaWx0ZXI6IGlzRXJyb3JSZXRyaWFibGUsXG4gICAgICAgIH0sIGZ1bmN0aW9uIChjYikgeyByZXR1cm4gX3RoaXMuX3N1Ym1pdFJlcXVlc3QocmVxUGFyYW1zLCBjYik7IH0sIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuICAgICAgICAgICAgLy8gZW5kcyBvbiByZXRyaWFibGUgZXJyb3JcbiAgICAgICAgICAgIGlmIChlcnIgJiYgaXNFcnJvclJldHJpYWJsZShlcnIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVyck1zZyA9IFwiRmV0Y2hTdWJwcm92aWRlciAtIGNhbm5vdCBjb21wbGV0ZSByZXF1ZXN0LiBBbGwgcmV0cmllcyBleGhhdXN0ZWQuXFxuT3JpZ2luYWwgRXJyb3I6XFxuXCIgKyBlcnIudG9TdHJpbmcoKSArIFwiXFxuXFxuXCI7XG4gICAgICAgICAgICAgICAgdmFyIHJldHJpZXNFeGhhdXN0ZWRFcnIgPSBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kKHJldHJpZXNFeGhhdXN0ZWRFcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGNvbnRpbnVlIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gZW5kKGVyciwgcmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBGZXRjaFN1YnByb3ZpZGVyLnByb3RvdHlwZS5jcmVhdGVQYXlsb2FkID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZV9wYXlsb2FkXzEuY3JlYXRlUGF5bG9hZChwYXlsb2FkKTtcbiAgICB9O1xuICAgIEZldGNoU3VicHJvdmlkZXIucHJvdG90eXBlLl9zdWJtaXRSZXF1ZXN0ID0gZnVuY3Rpb24gKHJlcVBhcmFtcywgZG9uZSkge1xuICAgICAgICB2YXIgdGFyZ2V0VXJsID0gdGhpcy5ycGNVcmw7XG4gICAgICAgIHByb21pc2VfdG9fY2FsbGJhY2tfMS5kZWZhdWx0KGNyb3NzX2ZldGNoXzEuZGVmYXVsdCh0YXJnZXRVcmwsIHJlcVBhcmFtcykpKGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBkb25lKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb250aW51ZSBwYXJzaW5nIHJlc3VsdFxuICAgICAgICAgICAgd2F0ZXJmYWxsXzEuZGVmYXVsdChbXG4gICAgICAgICAgICAgICAgY2hlY2tGb3JIdHRwRXJyb3JzLFxuICAgICAgICAgICAgICAgIC8vIGJ1ZmZlciBib2R5XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGNiKSB7IHJldHVybiBwcm9taXNlX3RvX2NhbGxiYWNrXzEuZGVmYXVsdChyZXMudGV4dCgpKShjYik7IH0sXG4gICAgICAgICAgICAgICAgLy8gcGFyc2UgYm9keVxuICAgICAgICAgICAgICAgIGFzeW5jaWZ5XzEuZGVmYXVsdChmdW5jdGlvbiAocmF3Qm9keSkgeyByZXR1cm4gSlNPTi5wYXJzZShyYXdCb2R5KTsgfSksXG4gICAgICAgICAgICAgICAgcGFyc2VSZXNwb25zZSxcbiAgICAgICAgICAgIF0sIGRvbmUpO1xuICAgICAgICAgICAgZnVuY3Rpb24gY2hlY2tGb3JIdHRwRXJyb3JzKGNiKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGVycm9yc1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocmVzLnN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQwNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYihuZXcganNvbl9ycGNfZXJyb3JfMS5kZWZhdWx0Lk1ldGhvZE5vdEZvdW5kKCkpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQxODpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYihjcmVhdGVSYXRlbGltaXRFcnJvcigpKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1MDM6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKGNyZWF0ZVRpbWVvdXRFcnJvcigpKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlUmVzcG9uc2UoYm9keSwgY2IpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgZXJyb3IgY29kZVxuICAgICAgICAgICAgICAgIGlmIChyZXMuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKG5ldyBqc29uX3JwY19lcnJvcl8xLmRlZmF1bHQuSW50ZXJuYWxFcnJvcihib2R5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBycGMgZXJyb3JcbiAgICAgICAgICAgICAgICBpZiAoYm9keS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IobmV3IGpzb25fcnBjX2Vycm9yXzEuZGVmYXVsdC5JbnRlcm5hbEVycm9yKGJvZHkuZXJyb3IpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHN1Y2Nlc3NmdWwgcmVzdWx0XG4gICAgICAgICAgICAgICAgY2IobnVsbCwgYm9keS5yZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBGZXRjaFN1YnByb3ZpZGVyO1xufShzdWJwcm92aWRlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEZldGNoU3VicHJvdmlkZXI7XG5mdW5jdGlvbiBpc0Vycm9yUmV0cmlhYmxlKGVycikge1xuICAgIHZhciBlcnJNc2cgPSBlcnIudG9TdHJpbmcoKTtcbiAgICByZXR1cm4gUkVUUklBQkxFX0VSUk9SUy5zb21lKGZ1bmN0aW9uIChwaHJhc2UpIHsgcmV0dXJuIGVyck1zZy5pbmNsdWRlcyhwaHJhc2UpOyB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJhdGVsaW1pdEVycm9yKCkge1xuICAgIHZhciBtc2cgPSBcIlJlcXVlc3QgaXMgYmVpbmcgcmF0ZSBsaW1pdGVkLlwiO1xuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IobXNnKTtcbiAgICByZXR1cm4gbmV3IGpzb25fcnBjX2Vycm9yXzEuZGVmYXVsdC5JbnRlcm5hbEVycm9yKGVycik7XG59XG5mdW5jdGlvbiBjcmVhdGVUaW1lb3V0RXJyb3IoKSB7XG4gICAgdmFyIG1zZyA9IFwiR2F0ZXdheSB0aW1lb3V0LiBUaGUgcmVxdWVzdCB0b29rIHRvbyBsb25nIHRvIHByb2Nlc3MuIFwiO1xuICAgIG1zZyArPSBcIlRoaXMgY2FuIGhhcHBlbiB3aGVuIHF1ZXJ5aW5nIGxvZ3Mgb3ZlciB0b28gd2lkZSBhIGJsb2NrIHJhbmdlLlwiO1xuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IobXNnKTtcbiAgICByZXR1cm4gbmV3IGpzb25fcnBjX2Vycm9yXzEuZGVmYXVsdC5JbnRlcm5hbEVycm9yKGVycik7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHBhcmFsbGVsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImFzeW5jL3BhcmFsbGVsXCIpKTtcbnZhciBzdWJwcm92aWRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9zdWJwcm92aWRlclwiKSk7XG52YXIgZXRoX3V0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsL2V0aC11dGlsXCIpO1xudmFyIHN0b3BsaWdodF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi91dGlsL3N0b3BsaWdodFwiKSk7XG52YXIgYmxvY2tfZmlsdGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vZmlsdGVycy9ibG9jay1maWx0ZXJcIikpO1xudmFyIGxvZ19maWx0ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9maWx0ZXJzL2xvZy1maWx0ZXJcIikpO1xudmFyIHBlbmRpbmdfdHhfZmlsdGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vZmlsdGVycy9wZW5kaW5nLXR4LWZpbHRlclwiKSk7XG52YXIgRmlsdGVyU3VicHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZpbHRlclN1YnByb3ZpZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZpbHRlclN1YnByb3ZpZGVyKG9wdHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIF90aGlzLmZpbHRlckluZGV4ID0gMDtcbiAgICAgICAgX3RoaXMuZmlsdGVycyA9IHt9O1xuICAgICAgICBfdGhpcy5maWx0ZXJEZXN0cm95SGFuZGxlcnMgPSB7fTtcbiAgICAgICAgX3RoaXMuYXN5bmNCbG9ja0hhbmRsZXJzID0ge307XG4gICAgICAgIF90aGlzLmFzeW5jUGVuZGluZ0Jsb2NrSGFuZGxlcnMgPSB7fTtcbiAgICAgICAgX3RoaXMuX3JlYWR5ID0gbmV3IHN0b3BsaWdodF8xLmRlZmF1bHQoKTtcbiAgICAgICAgX3RoaXMuX3JlYWR5LnNldE1heExpc3RlbmVycyhvcHRzLm1heEZpbHRlcnMgfHwgMjUpO1xuICAgICAgICBfdGhpcy5fcmVhZHkuZ28oKTtcbiAgICAgICAgX3RoaXMucGVuZGluZ0Jsb2NrVGltZW91dCA9IG9wdHMucGVuZGluZ0Jsb2NrVGltZW91dCB8fCA0MDAwO1xuICAgICAgICBfdGhpcy5jaGVja0ZvclBlbmRpbmdCbG9ja3NBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgLy8gVE9ETzogQWN0dWFsbHkgbG9hZCB0aGUgYmxvY2tzXG4gICAgICAgIC8vIHdlIGRvbnQgaGF2ZSBlbmdpbmUgaW1tZWRpdGF0ZWx5XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gYXN5bmNCbG9ja0hhbmRsZXJzIHJlcXVpcmUgbG9ja2luZyBwcm92aWRlciB1bnRpbCB1cGRhdGVzIGFyZSBjb21wbGV0ZWRcbiAgICAgICAgICAgIF90aGlzLmVuZ2luZS5vbignYmxvY2snLCBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgICAgICAgICAvLyBwYXVzZSBwcm9jZXNzaW5nXG4gICAgICAgICAgICAgICAgX3RoaXMuX3JlYWR5LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgZmlsdGVyc1xuICAgICAgICAgICAgICAgIHZhciB1cGRhdGVycyA9IHZhbHVlc0ZvcihfdGhpcy5hc3luY0Jsb2NrSGFuZGxlcnMpLm1hcChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuLmJpbmQobnVsbCwgYmxvY2spOyB9KTtcbiAgICAgICAgICAgICAgICBwYXJhbGxlbF8xLmRlZmF1bHQodXBkYXRlcnMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyB1bnBhdXNlIHByb2Nlc3NpbmdcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlYWR5LmdvKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRmlsdGVyU3VicHJvdmlkZXIucHJvdG90eXBlLmhhbmRsZVJlcXVlc3QgPSBmdW5jdGlvbiAocGF5bG9hZCwgbmV4dCwgZW5kKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHN3aXRjaCAocGF5bG9hZC5tZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgJ2V0aF9uZXdCbG9ja0ZpbHRlcic6XG4gICAgICAgICAgICAgICAgdGhpcy5uZXdCbG9ja0ZpbHRlcihlbmQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ2V0aF9uZXdQZW5kaW5nVHJhbnNhY3Rpb25GaWx0ZXInOlxuICAgICAgICAgICAgICAgIHRoaXMubmV3UGVuZGluZ1RyYW5zYWN0aW9uRmlsdGVyKGVuZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja0ZvclBlbmRpbmdCbG9ja3MoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdldGhfbmV3RmlsdGVyJzpcbiAgICAgICAgICAgICAgICB0aGlzLm5ld0xvZ0ZpbHRlcihwYXlsb2FkLnBhcmFtc1swXSwgZW5kKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdldGhfZ2V0RmlsdGVyQ2hhbmdlcyc6XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZHkuYXdhaXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5nZXRGaWx0ZXJDaGFuZ2VzKHBheWxvYWQucGFyYW1zWzBdLCBlbmQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ2V0aF9nZXRGaWx0ZXJMb2dzJzpcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkeS5hd2FpdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmdldEZpbHRlckxvZ3MocGF5bG9hZC5wYXJhbXNbMF0sIGVuZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAnZXRoX3VuaW5zdGFsbEZpbHRlcic6XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZHkuYXdhaXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy51bmluc3RhbGxGaWx0ZXIocGF5bG9hZC5wYXJhbXNbMF0sIGVuZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBGaWx0ZXJTdWJwcm92aWRlci5wcm90b3R5cGUubmV3QmxvY2tGaWx0ZXIgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fZ2V0QmxvY2tOdW1iZXIoZnVuY3Rpb24gKGVyciwgYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmaWx0ZXIgPSBuZXcgYmxvY2tfZmlsdGVyXzEuZGVmYXVsdCh7XG4gICAgICAgICAgICAgICAgYmxvY2tOdW1iZXI6IGJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgbmV3QmxvY2tIYW5kbGVyID0gZmlsdGVyLnVwZGF0ZS5iaW5kKGZpbHRlcik7XG4gICAgICAgICAgICBfdGhpcy5lbmdpbmUub24oJ2Jsb2NrJywgbmV3QmxvY2tIYW5kbGVyKTtcbiAgICAgICAgICAgIHZhciBkZXN0cm95SGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbmdpbmUucmVtb3ZlTGlzdGVuZXIoJ2Jsb2NrJywgbmV3QmxvY2tIYW5kbGVyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfdGhpcy5maWx0ZXJJbmRleCsrO1xuICAgICAgICAgICAgX3RoaXMuZmlsdGVyc1tfdGhpcy5maWx0ZXJJbmRleF0gPSBmaWx0ZXI7XG4gICAgICAgICAgICBfdGhpcy5maWx0ZXJEZXN0cm95SGFuZGxlcnNbX3RoaXMuZmlsdGVySW5kZXhdID0gZGVzdHJveUhhbmRsZXI7XG4gICAgICAgICAgICB2YXIgaGV4RmlsdGVySW5kZXggPSBldGhfdXRpbF8xLmludFRvSGV4KF90aGlzLmZpbHRlckluZGV4KTtcbiAgICAgICAgICAgIGNiKG51bGwsIGhleEZpbHRlckluZGV4KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBGaWx0ZXJTdWJwcm92aWRlci5wcm90b3R5cGUubmV3TG9nRmlsdGVyID0gZnVuY3Rpb24gKG9wdHMsIGRvbmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGZpbHRlciA9IG5ldyBsb2dfZmlsdGVyXzEuZGVmYXVsdChvcHRzKTtcbiAgICAgICAgdmFyIG5ld0xvZ0hhbmRsZXIgPSBmaWx0ZXIudXBkYXRlLmJpbmQoZmlsdGVyKTtcbiAgICAgICAgdmFyIGJsb2NrSGFuZGxlciA9IGZ1bmN0aW9uIChibG9jaywgY2IpIHtcbiAgICAgICAgICAgIF90aGlzLl9sb2dzRm9yQmxvY2soYmxvY2ssIGZ1bmN0aW9uIChlcnIsIGxvZ3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdMb2dIYW5kbGVyKGxvZ3MpO1xuICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5maWx0ZXJJbmRleCsrO1xuICAgICAgICB0aGlzLmFzeW5jQmxvY2tIYW5kbGVyc1t0aGlzLmZpbHRlckluZGV4XSA9IGJsb2NrSGFuZGxlcjtcbiAgICAgICAgdGhpcy5maWx0ZXJzW3RoaXMuZmlsdGVySW5kZXhdID0gZmlsdGVyO1xuICAgICAgICB2YXIgaGV4RmlsdGVySW5kZXggPSBldGhfdXRpbF8xLmludFRvSGV4KHRoaXMuZmlsdGVySW5kZXgpO1xuICAgICAgICBkb25lKG51bGwsIGhleEZpbHRlckluZGV4KTtcbiAgICB9O1xuICAgIEZpbHRlclN1YnByb3ZpZGVyLnByb3RvdHlwZS5uZXdQZW5kaW5nVHJhbnNhY3Rpb25GaWx0ZXIgPSBmdW5jdGlvbiAoZG9uZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZmlsdGVyID0gbmV3IHBlbmRpbmdfdHhfZmlsdGVyXzEuZGVmYXVsdCgpO1xuICAgICAgICB2YXIgbmV3VHhIYW5kbGVyID0gZmlsdGVyLnVwZGF0ZS5iaW5kKGZpbHRlcik7XG4gICAgICAgIHZhciBibG9ja0hhbmRsZXIgPSBmdW5jdGlvbiAoYmxvY2ssIGNiKSB7XG4gICAgICAgICAgICBfdGhpcy5fdHhIYXNoZXNGb3JCbG9jayhibG9jaywgZnVuY3Rpb24gKGVyciwgdHhzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV3VHhIYW5kbGVyKHR4cyk7XG4gICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmZpbHRlckluZGV4Kys7XG4gICAgICAgIHRoaXMuYXN5bmNQZW5kaW5nQmxvY2tIYW5kbGVyc1t0aGlzLmZpbHRlckluZGV4XSA9IGJsb2NrSGFuZGxlcjtcbiAgICAgICAgdGhpcy5maWx0ZXJzW3RoaXMuZmlsdGVySW5kZXhdID0gZmlsdGVyO1xuICAgICAgICB2YXIgaGV4RmlsdGVySW5kZXggPSBldGhfdXRpbF8xLmludFRvSGV4KHRoaXMuZmlsdGVySW5kZXgpO1xuICAgICAgICBkb25lKG51bGwsIGhleEZpbHRlckluZGV4KTtcbiAgICB9O1xuICAgIEZpbHRlclN1YnByb3ZpZGVyLnByb3RvdHlwZS5nZXRGaWx0ZXJDaGFuZ2VzID0gZnVuY3Rpb24gKGhleEZpbHRlcklkLCBjYikge1xuICAgICAgICB2YXIgZmlsdGVySWQgPSBwYXJzZUludChoZXhGaWx0ZXJJZCwgMTYpO1xuICAgICAgICB2YXIgZmlsdGVyID0gdGhpcy5maWx0ZXJzW2ZpbHRlcklkXTtcbiAgICAgICAgLy8gaWYgKCFmaWx0ZXIpIHsgY29uc29sZS53YXJuKCdGaWx0ZXJTdWJwcm92aWRlciAtIG5vIGZpbHRlciB3aXRoIHRoYXQgaWQ6JywgaGV4RmlsdGVySWQpOyB9XG4gICAgICAgIGlmICghZmlsdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2IobnVsbCwgW10pO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHRzID0gZmlsdGVyLmdldENoYW5nZXMoKTtcbiAgICAgICAgZmlsdGVyLmNsZWFyQ2hhbmdlcygpO1xuICAgICAgICBjYihudWxsLCByZXN1bHRzKTtcbiAgICB9O1xuICAgIEZpbHRlclN1YnByb3ZpZGVyLnByb3RvdHlwZS5nZXRGaWx0ZXJMb2dzID0gZnVuY3Rpb24gKGhleEZpbHRlcklkLCBjYikge1xuICAgICAgICB2YXIgZmlsdGVySWQgPSBwYXJzZUludChoZXhGaWx0ZXJJZCwgMTYpO1xuICAgICAgICB2YXIgZmlsdGVyID0gdGhpcy5maWx0ZXJzW2ZpbHRlcklkXTtcbiAgICAgICAgLy8gaWYgKCFmaWx0ZXIpIHsgY29uc29sZS53YXJuKCdGaWx0ZXJTdWJwcm92aWRlciAtIG5vIGZpbHRlciB3aXRoIHRoYXQgaWQ6JywgaGV4RmlsdGVySWQpOyB9XG4gICAgICAgIGlmICghZmlsdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2IobnVsbCwgW10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWx0ZXIudHlwZSA9PT0gJ2xvZycpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdFBheWxvYWQoe1xuICAgICAgICAgICAgICAgIGlkOiAwLFxuICAgICAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ2V0aF9nZXRMb2dzJyxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tQmxvY2s6IGZpbHRlci5mcm9tQmxvY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICB0b0Jsb2NrOiBmaWx0ZXIudG9CbG9jayxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IGZpbHRlci5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9waWNzOiBmaWx0ZXIudG9waWNzLFxuICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNiKG51bGwsIHJlcy5yZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYihudWxsLCBbXSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEZpbHRlclN1YnByb3ZpZGVyLnByb3RvdHlwZS51bmluc3RhbGxGaWx0ZXIgPSBmdW5jdGlvbiAoaGV4RmlsdGVySWQsIGNiKSB7XG4gICAgICAgIHZhciBmaWx0ZXJJZCA9IHBhcnNlSW50KGhleEZpbHRlcklkLCAxNik7XG4gICAgICAgIHZhciBmaWx0ZXIgPSB0aGlzLmZpbHRlcnNbZmlsdGVySWRdO1xuICAgICAgICBpZiAoIWZpbHRlcikge1xuICAgICAgICAgICAgY2IobnVsbCwgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmlsdGVyc1tmaWx0ZXJJZF0ucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgIHZhciBkZXN0cm95SGFuZGxlciA9IHRoaXMuZmlsdGVyRGVzdHJveUhhbmRsZXJzW2ZpbHRlcklkXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuZmlsdGVyc1tmaWx0ZXJJZF07XG4gICAgICAgIGRlbGV0ZSB0aGlzLmFzeW5jQmxvY2tIYW5kbGVyc1tmaWx0ZXJJZF07XG4gICAgICAgIGRlbGV0ZSB0aGlzLmFzeW5jUGVuZGluZ0Jsb2NrSGFuZGxlcnNbZmlsdGVySWRdO1xuICAgICAgICBkZWxldGUgdGhpcy5maWx0ZXJEZXN0cm95SGFuZGxlcnNbZmlsdGVySWRdO1xuICAgICAgICBpZiAoZGVzdHJveUhhbmRsZXIpIHtcbiAgICAgICAgICAgIGRlc3Ryb3lIYW5kbGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2IobnVsbCwgdHJ1ZSk7XG4gICAgfTtcbiAgICBGaWx0ZXJTdWJwcm92aWRlci5wcm90b3R5cGUuY2hlY2tGb3JQZW5kaW5nQmxvY2tzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5jaGVja0ZvclBlbmRpbmdCbG9ja3NBY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWN0aXZlUGVuZGluZ1R4RmlsdGVycyA9ICEhT2JqZWN0LmtleXModGhpcy5hc3luY1BlbmRpbmdCbG9ja0hhbmRsZXJzKS5sZW5ndGg7XG4gICAgICAgIGlmIChhY3RpdmVQZW5kaW5nVHhGaWx0ZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrRm9yUGVuZGluZ0Jsb2Nrc0FjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmVtaXRQYXlsb2FkKHtcbiAgICAgICAgICAgICAgICBpZDogMCxcbiAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdldGhfZ2V0QmxvY2tCeU51bWJlcicsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBbJ3BlbmRpbmcnLCB0cnVlXSxcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2hlY2tGb3JQZW5kaW5nQmxvY2tzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5vbk5ld1BlbmRpbmdCbG9jayhyZXMucmVzdWx0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIChlcnIpIHsgY29uc29sZS5lcnJvcihlcnIpOyB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNoZWNrRm9yUGVuZGluZ0Jsb2Nrc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KF90aGlzLmNoZWNrRm9yUGVuZGluZ0Jsb2Nrcy5iaW5kKF90aGlzKSwgX3RoaXMucGVuZGluZ0Jsb2NrVGltZW91dCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRmlsdGVyU3VicHJvdmlkZXIucHJvdG90eXBlLm9uTmV3UGVuZGluZ0Jsb2NrID0gZnVuY3Rpb24gKGJsb2NrLCBjYikge1xuICAgICAgICAvLyB1cGRhdGUgZmlsdGVyc1xuICAgICAgICB2YXIgdXBkYXRlcnMgPSB2YWx1ZXNGb3IodGhpcy5hc3luY1BlbmRpbmdCbG9ja0hhbmRsZXJzKS5tYXAoZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbi5iaW5kKG51bGwsIGJsb2NrKTsgfSk7XG4gICAgICAgIHBhcmFsbGVsXzEuZGVmYXVsdCh1cGRhdGVycywgY2IpO1xuICAgIH07XG4gICAgRmlsdGVyU3VicHJvdmlkZXIucHJvdG90eXBlLl9nZXRCbG9ja051bWJlciA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICB2YXIgYmxvY2tOdW1iZXIgPSBidWZmZXJUb051bWJlckhleCh0aGlzLmVuZ2luZS5jdXJyZW50QmxvY2subnVtYmVyKTtcbiAgICAgICAgY2IobnVsbCwgYmxvY2tOdW1iZXIpO1xuICAgIH07XG4gICAgRmlsdGVyU3VicHJvdmlkZXIucHJvdG90eXBlLl9sb2dzRm9yQmxvY2sgPSBmdW5jdGlvbiAoYmxvY2ssIGNiKSB7XG4gICAgICAgIHZhciBibG9ja051bWJlciA9IGJ1ZmZlclRvTnVtYmVySGV4KGJsb2NrLm51bWJlcik7XG4gICAgICAgIHRoaXMuZW1pdFBheWxvYWQoe1xuICAgICAgICAgICAgaWQ6IDAsXG4gICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgIG1ldGhvZDogJ2V0aF9nZXRMb2dzJyxcbiAgICAgICAgICAgIHBhcmFtczogW3tcbiAgICAgICAgICAgICAgICAgICAgZnJvbUJsb2NrOiBibG9ja051bWJlcixcbiAgICAgICAgICAgICAgICAgICAgdG9CbG9jazogYmxvY2tOdW1iZXIsXG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2IocmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2IobnVsbCwgcmVzcG9uc2UucmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBGaWx0ZXJTdWJwcm92aWRlci5wcm90b3R5cGUuX3R4SGFzaGVzRm9yQmxvY2sgPSBmdW5jdGlvbiAoYmxvY2ssIGNiKSB7XG4gICAgICAgIHZhciB0eHMgPSBibG9jay50cmFuc2FjdGlvbnM7XG4gICAgICAgIC8vIHNob3J0IGNpcmN1aXQgaWYgZW1wdHlcbiAgICAgICAgaWYgKHR4cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBjYihudWxsLCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHhzIGFyZSBhbHJlYWR5IGhhc2hlc1xuICAgICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB0eHNbMF0pIHtcbiAgICAgICAgICAgIGNiKG51bGwsIHR4cyk7XG4gICAgICAgICAgICAvLyB0eHMgYXJlIG9iaiwgbmVlZCB0byBtYXAgdG8gaGFzaGVzXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHR4cy5tYXAoZnVuY3Rpb24gKHR4KSB7IHJldHVybiB0eC5oYXNoOyB9KTtcbiAgICAgICAgICAgIGNiKG51bGwsIHJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRmlsdGVyU3VicHJvdmlkZXI7XG59KHN1YnByb3ZpZGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRmlsdGVyU3VicHJvdmlkZXI7XG4vLyB1dGlsXG5mdW5jdGlvbiBidWZmZXJUb051bWJlckhleChidWZmZXIpIHtcbiAgICByZXR1cm4gc3RyaXBMZWFkaW5nWmVybyhidWZmZXIudG9TdHJpbmcoJ2hleCcpKTtcbn1cbmZ1bmN0aW9uIHN0cmlwTGVhZGluZ1plcm8oaGV4TnVtKSB7XG4gICAgdmFyIHN0cmlwcGVkID0gZXRoX3V0aWxfMS5zdHJpcEhleFByZWZpeChoZXhOdW0pO1xuICAgIHdoaWxlIChzdHJpcHBlZFswXSA9PT0gJzAnKSB7XG4gICAgICAgIHN0cmlwcGVkID0gc3RyaXBwZWQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgc3RyaXBwZWQ7XG59XG5mdW5jdGlvbiB2YWx1ZXNGb3Iob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIG9ialtrZXldOyB9KTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZmlsdGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vZmlsdGVyXCIpKTtcbi8vXG4vLyBCbG9ja0ZpbHRlclxuLy9cbnZhciBCbG9ja0ZpbHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmxvY2tGaWx0ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQmxvY2tGaWx0ZXIob3B0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSBcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0Jsb2NrRmlsdGVyIC0gbmV3JylcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZSA9ICdibG9jayc7XG4gICAgICAgIF90aGlzLmVuZ2luZSA9IG9wdHMuZW5naW5lO1xuICAgICAgICBfdGhpcy5ibG9ja051bWJlciA9IG9wdHMuYmxvY2tOdW1iZXI7XG4gICAgICAgIF90aGlzLnVwZGF0ZXMgPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBCbG9ja0ZpbHRlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHZhciBibG9ja0hhc2ggPSBidWZmZXJUb0hleChibG9jay5oYXNoKTtcbiAgICAgICAgdGhpcy51cGRhdGVzLnB1c2goYmxvY2tIYXNoKTtcbiAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgYmxvY2spO1xuICAgIH07XG4gICAgQmxvY2tGaWx0ZXIucHJvdG90eXBlLmdldENoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdCbG9ja0ZpbHRlciAtIGdldENoYW5nZXM6JywgcmVzdWx0cy5sZW5ndGgpXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZXM7XG4gICAgfTtcbiAgICBCbG9ja0ZpbHRlci5wcm90b3R5cGUuY2xlYXJDaGFuZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnQmxvY2tGaWx0ZXIgLSBjbGVhckNoYW5nZXMnKVxuICAgICAgICB0aGlzLnVwZGF0ZXMgPSBbXTtcbiAgICB9O1xuICAgIHJldHVybiBCbG9ja0ZpbHRlcjtcbn0oZmlsdGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQmxvY2tGaWx0ZXI7XG5mdW5jdGlvbiBidWZmZXJUb0hleChidWZmZXIpIHtcbiAgICByZXR1cm4gJzB4JyArIGJ1ZmZlci50b1N0cmluZygnaGV4Jyk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbnZhciBGaWx0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZpbHRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGaWx0ZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEZpbHRlcjtcbn0oZXZlbnRzXzEuRXZlbnRFbWl0dGVyKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBGaWx0ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGZpbHRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2ZpbHRlclwiKSk7XG4vL1xuLy8gTG9nRmlsdGVyXG4vL1xudmFyIExvZ0ZpbHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTG9nRmlsdGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExvZ0ZpbHRlcihvcHRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IFxuICAgICAgICAvLyBjb25zb2xlLmxvZygnTG9nRmlsdGVyIC0gbmV3JylcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZSA9ICdsb2cnO1xuICAgICAgICBfdGhpcy5mcm9tQmxvY2sgPSAob3B0cy5mcm9tQmxvY2sgIT09IHVuZGVmaW5lZCkgPyBvcHRzLmZyb21CbG9jayA6ICdsYXRlc3QnO1xuICAgICAgICBfdGhpcy50b0Jsb2NrID0gKG9wdHMudG9CbG9jayAhPT0gdW5kZWZpbmVkKSA/IG9wdHMudG9CbG9jayA6ICdsYXRlc3QnO1xuICAgICAgICB2YXIgZXhwZWN0ZWRBZGRyZXNzID0gb3B0cy5hZGRyZXNzICYmIChBcnJheS5pc0FycmF5KG9wdHMuYWRkcmVzcykgPyBvcHRzLmFkZHJlc3MgOiBbb3B0cy5hZGRyZXNzXSk7XG4gICAgICAgIF90aGlzLmFkZHJlc3MgPSBleHBlY3RlZEFkZHJlc3MgJiYgZXhwZWN0ZWRBZGRyZXNzLm1hcChub3JtYWxpemVIZXgpO1xuICAgICAgICBfdGhpcy50b3BpY3MgPSBvcHRzLnRvcGljcyB8fCBbXTtcbiAgICAgICAgX3RoaXMudXBkYXRlcyA9IFtdO1xuICAgICAgICBfdGhpcy5hbGxSZXN1bHRzID0gW107XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTG9nRmlsdGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAobG9ncykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyB2YWxpZGF0ZSBmaWx0ZXIgbWF0Y2hcbiAgICAgICAgdmFyIHZhbGlkTG9ncyA9IFtdO1xuICAgICAgICBsb2dzLmZvckVhY2goZnVuY3Rpb24gKGxvZykge1xuICAgICAgICAgICAgdmFyIHZhbGlkYXRlZCA9IF90aGlzLnZhbGlkYXRlTG9nKGxvZyk7XG4gICAgICAgICAgICBpZiAoIXZhbGlkYXRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFkZCB0byByZXN1bHRzXG4gICAgICAgICAgICB2YWxpZExvZ3MucHVzaChsb2cpO1xuICAgICAgICAgICAgX3RoaXMudXBkYXRlcy5wdXNoKGxvZyk7XG4gICAgICAgICAgICBfdGhpcy5hbGxSZXN1bHRzLnB1c2gobG9nKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh2YWxpZExvZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgdmFsaWRMb2dzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTG9nRmlsdGVyLnByb3RvdHlwZS5nZXRDaGFuZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnTG9nRmlsdGVyIC0gZ2V0Q2hhbmdlcycpXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZXM7XG4gICAgfTtcbiAgICBMb2dGaWx0ZXIucHJvdG90eXBlLmdldEFsbFJlc3VsdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdMb2dGaWx0ZXIgLSBnZXRBbGxSZXN1bHRzJylcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxsUmVzdWx0cztcbiAgICB9O1xuICAgIExvZ0ZpbHRlci5wcm90b3R5cGUuY2xlYXJDaGFuZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnTG9nRmlsdGVyIC0gY2xlYXJDaGFuZ2VzJylcbiAgICAgICAgdGhpcy51cGRhdGVzID0gW107XG4gICAgfTtcbiAgICBMb2dGaWx0ZXIucHJvdG90eXBlLnZhbGlkYXRlTG9nID0gZnVuY3Rpb24gKGxvZykge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnTG9nRmlsdGVyIC0gdmFsaWRhdGVMb2c6JywgbG9nKVxuICAgICAgICAvLyBjaGVjayBpZiBibG9jayBudW1iZXIgaW4gYm91bmRzOlxuICAgICAgICAvLyBjb25zb2xlLmxvZygnTG9nRmlsdGVyIC0gdmFsaWRhdGVMb2cgLSBibG9ja051bWJlcicsIHRoaXMuZnJvbUJsb2NrLCB0aGlzLnRvQmxvY2spXG4gICAgICAgIGlmIChibG9ja1RhZ0lzTnVtYmVyKHRoaXMuZnJvbUJsb2NrKSAmJiBoZXhUb0ludCh0aGlzLmZyb21CbG9jaykgPj0gaGV4VG9JbnQobG9nLmJsb2NrTnVtYmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChibG9ja1RhZ0lzTnVtYmVyKHRoaXMudG9CbG9jaykgJiYgaGV4VG9JbnQodGhpcy50b0Jsb2NrKSA8PSBoZXhUb0ludChsb2cuYmxvY2tOdW1iZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkcmVzcyBpcyBjb3JyZWN0OlxuICAgICAgICAvLyBjb25zb2xlLmxvZygnTG9nRmlsdGVyIC0gdmFsaWRhdGVMb2cgLSBhZGRyZXNzJywgdGhpcy5hZGRyZXNzKVxuICAgICAgICBpZiAodGhpcy5hZGRyZXNzICYmICEodGhpcy5hZGRyZXNzLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS50b0xvd2VyQ2FzZSgpOyB9KS5pbmNsdWRlcyhsb2cuYWRkcmVzcy50b0xvd2VyQ2FzZSgpKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0b3BpY3MgbWF0Y2g6XG4gICAgICAgIC8vIHRvcGljcyBhcmUgcG9zaXRpb24tZGVwZW5kYW50XG4gICAgICAgIC8vIHRvcGljcyBjYW4gYmUgbmVzdGVkIHRvIHJlcHJlc2VudCBgb3JgIFtbYSB8fCBiXSwgY11cbiAgICAgICAgLy8gdG9waWNzIGNhbiBiZSBudWxsLCByZXByZXNlbnRpbmcgYSB3aWxkIGNhcmQgZm9yIHRoYXQgcG9zaXRpb25cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0xvZ0ZpbHRlciAtIHZhbGlkYXRlTG9nIC0gdG9waWNzJywgbG9nLnRvcGljcylcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0xvZ0ZpbHRlciAtIHZhbGlkYXRlTG9nIC0gYWdhaW5zdCB0b3BpY3MnLCB0aGlzLnRvcGljcylcbiAgICAgICAgdmFyIHRvcGljc01hdGNoID0gdGhpcy50b3BpY3MucmVkdWNlKGZ1bmN0aW9uIChwcmV2aW91c01hdGNoZWQsIHRvcGljUGF0dGVybiwgaW5kZXgpIHtcbiAgICAgICAgICAgIC8vIGFib3J0IGluIHByb2dyZXNzXG4gICAgICAgICAgICBpZiAoIXByZXZpb3VzTWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHdpbGQgY2FyZFxuICAgICAgICAgICAgaWYgKCF0b3BpY1BhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHBhdHRlcm4gaXMgbG9uZ2VyIHRoYW4gYWN0dWFsIHRvcGljc1xuICAgICAgICAgICAgdmFyIGxvZ1RvcGljID0gbG9nLnRvcGljc1tpbmRleF07XG4gICAgICAgICAgICBpZiAoIWxvZ1RvcGljKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2hlY2sgZWFjaCBwb3NzaWJsZSBtYXRjaGluZyB0b3BpY1xuICAgICAgICAgICAgdmFyIHN1YnRvcGljc1RvTWF0Y2ggPSBBcnJheS5pc0FycmF5KHRvcGljUGF0dGVybikgPyB0b3BpY1BhdHRlcm4gOiBbdG9waWNQYXR0ZXJuXTtcbiAgICAgICAgICAgIHZhciB0b3BpY0RvZXNNYXRjaCA9IHN1YnRvcGljc1RvTWF0Y2guZmlsdGVyKGZ1bmN0aW9uIChzdWJUb3BpYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2dUb3BpYy50b0xvd2VyQ2FzZSgpID09PSBzdWJUb3BpYy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfSkubGVuZ3RoID4gMDtcbiAgICAgICAgICAgIHJldHVybiB0b3BpY0RvZXNNYXRjaDtcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdMb2dGaWx0ZXIgLSB2YWxpZGF0ZUxvZyAtICcrKHRvcGljc01hdGNoID8gJ2FwcHJvdmVkIScgOiAnZGVuaWVkIScpKycgPT09PT09PT09PT09PT0nKVxuICAgICAgICByZXR1cm4gdG9waWNzTWF0Y2g7XG4gICAgfTtcbiAgICByZXR1cm4gTG9nRmlsdGVyO1xufShmaWx0ZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBMb2dGaWx0ZXI7XG5mdW5jdGlvbiBibG9ja1RhZ0lzTnVtYmVyKGJsb2NrVGFnKSB7XG4gICAgcmV0dXJuIGJsb2NrVGFnICYmIFsnZWFybGllc3QnLCAnbGF0ZXN0JywgJ3BlbmRpbmcnXS5pbmRleE9mKGJsb2NrVGFnKSA9PT0gLTE7XG59XG5mdW5jdGlvbiBoZXhUb0ludChoZXhTdHJpbmcpIHtcbiAgICByZXR1cm4gTnVtYmVyKGhleFN0cmluZyk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVIZXgoaGV4U3RyaW5nKSB7XG4gICAgcmV0dXJuIGhleFN0cmluZy5zbGljZSgwLCAyKSA9PT0gJzB4JyA/IGhleFN0cmluZyA6ICcweCcgKyBoZXhTdHJpbmc7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGZpbHRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2ZpbHRlclwiKSk7XG4vL1xuLy8gUGVuZGluZ1R4RmlsdGVyXG4vL1xudmFyIFBlbmRpbmdUcmFuc2FjdGlvbkZpbHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGVuZGluZ1RyYW5zYWN0aW9uRmlsdGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBlbmRpbmdUcmFuc2FjdGlvbkZpbHRlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdQZW5kaW5nVHJhbnNhY3Rpb25GaWx0ZXIgLSBuZXcnKVxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50eXBlID0gJ3BlbmRpbmdUeCc7XG4gICAgICAgIF90aGlzLnVwZGF0ZXMgPSBbXTtcbiAgICAgICAgX3RoaXMuYWxsUmVzdWx0cyA9IFtdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFBlbmRpbmdUcmFuc2FjdGlvbkZpbHRlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHR4cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnUGVuZGluZ1RyYW5zYWN0aW9uRmlsdGVyIC0gdXBkYXRlJylcbiAgICAgICAgdmFyIHZhbGlkVHhzID0gW107XG4gICAgICAgIHR4cy5mb3JFYWNoKGZ1bmN0aW9uICh0eCkge1xuICAgICAgICAgICAgLy8gdmFsaWRhdGUgZmlsdGVyIG1hdGNoXG4gICAgICAgICAgICB2YXIgdmFsaWRhdGVkID0gX3RoaXMudmFsaWRhdGVVbmlxdWUodHgpO1xuICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhZGQgdG8gcmVzdWx0c1xuICAgICAgICAgICAgdmFsaWRUeHMucHVzaCh0eCk7XG4gICAgICAgICAgICBfdGhpcy51cGRhdGVzLnB1c2godHgpO1xuICAgICAgICAgICAgX3RoaXMuYWxsUmVzdWx0cy5wdXNoKHR4KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh2YWxpZFR4cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCB2YWxpZFR4cyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBlbmRpbmdUcmFuc2FjdGlvbkZpbHRlci5wcm90b3R5cGUuZ2V0Q2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ1BlbmRpbmdUcmFuc2FjdGlvbkZpbHRlciAtIGdldENoYW5nZXMnKVxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVzO1xuICAgIH07XG4gICAgUGVuZGluZ1RyYW5zYWN0aW9uRmlsdGVyLnByb3RvdHlwZS5nZXRBbGxSZXN1bHRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnUGVuZGluZ1RyYW5zYWN0aW9uRmlsdGVyIC0gZ2V0QWxsUmVzdWx0cycpXG4gICAgICAgIHJldHVybiB0aGlzLmFsbFJlc3VsdHM7XG4gICAgfTtcbiAgICBQZW5kaW5nVHJhbnNhY3Rpb25GaWx0ZXIucHJvdG90eXBlLmNsZWFyQ2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ1BlbmRpbmdUcmFuc2FjdGlvbkZpbHRlciAtIGNsZWFyQ2hhbmdlcycpXG4gICAgICAgIHRoaXMudXBkYXRlcyA9IFtdO1xuICAgIH07XG4gICAgUGVuZGluZ1RyYW5zYWN0aW9uRmlsdGVyLnByb3RvdHlwZS52YWxpZGF0ZVVuaXF1ZSA9IGZ1bmN0aW9uICh0eCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbGxSZXN1bHRzLmluZGV4T2YodHgpID09PSAtMTtcbiAgICB9O1xuICAgIHJldHVybiBQZW5kaW5nVHJhbnNhY3Rpb25GaWx0ZXI7XG59KGZpbHRlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFBlbmRpbmdUcmFuc2FjdGlvbkZpbHRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc3VicHJvdmlkZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vc3VicHJvdmlkZXJcIikpO1xudmFyIEZpeHR1cmVQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRml4dHVyZVByb3ZpZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZpeHR1cmVQcm92aWRlcihzdGF0aWNSZXNwb25zZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RhdGljUmVzcG9uc2VzID0gc3RhdGljUmVzcG9uc2VzIHx8IHt9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEZpeHR1cmVQcm92aWRlci5wcm90b3R5cGUuaGFuZGxlUmVxdWVzdCA9IGZ1bmN0aW9uIChwYXlsb2FkLCBuZXh0LCBlbmQpIHtcbiAgICAgICAgdmFyIHN0YXRpY1Jlc3BvbnNlID0gdGhpcy5zdGF0aWNSZXNwb25zZXNbcGF5bG9hZC5tZXRob2RdO1xuICAgICAgICAvLyBhc3luYyBmdW5jdGlvblxuICAgICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHN0YXRpY1Jlc3BvbnNlKSB7XG4gICAgICAgICAgICBzdGF0aWNSZXNwb25zZShwYXlsb2FkLCBuZXh0LCBlbmQpO1xuICAgICAgICAgICAgLy8gc3RhdGljIHJlc3BvbnNlIC0gbnVsbCBpcyB2YWxpZCByZXNwb25zZVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRpY1Jlc3BvbnNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHJldHVybiByZXN1bHQgYXN5bmNocm9ub3VzbHlcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5kKG51bGwsIHN0YXRpY1Jlc3BvbnNlKTsgfSk7XG4gICAgICAgICAgICAvLyBubyBwcmVwYXJlZCByZXNwb25zZSAtIHNraXBcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEZpeHR1cmVQcm92aWRlcjtcbn0oc3VicHJvdmlkZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBGaXh0dXJlUHJvdmlkZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDYWxjdWxhdGUgZ2FzUHJpY2UgYmFzZWQgb24gbGFzdCBibG9ja3MuXG4gKiBAYXV0aG9yIGdpdGh1Yi5jb20vYXhpY1xuICpcbiAqIEZJWE1FOiBzdXBwb3J0IG1pbmltdW0gc3VnZ2VzdGVkIGdhcyBhbmQgcGVyaGFwcyBvdGhlciBvcHRpb25zIGZyb20gZ2V0aDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9nby1ldGhlcmV1bS9ibG9iL21hc3Rlci9ldGgvZ2FzcHJpY2UuZ29cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9nby1ldGhlcmV1bS93aWtpL0dhcy1QcmljZS1PcmFjbGVcbiAqL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbWFwXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImFzeW5jL21hcFwiKSk7XG52YXIgZ2FzX3ByaWNlX2Vycm9yXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzL2dhcy1wcmljZS1lcnJvclwiKTtcbnZhciBzdWJwcm92aWRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9zdWJwcm92aWRlclwiKSk7XG52YXIgR2FzcHJpY2VQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR2FzcHJpY2VQcm92aWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHYXNwcmljZVByb3ZpZGVyKG9wdHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubnVtYmVyT2ZCbG9ja3MgPSBvcHRzLm51bWJlck9mQmxvY2tzIHx8IDEwO1xuICAgICAgICBfdGhpcy5kZWxheUluQmxvY2tzID0gb3B0cy5kZWxheUluQmxvY2tzIHx8IDU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgR2FzcHJpY2VQcm92aWRlci5wcm90b3R5cGUuaGFuZGxlUmVxdWVzdCA9IGZ1bmN0aW9uIChwYXlsb2FkLCBuZXh0LCBlbmQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHBheWxvYWQubWV0aG9kICE9PSAnZXRoX2dhc1ByaWNlJykge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcCA9IHsgaWQ6IDAsIGpzb25ycGM6ICcyLjAnLCBtZXRob2Q6ICdldGhfYmxvY2tOdW1iZXInLCBwYXJhbXM6IFtdIH07XG4gICAgICAgIHRoaXMuZW1pdFBheWxvYWQocCwgZnVuY3Rpb24gKF8sIHJlcykge1xuICAgICAgICAgICAgLy8gRklYTUU6IGNvbnZlcnQgbnVtYmVyIHVzaW5nIGEgYmlnbnVtIGxpYnJhcnlcbiAgICAgICAgICAgIHZhciBsYXN0QmxvY2sgPSBwYXJzZUludChyZXMucmVzdWx0LCAxNikgLSBfdGhpcy5kZWxheUluQmxvY2tzO1xuICAgICAgICAgICAgdmFyIGJsb2NrTnVtYmVycyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpcy5udW1iZXJPZkJsb2NrczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYmxvY2tOdW1iZXJzLnB1c2goJzB4JyArIGxhc3RCbG9jay50b1N0cmluZygxNikpO1xuICAgICAgICAgICAgICAgIGxhc3RCbG9jay0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGdldEJsb2NrID0gZnVuY3Rpb24gKGl0ZW0sIGNiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAyID0geyBpZDogMCwganNvbnJwYzogJzIuMCcsIG1ldGhvZDogJ2V0aF9nZXRCbG9ja0J5TnVtYmVyJywgcGFyYW1zOiBbaXRlbSwgdHJ1ZV0gfTtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0UGF5bG9hZChwMiwgZnVuY3Rpb24gKGVyciwgYmxvY2tSZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFibG9ja1Jlcy5yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYihnYXNfcHJpY2VfZXJyb3JfMS5HYXNQcmljZUVycm9yLkJsb2NrTm90Rm91bmQoaXRlbSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNiKG51bGwsIGJsb2NrUmVzLnJlc3VsdC50cmFuc2FjdGlvbnMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIEZJWE1FOiB0aGlzIGNvdWxkIGJlIG1hZGUgbXVjaCBmYXN0ZXJcbiAgICAgICAgICAgIHZhciBjYWxjUHJpY2UgPSBmdW5jdGlvbiAoZXJyLCB0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAvLyBmbGF0dGVuIGFycmF5XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25zID0gdHJhbnNhY3Rpb25zLnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5jb25jYXQoYik7IH0sIFtdKTtcbiAgICAgICAgICAgICAgICAvLyBsZWF2ZSBvbmx5IHRoZSBnYXNwcmljZVxuICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBjb252ZXJ0IG51bWJlciB1c2luZyBhIGJpZ251bSBsaWJyYXJ5XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25zID0gdHJhbnNhY3Rpb25zLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gcGFyc2VJbnQoYS5nYXNQcmljZSwgMTYpOyB9LCBbXSk7XG4gICAgICAgICAgICAgICAgLy8gb3JkZXIgYXNjZW5kaW5nXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgLSBiOyB9KTtcbiAgICAgICAgICAgICAgICAvLyB6ZSBtZWRpYW5cbiAgICAgICAgICAgICAgICB2YXIgaGFsZiA9IE1hdGguZmxvb3IodHJhbnNhY3Rpb25zLmxlbmd0aCAvIDIpO1xuICAgICAgICAgICAgICAgIHZhciBtZWRpYW47XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9ucy5sZW5ndGggJSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lZGlhbiA9IHRyYW5zYWN0aW9uc1toYWxmXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lZGlhbiA9IE1hdGguZmxvb3IoKHRyYW5zYWN0aW9uc1toYWxmIC0gMV0gKyB0cmFuc2FjdGlvbnNbaGFsZl0pIC8gMi4wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW5kKG51bGwsIG1lZGlhbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbWFwXzEuZGVmYXVsdChibG9ja051bWJlcnMsIGdldEJsb2NrLCBjYWxjUHJpY2UpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBHYXNwcmljZVByb3ZpZGVyO1xufShzdWJwcm92aWRlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEdhc3ByaWNlUHJvdmlkZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjYWNoZV8xID0gcmVxdWlyZShcIi4vY2FjaGVcIik7XG5leHBvcnRzLkJsb2NrQ2FjaGVTdWJwcm92aWRlciA9IGNhY2hlXzEuZGVmYXVsdDtcbnZhciBkZWZhdWx0X2ZpeHR1cmVfMSA9IHJlcXVpcmUoXCIuL2RlZmF1bHQtZml4dHVyZVwiKTtcbmV4cG9ydHMuRGVmYXVsdEZpeHR1cmVTdWJwcm92aWRlciA9IGRlZmF1bHRfZml4dHVyZV8xLmRlZmF1bHQ7XG52YXIgZmV0Y2hfMSA9IHJlcXVpcmUoXCIuL2ZldGNoXCIpO1xuZXhwb3J0cy5GZXRjaFN1YnByb3ZpZGVyID0gZmV0Y2hfMS5kZWZhdWx0O1xudmFyIGZpbHRlcnNfMSA9IHJlcXVpcmUoXCIuL2ZpbHRlcnNcIik7XG5leHBvcnRzLkZpbHRlclN1YnByb3ZpZGVyID0gZmlsdGVyc18xLmRlZmF1bHQ7XG52YXIgZml4dHVyZV8xID0gcmVxdWlyZShcIi4vZml4dHVyZVwiKTtcbmV4cG9ydHMuRml4dHVyZVN1YnByb3ZpZGVyID0gZml4dHVyZV8xLmRlZmF1bHQ7XG52YXIgZ2FzcHJpY2VfMSA9IHJlcXVpcmUoXCIuL2dhc3ByaWNlXCIpO1xuZXhwb3J0cy5HYXNQcmljZVN1YnByb3ZpZGVyID0gZ2FzcHJpY2VfMS5kZWZhdWx0O1xudmFyIGluZmxpZ2h0X2NhY2hlXzEgPSByZXF1aXJlKFwiLi9pbmZsaWdodC1jYWNoZVwiKTtcbmV4cG9ydHMuSW5mbGlnaHRDYWNoZVN1YnByb3ZpZGVyID0gaW5mbGlnaHRfY2FjaGVfMS5kZWZhdWx0O1xudmFyIHByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlclwiKTtcbmV4cG9ydHMuUHJvdmlkZXJTdWJwcm92aWRlciA9IHByb3ZpZGVyXzEuZGVmYXVsdDtcbnZhciBzYW5pdGl6ZXJfMSA9IHJlcXVpcmUoXCIuL3Nhbml0aXplclwiKTtcbmV4cG9ydHMuU2FuaXRpemVyU3VicHJvdmlkZXIgPSBzYW5pdGl6ZXJfMS5kZWZhdWx0O1xudmFyIHN1YnNjcmlwdGlvbnNfMSA9IHJlcXVpcmUoXCIuL3N1YnNjcmlwdGlvbnNcIik7XG5leHBvcnRzLlN1YnNjcmlwdGlvblN1YnByb3ZpZGVyID0gc3Vic2NyaXB0aW9uc18xLmRlZmF1bHQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNsb25lXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImNsb25lXCIpKTtcbnZhciBzdWJwcm92aWRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9zdWJwcm92aWRlclwiKSk7XG52YXIgcnBjX2NhY2hlX3V0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9ycGMtY2FjaGUtdXRpbHNcIik7XG52YXIgSW5mbGlnaHRDYWNoZVN1YnByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbmZsaWdodENhY2hlU3VicHJvdmlkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5mbGlnaHRDYWNoZVN1YnByb3ZpZGVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pbmZsaWdodFJlcXVlc3RzID0ge307XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgSW5mbGlnaHRDYWNoZVN1YnByb3ZpZGVyLnByb3RvdHlwZS5oYW5kbGVSZXF1ZXN0ID0gZnVuY3Rpb24gKHBheWxvYWQsIG5leHQsIGVuZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY2FjaGVJZCA9IHJwY19jYWNoZV91dGlsc18xLmNhY2hlSWRlbnRpZmllckZvclBheWxvYWQocGF5bG9hZCwgeyBpbmNsdWRlQmxvY2tSZWY6IHRydWUgfSk7XG4gICAgICAgIC8vIGlmIG5vdCBjYWNoZWFibGUsIHNraXBcbiAgICAgICAgaWYgKCFjYWNoZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGZvciBtYXRjaGluZyByZXF1ZXN0c1xuICAgICAgICB2YXIgYWN0aXZlUmVxdWVzdEhhbmRsZXJzID0gdGhpcy5pbmZsaWdodFJlcXVlc3RzW2NhY2hlSWRdO1xuICAgICAgICBpZiAoIWFjdGl2ZVJlcXVlc3RIYW5kbGVycykge1xuICAgICAgICAgICAgLy8gY3JlYXRlIGluZmxpZ2h0IGNhY2hlIGZvciBjYWNoZUlkXG4gICAgICAgICAgICBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuaW5mbGlnaHRSZXF1ZXN0c1tjYWNoZUlkXSA9IGFjdGl2ZVJlcXVlc3RIYW5kbGVycztcbiAgICAgICAgICAgIG5leHQoZnVuY3Rpb24gKGVyciwgcmVzdWx0LCBjYikge1xuICAgICAgICAgICAgICAgIC8vIGNvbXBsZXRlIGluZmxpZ2h0IGZvciBjYWNoZUlkXG4gICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzLmluZmxpZ2h0UmVxdWVzdHNbY2FjaGVJZF07XG4gICAgICAgICAgICAgICAgYWN0aXZlUmVxdWVzdEhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHsgcmV0dXJuIGhhbmRsZXIoZXJyLCBjbG9uZV8xLmRlZmF1bHQocmVzdWx0KSk7IH0pO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNsb25lXzEuZGVmYXVsdChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGhpdCBpbmZsaWdodCBjYWNoZSBmb3IgY2FjaGVJZFxuICAgICAgICAgICAgLy8gc2V0dXAgdGhlIHJlc3BvbnNlIGxpc3RlbmVyXG4gICAgICAgICAgICBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMucHVzaChlbmQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gSW5mbGlnaHRDYWNoZVN1YnByb3ZpZGVyO1xufShzdWJwcm92aWRlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEluZmxpZ2h0Q2FjaGVTdWJwcm92aWRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIganNvbl9ycGNfZXJyb3JfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwianNvbi1ycGMtZXJyb3JcIikpO1xudmFyIHN1YnByb3ZpZGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3N1YnByb3ZpZGVyXCIpKTtcbi8vIHdyYXBzIGEgcHJvdmlkZXIgaW4gYSBzdWJwcm92aWRlciBpbnRlcmZhY2VcbnZhciBQcm92aWRlclN1YnByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQcm92aWRlclN1YnByb3ZpZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFByb3ZpZGVyU3VicHJvdmlkZXIocHJvdmlkZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBQcm92aWRlclN1YnByb3ZpZGVyLnByb3RvdHlwZS5oYW5kbGVSZXF1ZXN0ID0gZnVuY3Rpb24gKHBheWxvYWQsIG5leHQsIGVuZCkge1xuICAgICAgICB0aGlzLnByb3ZpZGVyLnNlbmRBc3luYyhwYXlsb2FkLCBmdW5jdGlvbiAoZXJyLCByZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmQoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmQobmV3IGpzb25fcnBjX2Vycm9yXzEuZGVmYXVsdC5JbnRlcm5hbEVycm9yKHJlc3BvbnNlLmVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbmQobnVsbCwgcmVzcG9uc2UucmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUHJvdmlkZXJTdWJwcm92aWRlcjtcbn0oc3VicHJvdmlkZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBQcm92aWRlclN1YnByb3ZpZGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzdWJwcm92aWRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9zdWJwcm92aWRlclwiKSk7XG52YXIgZXRoX3V0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsL2V0aC11dGlsXCIpO1xudmFyIFNhbml0aXplclN1YnByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTYW5pdGl6ZXJTdWJwcm92aWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTYW5pdGl6ZXJTdWJwcm92aWRlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBTYW5pdGl6ZXJTdWJwcm92aWRlci5wcm90b3R5cGUuaGFuZGxlUmVxdWVzdCA9IGZ1bmN0aW9uIChwYXlsb2FkLCBuZXh0LCBlbmQpIHtcbiAgICAgICAgdmFyIHR4UGFyYW1zID0gcGF5bG9hZC5wYXJhbXNbMF07XG4gICAgICAgIGlmICh0eXBlb2YgdHhQYXJhbXMgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHR4UGFyYW1zKSkge1xuICAgICAgICAgICAgdmFyIHNhbml0aXplZCA9IGNsb25lVHhQYXJhbXModHhQYXJhbXMpO1xuICAgICAgICAgICAgcGF5bG9hZC5wYXJhbXNbMF0gPSBzYW5pdGl6ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCgpO1xuICAgIH07XG4gICAgcmV0dXJuIFNhbml0aXplclN1YnByb3ZpZGVyO1xufShzdWJwcm92aWRlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFNhbml0aXplclN1YnByb3ZpZGVyO1xuLy8gd2UgdXNlIHRoaXMgdG8gY2xlYW4gYW55IGN1c3RvbSBwYXJhbXMgZnJvbSB0aGUgdHhQYXJhbXNcbnZhciBwZXJtaXR0ZWQgPSBbXG4gICAgJ2Zyb20nLFxuICAgICd0bycsXG4gICAgJ3ZhbHVlJyxcbiAgICAnZGF0YScsXG4gICAgJ2dhcycsXG4gICAgJ2dhc1ByaWNlJyxcbiAgICAnbm9uY2UnLFxuICAgICdmcm9tQmxvY2snLFxuICAgICd0b0Jsb2NrJyxcbiAgICAnYWRkcmVzcycsXG4gICAgJ3RvcGljcycsXG5dO1xuZnVuY3Rpb24gY2xvbmVUeFBhcmFtcyh0eFBhcmFtcykge1xuICAgIHZhciBzYW5pdGl6ZWQgPSBwZXJtaXR0ZWQucmVkdWNlKGZ1bmN0aW9uIChjb3B5LCBwKSB7XG4gICAgICAgIGlmIChwIGluIHR4UGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0eFBhcmFtc1twXSkpIHtcbiAgICAgICAgICAgICAgICBjb3B5W3BdID0gdHhQYXJhbXNbcF0ubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBzYW5pdGl6ZShpdGVtKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3B5W3BdID0gc2FuaXRpemUodHhQYXJhbXNbcF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH0sIHt9KTtcbiAgICByZXR1cm4gc2FuaXRpemVkO1xufVxuZnVuY3Rpb24gc2FuaXRpemUodmFsdWUpIHtcbiAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ2xhdGVzdCc6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgJ3BlbmRpbmcnOlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlICdlYXJsaWVzdCc6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBldGhfdXRpbF8xLmFkZEhleFByZWZpeCh2YWx1ZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHN1YnNjcmlwdGlvbl9lcnJvcl8xID0gcmVxdWlyZShcIi4uL2Vycm9ycy9zdWJzY3JpcHRpb24tZXJyb3JcIik7XG52YXIgZXRoX3V0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsL2V0aC11dGlsXCIpO1xudmFyIHJwY19oZXhfZW5jb2RpbmdfMSA9IHJlcXVpcmUoXCIuLi91dGlsL3JwYy1oZXgtZW5jb2RpbmdcIik7XG52YXIgZmlsdGVyc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2ZpbHRlcnNcIikpO1xudmFyIFN1YnNjcmlwdGlvblN1YnByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWJzY3JpcHRpb25TdWJwcm92aWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdWJzY3JpcHRpb25TdWJwcm92aWRlcihvcHRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN1YnNjcmlwdGlvbnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTdWJzY3JpcHRpb25TdWJwcm92aWRlci5wcm90b3R5cGUuaGFuZGxlUmVxdWVzdCA9IGZ1bmN0aW9uIChwYXlsb2FkLCBuZXh0LCBlbmQpIHtcbiAgICAgICAgc3dpdGNoIChwYXlsb2FkLm1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSAnZXRoX3N1YnNjcmliZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5ldGhfc3Vic2NyaWJlKHBheWxvYWQsIGVuZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdldGhfdW5zdWJzY3JpYmUnOlxuICAgICAgICAgICAgICAgIHRoaXMuZXRoX3Vuc3Vic2NyaWJlKHBheWxvYWQsIGVuZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuaGFuZGxlUmVxdWVzdC5jYWxsKHRoaXMsIHBheWxvYWQsIG5leHQsIGVuZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvblN1YnByb3ZpZGVyLnByb3RvdHlwZS5ldGhfc3Vic2NyaWJlID0gZnVuY3Rpb24gKHBheWxvYWQsIGNiKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb25UeXBlID0gcGF5bG9hZC5wYXJhbXNbMF07XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIChlcnIsIGhleElkKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaWQgPSBwYXJzZUludChoZXhJZCwgMTYpO1xuICAgICAgICAgICAgX3RoaXMuc3Vic2NyaXB0aW9uc1tpZF0gPSBzdWJzY3JpcHRpb25UeXBlO1xuICAgICAgICAgICAgX3RoaXMuZmlsdGVyc1tpZF0ub24oJ2RhdGEnLCBmdW5jdGlvbiAocmVzdWx0cykge1xuICAgICAgICAgICAgICAgIF90aGlzLmZpbHRlcnNbaWRdLmNsZWFyQ2hhbmdlcygpO1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXN1bHRzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gW3Jlc3VsdHNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgcmV0dXJuIF90aGlzLl9ub3RpZmljYXRpb25IYW5kbGVyKGhleElkLCBzdWJzY3JpcHRpb25UeXBlLCByKTsgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb25UeXBlID09PSAnbmV3UGVuZGluZ1RyYW5zYWN0aW9ucycpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jaGVja0ZvclBlbmRpbmdCbG9ja3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNiKG51bGwsIGhleElkKTtcbiAgICAgICAgfTtcbiAgICAgICAgc3dpdGNoIChzdWJzY3JpcHRpb25UeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdsb2dzJzpcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHBheWxvYWQucGFyYW1zWzFdO1xuICAgICAgICAgICAgICAgIHRoaXMubmV3TG9nRmlsdGVyKG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ25ld1BlbmRpbmdUcmFuc2FjdGlvbnMnOlxuICAgICAgICAgICAgICAgIHRoaXMubmV3UGVuZGluZ1RyYW5zYWN0aW9uRmlsdGVyKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ25ld0hlYWRzJzpcbiAgICAgICAgICAgICAgICB0aGlzLm5ld0Jsb2NrRmlsdGVyKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3N5bmNpbmcnOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjYihzdWJzY3JpcHRpb25fZXJyb3JfMS5TdWJzY3JpcHRpb25FcnJvci5VbnN1cHBvcnRlZFR5cGUoc3Vic2NyaXB0aW9uVHlwZSkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uU3VicHJvdmlkZXIucHJvdG90eXBlLmV0aF91bnN1YnNjcmliZSA9IGZ1bmN0aW9uIChwYXlsb2FkLCBjYikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgaGV4SWQgPSBwYXlsb2FkLnBhcmFtc1swXTtcbiAgICAgICAgdmFyIGlkID0gcGFyc2VJbnQoaGV4SWQsIDE2KTtcbiAgICAgICAgaWYgKCF0aGlzLnN1YnNjcmlwdGlvbnNbaWRdKSB7XG4gICAgICAgICAgICBjYihzdWJzY3JpcHRpb25fZXJyb3JfMS5TdWJzY3JpcHRpb25FcnJvci5Ob3RGb3VuZChoZXhJZCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51bmluc3RhbGxGaWx0ZXIoaGV4SWQsIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5zdWJzY3JpcHRpb25zW2lkXTtcbiAgICAgICAgICAgICAgICBjYihlcnIsIHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uU3VicHJvdmlkZXIucHJvdG90eXBlLl9ub3RpZmljYXRpb25IYW5kbGVyID0gZnVuY3Rpb24gKGhleElkLCBzdWJzY3JpcHRpb25UeXBlLCByZXN1bHQpIHtcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvblR5cGUgPT09ICduZXdIZWFkcycpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX25vdGlmaWNhdGlvblJlc3VsdEZyb21CbG9jayhyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGl0IHNlZW1zIHRoYXQgd2ViMyBkb2Vzbid0IGV4cGVjdCB0aGVyZSB0byBiZSBhIHNlcGFyYXRlIGVycm9yIGV2ZW50XG4gICAgICAgIC8vIHNvIHdlIG11c3QgZW1pdCBudWxsIGFsb25nIHdpdGggdGhlIHJlc3VsdCBvYmplY3RcbiAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgbnVsbCwge1xuICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICBtZXRob2Q6ICdldGhfc3Vic2NyaXB0aW9uJyxcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbjogaGV4SWQsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvblN1YnByb3ZpZGVyLnByb3RvdHlwZS5fbm90aWZpY2F0aW9uUmVzdWx0RnJvbUJsb2NrID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoYXNoOiBldGhfdXRpbF8xLmJ1ZmZlclRvSGV4KGJsb2NrLmhhc2gpLFxuICAgICAgICAgICAgcGFyZW50SGFzaDogZXRoX3V0aWxfMS5idWZmZXJUb0hleChibG9jay5wYXJlbnRIYXNoKSxcbiAgICAgICAgICAgIHNoYTNVbmNsZXM6IGV0aF91dGlsXzEuYnVmZmVyVG9IZXgoYmxvY2suc2hhM1VuY2xlcyksXG4gICAgICAgICAgICBtaW5lcjogZXRoX3V0aWxfMS5idWZmZXJUb0hleChibG9jay5taW5lciksXG4gICAgICAgICAgICBzdGF0ZVJvb3Q6IGV0aF91dGlsXzEuYnVmZmVyVG9IZXgoYmxvY2suc3RhdGVSb290KSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uc1Jvb3Q6IGV0aF91dGlsXzEuYnVmZmVyVG9IZXgoYmxvY2sudHJhbnNhY3Rpb25zUm9vdCksXG4gICAgICAgICAgICByZWNlaXB0c1Jvb3Q6IGV0aF91dGlsXzEuYnVmZmVyVG9IZXgoYmxvY2sucmVjZWlwdHNSb290KSxcbiAgICAgICAgICAgIGxvZ3NCbG9vbTogZXRoX3V0aWxfMS5idWZmZXJUb0hleChibG9jay5sb2dzQmxvb20pLFxuICAgICAgICAgICAgZGlmZmljdWx0eTogcnBjX2hleF9lbmNvZGluZ18xLmJ1ZmZlclRvUXVhbnRpdHlIZXgoYmxvY2suZGlmZmljdWx0eSksXG4gICAgICAgICAgICBudW1iZXI6IHJwY19oZXhfZW5jb2RpbmdfMS5idWZmZXJUb1F1YW50aXR5SGV4KGJsb2NrLm51bWJlciksXG4gICAgICAgICAgICBnYXNMaW1pdDogcnBjX2hleF9lbmNvZGluZ18xLmJ1ZmZlclRvUXVhbnRpdHlIZXgoYmxvY2suZ2FzTGltaXQpLFxuICAgICAgICAgICAgZ2FzVXNlZDogcnBjX2hleF9lbmNvZGluZ18xLmJ1ZmZlclRvUXVhbnRpdHlIZXgoYmxvY2suZ2FzVXNlZCksXG4gICAgICAgICAgICBub25jZTogYmxvY2subm9uY2UgPyBldGhfdXRpbF8xLmJ1ZmZlclRvSGV4KGJsb2NrLm5vbmNlKSA6IG51bGwsXG4gICAgICAgICAgICBtaXhIYXNoOiBldGhfdXRpbF8xLmJ1ZmZlclRvSGV4KGJsb2NrLm1peEhhc2gpLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBycGNfaGV4X2VuY29kaW5nXzEuYnVmZmVyVG9RdWFudGl0eUhleChibG9jay50aW1lc3RhbXApLFxuICAgICAgICAgICAgZXh0cmFEYXRhOiBldGhfdXRpbF8xLmJ1ZmZlclRvSGV4KGJsb2NrLmV4dHJhRGF0YSksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gU3Vic2NyaXB0aW9uU3VicHJvdmlkZXI7XG59KGZpbHRlcnNfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBTdWJzY3JpcHRpb25TdWJwcm92aWRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIHRocm93IG1lc3NhZ2UgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNzZXJ0ID0gYXNzZXJ0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXRoX2Jsb2NrX3RyYWNrZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZXRoLWJsb2NrLXRyYWNrZXJcIikpO1xudmFyIGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbnZhciBibG9ja190cmFja2VyX2Vycm9yXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzL2Jsb2NrLXRyYWNrZXItZXJyb3JcIik7XG52YXIgY3JlYXRlX3BheWxvYWRfMSA9IHJlcXVpcmUoXCIuL2NyZWF0ZS1wYXlsb2FkXCIpO1xudmFyIGV0aF91dGlsXzEgPSByZXF1aXJlKFwiLi9ldGgtdXRpbFwiKTtcbi8vIENsYXNzIHJlc3BvbnNpYmxlIGZvciB0cmFja2luZyBuZXcgYmxvY2tzIGFzIHRoZXkgYXJlIG1pbmVkLFxuLy8gbG9hZGluZyB0aGVtLCBwYXJzaW5nIHRoZW0sIGFuZCBhbGVydGluZyBzdWJzY3JpYmVycyB2aWEgZXZlbnRzLlxudmFyIEJsb2NrVHJhY2tlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmxvY2tUcmFja2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJsb2NrVHJhY2tlcihvcHRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIC8vIE51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZWZvcmUgcmV0cnlpbmdcbiAgICAgICAgX3RoaXMuYmxvY2tUaW1lb3V0ID0gMzAwO1xuICAgICAgICAvLyBNYXhpbXVtIGF0dGVtcHRzIHRvIGxvYWQgYSBibG9ja1xuICAgICAgICBfdGhpcy5tYXhCbG9ja1JldHJpZXMgPSAzO1xuICAgICAgICBfdGhpcy5wcm92aWRlciA9IG9wdHMucHJvdmlkZXI7XG4gICAgICAgIF90aGlzLl9ibG9ja1RyYWNrZXIgPSBvcHRzLmJsb2NrVHJhY2tlciB8fCBuZXcgZXRoX2Jsb2NrX3RyYWNrZXJfMS5kZWZhdWx0KF9fYXNzaWduKHt9LCBvcHRzLCB7IHNldFNraXBDYWNoZUZsYWc6IHRydWUgfSkpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEJsb2NrVHJhY2tlci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY3JlYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgIH07XG4gICAgQmxvY2tUcmFja2VyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3lTdWJzY3JpcHRpb25zKCk7XG4gICAgfTtcbiAgICBCbG9ja1RyYWNrZXIucHJvdG90eXBlLmZldGNoTGF0ZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5fYmxvY2tUcmFja2VyLmNoZWNrRm9yTGF0ZXN0QmxvY2soKS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJsb2NrVHJhY2tlci5wcm90b3R5cGUuY3JlYXRlU3Vic2NyaXB0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gb24gbmV3IGJsb2NrLCByZXF1ZXN0IGJsb2NrIGJvZHkgYW5kIGVtaXQgYXMgZXZlbnRzXG4gICAgICAgIHRoaXMuX2Jsb2NrVHJhY2tlci5vbignbGF0ZXN0JywgdGhpcy5vbkxhdGVzdC5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy8gZm9yd2FyZCBvdGhlciBldmVudHNcbiAgICAgICAgdGhpcy5fYmxvY2tUcmFja2VyLm9uKCdzeW5jJywgdGhpcy5lbWl0LmJpbmQodGhpcywgJ3N5bmMnKSk7XG4gICAgICAgIHRoaXMuX2Jsb2NrVHJhY2tlci5vbignZXJyb3InLCB0aGlzLmVtaXQuYmluZCh0aGlzLCAnZXJyb3InKSk7XG4gICAgfTtcbiAgICBCbG9ja1RyYWNrZXIucHJvdG90eXBlLmRlc3Ryb3lTdWJzY3JpcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBzdG9wIGJsb2NrIHBvbGxpbmcgYnkgcmVtb3ZpbmcgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIHRoaXMuX2Jsb2NrVHJhY2tlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB9O1xuICAgIEJsb2NrVHJhY2tlci5wcm90b3R5cGUub25MYXRlc3QgPSBmdW5jdGlvbiAoYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50QmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcbiAgICAgICAgdGhpcy5sb2FkQmxvY2soYmxvY2tOdW1iZXIpO1xuICAgIH07XG4gICAgLy8gVHJpZXMgdG8gZ2V0IHRoZSBibG9jayBwYXlsb2FkIHJlY3Vyc2l2ZWx5XG4gICAgQmxvY2tUcmFja2VyLnByb3RvdHlwZS5sb2FkQmxvY2sgPSBmdW5jdGlvbiAoYmxvY2tOdW1iZXIsIGNhbGxDb3VudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoY2FsbENvdW50ID09PSB2b2lkIDApIHsgY2FsbENvdW50ID0gMDsgfVxuICAgICAgICB0aGlzLl9nZXRCbG9ja0J5TnVtYmVyKGJsb2NrTnVtYmVyKS50aGVuKGZ1bmN0aW9uIChibG9ja1Jlc3BvbnNlKSB7XG4gICAgICAgICAgICAvLyBSZXN1bHQgY2FuIGJlIG51bGwgaWYgdGhlIGJsb2NrIGhhc24ndCBmdWxseSBwcm9wYWdhdGVkIHRvIHRoZSBub2Rlc1xuICAgICAgICAgICAgaWYgKGJsb2NrUmVzcG9uc2UucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlQmxvY2soYmxvY2tSZXNwb25zZS5yZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2FsbENvdW50IDwgX3RoaXMubWF4QmxvY2tSZXRyaWVzICYmIGJsb2NrTnVtYmVyID09PSBfdGhpcy5jdXJyZW50QmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGNhbGwgcmVjdXJzaXZlbHkgaWYgdGhlIGN1cnJlbnQgYmxvY2sgbnVtYmVyIGlzIHN0aWxsIHRoZSBzYW1lXG4gICAgICAgICAgICAgICAgLy8gYW5kIGlmIHdlIGFyZSB1bmRlciB0aGUgcmV0cnkgbGltaXQuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxvYWRCbG9jayhibG9ja051bWJlciwgY2FsbENvdW50ICsgMSk7XG4gICAgICAgICAgICAgICAgfSwgX3RoaXMuYmxvY2tUaW1lb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGJsb2NrX3RyYWNrZXJfZXJyb3JfMS5CbG9ja1RyYWNrZXJFcnJvci5CbG9ja05vdEZvdW5kKGJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgLy8gRG9uJ3QgcmV0cnkgZm9yIGVycm9ycyAocHJvdmlkZXIgc2hvdWxkIGhhdmUgYWxyZWFkeSByZXRyaWVkKVxuICAgICAgICAgICAgX3RoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJsb2NrVHJhY2tlci5wcm90b3R5cGUuX2dldEJsb2NrQnlOdW1iZXIgPSBmdW5jdGlvbiAoYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJlcSA9IGNyZWF0ZV9wYXlsb2FkXzEuY3JlYXRlUGF5bG9hZCh7IG1ldGhvZDogJ2V0aF9nZXRCbG9ja0J5TnVtYmVyJywgcGFyYW1zOiBbYmxvY2tOdW1iZXIsIGZhbHNlXSwgc2tpcENhY2hlOiB0cnVlIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xuICAgICAgICAgICAgX3RoaXMucHJvdmlkZXIuc2VuZEFzeW5jKHJlcSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bGZpbGwocmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIFBhcnNlIHRoZSBibG9jayBpbnRvIGEgYnVmZmVyIHJlcHJlc2VudGF0aW9uIGFuZCB1cGRhdGUgc3Vic2NyaWJlcnMuXG4gICAgQmxvY2tUcmFja2VyLnByb3RvdHlwZS51cGRhdGVCbG9jayA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB2YXIgYnVmZmVyQmxvY2sgPSB0b0J1ZmZlckJsb2NrKGJsb2NrKTtcbiAgICAgICAgLy8gc2V0IGN1cnJlbnQgKyBlbWl0IFwiYmxvY2tcIiBldmVudFxuICAgICAgICB0aGlzLl9zZXRDdXJyZW50QmxvY2soYnVmZmVyQmxvY2spO1xuICAgICAgICAvLyBlbWl0IG90aGVyIGV2ZW50c1xuICAgICAgICB0aGlzLmVtaXQoJ3Jhd0Jsb2NrJywgYmxvY2spO1xuICAgICAgICB0aGlzLmVtaXQoJ2xhdGVzdCcsIGJsb2NrKTtcbiAgICB9O1xuICAgIEJsb2NrVHJhY2tlci5wcm90b3R5cGUuX3NldEN1cnJlbnRCbG9jayA9IGZ1bmN0aW9uIChidWZmZXJCbG9jaykge1xuICAgICAgICB0aGlzLmN1cnJlbnRCbG9jayA9IGJ1ZmZlckJsb2NrO1xuICAgICAgICB0aGlzLmVtaXQoJ2Jsb2NrJywgYnVmZmVyQmxvY2spO1xuICAgIH07XG4gICAgcmV0dXJuIEJsb2NrVHJhY2tlcjtcbn0oZXZlbnRzXzEuRXZlbnRFbWl0dGVyKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBCbG9ja1RyYWNrZXI7XG4vLyB1dGlsXG5mdW5jdGlvbiB0b0J1ZmZlckJsb2NrKGpzb25CbG9jaykge1xuICAgIHJldHVybiB7XG4gICAgICAgIG51bWJlcjogZXRoX3V0aWxfMS50b0J1ZmZlcihqc29uQmxvY2subnVtYmVyKSxcbiAgICAgICAgaGFzaDogZXRoX3V0aWxfMS50b0J1ZmZlcihqc29uQmxvY2suaGFzaCksXG4gICAgICAgIHBhcmVudEhhc2g6IGV0aF91dGlsXzEudG9CdWZmZXIoanNvbkJsb2NrLnBhcmVudEhhc2gpLFxuICAgICAgICBub25jZTogZXRoX3V0aWxfMS50b0J1ZmZlcihqc29uQmxvY2subm9uY2UpLFxuICAgICAgICBtaXhIYXNoOiBldGhfdXRpbF8xLnRvQnVmZmVyKGpzb25CbG9jay5taXhIYXNoKSxcbiAgICAgICAgc2hhM1VuY2xlczogZXRoX3V0aWxfMS50b0J1ZmZlcihqc29uQmxvY2suc2hhM1VuY2xlcyksXG4gICAgICAgIGxvZ3NCbG9vbTogZXRoX3V0aWxfMS50b0J1ZmZlcihqc29uQmxvY2subG9nc0Jsb29tKSxcbiAgICAgICAgdHJhbnNhY3Rpb25zUm9vdDogZXRoX3V0aWxfMS50b0J1ZmZlcihqc29uQmxvY2sudHJhbnNhY3Rpb25zUm9vdCksXG4gICAgICAgIHN0YXRlUm9vdDogZXRoX3V0aWxfMS50b0J1ZmZlcihqc29uQmxvY2suc3RhdGVSb290KSxcbiAgICAgICAgcmVjZWlwdHNSb290OiBldGhfdXRpbF8xLnRvQnVmZmVyKGpzb25CbG9jay5yZWNlaXB0c1Jvb3QpLFxuICAgICAgICBtaW5lcjogZXRoX3V0aWxfMS50b0J1ZmZlcihqc29uQmxvY2subWluZXIpLFxuICAgICAgICBkaWZmaWN1bHR5OiBldGhfdXRpbF8xLnRvQnVmZmVyKGpzb25CbG9jay5kaWZmaWN1bHR5KSxcbiAgICAgICAgdG90YWxEaWZmaWN1bHR5OiBldGhfdXRpbF8xLnRvQnVmZmVyKGpzb25CbG9jay50b3RhbERpZmZpY3VsdHkpLFxuICAgICAgICBzaXplOiBldGhfdXRpbF8xLnRvQnVmZmVyKGpzb25CbG9jay5zaXplKSxcbiAgICAgICAgZXh0cmFEYXRhOiBldGhfdXRpbF8xLnRvQnVmZmVyKGpzb25CbG9jay5leHRyYURhdGEpLFxuICAgICAgICBnYXNMaW1pdDogZXRoX3V0aWxfMS50b0J1ZmZlcihqc29uQmxvY2suZ2FzTGltaXQpLFxuICAgICAgICBnYXNVc2VkOiBldGhfdXRpbF8xLnRvQnVmZmVyKGpzb25CbG9jay5nYXNVc2VkKSxcbiAgICAgICAgdGltZXN0YW1wOiBldGhfdXRpbF8xLnRvQnVmZmVyKGpzb25CbG9jay50aW1lc3RhbXApLFxuICAgICAgICB0cmFuc2FjdGlvbnM6IGpzb25CbG9jay50cmFuc2FjdGlvbnMsXG4gICAgfTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHh0ZW5kXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInh0ZW5kXCIpKTtcbnZhciByYW5kb21faWRfMSA9IHJlcXVpcmUoXCIuL3JhbmRvbS1pZFwiKTtcbmZ1bmN0aW9uIGNyZWF0ZVBheWxvYWQoZGF0YSkge1xuICAgIHJldHVybiB4dGVuZF8xLmRlZmF1bHQoe1xuICAgICAgICAvLyBkZWZhdWx0c1xuICAgICAgICBpZDogcmFuZG9tX2lkXzEuY3JlYXRlUmFuZG9tSWQoKSxcbiAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgIHBhcmFtczogW10sXG4gICAgfSwgZGF0YSk7XG59XG5leHBvcnRzLmNyZWF0ZVBheWxvYWQgPSBjcmVhdGVQYXlsb2FkO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYm5fanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYm4uanNcIikpO1xudmFyIGV0aGpzX3V0aWxfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZXRoanMtdXRpbFwiKSk7XG4vLyBNZXRob2RzIGZyb20gZXRoZXJldW1qcy11dGlsXG4vKipcbiAqIEF0dGVtcHRzIHRvIHR1cm4gYSB2YWx1ZSBpbnRvIGEgYEJ1ZmZlcmAuIEFzIGlucHV0IGl0IHN1cHBvcnRzXG4gKiBgQnVmZmVyYCwgYFN0cmluZ2AsIGBOdW1iZXJgLCBudWxsL3VuZGVmaW5lZCwgYEJOYCBhbmQgb3RoZXIgb2JqZWN0cyB3aXRoIGEgYHRvQXJyYXkoKWAgbWV0aG9kLlxuICogQHBhcmFtIHYgdGhlIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRvQnVmZmVyKHYpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2KSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgdiA9IEJ1ZmZlci5mcm9tKHYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKGV0aGpzX3V0aWxfMS5kZWZhdWx0LmlzSGV4U3RyaW5nKHYpKSB7XG4gICAgICAgICAgICAgICAgdiA9IEJ1ZmZlci5mcm9tKGV0aGpzX3V0aWxfMS5kZWZhdWx0LnBhZFRvRXZlbihldGhqc191dGlsXzEuZGVmYXVsdC5zdHJpcEhleFByZWZpeCh2KSksICdoZXgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBtYXgtbGluZS1sZW5ndGhcbiAgICAgICAgICAgICAgICBcIkNhbm5vdCBjb252ZXJ0IHN0cmluZyB0byBidWZmZXIuIHRvQnVmZmVyIG9ubHkgc3VwcG9ydHMgMHgtcHJlZml4ZWQgaGV4IHN0cmluZ3MgYW5kIHRoaXMgc3RyaW5nIHdhcyBnaXZlbjogXCIgKyB2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHYgPSBldGhqc191dGlsXzEuZGVmYXVsdC5pbnRUb0J1ZmZlcih2KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2ID09PSBudWxsIHx8IHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChibl9qc18xLmRlZmF1bHQuaXNCTih2KSkge1xuICAgICAgICAgICAgdiA9IHYudG9BcnJheUxpa2UoQnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2LnRvQXJyYXkpIHtcbiAgICAgICAgICAgIC8vIGNvbnZlcnRzIGEgQk4gdG8gYSBCdWZmZXJcbiAgICAgICAgICAgIHYgPSBCdWZmZXIuZnJvbSh2LnRvQXJyYXkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCB0eXBlOiBcIiArIHYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2O1xufVxuZXhwb3J0cy50b0J1ZmZlciA9IHRvQnVmZmVyO1xuLyoqXG4gKiBBZGRzIFwiMHhcIiB0byBhIGdpdmVuIGBTdHJpbmdgIGlmIGl0IGRvZXMgbm90IGFscmVhZHkgc3RhcnQgd2l0aCBcIjB4XCIuXG4gKi9cbmZ1bmN0aW9uIGFkZEhleFByZWZpeChzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgcmV0dXJuIGV0aGpzX3V0aWxfMS5kZWZhdWx0LmlzSGV4UHJlZml4ZWQoc3RyKSA/IHN0ciA6ICcweCcgKyBzdHI7XG59XG5leHBvcnRzLmFkZEhleFByZWZpeCA9IGFkZEhleFByZWZpeDtcbmZ1bmN0aW9uIHN0cmlwSGV4UHJlZml4KHN0cikge1xuICAgIHJldHVybiBldGhqc191dGlsXzEuZGVmYXVsdC5zdHJpcEhleFByZWZpeChzdHIpO1xufVxuZXhwb3J0cy5zdHJpcEhleFByZWZpeCA9IHN0cmlwSGV4UHJlZml4O1xuZnVuY3Rpb24gaW50VG9IZXgobikge1xuICAgIHJldHVybiBldGhqc191dGlsXzEuZGVmYXVsdC5pbnRUb0hleChuKTtcbn1cbmV4cG9ydHMuaW50VG9IZXggPSBpbnRUb0hleDtcbmZ1bmN0aW9uIGludFRvQnVmZmVyKG4pIHtcbiAgICByZXR1cm4gZXRoanNfdXRpbF8xLmRlZmF1bHQuaW50VG9CdWZmZXIobik7XG59XG5leHBvcnRzLmludFRvQnVmZmVyID0gaW50VG9CdWZmZXI7XG4vKipcbiAqIENvbnZlcnRzIGEgYEJ1ZmZlcmAgaW50byBhIGhleCBgU3RyaW5nYC5cbiAqIEBwYXJhbSBidWYgYEJ1ZmZlcmAgb2JqZWN0IHRvIGNvbnZlcnRcbiAqL1xuZnVuY3Rpb24gYnVmZmVyVG9IZXgoYnVmKSB7XG4gICAgYnVmID0gdG9CdWZmZXIoYnVmKTtcbiAgICByZXR1cm4gJzB4JyArIGJ1Zi50b1N0cmluZygnaGV4Jyk7XG59XG5leHBvcnRzLmJ1ZmZlclRvSGV4ID0gYnVmZmVyVG9IZXg7XG4vKipcbiAqIENvbnZlcnRzIGEgYEJ1ZmZlcmAgdG8gYSBgTnVtYmVyYC5cbiAqIEBwYXJhbSBidWYgYEJ1ZmZlcmAgb2JqZWN0IHRvIGNvbnZlcnRcbiAqIEB0aHJvd3MgSWYgdGhlIGlucHV0IG51bWJlciBleGNlZWRzIDUzIGJpdHMuXG4gKi9cbmZ1bmN0aW9uIGJ1ZmZlclRvSW50KGJ1Zikge1xuICAgIHJldHVybiBuZXcgYm5fanNfMS5kZWZhdWx0KHRvQnVmZmVyKGJ1ZikpLnRvTnVtYmVyKCk7XG59XG5leHBvcnRzLmJ1ZmZlclRvSW50ID0gYnVmZmVyVG9JbnQ7XG4vKipcbiAqIFRyaW1zIGxlYWRpbmcgemVyb3MgZnJvbSBhIGBCdWZmZXJgIG9yIGFuIGBBcnJheWAuXG4gKiBAcGFyYW0gYSAoQnVmZmVyfEFycmF5fFN0cmluZylcbiAqIEByZXR1cm4gKEJ1ZmZlcnxBcnJheXxTdHJpbmcpXG4gKi9cbmZ1bmN0aW9uIHVucGFkKGEpIHtcbiAgICBhID0gZXRoanNfdXRpbF8xLmRlZmF1bHQuc3RyaXBIZXhQcmVmaXgoYSk7XG4gICAgdmFyIGZpcnN0ID0gYVswXTtcbiAgICB3aGlsZSAoYS5sZW5ndGggPiAwICYmIGZpcnN0LnRvU3RyaW5nKCkgPT09ICcwJykge1xuICAgICAgICBhID0gYS5zbGljZSgxKTtcbiAgICAgICAgZmlyc3QgPSBhWzBdO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn1cbmV4cG9ydHMudW5wYWQgPSB1bnBhZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gZ290dGEga2VlcCBpdCB3aXRoaW4gTUFYX1NBRkVfSU5URUdFUlxudmFyIGV4dHJhRGlnaXRzID0gMztcbmZ1bmN0aW9uIGNyZWF0ZVJhbmRvbUlkKCkge1xuICAgIC8vIDEzIHRpbWUgZGlnaXRzXG4gICAgdmFyIGRhdGVQYXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgKiBNYXRoLnBvdygxMCwgZXh0cmFEaWdpdHMpO1xuICAgIC8vIDMgcmFuZG9tIGRpZ2l0c1xuICAgIHZhciBleHRyYVBhcnQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygxMCwgZXh0cmFEaWdpdHMpKTtcbiAgICAvLyAxNiBkaWdpdHNcbiAgICByZXR1cm4gZGF0ZVBhcnQgKyBleHRyYVBhcnQ7XG59XG5leHBvcnRzLmNyZWF0ZVJhbmRvbUlkID0gY3JlYXRlUmFuZG9tSWQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBqc29uX3N0YWJsZV9zdHJpbmdpZnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwianNvbi1zdGFibGUtc3RyaW5naWZ5XCIpKTtcbmZ1bmN0aW9uIGNhY2hlSWRlbnRpZmllckZvclBheWxvYWQocGF5bG9hZCwgb3B0cykge1xuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHsgb3B0cyA9IHt9OyB9XG4gICAgaWYgKCFjYW5DYWNoZShwYXlsb2FkKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGluY2x1ZGVCbG9ja1JlZiA9IG9wdHMuaW5jbHVkZUJsb2NrUmVmO1xuICAgIHZhciBwYXJhbXMgPSBpbmNsdWRlQmxvY2tSZWYgPyBwYXlsb2FkLnBhcmFtcyA6IHBhcmFtc1dpdGhvdXRCbG9ja1RhZyhwYXlsb2FkKTtcbiAgICByZXR1cm4gcGF5bG9hZC5tZXRob2QgKyAnOicgKyBqc29uX3N0YWJsZV9zdHJpbmdpZnlfMS5kZWZhdWx0KHBhcmFtcyk7XG59XG5leHBvcnRzLmNhY2hlSWRlbnRpZmllckZvclBheWxvYWQgPSBjYWNoZUlkZW50aWZpZXJGb3JQYXlsb2FkO1xuZnVuY3Rpb24gY2FuQ2FjaGUocGF5bG9hZCkge1xuICAgIHJldHVybiBjYWNoZVR5cGVGb3JQYXlsb2FkKHBheWxvYWQpICE9PSAnbmV2ZXInO1xufVxuZXhwb3J0cy5jYW5DYWNoZSA9IGNhbkNhY2hlO1xuZnVuY3Rpb24gYmxvY2tUYWdGb3JQYXlsb2FkKHBheWxvYWQpIHtcbiAgICB2YXIgaW5kZXggPSBibG9ja1RhZ1BhcmFtSW5kZXgocGF5bG9hZCk7XG4gICAgLy8gQmxvY2sgdGFnIHBhcmFtIG5vdCBwYXNzZWQuXG4gICAgaWYgKGluZGV4ID49IHBheWxvYWQucGFyYW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHBheWxvYWQucGFyYW1zW2luZGV4XTtcbn1cbmV4cG9ydHMuYmxvY2tUYWdGb3JQYXlsb2FkID0gYmxvY2tUYWdGb3JQYXlsb2FkO1xuZnVuY3Rpb24gcGFyYW1zV2l0aG91dEJsb2NrVGFnKHBheWxvYWQpIHtcbiAgICB2YXIgaW5kZXggPSBibG9ja1RhZ1BhcmFtSW5kZXgocGF5bG9hZCk7XG4gICAgLy8gQmxvY2sgdGFnIHBhcmFtIG5vdCBwYXNzZWQuXG4gICAgaWYgKGluZGV4ID49IHBheWxvYWQucGFyYW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcGF5bG9hZC5wYXJhbXM7XG4gICAgfVxuICAgIC8vIGV0aF9nZXRCbG9ja0J5TnVtYmVyIGhhcyB0aGUgYmxvY2sgdGFnIGZpcnN0LCB0aGVuIHRoZSBvcHRpb25hbCBpbmNsdWRlVHg/IHBhcmFtXG4gICAgaWYgKHBheWxvYWQubWV0aG9kID09PSAnZXRoX2dldEJsb2NrQnlOdW1iZXInKSB7XG4gICAgICAgIHJldHVybiBwYXlsb2FkLnBhcmFtcy5zbGljZSgxKTtcbiAgICB9XG4gICAgcmV0dXJuIHBheWxvYWQucGFyYW1zLnNsaWNlKDAsIGluZGV4KTtcbn1cbmV4cG9ydHMucGFyYW1zV2l0aG91dEJsb2NrVGFnID0gcGFyYW1zV2l0aG91dEJsb2NrVGFnO1xuZnVuY3Rpb24gYmxvY2tUYWdQYXJhbUluZGV4KHBheWxvYWQpIHtcbiAgICBzd2l0Y2ggKHBheWxvYWQubWV0aG9kKSB7XG4gICAgICAgIC8vIGJsb2NrVGFnIGlzIHRoaXJkIHBhcmFtXG4gICAgICAgIGNhc2UgJ2V0aF9nZXRTdG9yYWdlQXQnOlxuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIC8vIGJsb2NrVGFnIGlzIHNlY29uZCBwYXJhbVxuICAgICAgICBjYXNlICdldGhfZ2V0QmFsYW5jZSc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRDb2RlJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFRyYW5zYWN0aW9uQ291bnQnOlxuICAgICAgICBjYXNlICdldGhfY2FsbCc6XG4gICAgICAgIGNhc2UgJ2V0aF9lc3RpbWF0ZUdhcyc6XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgLy8gYmxvY2tUYWcgaXMgZmlyc3QgcGFyYW1cbiAgICAgICAgY2FzZSAnZXRoX2dldEJsb2NrQnlOdW1iZXInOlxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIC8vIHRoZXJlIGlzIG5vIGJsb2NrVGFnXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmV4cG9ydHMuYmxvY2tUYWdQYXJhbUluZGV4ID0gYmxvY2tUYWdQYXJhbUluZGV4O1xuZnVuY3Rpb24gY2FjaGVUeXBlRm9yUGF5bG9hZChwYXlsb2FkKSB7XG4gICAgc3dpdGNoIChwYXlsb2FkLm1ldGhvZCkge1xuICAgICAgICAvLyBjYWNoZSBwZXJtYW5lbnRseVxuICAgICAgICBjYXNlICduZXRfdmVyc2lvbic6XG4gICAgICAgIGNhc2UgJ3dlYjNfY2xpZW50VmVyc2lvbic6XG4gICAgICAgIGNhc2UgJ3dlYjNfc2hhMyc6XG4gICAgICAgIGNhc2UgJ2V0aF9wcm90b2NvbFZlcnNpb24nOlxuICAgICAgICBjYXNlICdldGhfZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50QnlIYXNoJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFVuY2xlQ291bnRCeUJsb2NrSGFzaCc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRDb2RlJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldEJsb2NrQnlIYXNoJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFRyYW5zYWN0aW9uQnlCbG9ja0hhc2hBbmRJbmRleCc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHQnOlxuICAgICAgICBjYXNlICdldGhfZ2V0VW5jbGVCeUJsb2NrSGFzaEFuZEluZGV4JzpcbiAgICAgICAgY2FzZSAnZXRoX2dldENvbXBpbGVycyc6XG4gICAgICAgIGNhc2UgJ2V0aF9jb21waWxlTExMJzpcbiAgICAgICAgY2FzZSAnZXRoX2NvbXBpbGVTb2xpZGl0eSc6XG4gICAgICAgIGNhc2UgJ2V0aF9jb21waWxlU2VycGVudCc6XG4gICAgICAgIGNhc2UgJ3NoaF92ZXJzaW9uJzpcbiAgICAgICAgICAgIHJldHVybiAncGVybWEnO1xuICAgICAgICAvLyBjYWNoZSB1bnRpbCBmb3JrXG4gICAgICAgIGNhc2UgJ2V0aF9nZXRCbG9ja0J5TnVtYmVyJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldEJsb2NrVHJhbnNhY3Rpb25Db3VudEJ5TnVtYmVyJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFVuY2xlQ291bnRCeUJsb2NrTnVtYmVyJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFRyYW5zYWN0aW9uQnlCbG9ja051bWJlckFuZEluZGV4JzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFVuY2xlQnlCbG9ja051bWJlckFuZEluZGV4JzpcbiAgICAgICAgICAgIHJldHVybiAnZm9yayc7XG4gICAgICAgIC8vIGNhY2hlIGZvciBibG9ja1xuICAgICAgICBjYXNlICdldGhfZ2FzUHJpY2UnOlxuICAgICAgICBjYXNlICdldGhfYmxvY2tOdW1iZXInOlxuICAgICAgICBjYXNlICdldGhfZ2V0QmFsYW5jZSc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRTdG9yYWdlQXQnOlxuICAgICAgICBjYXNlICdldGhfZ2V0VHJhbnNhY3Rpb25Db3VudCc6XG4gICAgICAgIGNhc2UgJ2V0aF9jYWxsJzpcbiAgICAgICAgY2FzZSAnZXRoX2VzdGltYXRlR2FzJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldEZpbHRlckxvZ3MnOlxuICAgICAgICBjYXNlICdldGhfZ2V0TG9ncyc6XG4gICAgICAgIGNhc2UgJ25ldF9wZWVyQ291bnQnOlxuICAgICAgICAgICAgcmV0dXJuICdibG9jayc7XG4gICAgICAgIC8vIG5ldmVyIGNhY2hlXG4gICAgICAgIGNhc2UgJ25ldF9wZWVyQ291bnQnOlxuICAgICAgICBjYXNlICduZXRfbGlzdGVuaW5nJzpcbiAgICAgICAgY2FzZSAnZXRoX3N5bmNpbmcnOlxuICAgICAgICBjYXNlICdldGhfc2lnbic6XG4gICAgICAgIGNhc2UgJ2V0aF9jb2luYmFzZSc6XG4gICAgICAgIGNhc2UgJ2V0aF9taW5pbmcnOlxuICAgICAgICBjYXNlICdldGhfaGFzaHJhdGUnOlxuICAgICAgICBjYXNlICdldGhfYWNjb3VudHMnOlxuICAgICAgICBjYXNlICdldGhfc2VuZFRyYW5zYWN0aW9uJzpcbiAgICAgICAgY2FzZSAnZXRoX3NlbmRSYXdUcmFuc2FjdGlvbic6XG4gICAgICAgIGNhc2UgJ2V0aF9uZXdGaWx0ZXInOlxuICAgICAgICBjYXNlICdldGhfbmV3QmxvY2tGaWx0ZXInOlxuICAgICAgICBjYXNlICdldGhfbmV3UGVuZGluZ1RyYW5zYWN0aW9uRmlsdGVyJzpcbiAgICAgICAgY2FzZSAnZXRoX3VuaW5zdGFsbEZpbHRlcic6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRGaWx0ZXJDaGFuZ2VzJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFdvcmsnOlxuICAgICAgICBjYXNlICdldGhfc3VibWl0V29yayc6XG4gICAgICAgIGNhc2UgJ2V0aF9zdWJtaXRIYXNocmF0ZSc6XG4gICAgICAgIGNhc2UgJ2RiX3B1dFN0cmluZyc6XG4gICAgICAgIGNhc2UgJ2RiX2dldFN0cmluZyc6XG4gICAgICAgIGNhc2UgJ2RiX3B1dEhleCc6XG4gICAgICAgIGNhc2UgJ2RiX2dldEhleCc6XG4gICAgICAgIGNhc2UgJ3NoaF9wb3N0JzpcbiAgICAgICAgY2FzZSAnc2hoX25ld0lkZW50aXR5JzpcbiAgICAgICAgY2FzZSAnc2hoX2hhc0lkZW50aXR5JzpcbiAgICAgICAgY2FzZSAnc2hoX25ld0dyb3VwJzpcbiAgICAgICAgY2FzZSAnc2hoX2FkZFRvR3JvdXAnOlxuICAgICAgICBjYXNlICdzaGhfbmV3RmlsdGVyJzpcbiAgICAgICAgY2FzZSAnc2hoX3VuaW5zdGFsbEZpbHRlcic6XG4gICAgICAgIGNhc2UgJ3NoaF9nZXRGaWx0ZXJDaGFuZ2VzJzpcbiAgICAgICAgY2FzZSAnc2hoX2dldE1lc3NhZ2VzJzpcbiAgICAgICAgICAgIHJldHVybiAnbmV2ZXInO1xuICAgIH1cbn1cbmV4cG9ydHMuY2FjaGVUeXBlRm9yUGF5bG9hZCA9IGNhY2hlVHlwZUZvclBheWxvYWQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydFwiKTtcbnZhciBldGhfdXRpbF8xID0gcmVxdWlyZShcIi4vZXRoLXV0aWxcIik7XG4vKlxuICogQXMgcGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvSlNPTi1SUEMjaGV4LXZhbHVlLWVuY29kaW5nXG4gKiBRdWFudGl0aWVzIHNob3VsZCBiZSByZXByZXNlbnRlZCBieSB0aGUgbW9zdCBjb21wYWN0IGhleCByZXByZXNlbnRhdGlvbiBwb3NzaWJsZVxuICogVGhpcyBtZWFucyB0aGF0IG5vIGxlYWRpbmcgemVyb2VzIGFyZSBhbGxvd2VkLiBUaGVyZSBoZWxwZXJzIG1ha2UgaXQgZWFzeVxuICogdG8gY29udmVydCB0byBhbmQgZnJvbSBpbnRlZ2VycyBhbmQgdGhlaXIgY29tcGFjdCBoZXggcmVwcmVzZW50YXRpb25cbiAqL1xuZnVuY3Rpb24gYnVmZmVyVG9RdWFudGl0eUhleChidWZmZXIpIHtcbiAgICBidWZmZXIgPSBldGhfdXRpbF8xLnRvQnVmZmVyKGJ1ZmZlcik7XG4gICAgdmFyIGhleCA9IGJ1ZmZlci50b1N0cmluZygnaGV4Jyk7XG4gICAgdmFyIHRyaW1tZWQgPSBldGhfdXRpbF8xLnVucGFkKGhleCk7XG4gICAgcmV0dXJuIGV0aF91dGlsXzEuYWRkSGV4UHJlZml4KHRyaW1tZWQpO1xufVxuZXhwb3J0cy5idWZmZXJUb1F1YW50aXR5SGV4ID0gYnVmZmVyVG9RdWFudGl0eUhleDtcbmZ1bmN0aW9uIGludFRvUXVhbnRpdHlIZXgobikge1xuICAgIGFzc2VydF8xLmFzc2VydCh0eXBlb2YgbiA9PT0gJ251bWJlcicgJiYgbiA9PT0gTWF0aC5mbG9vcihuKSwgJ2ludFRvUXVhbnRpdHlIZXggYXJnIG11c3QgYmUgYW4gaW50ZWdlcicpO1xuICAgIHZhciBuSGV4ID0gZXRoX3V0aWxfMS50b0J1ZmZlcihuKS50b1N0cmluZygnaGV4Jyk7XG4gICAgaWYgKG5IZXhbMF0gPT09ICcwJykge1xuICAgICAgICBuSGV4ID0gbkhleC5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICAgIHJldHVybiBldGhfdXRpbF8xLmFkZEhleFByZWZpeChuSGV4KTtcbn1cbmV4cG9ydHMuaW50VG9RdWFudGl0eUhleCA9IGludFRvUXVhbnRpdHlIZXg7XG5mdW5jdGlvbiBxdWFudGl0eUhleFRvSW50KHByZWZpeGVkUXVhbnRpdHlIZXgpIHtcbiAgICBhc3NlcnRfMS5hc3NlcnQodHlwZW9mIHByZWZpeGVkUXVhbnRpdHlIZXggPT09ICdzdHJpbmcnLCAnYXJnIHRvIHF1YW50aXR5SGV4VG9JbnQgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIHZhciBxdWFudGl0eUhleCA9IGV0aF91dGlsXzEuc3RyaXBIZXhQcmVmaXgocHJlZml4ZWRRdWFudGl0eUhleCk7XG4gICAgdmFyIGlzRXZlbiA9IHF1YW50aXR5SGV4Lmxlbmd0aCAlIDIgPT09IDA7XG4gICAgaWYgKCFpc0V2ZW4pIHtcbiAgICAgICAgcXVhbnRpdHlIZXggPSAnMCcgKyBxdWFudGl0eUhleDtcbiAgICB9XG4gICAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIocXVhbnRpdHlIZXgsICdoZXgnKTtcbiAgICByZXR1cm4gZXRoX3V0aWxfMS5idWZmZXJUb0ludChidWYpO1xufVxuZXhwb3J0cy5xdWFudGl0eUhleFRvSW50ID0gcXVhbnRpdHlIZXhUb0ludDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xudmFyIFN0b3BsaWdodCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3RvcGxpZ2h0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN0b3BsaWdodCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaXNMb2NrZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFN0b3BsaWdodC5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNMb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbWl0KCd1bmxvY2snKTtcbiAgICB9O1xuICAgIFN0b3BsaWdodC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pc0xvY2tlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdCgnbG9jaycpO1xuICAgIH07XG4gICAgU3RvcGxpZ2h0LnByb3RvdHlwZS5hd2FpdCA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICBpZiAodGhpcy5pc0xvY2tlZCkge1xuICAgICAgICAgICAgdGhpcy5vbmNlKCd1bmxvY2snLCBmbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZuKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN0b3BsaWdodDtcbn0oZXZlbnRzXzEuRXZlbnRFbWl0dGVyKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBTdG9wbGlnaHQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGFzeW5jaWZ5O1xuXG52YXIgX2luaXRpYWxQYXJhbXMgPSByZXF1aXJlKCcuL2ludGVybmFsL2luaXRpYWxQYXJhbXMnKTtcblxudmFyIF9pbml0aWFsUGFyYW1zMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaXRpYWxQYXJhbXMpO1xuXG52YXIgX3NldEltbWVkaWF0ZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc2V0SW1tZWRpYXRlJyk7XG5cbnZhciBfc2V0SW1tZWRpYXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NldEltbWVkaWF0ZSk7XG5cbnZhciBfd3JhcEFzeW5jID0gcmVxdWlyZSgnLi9pbnRlcm5hbC93cmFwQXN5bmMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBUYWtlIGEgc3luYyBmdW5jdGlvbiBhbmQgbWFrZSBpdCBhc3luYywgcGFzc2luZyBpdHMgcmV0dXJuIHZhbHVlIHRvIGFcbiAqIGNhbGxiYWNrLiBUaGlzIGlzIHVzZWZ1bCBmb3IgcGx1Z2dpbmcgc3luYyBmdW5jdGlvbnMgaW50byBhIHdhdGVyZmFsbCxcbiAqIHNlcmllcywgb3Igb3RoZXIgYXN5bmMgZnVuY3Rpb25zLiBBbnkgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZ2VuZXJhdGVkXG4gKiBmdW5jdGlvbiB3aWxsIGJlIHBhc3NlZCB0byB0aGUgd3JhcHBlZCBmdW5jdGlvbiAoZXhjZXB0IGZvciB0aGUgZmluYWxcbiAqIGNhbGxiYWNrIGFyZ3VtZW50KS4gRXJyb3JzIHRocm93biB3aWxsIGJlIHBhc3NlZCB0byB0aGUgY2FsbGJhY2suXG4gKlxuICogSWYgdGhlIGZ1bmN0aW9uIHBhc3NlZCB0byBgYXN5bmNpZnlgIHJldHVybnMgYSBQcm9taXNlLCB0aGF0IHByb21pc2VzJ3NcbiAqIHJlc29sdmVkL3JlamVjdGVkIHN0YXRlIHdpbGwgYmUgdXNlZCB0byBjYWxsIHRoZSBjYWxsYmFjaywgcmF0aGVyIHRoYW4gc2ltcGx5XG4gKiB0aGUgc3luY2hyb25vdXMgcmV0dXJuIHZhbHVlLlxuICpcbiAqIFRoaXMgYWxzbyBtZWFucyB5b3UgY2FuIGFzeW5jaWZ5IEVTMjAxNyBgYXN5bmNgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAbmFtZSBhc3luY2lmeVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpVdGlsc1xuICogQG1ldGhvZFxuICogQGFsaWFzIHdyYXBTeW5jXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyAtIFRoZSBzeW5jaHJvbm91cyBmdW5jdGlvbiwgb3IgUHJvbWlzZS1yZXR1cm5pbmdcbiAqIGZ1bmN0aW9uIHRvIGNvbnZlcnQgdG8gYW4ge0BsaW5rIEFzeW5jRnVuY3Rpb259LlxuICogQHJldHVybnMge0FzeW5jRnVuY3Rpb259IEFuIGFzeW5jaHJvbm91cyB3cmFwcGVyIG9mIHRoZSBgZnVuY2AuIFRvIGJlXG4gKiBpbnZva2VkIHdpdGggYChhcmdzLi4uLCBjYWxsYmFjaylgLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBwYXNzaW5nIGEgcmVndWxhciBzeW5jaHJvbm91cyBmdW5jdGlvblxuICogYXN5bmMud2F0ZXJmYWxsKFtcbiAqICAgICBhc3luYy5hcHBseShmcy5yZWFkRmlsZSwgZmlsZW5hbWUsIFwidXRmOFwiKSxcbiAqICAgICBhc3luYy5hc3luY2lmeShKU09OLnBhcnNlKSxcbiAqICAgICBmdW5jdGlvbiAoZGF0YSwgbmV4dCkge1xuICogICAgICAgICAvLyBkYXRhIGlzIHRoZSByZXN1bHQgb2YgcGFyc2luZyB0aGUgdGV4dC5cbiAqICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGEgcGFyc2luZyBlcnJvciwgaXQgd291bGQgaGF2ZSBiZWVuIGNhdWdodC5cbiAqICAgICB9XG4gKiBdLCBjYWxsYmFjayk7XG4gKlxuICogLy8gcGFzc2luZyBhIGZ1bmN0aW9uIHJldHVybmluZyBhIHByb21pc2VcbiAqIGFzeW5jLndhdGVyZmFsbChbXG4gKiAgICAgYXN5bmMuYXBwbHkoZnMucmVhZEZpbGUsIGZpbGVuYW1lLCBcInV0ZjhcIiksXG4gKiAgICAgYXN5bmMuYXN5bmNpZnkoZnVuY3Rpb24gKGNvbnRlbnRzKSB7XG4gKiAgICAgICAgIHJldHVybiBkYi5tb2RlbC5jcmVhdGUoY29udGVudHMpO1xuICogICAgIH0pLFxuICogICAgIGZ1bmN0aW9uIChtb2RlbCwgbmV4dCkge1xuICogICAgICAgICAvLyBgbW9kZWxgIGlzIHRoZSBpbnN0YW50aWF0ZWQgbW9kZWwgb2JqZWN0LlxuICogICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYW4gZXJyb3IsIHRoaXMgZnVuY3Rpb24gd291bGQgYmUgc2tpcHBlZC5cbiAqICAgICB9XG4gKiBdLCBjYWxsYmFjayk7XG4gKlxuICogLy8gZXMyMDE3IGV4YW1wbGUsIHRob3VnaCBgYXN5bmNpZnlgIGlzIG5vdCBuZWVkZWQgaWYgeW91ciBKUyBlbnZpcm9ubWVudFxuICogLy8gc3VwcG9ydHMgYXN5bmMgZnVuY3Rpb25zIG91dCBvZiB0aGUgYm94XG4gKiB2YXIgcSA9IGFzeW5jLnF1ZXVlKGFzeW5jLmFzeW5jaWZ5KGFzeW5jIGZ1bmN0aW9uKGZpbGUpIHtcbiAqICAgICB2YXIgaW50ZXJtZWRpYXRlU3RlcCA9IGF3YWl0IHByb2Nlc3NGaWxlKGZpbGUpO1xuICogICAgIHJldHVybiBhd2FpdCBzb21lUHJvbWlzZShpbnRlcm1lZGlhdGVTdGVwKVxuICogfSkpO1xuICpcbiAqIHEucHVzaChmaWxlcyk7XG4gKi9cbmZ1bmN0aW9uIGFzeW5jaWZ5KGZ1bmMpIHtcbiAgICBpZiAoKDAsIF93cmFwQXN5bmMuaXNBc3luYykoZnVuYykpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzIC8qLCBjYWxsYmFjayovKSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVQcm9taXNlKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gKDAsIF9pbml0aWFsUGFyYW1zMi5kZWZhdWx0KShmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiByZXN1bHQgaXMgUHJvbWlzZSBvYmplY3RcbiAgICAgICAgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVQcm9taXNlKHJlc3VsdCwgY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVQcm9taXNlKHByb21pc2UsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHByb21pc2UudGhlbih2YWx1ZSA9PiB7XG4gICAgICAgIGludm9rZUNhbGxiYWNrKGNhbGxiYWNrLCBudWxsLCB2YWx1ZSk7XG4gICAgfSwgZXJyID0+IHtcbiAgICAgICAgaW52b2tlQ2FsbGJhY2soY2FsbGJhY2ssIGVyciAmJiBlcnIubWVzc2FnZSA/IGVyciA6IG5ldyBFcnJvcihlcnIpKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gaW52b2tlQ2FsbGJhY2soY2FsbGJhY2ssIGVycm9yLCB2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNhbGxiYWNrKGVycm9yLCB2YWx1ZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICgwLCBfc2V0SW1tZWRpYXRlMi5kZWZhdWx0KShlID0+IHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0sIGVycik7XG4gICAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2VhY2hPZkxpbWl0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9lYWNoT2ZMaW1pdCcpO1xuXG52YXIgX2VhY2hPZkxpbWl0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VhY2hPZkxpbWl0KTtcblxudmFyIF93aXRob3V0SW5kZXggPSByZXF1aXJlKCcuL2ludGVybmFsL3dpdGhvdXRJbmRleCcpO1xuXG52YXIgX3dpdGhvdXRJbmRleDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93aXRob3V0SW5kZXgpO1xuXG52YXIgX3dyYXBBc3luYyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvd3JhcEFzeW5jJyk7XG5cbnZhciBfd3JhcEFzeW5jMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dyYXBBc3luYyk7XG5cbnZhciBfYXdhaXRpZnkgPSByZXF1aXJlKCcuL2ludGVybmFsL2F3YWl0aWZ5Jyk7XG5cbnZhciBfYXdhaXRpZnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXdhaXRpZnkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgZWFjaGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNofSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSBlYWNoTGltaXRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmVhY2hde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNofVxuICogQGFsaWFzIGZvckVhY2hMaW1pdFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpblxuICogYGNvbGxgLlxuICogVGhlIGFycmF5IGluZGV4IGlzIG5vdCBwYXNzZWQgdG8gdGhlIGl0ZXJhdGVlLlxuICogSWYgeW91IG5lZWQgdGhlIGluZGV4LCB1c2UgYGVhY2hPZkxpbWl0YC5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIEludm9rZWQgd2l0aCAoZXJyKS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIGEgY2FsbGJhY2sgaXMgb21pdHRlZFxuICovXG5mdW5jdGlvbiBlYWNoTGltaXQoY29sbCwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICByZXR1cm4gKDAsIF9lYWNoT2ZMaW1pdDIuZGVmYXVsdCkobGltaXQpKGNvbGwsICgwLCBfd2l0aG91dEluZGV4Mi5kZWZhdWx0KSgoMCwgX3dyYXBBc3luYzIuZGVmYXVsdCkoaXRlcmF0ZWUpKSwgY2FsbGJhY2spO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gKDAsIF9hd2FpdGlmeTIuZGVmYXVsdCkoZWFjaExpbWl0LCA0KTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2lzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9pc0FycmF5TGlrZScpO1xuXG52YXIgX2lzQXJyYXlMaWtlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzQXJyYXlMaWtlKTtcblxudmFyIF9icmVha0xvb3AgPSByZXF1aXJlKCcuL2ludGVybmFsL2JyZWFrTG9vcCcpO1xuXG52YXIgX2JyZWFrTG9vcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9icmVha0xvb3ApO1xuXG52YXIgX2VhY2hPZkxpbWl0ID0gcmVxdWlyZSgnLi9lYWNoT2ZMaW1pdCcpO1xuXG52YXIgX2VhY2hPZkxpbWl0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VhY2hPZkxpbWl0KTtcblxudmFyIF9vbmNlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9vbmNlJyk7XG5cbnZhciBfb25jZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vbmNlKTtcblxudmFyIF9vbmx5T25jZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvb25seU9uY2UnKTtcblxudmFyIF9vbmx5T25jZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vbmx5T25jZSk7XG5cbnZhciBfd3JhcEFzeW5jID0gcmVxdWlyZSgnLi9pbnRlcm5hbC93cmFwQXN5bmMnKTtcblxudmFyIF93cmFwQXN5bmMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd3JhcEFzeW5jKTtcblxudmFyIF9hd2FpdGlmeSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvYXdhaXRpZnknKTtcblxudmFyIF9hd2FpdGlmeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hd2FpdGlmeSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vIGVhY2hPZiBpbXBsZW1lbnRhdGlvbiBvcHRpbWl6ZWQgZm9yIGFycmF5LWxpa2VzXG5mdW5jdGlvbiBlYWNoT2ZBcnJheUxpa2UoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSAoMCwgX29uY2UyLmRlZmF1bHQpKGNhbGxiYWNrKTtcbiAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICBjb21wbGV0ZWQgPSAwLFxuICAgICAgICB7IGxlbmd0aCB9ID0gY29sbCxcbiAgICAgICAgY2FuY2VsZWQgPSBmYWxzZTtcbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGl0ZXJhdG9yQ2FsbGJhY2soZXJyLCB2YWx1ZSkge1xuICAgICAgICBpZiAoZXJyID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY2FuY2VsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYW5jZWxlZCA9PT0gdHJ1ZSkgcmV0dXJuO1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9IGVsc2UgaWYgKCsrY29tcGxldGVkID09PSBsZW5ndGggfHwgdmFsdWUgPT09IF9icmVha0xvb3AyLmRlZmF1bHQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKGNvbGxbaW5kZXhdLCBpbmRleCwgKDAsIF9vbmx5T25jZTIuZGVmYXVsdCkoaXRlcmF0b3JDYWxsYmFjaykpO1xuICAgIH1cbn1cblxuLy8gYSBnZW5lcmljIHZlcnNpb24gb2YgZWFjaE9mIHdoaWNoIGNhbiBoYW5kbGUgYXJyYXksIG9iamVjdCwgYW5kIGl0ZXJhdG9yIGNhc2VzLlxuZnVuY3Rpb24gZWFjaE9mR2VuZXJpYyhjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gKDAsIF9lYWNoT2ZMaW1pdDIuZGVmYXVsdCkoY29sbCwgSW5maW5pdHksIGl0ZXJhdGVlLCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogTGlrZSBbYGVhY2hgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaH0sIGV4Y2VwdCB0aGF0IGl0IHBhc3NlcyB0aGUga2V5IChvciBpbmRleCkgYXMgdGhlIHNlY29uZCBhcmd1bWVudFxuICogdG8gdGhlIGl0ZXJhdGVlLlxuICpcbiAqIEBuYW1lIGVhY2hPZlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGFsaWFzIGZvckVhY2hPZlxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBzZWUgW2FzeW5jLmVhY2hde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNofVxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoXG4gKiBpdGVtIGluIGBjb2xsYC5cbiAqIFRoZSBga2V5YCBpcyB0aGUgaXRlbSdzIGtleSwgb3IgaW5kZXggaW4gdGhlIGNhc2Ugb2YgYW4gYXJyYXkuXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGtleSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIEludm9rZWQgd2l0aCAoZXJyKS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIGEgY2FsbGJhY2sgaXMgb21pdHRlZFxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqID0ge2RldjogXCIvZGV2Lmpzb25cIiwgdGVzdDogXCIvdGVzdC5qc29uXCIsIHByb2Q6IFwiL3Byb2QuanNvblwifTtcbiAqIHZhciBjb25maWdzID0ge307XG4gKlxuICogYXN5bmMuZm9yRWFjaE9mKG9iaiwgZnVuY3Rpb24gKHZhbHVlLCBrZXksIGNhbGxiYWNrKSB7XG4gKiAgICAgZnMucmVhZEZpbGUoX19kaXJuYW1lICsgdmFsdWUsIFwidXRmOFwiLCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gKiAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICogICAgICAgICB0cnkge1xuICogICAgICAgICAgICAgY29uZmlnc1trZXldID0gSlNPTi5wYXJzZShkYXRhKTtcbiAqICAgICAgICAgfSBjYXRjaCAoZSkge1xuICogICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpO1xuICogICAgICAgICB9XG4gKiAgICAgICAgIGNhbGxiYWNrKCk7XG4gKiAgICAgfSk7XG4gKiB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgaWYgKGVycikgY29uc29sZS5lcnJvcihlcnIubWVzc2FnZSk7XG4gKiAgICAgLy8gY29uZmlncyBpcyBub3cgYSBtYXAgb2YgSlNPTiBkYXRhXG4gKiAgICAgZG9Tb21ldGhpbmdXaXRoKGNvbmZpZ3MpO1xuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGVhY2hPZihjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgZWFjaE9mSW1wbGVtZW50YXRpb24gPSAoMCwgX2lzQXJyYXlMaWtlMi5kZWZhdWx0KShjb2xsKSA/IGVhY2hPZkFycmF5TGlrZSA6IGVhY2hPZkdlbmVyaWM7XG4gICAgcmV0dXJuIGVhY2hPZkltcGxlbWVudGF0aW9uKGNvbGwsICgwLCBfd3JhcEFzeW5jMi5kZWZhdWx0KShpdGVyYXRlZSksIGNhbGxiYWNrKTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gKDAsIF9hd2FpdGlmeTIuZGVmYXVsdCkoZWFjaE9mLCAzKTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9lYWNoT2ZMaW1pdDIgPSByZXF1aXJlKCcuL2ludGVybmFsL2VhY2hPZkxpbWl0Jyk7XG5cbnZhciBfZWFjaE9mTGltaXQzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZWFjaE9mTGltaXQyKTtcblxudmFyIF93cmFwQXN5bmMgPSByZXF1aXJlKCcuL2ludGVybmFsL3dyYXBBc3luYycpO1xuXG52YXIgX3dyYXBBc3luYzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93cmFwQXN5bmMpO1xuXG52YXIgX2F3YWl0aWZ5ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9hd2FpdGlmeScpO1xuXG52YXIgX2F3YWl0aWZ5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2F3YWl0aWZ5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGVhY2hPZmBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNoT2Z9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYVxuICogdGltZS5cbiAqXG4gKiBAbmFtZSBlYWNoT2ZMaW1pdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuZWFjaE9mXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaE9mfVxuICogQGFsaWFzIGZvckVhY2hPZkxpbWl0XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaFxuICogaXRlbSBpbiBgY29sbGAuIFRoZSBga2V5YCBpcyB0aGUgaXRlbSdzIGtleSwgb3IgaW5kZXggaW4gdGhlIGNhc2Ugb2YgYW5cbiAqIGFycmF5LlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBrZXksIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbFxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBJbnZva2VkIHdpdGggKGVycikuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBhIGNhbGxiYWNrIGlzIG9taXR0ZWRcbiAqL1xuZnVuY3Rpb24gZWFjaE9mTGltaXQoY29sbCwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICByZXR1cm4gKDAsIF9lYWNoT2ZMaW1pdDMuZGVmYXVsdCkobGltaXQpKGNvbGwsICgwLCBfd3JhcEFzeW5jMi5kZWZhdWx0KShpdGVyYXRlZSksIGNhbGxiYWNrKTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gKDAsIF9hd2FpdGlmeTIuZGVmYXVsdCkoZWFjaE9mTGltaXQsIDQpO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2VhY2hMaW1pdCA9IHJlcXVpcmUoJy4vZWFjaExpbWl0Jyk7XG5cbnZhciBfZWFjaExpbWl0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VhY2hMaW1pdCk7XG5cbnZhciBfYXdhaXRpZnkgPSByZXF1aXJlKCcuL2ludGVybmFsL2F3YWl0aWZ5Jyk7XG5cbnZhciBfYXdhaXRpZnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXdhaXRpZnkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgZWFjaGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNofSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogTm90ZSwgdGhhdCB1bmxpa2UgW2BlYWNoYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2h9LCB0aGlzIGZ1bmN0aW9uIGFwcGxpZXMgaXRlcmF0ZWUgdG8gZWFjaCBpdGVtXG4gKiBpbiBzZXJpZXMgYW5kIHRoZXJlZm9yZSB0aGUgaXRlcmF0ZWUgZnVuY3Rpb25zIHdpbGwgY29tcGxldGUgaW4gb3JkZXIuXG5cbiAqIEBuYW1lIGVhY2hTZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmVhY2hde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNofVxuICogQGFsaWFzIGZvckVhY2hTZXJpZXNcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoXG4gKiBpdGVtIGluIGBjb2xsYC5cbiAqIFRoZSBhcnJheSBpbmRleCBpcyBub3QgcGFzc2VkIHRvIHRoZSBpdGVyYXRlZS5cbiAqIElmIHlvdSBuZWVkIHRoZSBpbmRleCwgdXNlIGBlYWNoT2ZTZXJpZXNgLlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGxcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gSW52b2tlZCB3aXRoIChlcnIpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgYSBjYWxsYmFjayBpcyBvbWl0dGVkXG4gKi9cbmZ1bmN0aW9uIGVhY2hTZXJpZXMoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gIHJldHVybiAoMCwgX2VhY2hMaW1pdDIuZGVmYXVsdCkoY29sbCwgMSwgaXRlcmF0ZWUsIGNhbGxiYWNrKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9ICgwLCBfYXdhaXRpZnkyLmRlZmF1bHQpKGVhY2hTZXJpZXMsIDMpO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBhc3luY0VhY2hPZkxpbWl0O1xuXG52YXIgX2JyZWFrTG9vcCA9IHJlcXVpcmUoJy4vYnJlYWtMb29wJyk7XG5cbnZhciBfYnJlYWtMb29wMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JyZWFrTG9vcCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vIGZvciBhc3luYyBnZW5lcmF0b3JzXG5mdW5jdGlvbiBhc3luY0VhY2hPZkxpbWl0KGdlbmVyYXRvciwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgbGV0IGNhbmNlbGVkID0gZmFsc2U7XG4gICAgbGV0IGF3YWl0aW5nID0gZmFsc2U7XG4gICAgbGV0IHJ1bm5pbmcgPSAwO1xuICAgIGxldCBpZHggPSAwO1xuXG4gICAgZnVuY3Rpb24gcmVwbGVuaXNoKCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKCdyZXBsZW5pc2gnKVxuICAgICAgICBpZiAocnVubmluZyA+PSBsaW1pdCB8fCBhd2FpdGluZyB8fCBkb25lKSByZXR1cm47XG4gICAgICAgIC8vY29uc29sZS5sb2coJ3JlcGxlbmlzaCBhd2FpdGluZycpXG4gICAgICAgIGF3YWl0aW5nID0gdHJ1ZTtcbiAgICAgICAgZ2VuZXJhdG9yLm5leHQoKS50aGVuKCh7IHZhbHVlLCBkb25lOiBpdGVyRG9uZSB9KSA9PiB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdnb3QgdmFsdWUnLCB2YWx1ZSlcbiAgICAgICAgICAgIGlmIChjYW5jZWxlZCB8fCBkb25lKSByZXR1cm47XG4gICAgICAgICAgICBhd2FpdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGl0ZXJEb25lKSB7XG4gICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bm5pbmcgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdkb25lIG5leHRDYicpXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBydW5uaW5nKys7XG4gICAgICAgICAgICBpdGVyYXRlZSh2YWx1ZSwgaWR4LCBpdGVyYXRlZUNhbGxiYWNrKTtcbiAgICAgICAgICAgIGlkeCsrO1xuICAgICAgICAgICAgcmVwbGVuaXNoKCk7XG4gICAgICAgIH0pLmNhdGNoKGhhbmRsZUVycm9yKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpdGVyYXRlZUNhbGxiYWNrKGVyciwgcmVzdWx0KSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ2l0ZXJhdGVlQ2FsbGJhY2snKVxuICAgICAgICBydW5uaW5nIC09IDE7XG4gICAgICAgIGlmIChjYW5jZWxlZCkgcmV0dXJuO1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gaGFuZGxlRXJyb3IoZXJyKTtcblxuICAgICAgICBpZiAoZXJyID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICBjYW5jZWxlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0ID09PSBfYnJlYWtMb29wMi5kZWZhdWx0IHx8IGRvbmUgJiYgcnVubmluZyA8PSAwKSB7XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2RvbmUgaXRlckNiJylcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXBsZW5pc2goKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVFcnJvcihlcnIpIHtcbiAgICAgICAgaWYgKGNhbmNlbGVkKSByZXR1cm47XG4gICAgICAgIGF3YWl0aW5nID0gZmFsc2U7XG4gICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH1cblxuICAgIHJlcGxlbmlzaCgpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBhd2FpdGlmeTtcbi8vIGNvbmRpdGlvbmFsbHkgcHJvbWlzaWZ5IGEgZnVuY3Rpb24uXG4vLyBvbmx5IHJldHVybiBhIHByb21pc2UgaWYgYSBjYWxsYmFjayBpcyBvbWl0dGVkXG5mdW5jdGlvbiBhd2FpdGlmeShhc3luY0ZuLCBhcml0eSA9IGFzeW5jRm4ubGVuZ3RoKSB7XG4gICAgaWYgKCFhcml0eSkgdGhyb3cgbmV3IEVycm9yKCdhcml0eSBpcyB1bmRlZmluZWQnKTtcbiAgICBmdW5jdGlvbiBhd2FpdGFibGUoLi4uYXJncykge1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3NbYXJpdHkgLSAxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGFzeW5jRm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgYXJnc1thcml0eSAtIDFdID0gKGVyciwgLi4uY2JBcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoY2JBcmdzLmxlbmd0aCA+IDEgPyBjYkFyZ3MgOiBjYkFyZ3NbMF0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFzeW5jRm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhd2FpdGFibGUsICduYW1lJywge1xuICAgICAgICB2YWx1ZTogYGF3YWl0YWJsZSgke2FzeW5jRm4ubmFtZX0pYFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGF3YWl0YWJsZTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLy8gQSB0ZW1wb3JhcnkgdmFsdWUgdXNlZCB0byBpZGVudGlmeSBpZiB0aGUgbG9vcCBzaG91bGQgYmUgYnJva2VuLlxuLy8gU2VlICMxMDY0LCAjMTI5M1xuY29uc3QgYnJlYWtMb29wID0ge307XG5leHBvcnRzLmRlZmF1bHQgPSBicmVha0xvb3A7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX29uY2UgPSByZXF1aXJlKCcuL29uY2UnKTtcblxudmFyIF9vbmNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29uY2UpO1xuXG52YXIgX2l0ZXJhdG9yID0gcmVxdWlyZSgnLi9pdGVyYXRvcicpO1xuXG52YXIgX2l0ZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2l0ZXJhdG9yKTtcblxudmFyIF9vbmx5T25jZSA9IHJlcXVpcmUoJy4vb25seU9uY2UnKTtcblxudmFyIF9vbmx5T25jZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vbmx5T25jZSk7XG5cbnZhciBfd3JhcEFzeW5jID0gcmVxdWlyZSgnLi93cmFwQXN5bmMnKTtcblxudmFyIF9hc3luY0VhY2hPZkxpbWl0ID0gcmVxdWlyZSgnLi9hc3luY0VhY2hPZkxpbWl0Jyk7XG5cbnZhciBfYXN5bmNFYWNoT2ZMaW1pdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3luY0VhY2hPZkxpbWl0KTtcblxudmFyIF9icmVha0xvb3AgPSByZXF1aXJlKCcuL2JyZWFrTG9vcCcpO1xuXG52YXIgX2JyZWFrTG9vcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9icmVha0xvb3ApO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBsaW1pdCA9PiB7XG4gICAgcmV0dXJuIChvYmosIGl0ZXJhdGVlLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBjYWxsYmFjayA9ICgwLCBfb25jZTIuZGVmYXVsdCkoY2FsbGJhY2spO1xuICAgICAgICBpZiAobGltaXQgPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2NvbmN1cnJlbmN5IGxpbWl0IGNhbm5vdCBiZSBsZXNzIHRoYW4gMScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCBfd3JhcEFzeW5jLmlzQXN5bmNHZW5lcmF0b3IpKG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX2FzeW5jRWFjaE9mTGltaXQyLmRlZmF1bHQpKG9iaiwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCBfd3JhcEFzeW5jLmlzQXN5bmNJdGVyYWJsZSkob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfYXN5bmNFYWNoT2ZMaW1pdDIuZGVmYXVsdCkob2JqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpLCBsaW1pdCwgaXRlcmF0ZWUsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV4dEVsZW0gPSAoMCwgX2l0ZXJhdG9yMi5kZWZhdWx0KShvYmopO1xuICAgICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgICB2YXIgY2FuY2VsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHJ1bm5pbmcgPSAwO1xuICAgICAgICB2YXIgbG9vcGluZyA9IGZhbHNlO1xuXG4gICAgICAgIGZ1bmN0aW9uIGl0ZXJhdGVlQ2FsbGJhY2soZXJyLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGNhbmNlbGVkKSByZXR1cm47XG4gICAgICAgICAgICBydW5uaW5nIC09IDE7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNhbmNlbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IF9icmVha0xvb3AyLmRlZmF1bHQgfHwgZG9uZSAmJiBydW5uaW5nIDw9IDApIHtcbiAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFsb29waW5nKSB7XG4gICAgICAgICAgICAgICAgcmVwbGVuaXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZXBsZW5pc2goKSB7XG4gICAgICAgICAgICBsb29waW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHdoaWxlIChydW5uaW5nIDwgbGltaXQgJiYgIWRvbmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IG5leHRFbGVtKCk7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChydW5uaW5nIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcnVubmluZyArPSAxO1xuICAgICAgICAgICAgICAgIGl0ZXJhdGVlKGVsZW0udmFsdWUsIGVsZW0ua2V5LCAoMCwgX29ubHlPbmNlMi5kZWZhdWx0KShpdGVyYXRlZUNhbGxiYWNrKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb29waW5nID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXBsZW5pc2goKTtcbiAgICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGNvbGwpIHtcbiAgICByZXR1cm4gY29sbFtTeW1ib2wuaXRlcmF0b3JdICYmIGNvbGxbU3ltYm9sLml0ZXJhdG9yXSgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MgLyosIGNhbGxiYWNrKi8pIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgYXJncywgY2FsbGJhY2spO1xuICAgIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNBcnJheUxpa2U7XG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJyAmJiB2YWx1ZS5sZW5ndGggPj0gMCAmJiB2YWx1ZS5sZW5ndGggJSAxID09PSAwO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVJdGVyYXRvcjtcblxudmFyIF9pc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxudmFyIF9pc0FycmF5TGlrZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0FycmF5TGlrZSk7XG5cbnZhciBfZ2V0SXRlcmF0b3IgPSByZXF1aXJlKCcuL2dldEl0ZXJhdG9yJyk7XG5cbnZhciBfZ2V0SXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0SXRlcmF0b3IpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBjcmVhdGVBcnJheUl0ZXJhdG9yKGNvbGwpIHtcbiAgICB2YXIgaSA9IC0xO1xuICAgIHZhciBsZW4gPSBjb2xsLmxlbmd0aDtcbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgcmV0dXJuICsraSA8IGxlbiA/IHsgdmFsdWU6IGNvbGxbaV0sIGtleTogaSB9IDogbnVsbDtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFUzIwMTVJdGVyYXRvcihpdGVyYXRvcikge1xuICAgIHZhciBpID0gLTE7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIHZhciBpdGVtID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoaXRlbS5kb25lKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaSsrO1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogaXRlbS52YWx1ZSwga2V5OiBpIH07XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlT2JqZWN0SXRlcmF0b3Iob2JqKSB7XG4gICAgdmFyIG9rZXlzID0gb2JqID8gT2JqZWN0LmtleXMob2JqKSA6IFtdO1xuICAgIHZhciBpID0gLTE7XG4gICAgdmFyIGxlbiA9IG9rZXlzLmxlbmd0aDtcbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgdmFyIGtleSA9IG9rZXlzWysraV07XG4gICAgICAgIHJldHVybiBpIDwgbGVuID8geyB2YWx1ZTogb2JqW2tleV0sIGtleSB9IDogbnVsbDtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJdGVyYXRvcihjb2xsKSB7XG4gICAgaWYgKCgwLCBfaXNBcnJheUxpa2UyLmRlZmF1bHQpKGNvbGwpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVBcnJheUl0ZXJhdG9yKGNvbGwpO1xuICAgIH1cblxuICAgIHZhciBpdGVyYXRvciA9ICgwLCBfZ2V0SXRlcmF0b3IyLmRlZmF1bHQpKGNvbGwpO1xuICAgIHJldHVybiBpdGVyYXRvciA/IGNyZWF0ZUVTMjAxNUl0ZXJhdG9yKGl0ZXJhdG9yKSA6IGNyZWF0ZU9iamVjdEl0ZXJhdG9yKGNvbGwpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBfYXN5bmNNYXA7XG5cbnZhciBfd3JhcEFzeW5jID0gcmVxdWlyZSgnLi93cmFwQXN5bmMnKTtcblxudmFyIF93cmFwQXN5bmMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd3JhcEFzeW5jKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2FzeW5jTWFwKGVhY2hmbiwgYXJyLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICBhcnIgPSBhcnIgfHwgW107XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICB2YXIgY291bnRlciA9IDA7XG4gICAgdmFyIF9pdGVyYXRlZSA9ICgwLCBfd3JhcEFzeW5jMi5kZWZhdWx0KShpdGVyYXRlZSk7XG5cbiAgICByZXR1cm4gZWFjaGZuKGFyciwgKHZhbHVlLCBfLCBpdGVyQ2IpID0+IHtcbiAgICAgICAgdmFyIGluZGV4ID0gY291bnRlcisrO1xuICAgICAgICBfaXRlcmF0ZWUodmFsdWUsIChlcnIsIHYpID0+IHtcbiAgICAgICAgICAgIHJlc3VsdHNbaW5kZXhdID0gdjtcbiAgICAgICAgICAgIGl0ZXJDYihlcnIpO1xuICAgICAgICB9KTtcbiAgICB9LCBlcnIgPT4ge1xuICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdHMpO1xuICAgIH0pO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IG9uY2U7XG5mdW5jdGlvbiBvbmNlKGZuKSB7XG4gICAgZnVuY3Rpb24gd3JhcHBlciguLi5hcmdzKSB7XG4gICAgICAgIGlmIChmbiA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICB2YXIgY2FsbEZuID0gZm47XG4gICAgICAgIGZuID0gbnVsbDtcbiAgICAgICAgY2FsbEZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHdyYXBwZXIsIGZuKTtcbiAgICByZXR1cm4gd3JhcHBlcjtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IG9ubHlPbmNlO1xuZnVuY3Rpb24gb25seU9uY2UoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKGZuID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsYmFjayB3YXMgYWxyZWFkeSBjYWxsZWQuXCIpO1xuICAgICAgICB2YXIgY2FsbEZuID0gZm47XG4gICAgICAgIGZuID0gbnVsbDtcbiAgICAgICAgY2FsbEZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2lzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG52YXIgX2lzQXJyYXlMaWtlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzQXJyYXlMaWtlKTtcblxudmFyIF93cmFwQXN5bmMgPSByZXF1aXJlKCcuL3dyYXBBc3luYycpO1xuXG52YXIgX3dyYXBBc3luYzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93cmFwQXN5bmMpO1xuXG52YXIgX2F3YWl0aWZ5ID0gcmVxdWlyZSgnLi9hd2FpdGlmeScpO1xuXG52YXIgX2F3YWl0aWZ5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2F3YWl0aWZ5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gKDAsIF9hd2FpdGlmeTIuZGVmYXVsdCkoKGVhY2hmbiwgdGFza3MsIGNhbGxiYWNrKSA9PiB7XG4gICAgdmFyIHJlc3VsdHMgPSAoMCwgX2lzQXJyYXlMaWtlMi5kZWZhdWx0KSh0YXNrcykgPyBbXSA6IHt9O1xuXG4gICAgZWFjaGZuKHRhc2tzLCAodGFzaywga2V5LCB0YXNrQ2IpID0+IHtcbiAgICAgICAgKDAsIF93cmFwQXN5bmMyLmRlZmF1bHQpKHRhc2spKChlcnIsIC4uLnJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgW3Jlc3VsdF0gPSByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRzW2tleV0gPSByZXN1bHQ7XG4gICAgICAgICAgICB0YXNrQ2IoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfSwgZXJyID0+IGNhbGxiYWNrKGVyciwgcmVzdWx0cykpO1xufSwgMyk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmNvbnN0IFBST01JU0VfU1lNQk9MID0gU3ltYm9sKCdwcm9taXNlQ2FsbGJhY2snKTtcblxuZnVuY3Rpb24gcHJvbWlzZUNhbGxiYWNrKCkge1xuICAgIGxldCByZXNvbHZlLCByZWplY3Q7XG4gICAgZnVuY3Rpb24gY2FsbGJhY2soZXJyLCAuLi5hcmdzKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgcmVzb2x2ZShhcmdzLmxlbmd0aCA+IDEgPyBhcmdzIDogYXJnc1swXSk7XG4gICAgfVxuXG4gICAgY2FsbGJhY2tbUFJPTUlTRV9TWU1CT0xdID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgIHJlc29sdmUgPSByZXMsIHJlamVjdCA9IHJlajtcbiAgICB9KTtcblxuICAgIHJldHVybiBjYWxsYmFjaztcbn1cblxuZXhwb3J0cy5wcm9taXNlQ2FsbGJhY2sgPSBwcm9taXNlQ2FsbGJhY2s7XG5leHBvcnRzLlBST01JU0VfU1lNQk9MID0gUFJPTUlTRV9TWU1CT0w7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmZhbGxiYWNrID0gZmFsbGJhY2s7XG5leHBvcnRzLndyYXAgPSB3cmFwO1xudmFyIGhhc1NldEltbWVkaWF0ZSA9IGV4cG9ydHMuaGFzU2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBzZXRJbW1lZGlhdGU7XG52YXIgaGFzTmV4dFRpY2sgPSBleHBvcnRzLmhhc05leHRUaWNrID0gdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwcm9jZXNzLm5leHRUaWNrID09PSAnZnVuY3Rpb24nO1xuXG5mdW5jdGlvbiBmYWxsYmFjayhmbikge1xuICAgIHNldFRpbWVvdXQoZm4sIDApO1xufVxuXG5mdW5jdGlvbiB3cmFwKGRlZmVyKSB7XG4gICAgcmV0dXJuIChmbiwgLi4uYXJncykgPT4gZGVmZXIoKCkgPT4gZm4oLi4uYXJncykpO1xufVxuXG52YXIgX2RlZmVyO1xuXG5pZiAoaGFzU2V0SW1tZWRpYXRlKSB7XG4gICAgX2RlZmVyID0gc2V0SW1tZWRpYXRlO1xufSBlbHNlIGlmIChoYXNOZXh0VGljaykge1xuICAgIF9kZWZlciA9IHByb2Nlc3MubmV4dFRpY2s7XG59IGVsc2Uge1xuICAgIF9kZWZlciA9IGZhbGxiYWNrO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSB3cmFwKF9kZWZlcik7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IF93aXRob3V0SW5kZXg7XG5mdW5jdGlvbiBfd2l0aG91dEluZGV4KGl0ZXJhdGVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSwgaW5kZXgsIGNhbGxiYWNrKSA9PiBpdGVyYXRlZSh2YWx1ZSwgY2FsbGJhY2spO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuaXNBc3luY0l0ZXJhYmxlID0gZXhwb3J0cy5pc0FzeW5jR2VuZXJhdG9yID0gZXhwb3J0cy5pc0FzeW5jID0gdW5kZWZpbmVkO1xuXG52YXIgX2FzeW5jaWZ5ID0gcmVxdWlyZSgnLi4vYXN5bmNpZnknKTtcblxudmFyIF9hc3luY2lmeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3luY2lmeSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGlzQXN5bmMoZm4pIHtcbiAgICByZXR1cm4gZm5bU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0FzeW5jRnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc0FzeW5jR2VuZXJhdG9yKGZuKSB7XG4gICAgcmV0dXJuIGZuW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdBc3luY0dlbmVyYXRvcic7XG59XG5cbmZ1bmN0aW9uIGlzQXN5bmNJdGVyYWJsZShvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9ialtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIHdyYXBBc3luYyhhc3luY0ZuKSB7XG4gICAgaWYgKHR5cGVvZiBhc3luY0ZuICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIGEgZnVuY3Rpb24nKTtcbiAgICByZXR1cm4gaXNBc3luYyhhc3luY0ZuKSA/ICgwLCBfYXN5bmNpZnkyLmRlZmF1bHQpKGFzeW5jRm4pIDogYXN5bmNGbjtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gd3JhcEFzeW5jO1xuZXhwb3J0cy5pc0FzeW5jID0gaXNBc3luYztcbmV4cG9ydHMuaXNBc3luY0dlbmVyYXRvciA9IGlzQXN5bmNHZW5lcmF0b3I7XG5leHBvcnRzLmlzQXN5bmNJdGVyYWJsZSA9IGlzQXN5bmNJdGVyYWJsZTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfbWFwMiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvbWFwJyk7XG5cbnZhciBfbWFwMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21hcDIpO1xuXG52YXIgX2VhY2hPZiA9IHJlcXVpcmUoJy4vZWFjaE9mJyk7XG5cbnZhciBfZWFjaE9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VhY2hPZik7XG5cbnZhciBfYXdhaXRpZnkgPSByZXF1aXJlKCcuL2ludGVybmFsL2F3YWl0aWZ5Jyk7XG5cbnZhciBfYXdhaXRpZnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXdhaXRpZnkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIFByb2R1Y2VzIGEgbmV3IGNvbGxlY3Rpb24gb2YgdmFsdWVzIGJ5IG1hcHBpbmcgZWFjaCB2YWx1ZSBpbiBgY29sbGAgdGhyb3VnaFxuICogdGhlIGBpdGVyYXRlZWAgZnVuY3Rpb24uIFRoZSBgaXRlcmF0ZWVgIGlzIGNhbGxlZCB3aXRoIGFuIGl0ZW0gZnJvbSBgY29sbGBcbiAqIGFuZCBhIGNhbGxiYWNrIGZvciB3aGVuIGl0IGhhcyBmaW5pc2hlZCBwcm9jZXNzaW5nLiBFYWNoIG9mIHRoZXNlIGNhbGxiYWNrXG4gKiB0YWtlcyAyIGFyZ3VtZW50czogYW4gYGVycm9yYCwgYW5kIHRoZSB0cmFuc2Zvcm1lZCBpdGVtIGZyb20gYGNvbGxgLiBJZlxuICogYGl0ZXJhdGVlYCBwYXNzZXMgYW4gZXJyb3IgdG8gaXRzIGNhbGxiYWNrLCB0aGUgbWFpbiBgY2FsbGJhY2tgIChmb3IgdGhlXG4gKiBgbWFwYCBmdW5jdGlvbikgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlIGVycm9yLlxuICpcbiAqIE5vdGUsIHRoYXQgc2luY2UgdGhpcyBmdW5jdGlvbiBhcHBsaWVzIHRoZSBgaXRlcmF0ZWVgIHRvIGVhY2ggaXRlbSBpblxuICogcGFyYWxsZWwsIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyB3aWxsIGNvbXBsZXRlXG4gKiBpbiBvcmRlci4gSG93ZXZlciwgdGhlIHJlc3VsdHMgYXJyYXkgd2lsbCBiZSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGVcbiAqIG9yaWdpbmFsIGBjb2xsYC5cbiAqXG4gKiBJZiBgbWFwYCBpcyBwYXNzZWQgYW4gT2JqZWN0LCB0aGUgcmVzdWx0cyB3aWxsIGJlIGFuIEFycmF5LiAgVGhlIHJlc3VsdHNcbiAqIHdpbGwgcm91Z2hseSBiZSBpbiB0aGUgb3JkZXIgb2YgdGhlIG9yaWdpbmFsIE9iamVjdHMnIGtleXMgKGJ1dCB0aGlzIGNhblxuICogdmFyeSBhY3Jvc3MgSmF2YVNjcmlwdCBlbmdpbmVzKS5cbiAqXG4gKiBAbmFtZSBtYXBcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW5cbiAqIGBjb2xsYC5cbiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCB0aGUgdHJhbnNmb3JtZWQgaXRlbS5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsIGBpdGVyYXRlZWBcbiAqIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIFJlc3VsdHMgaXMgYW4gQXJyYXkgb2YgdGhlXG4gKiB0cmFuc2Zvcm1lZCBpdGVtcyBmcm9tIHRoZSBgY29sbGAuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIGlzIHBhc3NlZFxuICogQGV4YW1wbGVcbiAqXG4gKiBhc3luYy5tYXAoWydmaWxlMScsJ2ZpbGUyJywnZmlsZTMnXSwgZnMuc3RhdCwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gKiAgICAgLy8gcmVzdWx0cyBpcyBub3cgYW4gYXJyYXkgb2Ygc3RhdHMgZm9yIGVhY2ggZmlsZVxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIG1hcChjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgcmV0dXJuICgwLCBfbWFwMy5kZWZhdWx0KShfZWFjaE9mMi5kZWZhdWx0LCBjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gKDAsIF9hd2FpdGlmeTIuZGVmYXVsdCkobWFwLCAzKTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHBhcmFsbGVsO1xuXG52YXIgX2VhY2hPZiA9IHJlcXVpcmUoJy4vZWFjaE9mJyk7XG5cbnZhciBfZWFjaE9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VhY2hPZik7XG5cbnZhciBfcGFyYWxsZWwyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9wYXJhbGxlbCcpO1xuXG52YXIgX3BhcmFsbGVsMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmFsbGVsMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICogUnVuIHRoZSBgdGFza3NgIGNvbGxlY3Rpb24gb2YgZnVuY3Rpb25zIGluIHBhcmFsbGVsLCB3aXRob3V0IHdhaXRpbmcgdW50aWxcbiAqIHRoZSBwcmV2aW91cyBmdW5jdGlvbiBoYXMgY29tcGxldGVkLiBJZiBhbnkgb2YgdGhlIGZ1bmN0aW9ucyBwYXNzIGFuIGVycm9yIHRvXG4gKiBpdHMgY2FsbGJhY2ssIHRoZSBtYWluIGBjYWxsYmFja2AgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlIHZhbHVlIG9mIHRoZVxuICogZXJyb3IuIE9uY2UgdGhlIGB0YXNrc2AgaGF2ZSBjb21wbGV0ZWQsIHRoZSByZXN1bHRzIGFyZSBwYXNzZWQgdG8gdGhlIGZpbmFsXG4gKiBgY2FsbGJhY2tgIGFzIGFuIGFycmF5LlxuICpcbiAqICoqTm90ZToqKiBgcGFyYWxsZWxgIGlzIGFib3V0IGtpY2tpbmctb2ZmIEkvTyB0YXNrcyBpbiBwYXJhbGxlbCwgbm90IGFib3V0XG4gKiBwYXJhbGxlbCBleGVjdXRpb24gb2YgY29kZS4gIElmIHlvdXIgdGFza3MgZG8gbm90IHVzZSBhbnkgdGltZXJzIG9yIHBlcmZvcm1cbiAqIGFueSBJL08sIHRoZXkgd2lsbCBhY3R1YWxseSBiZSBleGVjdXRlZCBpbiBzZXJpZXMuICBBbnkgc3luY2hyb25vdXMgc2V0dXBcbiAqIHNlY3Rpb25zIGZvciBlYWNoIHRhc2sgd2lsbCBoYXBwZW4gb25lIGFmdGVyIHRoZSBvdGhlci4gIEphdmFTY3JpcHQgcmVtYWluc1xuICogc2luZ2xlLXRocmVhZGVkLlxuICpcbiAqICoqSGludDoqKiBVc2UgW2ByZWZsZWN0YF17QGxpbmsgbW9kdWxlOlV0aWxzLnJlZmxlY3R9IHRvIGNvbnRpbnVlIHRoZVxuICogZXhlY3V0aW9uIG9mIG90aGVyIHRhc2tzIHdoZW4gYSB0YXNrIGZhaWxzLlxuICpcbiAqIEl0IGlzIGFsc28gcG9zc2libGUgdG8gdXNlIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5LiBFYWNoIHByb3BlcnR5IHdpbGxcbiAqIGJlIHJ1biBhcyBhIGZ1bmN0aW9uIGFuZCB0aGUgcmVzdWx0cyB3aWxsIGJlIHBhc3NlZCB0byB0aGUgZmluYWwgYGNhbGxiYWNrYFxuICogYXMgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXkuIFRoaXMgY2FuIGJlIGEgbW9yZSByZWFkYWJsZSB3YXkgb2YgaGFuZGxpbmdcbiAqIHJlc3VsdHMgZnJvbSB7QGxpbmsgYXN5bmMucGFyYWxsZWx9LlxuICpcbiAqIEBuYW1lIHBhcmFsbGVsXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSB0YXNrcyAtIEEgY29sbGVjdGlvbiBvZlxuICogW2FzeW5jIGZ1bmN0aW9uc117QGxpbmsgQXN5bmNGdW5jdGlvbn0gdG8gcnVuLlxuICogRWFjaCBhc3luYyBmdW5jdGlvbiBjYW4gY29tcGxldGUgd2l0aCBhbnkgbnVtYmVyIG9mIG9wdGlvbmFsIGByZXN1bHRgIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBbiBvcHRpb25hbCBjYWxsYmFjayB0byBydW4gb25jZSBhbGwgdGhlXG4gKiBmdW5jdGlvbnMgaGF2ZSBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LiBUaGlzIGZ1bmN0aW9uIGdldHMgYSByZXN1bHRzIGFycmF5XG4gKiAob3Igb2JqZWN0KSBjb250YWluaW5nIGFsbCB0aGUgcmVzdWx0IGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIHRhc2sgY2FsbGJhY2tzLlxuICogSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgYSBjYWxsYmFjayBpcyBub3QgcGFzc2VkXG4gKlxuICogQGV4YW1wbGVcbiAqIGFzeW5jLnBhcmFsbGVsKFtcbiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScpO1xuICogICAgICAgICB9LCAyMDApO1xuICogICAgIH0sXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0d28nKTtcbiAqICAgICAgICAgfSwgMTAwKTtcbiAqICAgICB9XG4gKiBdLFxuICogLy8gb3B0aW9uYWwgY2FsbGJhY2tcbiAqIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIC8vIHRoZSByZXN1bHRzIGFycmF5IHdpbGwgZXF1YWwgWydvbmUnLCd0d28nXSBldmVuIHRob3VnaFxuICogICAgIC8vIHRoZSBzZWNvbmQgZnVuY3Rpb24gaGFkIGEgc2hvcnRlciB0aW1lb3V0LlxuICogfSk7XG4gKlxuICogLy8gYW4gZXhhbXBsZSB1c2luZyBhbiBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheVxuICogYXN5bmMucGFyYWxsZWwoe1xuICogICAgIG9uZTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIDEpO1xuICogICAgICAgICB9LCAyMDApO1xuICogICAgIH0sXG4gKiAgICAgdHdvOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgMik7XG4gKiAgICAgICAgIH0sIDEwMCk7XG4gKiAgICAgfVxuICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gKiAgICAgLy8gcmVzdWx0cyBpcyBub3cgZXF1YWxzIHRvOiB7b25lOiAxLCB0d286IDJ9XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gcGFyYWxsZWwodGFza3MsIGNhbGxiYWNrKSB7XG4gIHJldHVybiAoMCwgX3BhcmFsbGVsMy5kZWZhdWx0KShfZWFjaE9mMi5kZWZhdWx0LCB0YXNrcywgY2FsbGJhY2spO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSByZXRyeTtcblxudmFyIF93cmFwQXN5bmMgPSByZXF1aXJlKCcuL2ludGVybmFsL3dyYXBBc3luYycpO1xuXG52YXIgX3dyYXBBc3luYzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93cmFwQXN5bmMpO1xuXG52YXIgX3Byb21pc2VDYWxsYmFjayA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvcHJvbWlzZUNhbGxiYWNrJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gZ2V0IGEgc3VjY2Vzc2Z1bCByZXNwb25zZSBmcm9tIGB0YXNrYCBubyBtb3JlIHRoYW4gYHRpbWVzYCB0aW1lc1xuICogYmVmb3JlIHJldHVybmluZyBhbiBlcnJvci4gSWYgdGhlIHRhc2sgaXMgc3VjY2Vzc2Z1bCwgdGhlIGBjYWxsYmFja2Agd2lsbCBiZVxuICogcGFzc2VkIHRoZSByZXN1bHQgb2YgdGhlIHN1Y2Nlc3NmdWwgdGFzay4gSWYgYWxsIGF0dGVtcHRzIGZhaWwsIHRoZSBjYWxsYmFja1xuICogd2lsbCBiZSBwYXNzZWQgdGhlIGVycm9yIGFuZCByZXN1bHQgKGlmIGFueSkgb2YgdGhlIGZpbmFsIGF0dGVtcHQuXG4gKlxuICogQG5hbWUgcmV0cnlcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBzZWUgW2FzeW5jLnJldHJ5YWJsZV17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnJldHJ5YWJsZX1cbiAqIEBwYXJhbSB7T2JqZWN0fG51bWJlcn0gW29wdHMgPSB7dGltZXM6IDUsIGludGVydmFsOiAwfXwgNV0gLSBDYW4gYmUgZWl0aGVyIGFuXG4gKiBvYmplY3Qgd2l0aCBgdGltZXNgIGFuZCBgaW50ZXJ2YWxgIG9yIGEgbnVtYmVyLlxuICogKiBgdGltZXNgIC0gVGhlIG51bWJlciBvZiBhdHRlbXB0cyB0byBtYWtlIGJlZm9yZSBnaXZpbmcgdXAuICBUaGUgZGVmYXVsdFxuICogICBpcyBgNWAuXG4gKiAqIGBpbnRlcnZhbGAgLSBUaGUgdGltZSB0byB3YWl0IGJldHdlZW4gcmV0cmllcywgaW4gbWlsbGlzZWNvbmRzLiAgVGhlXG4gKiAgIGRlZmF1bHQgaXMgYDBgLiBUaGUgaW50ZXJ2YWwgbWF5IGFsc28gYmUgc3BlY2lmaWVkIGFzIGEgZnVuY3Rpb24gb2YgdGhlXG4gKiAgIHJldHJ5IGNvdW50IChzZWUgZXhhbXBsZSkuXG4gKiAqIGBlcnJvckZpbHRlcmAgLSBBbiBvcHRpb25hbCBzeW5jaHJvbm91cyBmdW5jdGlvbiB0aGF0IGlzIGludm9rZWQgb25cbiAqICAgZXJyb25lb3VzIHJlc3VsdC4gSWYgaXQgcmV0dXJucyBgdHJ1ZWAgdGhlIHJldHJ5IGF0dGVtcHRzIHdpbGwgY29udGludWU7XG4gKiAgIGlmIHRoZSBmdW5jdGlvbiByZXR1cm5zIGBmYWxzZWAgdGhlIHJldHJ5IGZsb3cgaXMgYWJvcnRlZCB3aXRoIHRoZSBjdXJyZW50XG4gKiAgIGF0dGVtcHQncyBlcnJvciBhbmQgcmVzdWx0IGJlaW5nIHJldHVybmVkIHRvIHRoZSBmaW5hbCBjYWxsYmFjay5cbiAqICAgSW52b2tlZCB3aXRoIChlcnIpLlxuICogKiBJZiBgb3B0c2AgaXMgYSBudW1iZXIsIHRoZSBudW1iZXIgc3BlY2lmaWVzIHRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmV0cnksXG4gKiAgIHdpdGggdGhlIGRlZmF1bHQgaW50ZXJ2YWwgb2YgYDBgLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSB0YXNrIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gcmV0cnkuXG4gKiBJbnZva2VkIHdpdGggKGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBbiBvcHRpb25hbCBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiB0aGVcbiAqIHRhc2sgaGFzIHN1Y2NlZWRlZCwgb3IgYWZ0ZXIgdGhlIGZpbmFsIGZhaWxlZCBhdHRlbXB0LiBJdCByZWNlaXZlcyB0aGUgYGVycmBcbiAqIGFuZCBgcmVzdWx0YCBhcmd1bWVudHMgb2YgdGhlIGxhc3QgYXR0ZW1wdCBhdCBjb21wbGV0aW5nIHRoZSBgdGFza2AuIEludm9rZWRcbiAqIHdpdGggKGVyciwgcmVzdWx0cykuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlIGlmIG5vIGNhbGxiYWNrIHByb3ZpZGVkXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBUaGUgYHJldHJ5YCBmdW5jdGlvbiBjYW4gYmUgdXNlZCBhcyBhIHN0YW5kLWFsb25lIGNvbnRyb2wgZmxvdyBieSBwYXNzaW5nXG4gKiAvLyBhIGNhbGxiYWNrLCBhcyBzaG93biBiZWxvdzpcbiAqXG4gKiAvLyB0cnkgY2FsbGluZyBhcGlNZXRob2QgMyB0aW1lc1xuICogYXN5bmMucmV0cnkoMywgYXBpTWV0aG9kLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSByZXN1bHRcbiAqIH0pO1xuICpcbiAqIC8vIHRyeSBjYWxsaW5nIGFwaU1ldGhvZCAzIHRpbWVzLCB3YWl0aW5nIDIwMCBtcyBiZXR3ZWVuIGVhY2ggcmV0cnlcbiAqIGFzeW5jLnJldHJ5KHt0aW1lczogMywgaW50ZXJ2YWw6IDIwMH0sIGFwaU1ldGhvZCwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAqICAgICAvLyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgcmVzdWx0XG4gKiB9KTtcbiAqXG4gKiAvLyB0cnkgY2FsbGluZyBhcGlNZXRob2QgMTAgdGltZXMgd2l0aCBleHBvbmVudGlhbCBiYWNrb2ZmXG4gKiAvLyAoaS5lLiBpbnRlcnZhbHMgb2YgMTAwLCAyMDAsIDQwMCwgODAwLCAxNjAwLCAuLi4gbWlsbGlzZWNvbmRzKVxuICogYXN5bmMucmV0cnkoe1xuICogICB0aW1lczogMTAsXG4gKiAgIGludGVydmFsOiBmdW5jdGlvbihyZXRyeUNvdW50KSB7XG4gKiAgICAgcmV0dXJuIDUwICogTWF0aC5wb3coMiwgcmV0cnlDb3VudCk7XG4gKiAgIH1cbiAqIH0sIGFwaU1ldGhvZCwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAqICAgICAvLyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgcmVzdWx0XG4gKiB9KTtcbiAqXG4gKiAvLyB0cnkgY2FsbGluZyBhcGlNZXRob2QgdGhlIGRlZmF1bHQgNSB0aW1lcyBubyBkZWxheSBiZXR3ZWVuIGVhY2ggcmV0cnlcbiAqIGFzeW5jLnJldHJ5KGFwaU1ldGhvZCwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAqICAgICAvLyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgcmVzdWx0XG4gKiB9KTtcbiAqXG4gKiAvLyB0cnkgY2FsbGluZyBhcGlNZXRob2Qgb25seSB3aGVuIGVycm9yIGNvbmRpdGlvbiBzYXRpc2ZpZXMsIGFsbCBvdGhlclxuICogLy8gZXJyb3JzIHdpbGwgYWJvcnQgdGhlIHJldHJ5IGNvbnRyb2wgZmxvdyBhbmQgcmV0dXJuIHRvIGZpbmFsIGNhbGxiYWNrXG4gKiBhc3luYy5yZXRyeSh7XG4gKiAgIGVycm9yRmlsdGVyOiBmdW5jdGlvbihlcnIpIHtcbiAqICAgICByZXR1cm4gZXJyLm1lc3NhZ2UgPT09ICdUZW1wb3JhcnkgZXJyb3InOyAvLyBvbmx5IHJldHJ5IG9uIGEgc3BlY2lmaWMgZXJyb3JcbiAqICAgfVxuICogfSwgYXBpTWV0aG9kLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSByZXN1bHRcbiAqIH0pO1xuICpcbiAqIC8vIHRvIHJldHJ5IGluZGl2aWR1YWwgbWV0aG9kcyB0aGF0IGFyZSBub3QgYXMgcmVsaWFibGUgd2l0aGluIG90aGVyXG4gKiAvLyBjb250cm9sIGZsb3cgZnVuY3Rpb25zLCB1c2UgdGhlIGByZXRyeWFibGVgIHdyYXBwZXI6XG4gKiBhc3luYy5hdXRvKHtcbiAqICAgICB1c2VyczogYXBpLmdldFVzZXJzLmJpbmQoYXBpKSxcbiAqICAgICBwYXltZW50czogYXN5bmMucmV0cnlhYmxlKDMsIGFwaS5nZXRQYXltZW50cy5iaW5kKGFwaSkpXG4gKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICAvLyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgcmVzdWx0c1xuICogfSk7XG4gKlxuICovXG5jb25zdCBERUZBVUxUX1RJTUVTID0gNTtcbmNvbnN0IERFRkFVTFRfSU5URVJWQUwgPSAwO1xuXG5mdW5jdGlvbiByZXRyeShvcHRzLCB0YXNrLCBjYWxsYmFjaykge1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICB0aW1lczogREVGQVVMVF9USU1FUyxcbiAgICAgICAgaW50ZXJ2YWxGdW5jOiBjb25zdGFudChERUZBVUxUX0lOVEVSVkFMKVxuICAgIH07XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMgJiYgdHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSB0YXNrIHx8ICgwLCBfcHJvbWlzZUNhbGxiYWNrLnByb21pc2VDYWxsYmFjaykoKTtcbiAgICAgICAgdGFzayA9IG9wdHM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VUaW1lcyhvcHRpb25zLCBvcHRzKTtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCAoMCwgX3Byb21pc2VDYWxsYmFjay5wcm9taXNlQ2FsbGJhY2spKCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0YXNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnRzIGZvciBhc3luYy5yZXRyeVwiKTtcbiAgICB9XG5cbiAgICB2YXIgX3Rhc2sgPSAoMCwgX3dyYXBBc3luYzIuZGVmYXVsdCkodGFzayk7XG5cbiAgICB2YXIgYXR0ZW1wdCA9IDE7XG4gICAgZnVuY3Rpb24gcmV0cnlBdHRlbXB0KCkge1xuICAgICAgICBfdGFzaygoZXJyLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKGVyciAmJiBhdHRlbXB0KysgPCBvcHRpb25zLnRpbWVzICYmICh0eXBlb2Ygb3B0aW9ucy5lcnJvckZpbHRlciAhPSAnZnVuY3Rpb24nIHx8IG9wdGlvbnMuZXJyb3JGaWx0ZXIoZXJyKSkpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHJldHJ5QXR0ZW1wdCwgb3B0aW9ucy5pbnRlcnZhbEZ1bmMoYXR0ZW1wdCAtIDEpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0cnlBdHRlbXB0KCk7XG4gICAgcmV0dXJuIGNhbGxiYWNrW19wcm9taXNlQ2FsbGJhY2suUFJPTUlTRV9TWU1CT0xdO1xufVxuXG5mdW5jdGlvbiBwYXJzZVRpbWVzKGFjYywgdCkge1xuICAgIGlmICh0eXBlb2YgdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYWNjLnRpbWVzID0gK3QudGltZXMgfHwgREVGQVVMVF9USU1FUztcblxuICAgICAgICBhY2MuaW50ZXJ2YWxGdW5jID0gdHlwZW9mIHQuaW50ZXJ2YWwgPT09ICdmdW5jdGlvbicgPyB0LmludGVydmFsIDogY29uc3RhbnQoK3QuaW50ZXJ2YWwgfHwgREVGQVVMVF9JTlRFUlZBTCk7XG5cbiAgICAgICAgYWNjLmVycm9yRmlsdGVyID0gdC5lcnJvckZpbHRlcjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0ID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYWNjLnRpbWVzID0gK3QgfHwgREVGQVVMVF9USU1FUztcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50cyBmb3IgYXN5bmMucmV0cnlcIik7XG4gICAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfb25jZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvb25jZScpO1xuXG52YXIgX29uY2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb25jZSk7XG5cbnZhciBfb25seU9uY2UgPSByZXF1aXJlKCcuL2ludGVybmFsL29ubHlPbmNlJyk7XG5cbnZhciBfb25seU9uY2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb25seU9uY2UpO1xuXG52YXIgX3dyYXBBc3luYyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvd3JhcEFzeW5jJyk7XG5cbnZhciBfd3JhcEFzeW5jMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dyYXBBc3luYyk7XG5cbnZhciBfYXdhaXRpZnkgPSByZXF1aXJlKCcuL2ludGVybmFsL2F3YWl0aWZ5Jyk7XG5cbnZhciBfYXdhaXRpZnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXdhaXRpZnkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIFJ1bnMgdGhlIGB0YXNrc2AgYXJyYXkgb2YgZnVuY3Rpb25zIGluIHNlcmllcywgZWFjaCBwYXNzaW5nIHRoZWlyIHJlc3VsdHMgdG9cbiAqIHRoZSBuZXh0IGluIHRoZSBhcnJheS4gSG93ZXZlciwgaWYgYW55IG9mIHRoZSBgdGFza3NgIHBhc3MgYW4gZXJyb3IgdG8gdGhlaXJcbiAqIG93biBjYWxsYmFjaywgdGhlIG5leHQgZnVuY3Rpb24gaXMgbm90IGV4ZWN1dGVkLCBhbmQgdGhlIG1haW4gYGNhbGxiYWNrYCBpc1xuICogaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlIGVycm9yLlxuICpcbiAqIEBuYW1lIHdhdGVyZmFsbFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtBcnJheX0gdGFza3MgLSBBbiBhcnJheSBvZiBbYXN5bmMgZnVuY3Rpb25zXXtAbGluayBBc3luY0Z1bmN0aW9ufVxuICogdG8gcnVuLlxuICogRWFjaCBmdW5jdGlvbiBzaG91bGQgY29tcGxldGUgd2l0aCBhbnkgbnVtYmVyIG9mIGByZXN1bHRgIHZhbHVlcy5cbiAqIFRoZSBgcmVzdWx0YCB2YWx1ZXMgd2lsbCBiZSBwYXNzZWQgYXMgYXJndW1lbnRzLCBpbiBvcmRlciwgdG8gdGhlIG5leHQgdGFzay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBbiBvcHRpb25hbCBjYWxsYmFjayB0byBydW4gb25jZSBhbGwgdGhlXG4gKiBmdW5jdGlvbnMgaGF2ZSBjb21wbGV0ZWQuIFRoaXMgd2lsbCBiZSBwYXNzZWQgdGhlIHJlc3VsdHMgb2YgdGhlIGxhc3QgdGFzaydzXG4gKiBjYWxsYmFjay4gSW52b2tlZCB3aXRoIChlcnIsIFtyZXN1bHRzXSkuXG4gKiBAcmV0dXJucyB1bmRlZmluZWRcbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMud2F0ZXJmYWxsKFtcbiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBjYWxsYmFjayhudWxsLCAnb25lJywgJ3R3bycpO1xuICogICAgIH0sXG4gKiAgICAgZnVuY3Rpb24oYXJnMSwgYXJnMiwgY2FsbGJhY2spIHtcbiAqICAgICAgICAgLy8gYXJnMSBub3cgZXF1YWxzICdvbmUnIGFuZCBhcmcyIG5vdyBlcXVhbHMgJ3R3bydcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ3RocmVlJyk7XG4gKiAgICAgfSxcbiAqICAgICBmdW5jdGlvbihhcmcxLCBjYWxsYmFjaykge1xuICogICAgICAgICAvLyBhcmcxIG5vdyBlcXVhbHMgJ3RocmVlJ1xuICogICAgICAgICBjYWxsYmFjayhudWxsLCAnZG9uZScpO1xuICogICAgIH1cbiAqIF0sIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuICogICAgIC8vIHJlc3VsdCBub3cgZXF1YWxzICdkb25lJ1xuICogfSk7XG4gKlxuICogLy8gT3IsIHdpdGggbmFtZWQgZnVuY3Rpb25zOlxuICogYXN5bmMud2F0ZXJmYWxsKFtcbiAqICAgICBteUZpcnN0RnVuY3Rpb24sXG4gKiAgICAgbXlTZWNvbmRGdW5jdGlvbixcbiAqICAgICBteUxhc3RGdW5jdGlvbixcbiAqIF0sIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuICogICAgIC8vIHJlc3VsdCBub3cgZXF1YWxzICdkb25lJ1xuICogfSk7XG4gKiBmdW5jdGlvbiBteUZpcnN0RnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICBjYWxsYmFjayhudWxsLCAnb25lJywgJ3R3bycpO1xuICogfVxuICogZnVuY3Rpb24gbXlTZWNvbmRGdW5jdGlvbihhcmcxLCBhcmcyLCBjYWxsYmFjaykge1xuICogICAgIC8vIGFyZzEgbm93IGVxdWFscyAnb25lJyBhbmQgYXJnMiBub3cgZXF1YWxzICd0d28nXG4gKiAgICAgY2FsbGJhY2sobnVsbCwgJ3RocmVlJyk7XG4gKiB9XG4gKiBmdW5jdGlvbiBteUxhc3RGdW5jdGlvbihhcmcxLCBjYWxsYmFjaykge1xuICogICAgIC8vIGFyZzEgbm93IGVxdWFscyAndGhyZWUnXG4gKiAgICAgY2FsbGJhY2sobnVsbCwgJ2RvbmUnKTtcbiAqIH1cbiAqL1xuZnVuY3Rpb24gd2F0ZXJmYWxsKHRhc2tzLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gKDAsIF9vbmNlMi5kZWZhdWx0KShjYWxsYmFjayk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRhc2tzKSkgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgdG8gd2F0ZXJmYWxsIG11c3QgYmUgYW4gYXJyYXkgb2YgZnVuY3Rpb25zJykpO1xuICAgIGlmICghdGFza3MubGVuZ3RoKSByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB2YXIgdGFza0luZGV4ID0gMDtcblxuICAgIGZ1bmN0aW9uIG5leHRUYXNrKGFyZ3MpIHtcbiAgICAgICAgdmFyIHRhc2sgPSAoMCwgX3dyYXBBc3luYzIuZGVmYXVsdCkodGFza3NbdGFza0luZGV4KytdKTtcbiAgICAgICAgdGFzayguLi5hcmdzLCAoMCwgX29ubHlPbmNlMi5kZWZhdWx0KShuZXh0KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbmV4dChlcnIsIC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKGVyciA9PT0gZmFsc2UpIHJldHVybjtcbiAgICAgICAgaWYgKGVyciB8fCB0YXNrSW5kZXggPT09IHRhc2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dFRhc2soYXJncyk7XG4gICAgfVxuXG4gICAgbmV4dFRhc2soW10pO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSAoMCwgX2F3YWl0aWZ5Mi5kZWZhdWx0KSh3YXRlcmZhbGwpO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiLypcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHRcbiAqIGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGVcbiAqIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyXG4gKiBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7Q3J5cHRvLCBEZWZhdWx0Q3J5cHRvfSBmcm9tICcuL2NyeXB0b191dGlscyc7XG5pbXBvcnQge2xvZ30gZnJvbSAnLi9sb2dnZXInO1xuaW1wb3J0IHtTdHJpbmdNYXB9IGZyb20gJy4vdHlwZXMnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gQXV0aG9yaXphdGlvblJlcXVlc3QgYXMgSlNPTi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBdXRob3JpemF0aW9uUmVxdWVzdEpzb24ge1xuICByZXNwb25zZV90eXBlOiBzdHJpbmc7XG4gIGNsaWVudF9pZDogc3RyaW5nO1xuICByZWRpcmVjdF91cmk6IHN0cmluZztcbiAgc2NvcGU6IHN0cmluZztcbiAgc3RhdGU/OiBzdHJpbmc7XG4gIGV4dHJhcz86IFN0cmluZ01hcDtcbiAgaW50ZXJuYWw/OiBTdHJpbmdNYXA7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgY3J5cHRvZ3JhcGhpY2FsbHkgcmFuZG9tIG5ldyBzdGF0ZS4gVXNlZnVsIGZvciBDU1JGIHByb3RlY3Rpb24uXG4gKi9cbmNvbnN0IFNJWkUgPSAxMDsgIC8vIDEwIGJ5dGVzXG5jb25zdCBuZXdTdGF0ZSA9IGZ1bmN0aW9uKGNyeXB0bzogQ3J5cHRvKTogc3RyaW5nIHtcbiAgcmV0dXJuIGNyeXB0by5nZW5lcmF0ZVJhbmRvbShTSVpFKTtcbn07XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgQXV0aG9yaXphdGlvblJlcXVlc3QuXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBsb29rIGF0XG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjc0OSNzZWN0aW9uLTQuMS4xXG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRob3JpemF0aW9uUmVxdWVzdCB7XG4gIHN0YXRpYyBSRVNQT05TRV9UWVBFX1RPS0VOID0gJ3Rva2VuJztcbiAgc3RhdGljIFJFU1BPTlNFX1RZUEVfQ09ERSA9ICdjb2RlJztcblxuICAvLyBOT1RFOlxuICAvLyBCb3RoIHJlZGlyZWN0X3VyaSBhbmQgc3RhdGUgYXJlIGFjdHVhbGx5IG9wdGlvbmFsLlxuICAvLyBIb3dldmVyIEFwcEF1dGggaXMgbW9yZSBvcGlvbmlvbmF0ZWQsIGFuZCByZXF1aXJlcyB5b3UgdG8gdXNlIGJvdGguXG5cbiAgY2xpZW50SWQ6IHN0cmluZztcbiAgcmVkaXJlY3RVcmk6IHN0cmluZztcbiAgc2NvcGU6IHN0cmluZztcbiAgcmVzcG9uc2VUeXBlOiBzdHJpbmc7XG4gIHN0YXRlOiBzdHJpbmc7XG4gIGV4dHJhcz86IFN0cmluZ01hcDtcbiAgaW50ZXJuYWw/OiBTdHJpbmdNYXA7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IEF1dGhvcml6YXRpb25SZXF1ZXN0LlxuICAgKiBVc2UgYSBgdW5kZWZpbmVkYCB2YWx1ZSBmb3IgdGhlIGBzdGF0ZWAgcGFyYW1ldGVyLCB0byBnZW5lcmF0ZSBhIHJhbmRvbVxuICAgKiBzdGF0ZSBmb3IgQ1NSRiBwcm90ZWN0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgICByZXF1ZXN0OiBBdXRob3JpemF0aW9uUmVxdWVzdEpzb24sXG4gICAgICBwcml2YXRlIGNyeXB0bzogQ3J5cHRvID0gbmV3IERlZmF1bHRDcnlwdG8oKSxcbiAgICAgIHByaXZhdGUgdXNlUGtjZTogYm9vbGVhbiA9IHRydWUpIHtcbiAgICB0aGlzLmNsaWVudElkID0gcmVxdWVzdC5jbGllbnRfaWQ7XG4gICAgdGhpcy5yZWRpcmVjdFVyaSA9IHJlcXVlc3QucmVkaXJlY3RfdXJpO1xuICAgIHRoaXMuc2NvcGUgPSByZXF1ZXN0LnNjb3BlO1xuICAgIHRoaXMucmVzcG9uc2VUeXBlID0gcmVxdWVzdC5yZXNwb25zZV90eXBlIHx8IEF1dGhvcml6YXRpb25SZXF1ZXN0LlJFU1BPTlNFX1RZUEVfQ09ERTtcbiAgICB0aGlzLnN0YXRlID0gcmVxdWVzdC5zdGF0ZSB8fCBuZXdTdGF0ZShjcnlwdG8pO1xuICAgIHRoaXMuZXh0cmFzID0gcmVxdWVzdC5leHRyYXM7XG4gICAgLy8gcmVhZCBpbnRlcm5hbCBwcm9wZXJ0aWVzIGlmIGF2YWlsYWJsZVxuICAgIHRoaXMuaW50ZXJuYWwgPSByZXF1ZXN0LmludGVybmFsO1xuICB9XG5cbiAgc2V0dXBDb2RlVmVyaWZpZXIoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF0aGlzLnVzZVBrY2UpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29kZVZlcmlmaWVyID0gdGhpcy5jcnlwdG8uZ2VuZXJhdGVSYW5kb20oMTI4KTtcbiAgICAgIGNvbnN0IGNoYWxsZW5nZTogUHJvbWlzZTxzdHJpbmd8dW5kZWZpbmVkPiA9XG4gICAgICAgICAgdGhpcy5jcnlwdG8uZGVyaXZlQ2hhbGxlbmdlKGNvZGVWZXJpZmllcikuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgbG9nKCdVbmFibGUgdG8gZ2VuZXJhdGUgUEtDRSBjaGFsbGVuZ2UuIE5vdCB1c2luZyBQS0NFJywgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICB9KTtcbiAgICAgIHJldHVybiBjaGFsbGVuZ2UudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgLy8ga2VlcCB0cmFjayBvZiB0aGUgY29kZSB1c2VkLlxuICAgICAgICAgIHRoaXMuaW50ZXJuYWwgPSB0aGlzLmludGVybmFsIHx8IHt9O1xuICAgICAgICAgIHRoaXMuaW50ZXJuYWxbJ2NvZGVfdmVyaWZpZXInXSA9IGNvZGVWZXJpZmllcjtcbiAgICAgICAgICB0aGlzLmV4dHJhcyA9IHRoaXMuZXh0cmFzIHx8IHt9O1xuICAgICAgICAgIHRoaXMuZXh0cmFzWydjb2RlX2NoYWxsZW5nZSddID0gcmVzdWx0O1xuICAgICAgICAgIC8vIFdlIGFsd2F5cyB1c2UgUzI1Ni4gUGxhaW4gaXMgbm90IGdvb2QgZW5vdWdoLlxuICAgICAgICAgIHRoaXMuZXh0cmFzWydjb2RlX2NoYWxsZW5nZV9tZXRob2QnXSA9ICdTMjU2JztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZXMgdGhlIEF1dGhvcml6YXRpb25SZXF1ZXN0IHRvIGEgSmF2YVNjcmlwdCBPYmplY3QuXG4gICAqL1xuICB0b0pzb24oKTogUHJvbWlzZTxBdXRob3JpemF0aW9uUmVxdWVzdEpzb24+IHtcbiAgICAvLyBBbHdheXMgbWFrZSBzdXJlIHRoYXQgdGhlIGNvZGUgdmVyaWZpZXIgaXMgc2V0dXAgd2hlbiB0b0pzb24oKSBpcyBjYWxsZWQuXG4gICAgcmV0dXJuIHRoaXMuc2V0dXBDb2RlVmVyaWZpZXIoKS50aGVuKCgpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc3BvbnNlX3R5cGU6IHRoaXMucmVzcG9uc2VUeXBlLFxuICAgICAgICBjbGllbnRfaWQ6IHRoaXMuY2xpZW50SWQsXG4gICAgICAgIHJlZGlyZWN0X3VyaTogdGhpcy5yZWRpcmVjdFVyaSxcbiAgICAgICAgc2NvcGU6IHRoaXMuc2NvcGUsXG4gICAgICAgIHN0YXRlOiB0aGlzLnN0YXRlLFxuICAgICAgICBleHRyYXM6IHRoaXMuZXh0cmFzLFxuICAgICAgICBpbnRlcm5hbDogdGhpcy5pbnRlcm5hbFxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHRcbiAqIGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGVcbiAqIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyXG4gKiBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7QXV0aG9yaXphdGlvblJlcXVlc3R9IGZyb20gJy4vYXV0aG9yaXphdGlvbl9yZXF1ZXN0JztcbmltcG9ydCB7QXV0aG9yaXphdGlvbkVycm9yLCBBdXRob3JpemF0aW9uUmVzcG9uc2V9IGZyb20gJy4vYXV0aG9yaXphdGlvbl9yZXNwb25zZSc7XG5pbXBvcnQge0F1dGhvcml6YXRpb25TZXJ2aWNlQ29uZmlndXJhdGlvbn0gZnJvbSAnLi9hdXRob3JpemF0aW9uX3NlcnZpY2VfY29uZmlndXJhdGlvbic7XG5pbXBvcnQge0NyeXB0b30gZnJvbSAnLi9jcnlwdG9fdXRpbHMnO1xuaW1wb3J0IHtsb2d9IGZyb20gJy4vbG9nZ2VyJztcbmltcG9ydCB7UXVlcnlTdHJpbmdVdGlsc30gZnJvbSAnLi9xdWVyeV9zdHJpbmdfdXRpbHMnO1xuaW1wb3J0IHtTdHJpbmdNYXB9IGZyb20gJy4vdHlwZXMnO1xuXG5cbi8qKlxuICogVGhpcyB0eXBlIHJlcHJlc2VudHMgYSBsYW1iZGEgdGhhdCBjYW4gdGFrZSBhbiBBdXRob3JpemF0aW9uUmVxdWVzdCxcbiAqIGFuZCBhbiBBdXRob3JpemF0aW9uUmVzcG9uc2UgYXMgYXJndW1lbnRzLlxuICovXG5leHBvcnQgdHlwZSBBdXRob3JpemF0aW9uTGlzdGVuZXIgPVxuICAgIChyZXF1ZXN0OiBBdXRob3JpemF0aW9uUmVxdWVzdCxcbiAgICAgcmVzcG9uc2U6IEF1dGhvcml6YXRpb25SZXNwb25zZXxudWxsLFxuICAgICBlcnJvcjogQXV0aG9yaXphdGlvbkVycm9yfG51bGwpID0+IHZvaWQ7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHN0cnVjdHVyYWwgdHlwZSBob2xkaW5nIGJvdGggYXV0aG9yaXphdGlvbiByZXF1ZXN0IGFuZCByZXNwb25zZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBdXRob3JpemF0aW9uUmVxdWVzdFJlc3BvbnNlIHtcbiAgcmVxdWVzdDogQXV0aG9yaXphdGlvblJlcXVlc3Q7XG4gIHJlc3BvbnNlOiBBdXRob3JpemF0aW9uUmVzcG9uc2V8bnVsbDtcbiAgZXJyb3I6IEF1dGhvcml6YXRpb25FcnJvcnxudWxsO1xufVxuXG4vKipcbiAqIEF1dGhvcml6YXRpb24gU2VydmljZSBub3RpZmllci5cbiAqIFRoaXMgbWFuYWdlcyB0aGUgY29tbXVuaWNhdGlvbiBvZiB0aGUgQXV0aG9yaXphdGlvblJlc3BvbnNlIHRvIHRoZSAzcCBjbGllbnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRob3JpemF0aW9uTm90aWZpZXIge1xuICBwcml2YXRlIGxpc3RlbmVyOiBBdXRob3JpemF0aW9uTGlzdGVuZXJ8bnVsbCA9IG51bGw7XG5cbiAgc2V0QXV0aG9yaXphdGlvbkxpc3RlbmVyKGxpc3RlbmVyOiBBdXRob3JpemF0aW9uTGlzdGVuZXIpIHtcbiAgICB0aGlzLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGF1dGhvcml6YXRpb24gY29tcGxldGUgY2FsbGJhY2suXG4gICAqL1xuICBvbkF1dGhvcml6YXRpb25Db21wbGV0ZShcbiAgICAgIHJlcXVlc3Q6IEF1dGhvcml6YXRpb25SZXF1ZXN0LFxuICAgICAgcmVzcG9uc2U6IEF1dGhvcml6YXRpb25SZXNwb25zZXxudWxsLFxuICAgICAgZXJyb3I6IEF1dGhvcml6YXRpb25FcnJvcnxudWxsKTogdm9pZCB7XG4gICAgaWYgKHRoaXMubGlzdGVuZXIpIHtcbiAgICAgIC8vIGNvbXBsZXRlIGF1dGhvcml6YXRpb24gcmVxdWVzdFxuICAgICAgdGhpcy5saXN0ZW5lcihyZXF1ZXN0LCByZXNwb25zZSwgZXJyb3IpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBUT0RPKHJhaHVscmF2QCk6IGFkZCBtb3JlIGJ1aWx0IGluIHBhcmFtZXRlcnMuXG4vKiBidWlsdCBpbiBwYXJhbWV0ZXJzLiAqL1xuZXhwb3J0IGNvbnN0IEJVSUxUX0lOX1BBUkFNRVRFUlMgPSBbJ3JlZGlyZWN0X3VyaScsICdjbGllbnRfaWQnLCAncmVzcG9uc2VfdHlwZScsICdzdGF0ZScsICdzY29wZSddO1xuXG4vKipcbiAqIERlZmluZXMgdGhlIGludGVyZmFjZSB3aGljaCBpcyBjYXBhYmxlIG9mIGhhbmRsaW5nIGFuIGF1dGhvcml6YXRpb24gcmVxdWVzdFxuICogdXNpbmcgdmFyaW91cyBtZXRob2RzIChpZnJhbWUgLyBwb3B1cCAvIGRpZmZlcmVudCBwcm9jZXNzIGV0Yy4pLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQXV0aG9yaXphdGlvblJlcXVlc3RIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IocHVibGljIHV0aWxzOiBRdWVyeVN0cmluZ1V0aWxzLCBwcm90ZWN0ZWQgY3J5cHRvOiBDcnlwdG8pIHt9XG5cbiAgLy8gbm90aWZpZXIgc2VuZCB0aGUgcmVzcG9uc2UgYmFjayB0byB0aGUgY2xpZW50LlxuICBwcm90ZWN0ZWQgbm90aWZpZXI6IEF1dGhvcml6YXRpb25Ob3RpZmllcnxudWxsID0gbnVsbDtcblxuICAvKipcbiAgICogQSB1dGlsaXR5IG1ldGhvZCB0byBiZSBhYmxlIHRvIGJ1aWxkIHRoZSBhdXRob3JpemF0aW9uIHJlcXVlc3QgVVJMLlxuICAgKi9cbiAgcHJvdGVjdGVkIGJ1aWxkUmVxdWVzdFVybChcbiAgICAgIGNvbmZpZ3VyYXRpb246IEF1dGhvcml6YXRpb25TZXJ2aWNlQ29uZmlndXJhdGlvbixcbiAgICAgIHJlcXVlc3Q6IEF1dGhvcml6YXRpb25SZXF1ZXN0KSB7XG4gICAgLy8gYnVpbGQgdGhlIHF1ZXJ5IHN0cmluZ1xuICAgIC8vIGNvZXJjZSB0byBhbnkgdHlwZSBmb3IgY29udmVuaWVuY2VcbiAgICBsZXQgcmVxdWVzdE1hcDogU3RyaW5nTWFwID0ge1xuICAgICAgJ3JlZGlyZWN0X3VyaSc6IHJlcXVlc3QucmVkaXJlY3RVcmksXG4gICAgICAnY2xpZW50X2lkJzogcmVxdWVzdC5jbGllbnRJZCxcbiAgICAgICdyZXNwb25zZV90eXBlJzogcmVxdWVzdC5yZXNwb25zZVR5cGUsXG4gICAgICAnc3RhdGUnOiByZXF1ZXN0LnN0YXRlLFxuICAgICAgJ3Njb3BlJzogcmVxdWVzdC5zY29wZVxuICAgIH07XG5cbiAgICAvLyBjb3B5IG92ZXIgZXh0cmFzXG4gICAgaWYgKHJlcXVlc3QuZXh0cmFzKSB7XG4gICAgICBmb3IgKGxldCBleHRyYSBpbiByZXF1ZXN0LmV4dHJhcykge1xuICAgICAgICBpZiAocmVxdWVzdC5leHRyYXMuaGFzT3duUHJvcGVydHkoZXh0cmEpKSB7XG4gICAgICAgICAgLy8gY2hlY2sgYmVmb3JlIGluc2VydGluZyB0byByZXF1ZXN0TWFwXG4gICAgICAgICAgaWYgKEJVSUxUX0lOX1BBUkFNRVRFUlMuaW5kZXhPZihleHRyYSkgPCAwKSB7XG4gICAgICAgICAgICByZXF1ZXN0TWFwW2V4dHJhXSA9IHJlcXVlc3QuZXh0cmFzW2V4dHJhXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgcXVlcnkgPSB0aGlzLnV0aWxzLnN0cmluZ2lmeShyZXF1ZXN0TWFwKTtcbiAgICBsZXQgYmFzZVVybCA9IGNvbmZpZ3VyYXRpb24uYXV0aG9yaXphdGlvbkVuZHBvaW50O1xuICAgIGxldCB1cmwgPSBgJHtiYXNlVXJsfT8ke3F1ZXJ5fWA7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wbGV0ZXMgdGhlIGF1dGhvcml6YXRpb24gcmVxdWVzdCBpZiBuZWNlc3NhcnkgJiB3aGVuIHBvc3NpYmxlLlxuICAgKi9cbiAgY29tcGxldGVBdXRob3JpemF0aW9uUmVxdWVzdElmUG9zc2libGUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gY2FsbCBjb21wbGV0ZSBhdXRob3JpemF0aW9uIGlmIHBvc3NpYmxlIHRvIHNlZSB0aGVyZSBtaWdodFxuICAgIC8vIGJlIGEgcmVzcG9uc2UgdGhhdCBuZWVkcyB0byBiZSBkZWxpdmVyZWQuXG4gICAgbG9nKGBDaGVja2luZyB0byBzZWUgaWYgdGhlcmUgaXMgYW4gYXV0aG9yaXphdGlvbiByZXNwb25zZSB0byBiZSBkZWxpdmVyZWQuYCk7XG4gICAgaWYgKCF0aGlzLm5vdGlmaWVyKSB7XG4gICAgICBsb2coYE5vdGlmaWVyIGlzIG5vdCBwcmVzZW50IG9uIEF1dGhvcml6YXRpb25SZXF1ZXN0IGhhbmRsZXIuXG4gICAgICAgICAgTm8gZGVsaXZlcnkgb2YgcmVzdWx0IHdpbGwgYmUgcG9zc2libGVgKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb21wbGV0ZUF1dGhvcml6YXRpb25SZXF1ZXN0KCkudGhlbihyZXN1bHQgPT4ge1xuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgbG9nKGBObyByZXN1bHQgaXMgYXZhaWxhYmxlIHlldC5gKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgJiYgdGhpcy5ub3RpZmllcikge1xuICAgICAgICB0aGlzLm5vdGlmaWVyLm9uQXV0aG9yaXphdGlvbkNvbXBsZXRlKHJlc3VsdC5yZXF1ZXN0LCByZXN1bHQucmVzcG9uc2UsIHJlc3VsdC5lcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZGVmYXVsdCBBdXRob3JpemF0aW9uIFNlcnZpY2Ugbm90aWZpZXIuXG4gICAqL1xuICBzZXRBdXRob3JpemF0aW9uTm90aWZpZXIobm90aWZpZXI6IEF1dGhvcml6YXRpb25Ob3RpZmllcik6IEF1dGhvcml6YXRpb25SZXF1ZXN0SGFuZGxlciB7XG4gICAgdGhpcy5ub3RpZmllciA9IG5vdGlmaWVyO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNYWtlcyBhbiBhdXRob3JpemF0aW9uIHJlcXVlc3QuXG4gICAqL1xuICBhYnN0cmFjdCBwZXJmb3JtQXV0aG9yaXphdGlvblJlcXVlc3QoXG4gICAgICBjb25maWd1cmF0aW9uOiBBdXRob3JpemF0aW9uU2VydmljZUNvbmZpZ3VyYXRpb24sXG4gICAgICByZXF1ZXN0OiBBdXRob3JpemF0aW9uUmVxdWVzdCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhbiBhdXRob3JpemF0aW9uIGZsb3cgY2FuIGJlIGNvbXBsZXRlZCwgYW5kIGNvbXBsZXRlcyBpdC5cbiAgICogVGhlIGhhbmRsZXIgcmV0dXJucyBhIGBQcm9taXNlPEF1dGhvcml6YXRpb25SZXF1ZXN0UmVzcG9uc2U+YCBpZiByZWFkeSwgb3IgYSBgUHJvbWlzZTxudWxsPmBcbiAgICogaWYgbm90IHJlYWR5LlxuICAgKi9cbiAgcHJvdGVjdGVkIGFic3RyYWN0IGNvbXBsZXRlQXV0aG9yaXphdGlvblJlcXVlc3QoKTogUHJvbWlzZTxBdXRob3JpemF0aW9uUmVxdWVzdFJlc3BvbnNlfG51bGw+O1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHRcbiAqIGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGVcbiAqIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyXG4gKiBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgQXV0aG9yaXphdGlvblJlc3BvbnNlIGFzIGEgSlNPTiBvYmplY3QuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQXV0aG9yaXphdGlvblJlc3BvbnNlSnNvbiB7XG4gIGNvZGU6IHN0cmluZztcbiAgc3RhdGU6IHN0cmluZztcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBBdXRob3JpemF0aW9uRXJyb3IgYXMgYSBKU09OIG9iamVjdC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBdXRob3JpemF0aW9uRXJyb3JKc29uIHtcbiAgZXJyb3I6IHN0cmluZztcbiAgZXJyb3JfZGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gIGVycm9yX3VyaT86IHN0cmluZztcbiAgc3RhdGU/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgQXV0aG9yaXphdGlvbiBSZXNwb25zZSB0eXBlLlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gbG9vayBhdFxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY3NDkjc2VjdGlvbi00LjEuMlxuICovXG5leHBvcnQgY2xhc3MgQXV0aG9yaXphdGlvblJlc3BvbnNlIHtcbiAgY29kZTogc3RyaW5nO1xuICBzdGF0ZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHJlc3BvbnNlOiBBdXRob3JpemF0aW9uUmVzcG9uc2VKc29uKSB7XG4gICAgdGhpcy5jb2RlID0gcmVzcG9uc2UuY29kZTtcbiAgICB0aGlzLnN0YXRlID0gcmVzcG9uc2Uuc3RhdGU7XG4gIH1cblxuICB0b0pzb24oKTogQXV0aG9yaXphdGlvblJlc3BvbnNlSnNvbiB7XG4gICAgcmV0dXJuIHtjb2RlOiB0aGlzLmNvZGUsIHN0YXRlOiB0aGlzLnN0YXRlfTtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIEF1dGhvcml6YXRpb24gZXJyb3IgcmVzcG9uc2UuXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBsb29rIGF0OlxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY3NDkjc2VjdGlvbi00LjEuMi4xXG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRob3JpemF0aW9uRXJyb3Ige1xuICBlcnJvcjogc3RyaW5nO1xuICBlcnJvckRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICBlcnJvclVyaT86IHN0cmluZztcbiAgc3RhdGU/OiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoZXJyb3I6IEF1dGhvcml6YXRpb25FcnJvckpzb24pIHtcbiAgICB0aGlzLmVycm9yID0gZXJyb3IuZXJyb3I7XG4gICAgdGhpcy5lcnJvckRlc2NyaXB0aW9uID0gZXJyb3IuZXJyb3JfZGVzY3JpcHRpb247XG4gICAgdGhpcy5lcnJvclVyaSA9IGVycm9yLmVycm9yX3VyaTtcbiAgICB0aGlzLnN0YXRlID0gZXJyb3Iuc3RhdGU7XG4gIH1cblxuICB0b0pzb24oKTogQXV0aG9yaXphdGlvbkVycm9ySnNvbiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yOiB0aGlzLmVycm9yLFxuICAgICAgZXJyb3JfZGVzY3JpcHRpb246IHRoaXMuZXJyb3JEZXNjcmlwdGlvbixcbiAgICAgIGVycm9yX3VyaTogdGhpcy5lcnJvclVyaSxcbiAgICAgIHN0YXRlOiB0aGlzLnN0YXRlXG4gICAgfTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHRcbiAqIGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGVcbiAqIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyXG4gKiBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7SlF1ZXJ5UmVxdWVzdG9yLCBSZXF1ZXN0b3J9IGZyb20gJy4veGhyJztcblxuXG4vKipcbiAqIFJlcHJlc2VudHMgQXV0aG9yaXphdGlvblNlcnZpY2VDb25maWd1cmF0aW9uIGFzIGEgSlNPTiBvYmplY3QuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQXV0aG9yaXphdGlvblNlcnZpY2VDb25maWd1cmF0aW9uSnNvbiB7XG4gIGF1dGhvcml6YXRpb25fZW5kcG9pbnQ6IHN0cmluZztcbiAgdG9rZW5fZW5kcG9pbnQ6IHN0cmluZztcbiAgcmV2b2NhdGlvbl9lbmRwb2ludDogc3RyaW5nO1xuICBlbmRfc2Vzc2lvbl9lbmRwb2ludD86IHN0cmluZztcbiAgdXNlcmluZm9fZW5kcG9pbnQ/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogVGhlIHN0YW5kYXJkIGJhc2UgcGF0aCBmb3Igd2VsbC1rbm93biByZXNvdXJjZXMgb24gZG9tYWlucy5cbiAqIFNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNTc4NSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqL1xuY29uc3QgV0VMTF9LTk9XTl9QQVRIID0gJy53ZWxsLWtub3duJztcblxuLyoqXG4gKiBUaGUgc3RhbmRhcmQgcmVzb3VyY2UgdW5kZXIgdGhlIHdlbGwga25vd24gcGF0aCBhdCB3aGljaCBhbiBPcGVuSUQgQ29ubmVjdFxuICogZGlzY292ZXJ5IGRvY3VtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBhbiBpc3N1ZXIncyBiYXNlIFVSSS5cbiAqL1xuY29uc3QgT1BFTklEX0NPTkZJR1VSQVRJT04gPSAnb3BlbmlkLWNvbmZpZ3VyYXRpb24nO1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gZGV0YWlscyByZXF1aXJlZCB0byBpbnRlcmFjdCB3aXRoIGFuIGF1dGhvcml6YXRpb24gc2VydmljZS5cbiAqXG4gKiBNb3JlIGluZm9ybWF0aW9uIGF0IGh0dHBzOi8vb3BlbmlkLm5ldC9zcGVjcy9vcGVuaWQtY29ubmVjdC1kaXNjb3ZlcnktMV8wLTE3Lmh0bWxcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dGhvcml6YXRpb25TZXJ2aWNlQ29uZmlndXJhdGlvbiB7XG4gIGF1dGhvcml6YXRpb25FbmRwb2ludDogc3RyaW5nO1xuICB0b2tlbkVuZHBvaW50OiBzdHJpbmc7XG4gIHJldm9jYXRpb25FbmRwb2ludDogc3RyaW5nO1xuICB1c2VySW5mb0VuZHBvaW50Pzogc3RyaW5nO1xuICBlbmRTZXNzaW9uRW5kcG9pbnQ/OiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IocmVxdWVzdDogQXV0aG9yaXphdGlvblNlcnZpY2VDb25maWd1cmF0aW9uSnNvbikge1xuICAgIHRoaXMuYXV0aG9yaXphdGlvbkVuZHBvaW50ID0gcmVxdWVzdC5hdXRob3JpemF0aW9uX2VuZHBvaW50O1xuICAgIHRoaXMudG9rZW5FbmRwb2ludCA9IHJlcXVlc3QudG9rZW5fZW5kcG9pbnQ7XG4gICAgdGhpcy5yZXZvY2F0aW9uRW5kcG9pbnQgPSByZXF1ZXN0LnJldm9jYXRpb25fZW5kcG9pbnQ7XG4gICAgdGhpcy51c2VySW5mb0VuZHBvaW50ID0gcmVxdWVzdC51c2VyaW5mb19lbmRwb2ludDtcbiAgICB0aGlzLmVuZFNlc3Npb25FbmRwb2ludCA9IHJlcXVlc3QuZW5kX3Nlc3Npb25fZW5kcG9pbnQ7XG4gIH1cblxuICB0b0pzb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGF1dGhvcml6YXRpb25fZW5kcG9pbnQ6IHRoaXMuYXV0aG9yaXphdGlvbkVuZHBvaW50LFxuICAgICAgdG9rZW5fZW5kcG9pbnQ6IHRoaXMudG9rZW5FbmRwb2ludCxcbiAgICAgIHJldm9jYXRpb25fZW5kcG9pbnQ6IHRoaXMucmV2b2NhdGlvbkVuZHBvaW50LFxuICAgICAgZW5kX3Nlc3Npb25fZW5kcG9pbnQ6IHRoaXMuZW5kU2Vzc2lvbkVuZHBvaW50LFxuICAgICAgdXNlcmluZm9fZW5kcG9pbnQ6IHRoaXMudXNlckluZm9FbmRwb2ludFxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgZmV0Y2hGcm9tSXNzdWVyKG9wZW5JZElzc3VlclVybDogc3RyaW5nLCByZXF1ZXN0b3I/OiBSZXF1ZXN0b3IpOlxuICAgICAgUHJvbWlzZTxBdXRob3JpemF0aW9uU2VydmljZUNvbmZpZ3VyYXRpb24+IHtcbiAgICBjb25zdCBmdWxsVXJsID0gYCR7b3BlbklkSXNzdWVyVXJsfS8ke1dFTExfS05PV05fUEFUSH0vJHtPUEVOSURfQ09ORklHVVJBVElPTn1gO1xuXG4gICAgY29uc3QgcmVxdWVzdG9yVG9Vc2UgPSByZXF1ZXN0b3IgfHwgbmV3IEpRdWVyeVJlcXVlc3RvcigpO1xuXG4gICAgcmV0dXJuIHJlcXVlc3RvclRvVXNlXG4gICAgICAgIC54aHI8QXV0aG9yaXphdGlvblNlcnZpY2VDb25maWd1cmF0aW9uSnNvbj4oe3VybDogZnVsbFVybCwgZGF0YVR5cGU6ICdqc29uJywgbWV0aG9kOiAnR0VUJ30pXG4gICAgICAgIC50aGVuKGpzb24gPT4gbmV3IEF1dGhvcml6YXRpb25TZXJ2aWNlQ29uZmlndXJhdGlvbihqc29uKSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0XG4gKiBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlXG4gKiBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlclxuICogZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgKiBhcyBiYXNlNjQgZnJvbSAnYmFzZTY0LWpzJztcblxuaW1wb3J0IHtBcHBBdXRoRXJyb3J9IGZyb20gJy4vZXJyb3JzJztcblxuY29uc3QgSEFTX0NSWVBUTyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICEhKHdpbmRvdy5jcnlwdG8gYXMgYW55KTtcbmNvbnN0IEhBU19TVUJUTEVfQ1JZUFRPID0gSEFTX0NSWVBUTyAmJiAhISh3aW5kb3cuY3J5cHRvLnN1YnRsZSBhcyBhbnkpO1xuY29uc3QgQ0hBUlNFVCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBidWZmZXJUb1N0cmluZyhidWZmZXI6IFVpbnQ4QXJyYXkpIHtcbiAgbGV0IHN0YXRlID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyLmJ5dGVMZW5ndGg7IGkgKz0gMSkge1xuICAgIGxldCBpbmRleCA9IGJ1ZmZlcltpXSAlIENIQVJTRVQubGVuZ3RoO1xuICAgIHN0YXRlLnB1c2goQ0hBUlNFVFtpbmRleF0pO1xuICB9XG4gIHJldHVybiBzdGF0ZS5qb2luKCcnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVybFNhZmUoYnVmZmVyOiBVaW50OEFycmF5KTogc3RyaW5nIHtcbiAgY29uc3QgZW5jb2RlZCA9IGJhc2U2NC5mcm9tQnl0ZUFycmF5KG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpO1xuICByZXR1cm4gZW5jb2RlZC5yZXBsYWNlKC9cXCsvZywgJy0nKS5yZXBsYWNlKC9cXC8vZywgJ18nKS5yZXBsYWNlKC89L2csICcnKTtcbn1cblxuLy8gYWRhcHRlZCBmcm9tIHNvdXJjZTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTEwNTg4NThcbi8vIHRoaXMgaXMgdXNlZCBpbiBwbGFjZSBvZiBUZXh0RW5jb2RlIGFzIHRoZSBhcGkgaXMgbm90IHlldFxuLy8gd2VsbCBzdXBwb3J0ZWQ6IGh0dHBzOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1UZXh0RW5jb2RlclxuZXhwb3J0IGZ1bmN0aW9uIHRleHRFbmNvZGVMaXRlKHN0cjogc3RyaW5nKSB7XG4gIGNvbnN0IGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcihzdHIubGVuZ3RoKTtcbiAgY29uc3QgYnVmVmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zik7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBidWZWaWV3W2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIGJ1ZlZpZXc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3J5cHRvIHtcbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgcmFuZG9tIHN0cmluZ1xuICAgKi9cbiAgZ2VuZXJhdGVSYW5kb20oc2l6ZTogbnVtYmVyKTogc3RyaW5nO1xuICAvKipcbiAgICogQ29tcHV0ZSB0aGUgU0hBMjU2IG9mIGEgZ2l2ZW4gY29kZS5cbiAgICogVGhpcyBpcyB1c2VmdWwgd2hlbiB1c2luZyBQS0NFLlxuICAgKi9cbiAgZGVyaXZlQ2hhbGxlbmdlKGNvZGU6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPjtcbn1cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgYENyeXB0b2AgaW50ZXJmYWNlLlxuICogVGhpcyB1c2VzIHRoZSBjYXBhYmlsaXRpZXMgb2YgdGhlIGJyb3dzZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWZhdWx0Q3J5cHRvIGltcGxlbWVudHMgQ3J5cHRvIHtcbiAgZ2VuZXJhdGVSYW5kb20oc2l6ZTogbnVtYmVyKSB7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgaWYgKEhBU19DUllQVE8pIHtcbiAgICAgIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGJ1ZmZlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZhbGwgYmFjayB0byBNYXRoLnJhbmRvbSgpIGlmIG5vdGhpbmcgZWxzZSBpcyBhdmFpbGFibGVcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSArPSAxKSB7XG4gICAgICAgIGJ1ZmZlcltpXSA9IChNYXRoLnJhbmRvbSgpICogQ0hBUlNFVC5sZW5ndGgpIHwgMDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlclRvU3RyaW5nKGJ1ZmZlcik7XG4gIH1cblxuICBkZXJpdmVDaGFsbGVuZ2UoY29kZTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBpZiAoY29kZS5sZW5ndGggPCA0MyB8fCBjb2RlLmxlbmd0aCA+IDEyOCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBBcHBBdXRoRXJyb3IoJ0ludmFsaWQgY29kZSBsZW5ndGguJykpO1xuICAgIH1cbiAgICBpZiAoIUhBU19TVUJUTEVfQ1JZUFRPKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEFwcEF1dGhFcnJvcignd2luZG93LmNyeXB0by5zdWJ0bGUgaXMgdW5hdmFpbGFibGUuJykpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjcnlwdG8uc3VidGxlLmRpZ2VzdCgnU0hBLTI1NicsIHRleHRFbmNvZGVMaXRlKGNvZGUpKS50aGVuKGJ1ZmZlciA9PiB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKHVybFNhZmUobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSkpO1xuICAgICAgfSwgZXJyb3IgPT4gcmVqZWN0KGVycm9yKSk7XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0XG4gKiBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlXG4gKiBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlclxuICogZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIEFwcEF1dGhFcnJvciB0eXBlLlxuICovXG5leHBvcnQgY2xhc3MgQXBwQXV0aEVycm9yIHtcbiAgY29uc3RydWN0b3IocHVibGljIG1lc3NhZ2U6IHN0cmluZywgcHVibGljIGV4dHJhcz86IGFueSkge31cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0XG4gKiBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlXG4gKiBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlclxuICogZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBHbG9iYWwgZmxhZ3MgdGhhdCBjb250cm9sIHRoZSBiZWhhdmlvciBvZiBBcHAgQXV0aCBKUy4gKi9cblxuLyogTG9nZ2luZyB0dXJuZWQgb24gPyAqL1xuZXhwb3J0IGNvbnN0IElTX0xPRyA9IHRydWU7XG5cbi8qIFByb2ZpbGluZyB0dXJuZWQgb24gPyAqL1xuZXhwb3J0IGNvbnN0IElTX1BST0ZJTEUgPSBmYWxzZTtcbiIsImV4cG9ydCAqIGZyb20gJy4vYXV0aG9yaXphdGlvbl9yZXF1ZXN0JztcbmV4cG9ydCAqIGZyb20gJy4vYXV0aG9yaXphdGlvbl9yZXF1ZXN0X2hhbmRsZXInO1xuZXhwb3J0ICogZnJvbSAnLi9hdXRob3JpemF0aW9uX3Jlc3BvbnNlJztcbmV4cG9ydCAqIGZyb20gJy4vYXV0aG9yaXphdGlvbl9zZXJ2aWNlX2NvbmZpZ3VyYXRpb24nO1xuZXhwb3J0ICogZnJvbSAnLi9jcnlwdG9fdXRpbHMnO1xuZXhwb3J0ICogZnJvbSAnLi9lcnJvcnMnO1xuZXhwb3J0ICogZnJvbSAnLi9mbGFncyc7XG5leHBvcnQgKiBmcm9tICcuL2xvZ2dlcic7XG5leHBvcnQgKiBmcm9tICcuL3F1ZXJ5X3N0cmluZ191dGlscyc7XG5leHBvcnQgKiBmcm9tICcuL3JlZGlyZWN0X2Jhc2VkX2hhbmRsZXInO1xuZXhwb3J0ICogZnJvbSAnLi9yZXZva2VfdG9rZW5fcmVxdWVzdCc7XG5leHBvcnQgKiBmcm9tICcuL3N0b3JhZ2UnO1xuZXhwb3J0ICogZnJvbSAnLi90b2tlbl9yZXF1ZXN0JztcbmV4cG9ydCAqIGZyb20gJy4vdG9rZW5fcmVxdWVzdF9oYW5kbGVyJztcbmV4cG9ydCAqIGZyb20gJy4vdG9rZW5fcmVzcG9uc2UnO1xuZXhwb3J0ICogZnJvbSAnLi90eXBlcyc7XG5leHBvcnQgKiBmcm9tICcuL3hocic7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdFxuICogaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZVxuICogTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXJcbiAqIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtJU19MT0csIElTX1BST0ZJTEV9IGZyb20gJy4vZmxhZ3MnO1xuXG5leHBvcnQgZnVuY3Rpb24gbG9nKG1lc3NhZ2U6IHN0cmluZywgLi4uYXJnczogYW55W10pIHtcbiAgaWYgKElTX0xPRykge1xuICAgIGxldCBsZW5ndGggPSBhcmdzID8gYXJncy5sZW5ndGggOiAwO1xuICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICBjb25zb2xlLmxvZyhtZXNzYWdlLCAuLi5hcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBjaGVjayB0byBzZWUgaWYgbmF0aXZlIHN1cHBvcnQgZm9yIHByb2ZpbGluZyBpcyBhdmFpbGFibGUuXG5jb25zdCBOQVRJVkVfUFJPRklMRV9TVVBQT1JUID1cbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhIXdpbmRvdy5wZXJmb3JtYW5jZSAmJiAhIWNvbnNvbGUucHJvZmlsZTtcblxuLyoqXG4gKiBBIGRlY29yYXRvciB0aGF0IGNhbiBwcm9maWxlIGEgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9maWxlKHRhcmdldDogYW55LCBwcm9wZXJ0eUtleTogc3RyaW5nLCBkZXNjcmlwdG9yOiBQcm9wZXJ0eURlc2NyaXB0b3IpIHtcbiAgaWYgKElTX1BST0ZJTEUpIHtcbiAgICByZXR1cm4gcGVyZm9ybVByb2ZpbGUodGFyZ2V0LCBwcm9wZXJ0eUtleSwgZGVzY3JpcHRvcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmV0dXJuIGFzLWlzXG4gICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGVyZm9ybVByb2ZpbGUoXG4gICAgdGFyZ2V0OiBhbnksIHByb3BlcnR5S2V5OiBzdHJpbmcsIGRlc2NyaXB0b3I6IFByb3BlcnR5RGVzY3JpcHRvcik6IFByb3BlcnR5RGVzY3JpcHRvciB7XG4gIGxldCBvcmlnaW5hbENhbGxhYmxlID0gZGVzY3JpcHRvci52YWx1ZTtcbiAgLy8gbmFtZSBtdXN0IGV4aXN0XG4gIGxldCBuYW1lID0gb3JpZ2luYWxDYWxsYWJsZS5uYW1lO1xuICBpZiAoIW5hbWUpIHtcbiAgICBuYW1lID0gJ2Fub255bW91cyBmdW5jdGlvbic7XG4gIH1cbiAgaWYgKE5BVElWRV9QUk9GSUxFX1NVUFBPUlQpIHtcbiAgICBkZXNjcmlwdG9yLnZhbHVlID0gZnVuY3Rpb24oYXJnczogYW55W10pIHtcbiAgICAgIGNvbnNvbGUucHJvZmlsZShuYW1lKTtcbiAgICAgIGxldCBzdGFydFRpbWUgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBsZXQgcmVzdWx0ID0gb3JpZ2luYWxDYWxsYWJsZS5jYWxsKHRoaXMgfHwgd2luZG93LCAuLi5hcmdzKTtcbiAgICAgIGxldCBkdXJhdGlvbiA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgIGNvbnNvbGUubG9nKGAke25hbWV9IHRvb2sgJHtkdXJhdGlvbn0gbXNgKTtcbiAgICAgIGNvbnNvbGUucHJvZmlsZUVuZCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGRlc2NyaXB0b3IudmFsdWUgPSBmdW5jdGlvbihhcmdzOiBhbnlbXSkge1xuICAgICAgbG9nKGBQcm9maWxlIHN0YXJ0ICR7bmFtZX1gKTtcbiAgICAgIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgICBsZXQgcmVzdWx0ID0gb3JpZ2luYWxDYWxsYWJsZS5jYWxsKHRoaXMgfHwgd2luZG93LCAuLi5hcmdzKTtcbiAgICAgIGxldCBkdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGFydDtcbiAgICAgIGxvZyhgUHJvZmlsZSBlbmQgJHtuYW1lfSB0b29rICR7ZHVyYXRpb259IG1zLmApO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9XG4gIHJldHVybiBkZXNjcmlwdG9yO1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHRcbiAqIGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGVcbiAqIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyXG4gKiBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7TG9jYXRpb25MaWtlLCBTdHJpbmdNYXB9IGZyb20gJy4vdHlwZXMnO1xuXG5cbi8qKlxuICogUXVlcnkgU3RyaW5nIFV0aWxpdGllcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBRdWVyeVN0cmluZ1V0aWxzIHtcbiAgc3RyaW5naWZ5KGlucHV0OiBTdHJpbmdNYXApOiBzdHJpbmc7XG4gIHBhcnNlKHF1ZXJ5OiBMb2NhdGlvbkxpa2UsIHVzZUhhc2g/OiBib29sZWFuKTogU3RyaW5nTWFwO1xuICBwYXJzZVF1ZXJ5U3RyaW5nKHF1ZXJ5OiBzdHJpbmcpOiBTdHJpbmdNYXA7XG59XG5cbmV4cG9ydCBjbGFzcyBCYXNpY1F1ZXJ5U3RyaW5nVXRpbHMgaW1wbGVtZW50cyBRdWVyeVN0cmluZ1V0aWxzIHtcbiAgcGFyc2UoaW5wdXQ6IExvY2F0aW9uTGlrZSwgdXNlSGFzaD86IGJvb2xlYW4pIHtcbiAgICBpZiAodXNlSGFzaCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VRdWVyeVN0cmluZyhpbnB1dC5oYXNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VRdWVyeVN0cmluZyhpbnB1dC5zZWFyY2gpO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlUXVlcnlTdHJpbmcocXVlcnk6IHN0cmluZyk6IFN0cmluZ01hcCB7XG4gICAgbGV0IHJlc3VsdDogU3RyaW5nTWFwID0ge307XG4gICAgLy8gaWYgYW55dGhpbmcgc3RhcnRzIHdpdGggPywgIyBvciAmIHJlbW92ZSBpdFxuICAgIHF1ZXJ5ID0gcXVlcnkudHJpbSgpLnJlcGxhY2UoL14oXFw/fCN8JikvLCAnJyk7XG4gICAgbGV0IHBhcmFtcyA9IHF1ZXJ5LnNwbGl0KCcmJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGxldCBwYXJhbSA9IHBhcmFtc1tpXTsgIC8vIGxvb2tzIHNvbWV0aGluZyBsaWtlIGE9YlxuICAgICAgbGV0IHBhcnRzID0gcGFyYW0uc3BsaXQoJz0nKTtcbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggPj0gMikge1xuICAgICAgICBsZXQga2V5ID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhcnRzLnNoaWZ0KCkhKTtcbiAgICAgICAgbGV0IHZhbHVlID0gcGFydHMubGVuZ3RoID4gMCA/IHBhcnRzLmpvaW4oJz0nKSA6IG51bGw7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgc3RyaW5naWZ5KGlucHV0OiBTdHJpbmdNYXApIHtcbiAgICBsZXQgZW5jb2RlZDogc3RyaW5nW10gPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgaW4gaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dC5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGlucHV0W2tleV0pIHtcbiAgICAgICAgZW5jb2RlZC5wdXNoKGAke2VuY29kZVVSSUNvbXBvbmVudChrZXkpfT0ke2VuY29kZVVSSUNvbXBvbmVudChpbnB1dFtrZXldKX1gKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW5jb2RlZC5qb2luKCcmJyk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0XG4gKiBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlXG4gKiBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlclxuICogZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge0F1dGhvcml6YXRpb25SZXF1ZXN0fSBmcm9tICcuL2F1dGhvcml6YXRpb25fcmVxdWVzdCc7XG5pbXBvcnQge0F1dGhvcml6YXRpb25SZXF1ZXN0SGFuZGxlciwgQXV0aG9yaXphdGlvblJlcXVlc3RSZXNwb25zZX0gZnJvbSAnLi9hdXRob3JpemF0aW9uX3JlcXVlc3RfaGFuZGxlcic7XG5pbXBvcnQge0F1dGhvcml6YXRpb25FcnJvciwgQXV0aG9yaXphdGlvblJlc3BvbnNlfSBmcm9tICcuL2F1dGhvcml6YXRpb25fcmVzcG9uc2UnXG5pbXBvcnQge0F1dGhvcml6YXRpb25TZXJ2aWNlQ29uZmlndXJhdGlvbn0gZnJvbSAnLi9hdXRob3JpemF0aW9uX3NlcnZpY2VfY29uZmlndXJhdGlvbic7XG5pbXBvcnQge0NyeXB0bywgRGVmYXVsdENyeXB0b30gZnJvbSAnLi9jcnlwdG9fdXRpbHMnO1xuaW1wb3J0IHtsb2d9IGZyb20gJy4vbG9nZ2VyJztcbmltcG9ydCB7QmFzaWNRdWVyeVN0cmluZ1V0aWxzfSBmcm9tICcuL3F1ZXJ5X3N0cmluZ191dGlscyc7XG5pbXBvcnQge0xvY2FsU3RvcmFnZUJhY2tlbmQsIFN0b3JhZ2VCYWNrZW5kfSBmcm9tICcuL3N0b3JhZ2UnO1xuaW1wb3J0IHtMb2NhdGlvbkxpa2V9IGZyb20gJy4vdHlwZXMnO1xuXG5cbi8qKiBrZXkgZm9yIGF1dGhvcml6YXRpb24gcmVxdWVzdC4gKi9cbmNvbnN0IGF1dGhvcml6YXRpb25SZXF1ZXN0S2V5ID1cbiAgICAoaGFuZGxlOiBzdHJpbmcpID0+IHtcbiAgICAgIHJldHVybiBgJHtoYW5kbGV9X2FwcGF1dGhfYXV0aG9yaXphdGlvbl9yZXF1ZXN0YDtcbiAgICB9XG5cbi8qKiBrZXkgZm9yIGF1dGhvcml6YXRpb24gc2VydmljZSBjb25maWd1cmF0aW9uICovXG5jb25zdCBhdXRob3JpemF0aW9uU2VydmljZUNvbmZpZ3VyYXRpb25LZXkgPVxuICAgIChoYW5kbGU6IHN0cmluZykgPT4ge1xuICAgICAgcmV0dXJuIGAke2hhbmRsZX1fYXBwYXV0aF9hdXRob3JpemF0aW9uX3NlcnZpY2VfY29uZmlndXJhdGlvbmA7XG4gICAgfVxuXG4vKioga2V5IGluIGxvY2FsIHN0b3JhZ2Ugd2hpY2ggcmVwcmVzZW50cyB0aGUgY3VycmVudCBhdXRob3JpemF0aW9uIHJlcXVlc3QuICovXG5jb25zdCBBVVRIT1JJWkFUSU9OX1JFUVVFU1RfSEFORExFX0tFWSA9ICdhcHBhdXRoX2N1cnJlbnRfYXV0aG9yaXphdGlvbl9yZXF1ZXN0JztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIEF1dGhvcml6YXRpb25SZXF1ZXN0SGFuZGxlciB3aGljaCB1c2VzIGEgc3RhbmRhcmRcbiAqIHJlZGlyZWN0IGJhc2VkIGNvZGUgZmxvdy5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlZGlyZWN0UmVxdWVzdEhhbmRsZXIgZXh0ZW5kcyBBdXRob3JpemF0aW9uUmVxdWVzdEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvcihcbiAgICAgIC8vIHVzZSB0aGUgcHJvdmlkZWQgc3RvcmFnZSBiYWNrZW5kXG4gICAgICAvLyBvciBpbml0aWFsaXplIGxvY2FsIHN0b3JhZ2Ugd2l0aCB0aGUgZGVmYXVsdCBzdG9yYWdlIGJhY2tlbmQgd2hpY2hcbiAgICAgIC8vIHVzZXMgd2luZG93LmxvY2FsU3RvcmFnZVxuICAgICAgcHVibGljIHN0b3JhZ2VCYWNrZW5kOiBTdG9yYWdlQmFja2VuZCA9IG5ldyBMb2NhbFN0b3JhZ2VCYWNrZW5kKCksXG4gICAgICB1dGlscyA9IG5ldyBCYXNpY1F1ZXJ5U3RyaW5nVXRpbHMoKSxcbiAgICAgIHB1YmxpYyBsb2NhdGlvbkxpa2U6IExvY2F0aW9uTGlrZSA9IHdpbmRvdy5sb2NhdGlvbixcbiAgICAgIGNyeXB0bzogQ3J5cHRvID0gbmV3IERlZmF1bHRDcnlwdG8oKSkge1xuICAgIHN1cGVyKHV0aWxzLCBjcnlwdG8pO1xuICB9XG5cbiAgcGVyZm9ybUF1dGhvcml6YXRpb25SZXF1ZXN0KFxuICAgICAgY29uZmlndXJhdGlvbjogQXV0aG9yaXphdGlvblNlcnZpY2VDb25maWd1cmF0aW9uLFxuICAgICAgcmVxdWVzdDogQXV0aG9yaXphdGlvblJlcXVlc3QpIHtcbiAgICBjb25zdCBoYW5kbGUgPSB0aGlzLmNyeXB0by5nZW5lcmF0ZVJhbmRvbSgxMCk7XG5cbiAgICAvLyBiZWZvcmUgeW91IG1ha2UgcmVxdWVzdCwgcGVyc2lzdCBhbGwgcmVxdWVzdCByZWxhdGVkIGRhdGEgaW4gbG9jYWwgc3RvcmFnZS5cbiAgICBjb25zdCBwZXJzaXN0ZWQgPSBQcm9taXNlLmFsbChbXG4gICAgICB0aGlzLnN0b3JhZ2VCYWNrZW5kLnNldEl0ZW0oQVVUSE9SSVpBVElPTl9SRVFVRVNUX0hBTkRMRV9LRVksIGhhbmRsZSksXG4gICAgICAvLyBDYWxsaW5nIHRvSnNvbigpIGFkZHMgaW4gdGhlIGNvZGUgJiBjaGFsbGVuZ2Ugd2hlbiBwb3NzaWJsZVxuICAgICAgcmVxdWVzdC50b0pzb24oKS50aGVuKFxuICAgICAgICAgIHJlc3VsdCA9PlxuICAgICAgICAgICAgICB0aGlzLnN0b3JhZ2VCYWNrZW5kLnNldEl0ZW0oYXV0aG9yaXphdGlvblJlcXVlc3RLZXkoaGFuZGxlKSwgSlNPTi5zdHJpbmdpZnkocmVzdWx0KSkpLFxuICAgICAgdGhpcy5zdG9yYWdlQmFja2VuZC5zZXRJdGVtKFxuICAgICAgICAgIGF1dGhvcml6YXRpb25TZXJ2aWNlQ29uZmlndXJhdGlvbktleShoYW5kbGUpLCBKU09OLnN0cmluZ2lmeShjb25maWd1cmF0aW9uLnRvSnNvbigpKSksXG4gICAgXSk7XG5cbiAgICBwZXJzaXN0ZWQudGhlbigoKSA9PiB7XG4gICAgICAvLyBtYWtlIHRoZSByZWRpcmVjdCByZXF1ZXN0XG4gICAgICBsZXQgdXJsID0gdGhpcy5idWlsZFJlcXVlc3RVcmwoY29uZmlndXJhdGlvbiwgcmVxdWVzdCk7XG4gICAgICBsb2coJ01ha2luZyBhIHJlcXVlc3QgdG8gJywgcmVxdWVzdCwgdXJsKTtcbiAgICAgIHRoaXMubG9jYXRpb25MaWtlLmFzc2lnbih1cmwpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIGludHJvc3BlY3QgdGhlIGNvbnRlbnRzIG9mIHN0b3JhZ2UgYmFja2VuZCBhbmQgY29tcGxldGVzIHRoZVxuICAgKiByZXF1ZXN0LlxuICAgKi9cbiAgcHJvdGVjdGVkIGNvbXBsZXRlQXV0aG9yaXphdGlvblJlcXVlc3QoKTogUHJvbWlzZTxBdXRob3JpemF0aW9uUmVxdWVzdFJlc3BvbnNlfG51bGw+IHtcbiAgICAvLyBUT0RPKHJhaHVscmF2QCk6IGhhbmRsZSBhdXRob3JpemF0aW9uIGVycm9ycy5cbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlQmFja2VuZC5nZXRJdGVtKEFVVEhPUklaQVRJT05fUkVRVUVTVF9IQU5ETEVfS0VZKS50aGVuKGhhbmRsZSA9PiB7XG4gICAgICBpZiAoaGFuZGxlKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSBwZW5kaW5nIHJlcXVlc3QuXG4gICAgICAgIC8vIGZldGNoIGF1dGhvcml6YXRpb24gcmVxdWVzdCwgYW5kIGNoZWNrIHN0YXRlXG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JhZ2VCYWNrZW5kXG4gICAgICAgICAgICAuZ2V0SXRlbShhdXRob3JpemF0aW9uUmVxdWVzdEtleShoYW5kbGUpKVxuICAgICAgICAgICAgLy8gcmVxdWlyZXMgYSBjb3JyZXNwb25kaW5nIGluc3RhbmNlIG9mIHJlc3VsdFxuICAgICAgICAgICAgLy8gVE9ETyhyYWh1bHJhdkApOiBjaGVjayBmb3IgaW5jb25zaXRlbnQgc3RhdGUgaGVyZVxuICAgICAgICAgICAgLnRoZW4ocmVzdWx0ID0+IEpTT04ucGFyc2UocmVzdWx0ISkpXG4gICAgICAgICAgICAudGhlbihqc29uID0+IG5ldyBBdXRob3JpemF0aW9uUmVxdWVzdChqc29uKSlcbiAgICAgICAgICAgIC50aGVuKHJlcXVlc3QgPT4ge1xuICAgICAgICAgICAgICAvLyBjaGVjayByZWRpcmVjdF91cmkgYW5kIHN0YXRlXG4gICAgICAgICAgICAgIGxldCBjdXJyZW50VXJpID0gYCR7dGhpcy5sb2NhdGlvbkxpa2Uub3JpZ2lufSR7dGhpcy5sb2NhdGlvbkxpa2UucGF0aG5hbWV9YDtcbiAgICAgICAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0gdGhpcy51dGlscy5wYXJzZSh0aGlzLmxvY2F0aW9uTGlrZSwgdHJ1ZSAvKiB1c2UgaGFzaCAqLyk7XG4gICAgICAgICAgICAgIGxldCBzdGF0ZTogc3RyaW5nfHVuZGVmaW5lZCA9IHF1ZXJ5UGFyYW1zWydzdGF0ZSddO1xuICAgICAgICAgICAgICBsZXQgY29kZTogc3RyaW5nfHVuZGVmaW5lZCA9IHF1ZXJ5UGFyYW1zWydjb2RlJ107XG4gICAgICAgICAgICAgIGxldCBlcnJvcjogc3RyaW5nfHVuZGVmaW5lZCA9IHF1ZXJ5UGFyYW1zWydlcnJvciddO1xuICAgICAgICAgICAgICBsb2coJ1BvdGVudGlhbCBhdXRob3JpemF0aW9uIHJlcXVlc3QgJywgY3VycmVudFVyaSwgcXVlcnlQYXJhbXMsIHN0YXRlLCBjb2RlLCBlcnJvcik7XG4gICAgICAgICAgICAgIGxldCBzaG91bGROb3RpZnkgPSBzdGF0ZSA9PT0gcmVxdWVzdC5zdGF0ZTtcbiAgICAgICAgICAgICAgbGV0IGF1dGhvcml6YXRpb25SZXNwb25zZTogQXV0aG9yaXphdGlvblJlc3BvbnNlfG51bGwgPSBudWxsO1xuICAgICAgICAgICAgICBsZXQgYXV0aG9yaXphdGlvbkVycm9yOiBBdXRob3JpemF0aW9uRXJyb3J8bnVsbCA9IG51bGw7XG4gICAgICAgICAgICAgIGlmIChzaG91bGROb3RpZnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGdldCBhZGRpdGlvbmFsIG9wdGlvbmFsIGluZm8uXG4gICAgICAgICAgICAgICAgICBsZXQgZXJyb3JVcmkgPSBxdWVyeVBhcmFtc1snZXJyb3JfdXJpJ107XG4gICAgICAgICAgICAgICAgICBsZXQgZXJyb3JEZXNjcmlwdGlvbiA9IHF1ZXJ5UGFyYW1zWydlcnJvcl9kZXNjcmlwdGlvbiddO1xuICAgICAgICAgICAgICAgICAgYXV0aG9yaXphdGlvbkVycm9yID0gbmV3IEF1dGhvcml6YXRpb25FcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JfZGVzY3JpcHRpb246IGVycm9yRGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgIGVycm9yX3VyaTogZXJyb3JVcmksXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGF1dGhvcml6YXRpb25SZXNwb25zZSA9IG5ldyBBdXRob3JpemF0aW9uUmVzcG9uc2Uoe2NvZGU6IGNvZGUsIHN0YXRlOiBzdGF0ZX0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjbGVhbnVwIHN0YXRlXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2VcbiAgICAgICAgICAgICAgICAgICAgLmFsbChbXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlQmFja2VuZC5yZW1vdmVJdGVtKEFVVEhPUklaQVRJT05fUkVRVUVTVF9IQU5ETEVfS0VZKSxcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3JhZ2VCYWNrZW5kLnJlbW92ZUl0ZW0oYXV0aG9yaXphdGlvblJlcXVlc3RLZXkoaGFuZGxlKSksXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlQmFja2VuZC5yZW1vdmVJdGVtKGF1dGhvcml6YXRpb25TZXJ2aWNlQ29uZmlndXJhdGlvbktleShoYW5kbGUpKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgbG9nKCdEZWxpdmVyaW5nIGF1dGhvcml6YXRpb24gcmVzcG9uc2UnKTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBhdXRob3JpemF0aW9uUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogYXV0aG9yaXphdGlvbkVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgfSBhcyBBdXRob3JpemF0aW9uUmVxdWVzdFJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2coJ01pc21hdGNoZWQgcmVxdWVzdCAoc3RhdGUgYW5kIHJlcXVlc3RfdXJpKSBkb250IG1hdGNoLicpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbiIsImltcG9ydCB7U3RyaW5nTWFwfSBmcm9tICcuL3R5cGVzJztcblxuLypcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHRcbiAqIGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGVcbiAqIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyXG4gKiBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogU3VwcG9ydGVkIHRva2VuIHR5cGVzXG4gKi9cbmV4cG9ydCB0eXBlIFRva2VuVHlwZUhpbnQgPSAncmVmcmVzaF90b2tlbid8J2FjY2Vzc190b2tlbic7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgVG9rZW4gUmVxdWVzdCBhcyBKU09OLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJldm9rZVRva2VuUmVxdWVzdEpzb24ge1xuICB0b2tlbjogc3RyaW5nO1xuICB0b2tlbl90eXBlX2hpbnQ/OiBUb2tlblR5cGVIaW50O1xuICBjbGllbnRfaWQ/OiBzdHJpbmc7XG4gIGNsaWVudF9zZWNyZXQ/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHJldm9rZSB0b2tlbiByZXF1ZXN0LlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gbG9vayBhdDpcbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MDA5I3NlY3Rpb24tMi4xXG4gKi9cbmV4cG9ydCBjbGFzcyBSZXZva2VUb2tlblJlcXVlc3Qge1xuICB0b2tlbjogc3RyaW5nO1xuICB0b2tlblR5cGVIaW50OiBUb2tlblR5cGVIaW50fHVuZGVmaW5lZDtcbiAgY2xpZW50SWQ6IHN0cmluZ3x1bmRlZmluZWQ7XG4gIGNsaWVudFNlY3JldDogc3RyaW5nfHVuZGVmaW5lZDtcblxuICBjb25zdHJ1Y3RvcihyZXF1ZXN0OiBSZXZva2VUb2tlblJlcXVlc3RKc29uKSB7XG4gICAgdGhpcy50b2tlbiA9IHJlcXVlc3QudG9rZW47XG4gICAgdGhpcy50b2tlblR5cGVIaW50ID0gcmVxdWVzdC50b2tlbl90eXBlX2hpbnQ7XG4gICAgdGhpcy5jbGllbnRJZCA9IHJlcXVlc3QuY2xpZW50X2lkO1xuICAgIHRoaXMuY2xpZW50U2VjcmV0ID0gcmVxdWVzdC5jbGllbnRfc2VjcmV0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZXMgYSBUb2tlblJlcXVlc3QgdG8gYSBKYXZhU2NyaXB0IG9iamVjdC5cbiAgICovXG4gIHRvSnNvbigpOiBSZXZva2VUb2tlblJlcXVlc3RKc29uIHtcbiAgICBsZXQganNvbjogUmV2b2tlVG9rZW5SZXF1ZXN0SnNvbiA9IHt0b2tlbjogdGhpcy50b2tlbn07XG4gICAgaWYgKHRoaXMudG9rZW5UeXBlSGludCkge1xuICAgICAganNvblsndG9rZW5fdHlwZV9oaW50J10gPSB0aGlzLnRva2VuVHlwZUhpbnQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmNsaWVudElkKSB7XG4gICAgICBqc29uWydjbGllbnRfaWQnXSA9IHRoaXMuY2xpZW50SWQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmNsaWVudFNlY3JldCkge1xuICAgICAganNvblsnY2xpZW50X3NlY3JldCddID0gdGhpcy5jbGllbnRTZWNyZXQ7XG4gICAgfVxuICAgIHJldHVybiBqc29uO1xuICB9XG5cbiAgdG9TdHJpbmdNYXAoKTogU3RyaW5nTWFwIHtcbiAgICBsZXQganNvbiA9IHRoaXMudG9Kc29uKCk7XG4gICAgLy8gOihcbiAgICByZXR1cm4gKGpzb24gYXMgYW55KTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHRcbiAqIGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGVcbiAqIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyXG4gKiBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQSBzdWJzZXQgb2YgdGhlIGBTdG9yYWdlYCBpbnRlcmZhY2Ugd2hpY2ggd2UgbmVlZCBmb3IgdGhlIGJhY2tlbmRzIHRvIHdvcmsuXG4gKlxuICogRXNzZW50aWFsbHkgcmVtb3ZlcyB0aGUgaW5kZXhhYmxlIHByb3BlcnRpZXMgYW5kIHJlYWRvbmx5IHByb3BlcnRpZXMgZnJvbVxuICogYFN0b3JhZ2VgIGluIGxpYi5kb20uZC50cy4gVGhpcyBpcyBzbyB0aGF0IGEgY3VzdG9tIHR5cGUgY2FuIGV4dGVuZCBpdCBmb3JcbiAqIHRlc3RpbmcuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVW5kZXJseWluZ1N0b3JhZ2Uge1xuICByZWFkb25seSBsZW5ndGg6IG51bWJlcjtcbiAgY2xlYXIoKTogdm9pZDtcbiAgZ2V0SXRlbShrZXk6IHN0cmluZyk6IHN0cmluZ3xudWxsO1xuICByZW1vdmVJdGVtKGtleTogc3RyaW5nKTogdm9pZDtcbiAgc2V0SXRlbShrZXk6IHN0cmluZywgZGF0YTogc3RyaW5nKTogdm9pZDtcbn1cblxuLyoqXG4gKiBBc3luY2hyb25vdXMgc3RvcmFnZSBBUElzLiBBbGwgbWV0aG9kcyByZXR1cm4gYSBgUHJvbWlzZWAuXG4gKiBBbGwgbWV0aG9kcyB0YWtlIHRoZSBgRE9NU3RyaW5nYFxuICogSURMIHR5cGUgKGFzIGl0IGlzIHRoZSBsb3dlc3QgY29tbW9uIGRlbm9taW5hdG9yKS5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFN0b3JhZ2VCYWNrZW5kIHtcbiAgLyoqXG4gICAqIFdoZW4gcGFzc2VkIGEga2V5IGBuYW1lYCwgd2lsbCByZXR1cm4gdGhhdCBrZXkncyB2YWx1ZS5cbiAgICovXG4gIHB1YmxpYyBhYnN0cmFjdCBnZXRJdGVtKG5hbWU6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nfG51bGw+O1xuXG4gIC8qKlxuICAgKiBXaGVuIHBhc3NlZCBhIGtleSBgbmFtZWAsIHdpbGwgcmVtb3ZlIHRoYXQga2V5IGZyb20gdGhlIHN0b3JhZ2UuXG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgcmVtb3ZlSXRlbShuYW1lOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBXaGVuIGludm9rZWQsIHdpbGwgZW1wdHkgYWxsIGtleXMgb3V0IG9mIHRoZSBzdG9yYWdlLlxuICAgKi9cbiAgcHVibGljIGFic3RyYWN0IGNsZWFyKCk6IFByb21pc2U8dm9pZD47XG5cbiAgLyoqXG4gICAqIFRoZSBzZXRJdGVtKCkgbWV0aG9kIG9mIHRoZSBgU3RvcmFnZUJhY2tlbmRgIGludGVyZmFjZSxcbiAgICogd2hlbiBwYXNzZWQgYSBrZXkgbmFtZSBhbmQgdmFsdWUsIHdpbGwgYWRkIHRoYXQga2V5IHRvIHRoZSBzdG9yYWdlLFxuICAgKiBvciB1cGRhdGUgdGhhdCBrZXkncyB2YWx1ZSBpZiBpdCBhbHJlYWR5IGV4aXN0cy5cbiAgICovXG4gIHB1YmxpYyBhYnN0cmFjdCBzZXRJdGVtKG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyk6IFByb21pc2U8dm9pZD47XG59XG5cbi8qKlxuICogQSBgU3RvcmFnZUJhY2tlbmRgIGJhY2tlZCBieSBgbG9jYWxzdG9yYWdlYC5cbiAqL1xuZXhwb3J0IGNsYXNzIExvY2FsU3RvcmFnZUJhY2tlbmQgZXh0ZW5kcyBTdG9yYWdlQmFja2VuZCB7XG4gIHByaXZhdGUgc3RvcmFnZTogVW5kZXJseWluZ1N0b3JhZ2U7XG4gIGNvbnN0cnVjdG9yKHN0b3JhZ2U/OiBVbmRlcmx5aW5nU3RvcmFnZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZSB8fCB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9XG5cbiAgcHVibGljIGdldEl0ZW0obmFtZTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmd8bnVsbD4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTxzdHJpbmd8bnVsbD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnN0b3JhZ2UuZ2V0SXRlbShuYW1lKTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgcmVtb3ZlSXRlbShuYW1lOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5zdG9yYWdlLnJlbW92ZUl0ZW0obmFtZSk7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgY2xlYXIoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuc3RvcmFnZS5jbGVhcigpO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHNldEl0ZW0obmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuc3RvcmFnZS5zZXRJdGVtKG5hbWUsIHZhbHVlKTtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHRcbiAqIGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGVcbiAqIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyXG4gKiBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7U3RyaW5nTWFwfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGNvbnN0IEdSQU5UX1RZUEVfQVVUSE9SSVpBVElPTl9DT0RFID0gJ2F1dGhvcml6YXRpb25fY29kZSc7XG5leHBvcnQgY29uc3QgR1JBTlRfVFlQRV9SRUZSRVNIX1RPS0VOID0gJ3JlZnJlc2hfdG9rZW4nO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFRva2VuIFJlcXVlc3QgYXMgSlNPTi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUb2tlblJlcXVlc3RKc29uIHtcbiAgZ3JhbnRfdHlwZTogc3RyaW5nO1xuICBjb2RlPzogc3RyaW5nO1xuICByZWZyZXNoX3Rva2VuPzogc3RyaW5nLCByZWRpcmVjdF91cmk6IHN0cmluZztcbiAgY2xpZW50X2lkOiBzdHJpbmc7XG4gIGV4dHJhcz86IFN0cmluZ01hcDtcbn1cblxuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gQWNjZXNzIFRva2VuIHJlcXVlc3QuXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBsb29rIGF0OlxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY3NDkjc2VjdGlvbi00LjEuM1xuICovXG5leHBvcnQgY2xhc3MgVG9rZW5SZXF1ZXN0IHtcbiAgY2xpZW50SWQ6IHN0cmluZztcbiAgcmVkaXJlY3RVcmk6IHN0cmluZztcbiAgZ3JhbnRUeXBlOiBzdHJpbmc7XG4gIGNvZGU6IHN0cmluZ3x1bmRlZmluZWQ7XG4gIHJlZnJlc2hUb2tlbjogc3RyaW5nfHVuZGVmaW5lZDtcbiAgZXh0cmFzOiBTdHJpbmdNYXB8dW5kZWZpbmVkXG5cbiAgY29uc3RydWN0b3IocmVxdWVzdDogVG9rZW5SZXF1ZXN0SnNvbikge1xuICAgIHRoaXMuY2xpZW50SWQgPSByZXF1ZXN0LmNsaWVudF9pZDtcbiAgICB0aGlzLnJlZGlyZWN0VXJpID0gcmVxdWVzdC5yZWRpcmVjdF91cmk7XG4gICAgdGhpcy5ncmFudFR5cGUgPSByZXF1ZXN0LmdyYW50X3R5cGU7XG4gICAgdGhpcy5jb2RlID0gcmVxdWVzdC5jb2RlO1xuICAgIHRoaXMucmVmcmVzaFRva2VuID0gcmVxdWVzdC5yZWZyZXNoX3Rva2VuO1xuICAgIHRoaXMuZXh0cmFzID0gcmVxdWVzdC5leHRyYXM7XG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplcyBhIFRva2VuUmVxdWVzdCB0byBhIEphdmFTY3JpcHQgb2JqZWN0LlxuICAgKi9cbiAgdG9Kc29uKCk6IFRva2VuUmVxdWVzdEpzb24ge1xuICAgIHJldHVybiB7XG4gICAgICBncmFudF90eXBlOiB0aGlzLmdyYW50VHlwZSxcbiAgICAgIGNvZGU6IHRoaXMuY29kZSxcbiAgICAgIHJlZnJlc2hfdG9rZW46IHRoaXMucmVmcmVzaFRva2VuLFxuICAgICAgcmVkaXJlY3RfdXJpOiB0aGlzLnJlZGlyZWN0VXJpLFxuICAgICAgY2xpZW50X2lkOiB0aGlzLmNsaWVudElkLFxuICAgICAgZXh0cmFzOiB0aGlzLmV4dHJhc1xuICAgIH07XG4gIH1cblxuICB0b1N0cmluZ01hcCgpOiBTdHJpbmdNYXAge1xuICAgIGxldCBtYXA6IFN0cmluZ01hcCA9IHtcbiAgICAgIGdyYW50X3R5cGU6IHRoaXMuZ3JhbnRUeXBlLFxuICAgICAgY2xpZW50X2lkOiB0aGlzLmNsaWVudElkLFxuICAgICAgcmVkaXJlY3RfdXJpOiB0aGlzLnJlZGlyZWN0VXJpXG4gICAgfTtcblxuICAgIGlmICh0aGlzLmNvZGUpIHtcbiAgICAgIG1hcFsnY29kZSddID0gdGhpcy5jb2RlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlZnJlc2hUb2tlbikge1xuICAgICAgbWFwWydyZWZyZXNoX3Rva2VuJ10gPSB0aGlzLnJlZnJlc2hUb2tlbjtcbiAgICB9XG5cbiAgICAvLyBjb3B5IG92ZXIgZXh0cmFzXG4gICAgaWYgKHRoaXMuZXh0cmFzKSB7XG4gICAgICBmb3IgKGxldCBleHRyYSBpbiB0aGlzLmV4dHJhcykge1xuICAgICAgICBpZiAodGhpcy5leHRyYXMuaGFzT3duUHJvcGVydHkoZXh0cmEpICYmICFtYXAuaGFzT3duUHJvcGVydHkoZXh0cmEpKSB7XG4gICAgICAgICAgLy8gY2hlY2sgYmVmb3JlIGluc2VydGluZyB0byByZXF1ZXN0TWFwXG4gICAgICAgICAgbWFwW2V4dHJhXSA9IHRoaXMuZXh0cmFzW2V4dHJhXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFwO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdFxuICogaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZVxuICogTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXJcbiAqIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtBdXRob3JpemF0aW9uU2VydmljZUNvbmZpZ3VyYXRpb259IGZyb20gJy4vYXV0aG9yaXphdGlvbl9zZXJ2aWNlX2NvbmZpZ3VyYXRpb24nO1xuaW1wb3J0IHtBcHBBdXRoRXJyb3J9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7QmFzaWNRdWVyeVN0cmluZ1V0aWxzLCBRdWVyeVN0cmluZ1V0aWxzfSBmcm9tICcuL3F1ZXJ5X3N0cmluZ191dGlscyc7XG5pbXBvcnQge1Jldm9rZVRva2VuUmVxdWVzdH0gZnJvbSAnLi9yZXZva2VfdG9rZW5fcmVxdWVzdCc7XG5pbXBvcnQge1Rva2VuUmVxdWVzdH0gZnJvbSAnLi90b2tlbl9yZXF1ZXN0JztcbmltcG9ydCB7VG9rZW5FcnJvciwgVG9rZW5FcnJvckpzb24sIFRva2VuUmVzcG9uc2UsIFRva2VuUmVzcG9uc2VKc29ufSBmcm9tICcuL3Rva2VuX3Jlc3BvbnNlJztcbmltcG9ydCB7SlF1ZXJ5UmVxdWVzdG9yLCBSZXF1ZXN0b3J9IGZyb20gJy4veGhyJztcblxuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gaW50ZXJmYWNlIHdoaWNoIGNhbiBtYWtlIGEgdG9rZW4gcmVxdWVzdC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUb2tlblJlcXVlc3RIYW5kbGVyIHtcbiAgLyoqXG4gICAqIFBlcmZvcm1zIHRoZSB0b2tlbiByZXF1ZXN0LCBnaXZlbiB0aGUgc2VydmljZSBjb25maWd1cmF0aW9uLlxuICAgKi9cbiAgcGVyZm9ybVRva2VuUmVxdWVzdChjb25maWd1cmF0aW9uOiBBdXRob3JpemF0aW9uU2VydmljZUNvbmZpZ3VyYXRpb24sIHJlcXVlc3Q6IFRva2VuUmVxdWVzdCk6XG4gICAgICBQcm9taXNlPFRva2VuUmVzcG9uc2U+O1xuXG4gIHBlcmZvcm1SZXZva2VUb2tlblJlcXVlc3QoXG4gICAgICBjb25maWd1cmF0aW9uOiBBdXRob3JpemF0aW9uU2VydmljZUNvbmZpZ3VyYXRpb24sXG4gICAgICByZXF1ZXN0OiBSZXZva2VUb2tlblJlcXVlc3QpOiBQcm9taXNlPGJvb2xlYW4+O1xufVxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IHRva2VuIHJlcXVlc3QgaGFuZGxlci5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VUb2tlblJlcXVlc3RIYW5kbGVyIGltcGxlbWVudHMgVG9rZW5SZXF1ZXN0SGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKFxuICAgICAgcHVibGljIHJlYWRvbmx5IHJlcXVlc3RvcjogUmVxdWVzdG9yID0gbmV3IEpRdWVyeVJlcXVlc3RvcigpLFxuICAgICAgcHVibGljIHJlYWRvbmx5IHV0aWxzOiBRdWVyeVN0cmluZ1V0aWxzID0gbmV3IEJhc2ljUXVlcnlTdHJpbmdVdGlscygpKSB7fVxuXG4gIHByaXZhdGUgaXNUb2tlblJlc3BvbnNlKHJlc3BvbnNlOiBUb2tlblJlc3BvbnNlSnNvbnxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgVG9rZW5FcnJvckpzb24pOiByZXNwb25zZSBpcyBUb2tlblJlc3BvbnNlSnNvbiB7XG4gICAgcmV0dXJuIChyZXNwb25zZSBhcyBUb2tlbkVycm9ySnNvbikuZXJyb3IgPT09IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHBlcmZvcm1SZXZva2VUb2tlblJlcXVlc3QoXG4gICAgICBjb25maWd1cmF0aW9uOiBBdXRob3JpemF0aW9uU2VydmljZUNvbmZpZ3VyYXRpb24sXG4gICAgICByZXF1ZXN0OiBSZXZva2VUb2tlblJlcXVlc3QpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBsZXQgcmV2b2tlVG9rZW5SZXNwb25zZSA9IHRoaXMucmVxdWVzdG9yLnhocjxib29sZWFuPih7XG4gICAgICB1cmw6IGNvbmZpZ3VyYXRpb24ucmV2b2NhdGlvbkVuZHBvaW50LFxuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7J0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnfSxcbiAgICAgIGRhdGE6IHRoaXMudXRpbHMuc3RyaW5naWZ5KHJlcXVlc3QudG9TdHJpbmdNYXAoKSlcbiAgICB9KTtcblxuICAgIHJldHVybiByZXZva2VUb2tlblJlc3BvbnNlLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH1cblxuICBwZXJmb3JtVG9rZW5SZXF1ZXN0KGNvbmZpZ3VyYXRpb246IEF1dGhvcml6YXRpb25TZXJ2aWNlQ29uZmlndXJhdGlvbiwgcmVxdWVzdDogVG9rZW5SZXF1ZXN0KTpcbiAgICAgIFByb21pc2U8VG9rZW5SZXNwb25zZT4ge1xuICAgIGxldCB0b2tlblJlc3BvbnNlID0gdGhpcy5yZXF1ZXN0b3IueGhyPFRva2VuUmVzcG9uc2VKc29ufFRva2VuRXJyb3JKc29uPih7XG4gICAgICB1cmw6IGNvbmZpZ3VyYXRpb24udG9rZW5FbmRwb2ludCxcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgZGF0YVR5cGU6ICdqc29uJywgIC8vIGFkZGluZyBpbXBsaWNpdCBkYXRhVHlwZVxuICAgICAgaGVhZGVyczogeydDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ30sXG4gICAgICBkYXRhOiB0aGlzLnV0aWxzLnN0cmluZ2lmeShyZXF1ZXN0LnRvU3RyaW5nTWFwKCkpXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdG9rZW5SZXNwb25zZS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgIGlmICh0aGlzLmlzVG9rZW5SZXNwb25zZShyZXNwb25zZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUb2tlblJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdDxUb2tlblJlc3BvbnNlPihcbiAgICAgICAgICAgIG5ldyBBcHBBdXRoRXJyb3IocmVzcG9uc2UuZXJyb3IsIG5ldyBUb2tlbkVycm9yKHJlc3BvbnNlKSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdFxuICogaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZVxuICogTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXJcbiAqIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBhY2Nlc3MgdG9rZW4gdHlwZXMuXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWU6XG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjc0OSNzZWN0aW9uLTcuMVxuICovXG5leHBvcnQgdHlwZSBUb2tlblR5cGUgPSAnYmVhcmVyJ3wnbWFjJztcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBUb2tlblJlc3BvbnNlIGFzIGEgSlNPTiBPYmplY3QuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVG9rZW5SZXNwb25zZUpzb24ge1xuICBhY2Nlc3NfdG9rZW46IHN0cmluZztcbiAgdG9rZW5fdHlwZT86IFRva2VuVHlwZTsgLyogdHJlYXRpbmcgdG9rZW4gdHlwZSBhcyBvcHRpb25hbCwgYXMgaXRzIGdvaW5nIHRvIGJlIGluZmVycmVkLiAqL1xuICBleHBpcmVzX2luPzogbnVtYmVyOyAgICAvKiBsaWZldGltZSBpbiBzZWNvbmRzLiAqL1xuICByZWZyZXNoX3Rva2VuPzogc3RyaW5nO1xuICBzY29wZT86IHN0cmluZztcbiAgaWRfdG9rZW4/OiBzdHJpbmc7ICAvKiBodHRwczovL29wZW5pZC5uZXQvc3BlY3Mvb3BlbmlkLWNvbm5lY3QtY29yZS0xXzAuaHRtbCNUb2tlblJlc3BvbnNlICovXG4gIGlzc3VlZF9hdD86IG51bWJlcjsgLyogd2hlbiB3YXMgaXQgaXNzdWVkID8gKi9cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBwb3NzaWJsZSBlcnJvciBjb2RlcyBmcm9tIHRoZSB0b2tlbiBlbmRwb2ludC5cbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIGxvb2sgYXQ6XG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjc0OSNzZWN0aW9uLTUuMlxuICovXG5leHBvcnQgdHlwZSBFcnJvclR5cGUgPSAnaW52YWxpZF9yZXF1ZXN0J3wnaW52YWxpZF9jbGllbnQnfCdpbnZhbGlkX2dyYW50J3wndW5hdXRob3JpemVkX2NsaWVudCd8XG4gICAgJ3Vuc3VwcG9ydGVkX2dyYW50X3R5cGUnfCdpbnZhbGlkX3Njb3BlJztcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBUb2tlbkVycm9yIGFzIGEgSlNPTiBPYmplY3QuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVG9rZW5FcnJvckpzb24ge1xuICBlcnJvcjogRXJyb3JUeXBlO1xuICBlcnJvcl9kZXNjcmlwdGlvbj86IHN0cmluZztcbiAgZXJyb3JfdXJpPzogc3RyaW5nO1xufVxuXG4vLyBjb25zdGFudHNcbmNvbnN0IEFVVEhfRVhQSVJZX0JVRkZFUiA9IDEwICogNjAgKiAtMTsgIC8vIDEwIG1pbnMgaW4gc2Vjb25kc1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGluc3RhbnQgb2YgdGltZSBpbiBzZWNvbmRzLlxuICovXG5leHBvcnQgY29uc3Qgbm93SW5TZWNvbmRzID0gKCkgPT4gTWF0aC5yb3VuZChuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFRva2VuIFJlc3BvbnNlIHR5cGUuXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBsb29rIGF0OlxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY3NDkjc2VjdGlvbi01LjFcbiAqL1xuZXhwb3J0IGNsYXNzIFRva2VuUmVzcG9uc2Uge1xuICBhY2Nlc3NUb2tlbjogc3RyaW5nO1xuICB0b2tlblR5cGU6IFRva2VuVHlwZTtcbiAgZXhwaXJlc0luOiBudW1iZXJ8dW5kZWZpbmVkO1xuICByZWZyZXNoVG9rZW46IHN0cmluZ3x1bmRlZmluZWQ7XG4gIHNjb3BlOiBzdHJpbmd8dW5kZWZpbmVkO1xuICBpZFRva2VuOiBzdHJpbmd8dW5kZWZpbmVkO1xuICBpc3N1ZWRBdDogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKHJlc3BvbnNlOiBUb2tlblJlc3BvbnNlSnNvbikge1xuICAgIHRoaXMuYWNjZXNzVG9rZW4gPSByZXNwb25zZS5hY2Nlc3NfdG9rZW47XG4gICAgdGhpcy50b2tlblR5cGUgPSByZXNwb25zZS50b2tlbl90eXBlIHx8ICdiZWFyZXInO1xuICAgIHRoaXMuZXhwaXJlc0luID0gcmVzcG9uc2UuZXhwaXJlc19pbjtcbiAgICB0aGlzLnJlZnJlc2hUb2tlbiA9IHJlc3BvbnNlLnJlZnJlc2hfdG9rZW47XG4gICAgdGhpcy5zY29wZSA9IHJlc3BvbnNlLnNjb3BlO1xuICAgIHRoaXMuaWRUb2tlbiA9IHJlc3BvbnNlLmlkX3Rva2VuO1xuICAgIHRoaXMuaXNzdWVkQXQgPSByZXNwb25zZS5pc3N1ZWRfYXQgfHwgbm93SW5TZWNvbmRzKCk7XG4gIH1cblxuICB0b0pzb24oKTogVG9rZW5SZXNwb25zZUpzb24ge1xuICAgIHJldHVybiB7XG4gICAgICBhY2Nlc3NfdG9rZW46IHRoaXMuYWNjZXNzVG9rZW4sXG4gICAgICBpZF90b2tlbjogdGhpcy5pZFRva2VuLFxuICAgICAgcmVmcmVzaF90b2tlbjogdGhpcy5yZWZyZXNoVG9rZW4sXG4gICAgICBzY29wZTogdGhpcy5zY29wZSxcbiAgICAgIHRva2VuX3R5cGU6IHRoaXMudG9rZW5UeXBlLFxuICAgICAgaXNzdWVkX2F0OiB0aGlzLmlzc3VlZEF0LFxuICAgICAgZXhwaXJlc19pbjogdGhpcy5leHBpcmVzSW5cbiAgICB9O1xuICB9XG5cbiAgaXNWYWxpZChidWZmZXI6IG51bWJlciA9IEFVVEhfRVhQSVJZX0JVRkZFUik6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLmV4cGlyZXNJbikge1xuICAgICAgbGV0IG5vdyA9IG5vd0luU2Vjb25kcygpO1xuICAgICAgcmV0dXJuIG5vdyA8IHRoaXMuaXNzdWVkQXQgKyB0aGlzLmV4cGlyZXNJbiArIGJ1ZmZlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgVG9rZW4gRXJyb3IgdHlwZS5cbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIGxvb2sgYXQ6XG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjc0OSNzZWN0aW9uLTUuMlxuICovXG5leHBvcnQgY2xhc3MgVG9rZW5FcnJvciB7XG4gIGVycm9yOiBFcnJvclR5cGU7XG4gIGVycm9yRGVzY3JpcHRpb246IHN0cmluZ3x1bmRlZmluZWQ7XG4gIGVycm9yVXJpOiBzdHJpbmd8dW5kZWZpbmVkO1xuXG4gIGNvbnN0cnVjdG9yKHRva2VuRXJyb3I6IFRva2VuRXJyb3JKc29uKSB7XG4gICAgdGhpcy5lcnJvciA9IHRva2VuRXJyb3IuZXJyb3I7XG4gICAgdGhpcy5lcnJvckRlc2NyaXB0aW9uID0gdG9rZW5FcnJvci5lcnJvcl9kZXNjcmlwdGlvbjtcbiAgICB0aGlzLmVycm9yVXJpID0gdG9rZW5FcnJvci5lcnJvcl91cmk7XG4gIH1cblxuICB0b0pzb24oKTogVG9rZW5FcnJvckpzb24ge1xuICAgIHJldHVybiB7XG4gICAgICBlcnJvcjogdGhpcy5lcnJvciwgZXJyb3JfZGVzY3JpcHRpb246IHRoaXMuZXJyb3JEZXNjcmlwdGlvbiwgZXJyb3JfdXJpOiB0aGlzLmVycm9yVXJpXG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdFxuICogaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZVxuICogTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXJcbiAqIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtBcHBBdXRoRXJyb3J9IGZyb20gJy4vZXJyb3JzJztcblxuLyoqXG4gKiBBbiBjbGFzcyB0aGF0IGFic3RyYWN0cyBhd2F5IHRoZSBhYmlsaXR5IHRvIG1ha2UgYW4gWE1MSHR0cFJlcXVlc3QuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBSZXF1ZXN0b3Ige1xuICBhYnN0cmFjdCB4aHI8VD4oc2V0dGluZ3M6IEpRdWVyeUFqYXhTZXR0aW5ncyk6IFByb21pc2U8VD47XG59XG5cbi8qKlxuICogVXNlcyAkLmFqYXggdG8gbWFrZXMgdGhlIEFqYXggcmVxdWVzdHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBKUXVlcnlSZXF1ZXN0b3IgZXh0ZW5kcyBSZXF1ZXN0b3Ige1xuICB4aHI8VD4oc2V0dGluZ3M6IEpRdWVyeUFqYXhTZXR0aW5ncyk6IFByb21pc2U8VD4ge1xuICAgIC8vIE5PVEU6IHVzaW5nIGpxdWVyeSB0byBtYWtlIFhIUidzIGFzIHdoYXR3Zy1mZXRjaCByZXF1aXJlc1xuICAgIC8vIHRoYXQgSSB0YXJnZXQgRVM2LlxuICAgIGNvbnN0IHhociA9ICQuYWpheChzZXR0aW5ncyk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPFQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHhoci50aGVuKFxuICAgICAgICAgIChkYXRhLCB0ZXh0U3RhdHVzLCBqcVhocikgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZShkYXRhIGFzIFQpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgKGpxWGhyLCB0ZXh0U3RhdHVzLCBlcnJvcikgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBBcHBBdXRoRXJyb3IoZXJyb3IpKTtcbiAgICAgICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuXG5cbi8qKlxuICogVXNlcyBmZXRjaCBBUEkgdG8gbWFrZSBBamF4IHJlcXVlc3RzXG4gKi9cbmV4cG9ydCBjbGFzcyBGZXRjaFJlcXVlc3RvciBleHRlbmRzIFJlcXVlc3RvciB7XG4gIHhocjxUPihzZXR0aW5nczogSlF1ZXJ5QWpheFNldHRpbmdzKTogUHJvbWlzZTxUPiB7XG4gICAgaWYgKCFzZXR0aW5ncy51cmwpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgQXBwQXV0aEVycm9yKCdBIFVSTCBtdXN0IGJlIHByb3ZpZGVkLicpKTtcbiAgICB9XG4gICAgbGV0IHVybDogVVJMID0gbmV3IFVSTCg8c3RyaW5nPnNldHRpbmdzLnVybCk7XG4gICAgbGV0IHJlcXVlc3RJbml0OiBSZXF1ZXN0SW5pdCA9IHt9O1xuICAgIHJlcXVlc3RJbml0Lm1ldGhvZCA9IHNldHRpbmdzLm1ldGhvZDtcbiAgICByZXF1ZXN0SW5pdC5tb2RlID0gJ2NvcnMnO1xuXG4gICAgaWYgKHNldHRpbmdzLmRhdGEpIHtcbiAgICAgIGlmIChzZXR0aW5ncy5tZXRob2QgJiYgc2V0dGluZ3MubWV0aG9kLnRvVXBwZXJDYXNlKCkgPT09ICdQT1NUJykge1xuICAgICAgICByZXF1ZXN0SW5pdC5ib2R5ID0gPHN0cmluZz5zZXR0aW5ncy5kYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoc2V0dGluZ3MuZGF0YSk7XG4gICAgICAgIHNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PsKge1xuICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXQgdGhlIHJlcXVlc3QgaGVhZGVyc1xuICAgIHJlcXVlc3RJbml0LmhlYWRlcnMgPSB7fTtcbiAgICBpZiAoc2V0dGluZ3MuaGVhZGVycykge1xuICAgICAgZm9yIChsZXQgaSBpbiBzZXR0aW5ncy5oZWFkZXJzKSB7XG4gICAgICAgIGlmIChzZXR0aW5ncy5oZWFkZXJzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgcmVxdWVzdEluaXQuaGVhZGVyc1tpXSA9IDxzdHJpbmc+c2V0dGluZ3MuaGVhZGVyc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGlzSnNvbkRhdGFUeXBlID0gc2V0dGluZ3MuZGF0YVR5cGUgJiYgc2V0dGluZ3MuZGF0YVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ2pzb24nO1xuXG4gICAgLy8gU2V0ICdBY2NlcHQnIGhlYWRlciB2YWx1ZSBmb3IganNvbiByZXF1ZXN0cyAoVGFrZW4gZnJvbVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L2Jsb2IvZTBkOTQxMTU2OTAwYTZiZmY3YzA5OGM4ZWE3MjkwNTI4ZTQ2OGNmOC9zcmMvYWpheC5qcyNMNjQ0XG4gICAgLy8gKVxuICAgIGlmIChpc0pzb25EYXRhVHlwZSkge1xuICAgICAgcmVxdWVzdEluaXQuaGVhZGVyc1snQWNjZXB0J10gPSAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0LCAqLyo7IHE9MC4wMSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZldGNoKHVybC50b1N0cmluZygpLCByZXF1ZXN0SW5pdCkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDIwMCAmJiByZXNwb25zZS5zdGF0dXMgPCAzMDApIHtcbiAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJyk7XG4gICAgICAgIGlmIChpc0pzb25EYXRhVHlwZSB8fCAoY29udGVudFR5cGUgJiYgY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24vanNvbicpICE9PSAtMSkpIHtcbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgQXBwQXV0aEVycm9yKHJlc3BvbnNlLnN0YXR1cy50b1N0cmluZygpLCByZXNwb25zZS5zdGF0dXNUZXh0KSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIHRlc3RpbmcuIEp1c3QgdXNlcyB0aGUgdW5kZXJseWluZ1xuICogUHJvbWlzZSB0byBtb2NrIHRoZSBiZWhhdmlvciBvZiB0aGUgUmVxdWVzdG9yLlxuICovXG5leHBvcnQgY2xhc3MgVGVzdFJlcXVlc3RvciBleHRlbmRzIFJlcXVlc3RvciB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBwcm9taXNlOiBQcm9taXNlPGFueT4pIHtcbiAgICBzdXBlcigpO1xuICB9XG4gIHhocjxUPihzZXR0aW5nczogSlF1ZXJ5QWpheFNldHRpbmdzKTogUHJvbWlzZTxUPiB7XG4gICAgcmV0dXJuIHRoaXMucHJvbWlzZTsgIC8vIHVuc2FmZSBjYXN0XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5mYWxsYmFjayA9IGZhbGxiYWNrO1xuZXhwb3J0cy53cmFwID0gd3JhcDtcbnZhciBoYXNTZXRJbW1lZGlhdGUgPSBleHBvcnRzLmhhc1NldEltbWVkaWF0ZSA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicgJiYgc2V0SW1tZWRpYXRlO1xudmFyIGhhc05leHRUaWNrID0gZXhwb3J0cy5oYXNOZXh0VGljayA9IHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcHJvY2Vzcy5uZXh0VGljayA9PT0gJ2Z1bmN0aW9uJztcblxuZnVuY3Rpb24gZmFsbGJhY2soZm4pIHtcbiAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbn1cblxuZnVuY3Rpb24gd3JhcChkZWZlcikge1xuICAgIHJldHVybiAoZm4sIC4uLmFyZ3MpID0+IGRlZmVyKCgpID0+IGZuKC4uLmFyZ3MpKTtcbn1cblxudmFyIF9kZWZlcjtcblxuaWYgKGhhc1NldEltbWVkaWF0ZSkge1xuICAgIF9kZWZlciA9IHNldEltbWVkaWF0ZTtcbn0gZWxzZSBpZiAoaGFzTmV4dFRpY2spIHtcbiAgICBfZGVmZXIgPSBwcm9jZXNzLm5leHRUaWNrO1xufSBlbHNlIHtcbiAgICBfZGVmZXIgPSBmYWxsYmFjaztcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gd3JhcChfZGVmZXIpOyIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayhcbiAgICAgIHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aClcbiAgICApKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIoZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdmFyIHYgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMpO1xuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSBtb2R1bGUuZXhwb3J0cyA9IHY7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZmFjdG9yeSk7XG4gICAgfVxufSkoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4gICAgLyoqXG4gICAgICogQSB0b2tlbiB0aGF0IHByb3ZpZGVzIGFjY2VzcyB0byBCaXRza2kgb24gYmVoYWxmIG9mIGEgdXNlci5cbiAgICAgKi9cbiAgICBjbGFzcyBBY2Nlc3NUb2tlbiB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHRva2VuLCBleHBpcmVzSW4pIHtcbiAgICAgICAgICAgIHRoaXMuZXhwaXJlc0F0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgaWYgKGV4cGlyZXNJbikge1xuICAgICAgICAgICAgICAgIHRoaXMuZXhwaXJlc0F0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkgKyBleHBpcmVzSW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGV4cGlyZWQoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5leHBpcmVzQXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub3cgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBleHBpcmVzSW4gPSB0aGlzLmV4cGlyZXNBdCAtIG5vdztcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwaXJlc0luIDw9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXhwb3J0cy5BY2Nlc3NUb2tlbiA9IEFjY2Vzc1Rva2VuO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY2Nlc3MtdG9rZW4uanMubWFwIiwidmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHZhciB2ID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzKTtcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkgbW9kdWxlLmV4cG9ydHMgPSB2O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJAYml0c2tpL3Byb3ZpZGVyLWVuZ2luZVwiLCBcIi4vZXJyb3JzL3Byb3ZpZGVyLWVycm9yXCIsIFwiLi9zdWJwcm92aWRlcnMvbm9uY2UtdHJhY2tlclwiLCBcIi4vc3VicHJvdmlkZXJzL3RyYW5zYWN0aW9uLXZhbGlkYXRvclwiLCBcIi4vc3VicHJvdmlkZXJzL3R5cGVkLWRhdGFcIl0sIGZhY3RvcnkpO1xuICAgIH1cbn0pKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICAgIGNvbnN0IHByb3ZpZGVyX2VuZ2luZV8xID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJAYml0c2tpL3Byb3ZpZGVyLWVuZ2luZVwiKSk7XG4gICAgY29uc3QgcHJvdmlkZXJfZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2Vycm9ycy9wcm92aWRlci1lcnJvclwiKTtcbiAgICBjb25zdCBub25jZV90cmFja2VyXzEgPSByZXF1aXJlKFwiLi9zdWJwcm92aWRlcnMvbm9uY2UtdHJhY2tlclwiKTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbl92YWxpZGF0b3JfMSA9IHJlcXVpcmUoXCIuL3N1YnByb3ZpZGVycy90cmFuc2FjdGlvbi12YWxpZGF0b3JcIik7XG4gICAgY29uc3QgdHlwZWRfZGF0YV8xID0gcmVxdWlyZShcIi4vc3VicHJvdmlkZXJzL3R5cGVkLWRhdGFcIik7XG4gICAgY2xhc3MgQml0c2tpRW5naW5lIGV4dGVuZHMgcHJvdmlkZXJfZW5naW5lXzEuZGVmYXVsdCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgICAgICAvLyBIYW5kbGVzIHN0YXRpYyByZXNwb25zZXNcbiAgICAgICAgICAgIHRoaXMuYWRkUHJvdmlkZXIobmV3IHByb3ZpZGVyX2VuZ2luZV8xLkRlZmF1bHRGaXh0dXJlU3VicHJvdmlkZXIoKSk7XG4gICAgICAgICAgICAvLyBNb25pdG9ycyByZXF1ZXN0cyB0byBldGhfZ2V0VHJhbnNhY3Rpb25Db3VudCBhbmQgZXRoX3NlbmRUcmFuc2FjdGlvbiB0byB0cmFja1xuICAgICAgICAgICAgLy8gcGVuZGluZyB0cmFuc2FjdGlvbnNcbiAgICAgICAgICAgIHRoaXMuYWRkUHJvdmlkZXIobmV3IG5vbmNlX3RyYWNrZXJfMS5Ob25jZVRyYWNrZXJTdWJwcm92aWRlcigpKTtcbiAgICAgICAgICAgIC8vIFNhbml0aXplcyB0cmFuc2FjdGlvbiBwYXJhbXMsIHJlbW92aW5nIGFueXRoaW5nIGludmFsaWRcbiAgICAgICAgICAgIHRoaXMuYWRkUHJvdmlkZXIobmV3IHByb3ZpZGVyX2VuZ2luZV8xLlNhbml0aXplclN1YnByb3ZpZGVyKCkpO1xuICAgICAgICAgICAgY29uc3QgZW5hYmxlVmFsaWRhdG9yID0gIShvcHRpb25zICYmIG9wdGlvbnMuZGlzYWJsZVZhbGlkYXRpb24gPT09IHRydWUpO1xuICAgICAgICAgICAgaWYgKGVuYWJsZVZhbGlkYXRvcikge1xuICAgICAgICAgICAgICAgIC8vIEVuc3VyZXMgdGhhdCB0cmFuc2FjdGlvbnMgYXJlIHdlbGwgZm9ybWVkIChub25jZSwgZ2FzLCBnYXNQcmljZSwgZnJvbSkgYmVmb3JlIHRoZXkgYXJlIHNlbnQgdG8gQml0c2tpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRQcm92aWRlcihuZXcgdHJhbnNhY3Rpb25fdmFsaWRhdG9yXzEuVHJhbnNhY3Rpb25WYWxpZGF0b3JTdWJwcm92aWRlcihvcHRpb25zLm1pbkdhc1ByaWNlKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRQcm92aWRlcihuZXcgdHlwZWRfZGF0YV8xLlR5cGVkRGF0YVNhbml0aXplclN1YnByb3ZpZGVyKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZW5hYmxlQ2FjaGUgPSAhKG9wdGlvbnMgJiYgb3B0aW9ucy5kaXNhYmxlQ2FjaGluZyA9PT0gdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoZW5hYmxlQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICAvLyBCbG9jayBDYWNoZSAtIGNhY2hlcyBjZXJ0YWluIHJlcXVlc3RzIGJ5IHRoZWlyIGJsb2NrIG51bWJlclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkUHJvdmlkZXIobmV3IHByb3ZpZGVyX2VuZ2luZV8xLkJsb2NrQ2FjaGVTdWJwcm92aWRlcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEhhbmRsZXMgc3Vic2NyaXB0aW9ucyBhbmQgZmlsdGVyc1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyQW5kU3Vic1N1YnByb3ZpZGVyID0gbmV3IHByb3ZpZGVyX2VuZ2luZV8xLlN1YnNjcmlwdGlvblN1YnByb3ZpZGVyKCk7XG4gICAgICAgICAgICAvLyBXYXRjaCBmb3IgdXBkYXRlcyBmcm9tIHN1YnNjcmlwdGlvbnNcbiAgICAgICAgICAgIGZpbHRlckFuZFN1YnNTdWJwcm92aWRlci5vbignZGF0YScsIChfLCBub3RpZmljYXRpb24pID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uTWVzc2FnZShub3RpZmljYXRpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmFkZFByb3ZpZGVyKGZpbHRlckFuZFN1YnNTdWJwcm92aWRlcik7XG4gICAgICAgICAgICBpZiAoZW5hYmxlQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICAvLyBEZWJvdW5jZXMgZHVwbGljYXRlIHJlcXVlc3RzIHRoYXQgb2NjdXIgYXQgdGhlIHNhbWUgdGltZVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkUHJvdmlkZXIobmV3IHByb3ZpZGVyX2VuZ2luZV8xLkluZmxpZ2h0Q2FjaGVTdWJwcm92aWRlcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdXBwb3J0c1N1YnNjcmlwdGlvbnMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcG9sbEZvckJsb2NrcztcbiAgICAgICAgfVxuICAgICAgICBzdWJzY3JpYmUoc3Vic2NyaWJlTWV0aG9kID0gJ2V0aF9zdWJzY3JpYmUnLCBzdWJzY3JpcHRpb25NZXRob2QsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcG9sbEZvckJsb2Nrcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChwcm92aWRlcl9lcnJvcl8xLlByb3ZpZGVyRXJyb3IuU3Vic2NyaXB0aW9uc1VuYXZhaWxhYmxlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyYW1ldGVycy51bnNoaWZ0KHN1YnNjcmlwdGlvbk1ldGhvZCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHN1YnNjcmliZU1ldGhvZCwgcGFyYW1ldGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgdW5zdWJzY3JpYmUoc3Vic2NyaXB0aW9uSWQsIHVuc3Vic2NyaWJlTWV0aG9kID0gJ2V0aF91bnN1YnNjcmliZScpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcG9sbEZvckJsb2Nrcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChwcm92aWRlcl9lcnJvcl8xLlByb3ZpZGVyRXJyb3IuU3Vic2NyaXB0aW9uc1VuYXZhaWxhYmxlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh1bnN1YnNjcmliZU1ldGhvZCwgW3N1YnNjcmlwdGlvbklkXSkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoc3Vic2NyaXB0aW9uSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBvbk1lc3NhZ2Uobm90aWZpY2F0aW9uKSB7XG4gICAgICAgICAgICAvLyBSZS1lbWl0IChwcmV2aW91cyBiZWhhdmlvciB+IHdlYjMgMS4wLjAtYmV0YS4zNylcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIG51bGwsIG5vdGlmaWNhdGlvbik7XG4gICAgICAgICAgICBpZiAobm90aWZpY2F0aW9uICYmIG5vdGlmaWNhdGlvbi5wYXJhbXMgJiYgbm90aWZpY2F0aW9uLnBhcmFtcy5zdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBDdXJyZW50IHdlYjMgYmVoYXZpb3IgLSBlbWl0IHN1YnNjcmlwdGlvbiBpZFxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChub3RpZmljYXRpb24ucGFyYW1zLnN1YnNjcmlwdGlvbiwgbm90aWZpY2F0aW9uLnBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXhwb3J0cy5CaXRza2lFbmdpbmUgPSBCaXRza2lFbmdpbmU7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpdHNraS1lbmdpbmUuanMubWFwIiwiKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHZhciB2ID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzKTtcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkgbW9kdWxlLmV4cG9ydHMgPSB2O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZhY3RvcnkpO1xuICAgIH1cbn0pKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICAgIC8vIEpTT04tUlBDIG1ldGhvZHMgdGhhdCByZXF1aXJlIEF1dGhvcml6YXRpb24gaGVhZGVyXG4gICAgZXhwb3J0cy5BVVRIRU5USUNBVEVEX01FVEhPRFMgPSBbXG4gICAgICAgICdldGhfYWNjb3VudHMnLFxuICAgICAgICAnZXRoX3NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgICdldGhfc2lnblRyYW5zYWN0aW9uJyxcbiAgICAgICAgJ2V0aF9zaWduVHlwZWREYXRhJyxcbiAgICAgICAgJ3BlcnNvbmFsX3NpZ24nLFxuICAgICAgICAnZXRoX3NpZ24nLFxuICAgIF07XG4gICAgLy8gRXJyb3IgbWVzc2FnZXMgdGhhdCBhcmUgdXN1YWxseSB0cmFuc2llbnQgYW5kIHNob3VsZCBiZSByZXRyaWVkXG4gICAgZXhwb3J0cy5SRVRSSUFCTEVfRVJST1JTID0gW1xuICAgICAgICAvLyBpZ25vcmUgc2VydmVyIG92ZXJsb2FkIGVycm9yc1xuICAgICAgICAnR2F0ZXdheSB0aW1lb3V0JyxcbiAgICAgICAgJ0VUSU1FRE9VVCcsXG4gICAgICAgICdFTk9URk9VTkQnLFxuICAgICAgICAvLyBpZ25vcmUgc2VydmVyIHNlbnQgaHRtbCBlcnJvciBwYWdlc1xuICAgICAgICAvLyBvciB0cnVuY2F0ZWQganNvbiByZXNwb25zZXNcbiAgICAgICAgJ1N5bnRheEVycm9yJyxcbiAgICAgICAgJ0VDT05OUkVTRVQnLFxuICAgICAgICAnRUhPU1RVTlJFQUNIJyxcbiAgICAgICAgJ1RpbWVvdXQgb3V0IHdoaWxlIHdhaXRpbmcgZm9yIHJlc3BvbnNlJyxcbiAgICBdO1xuICAgIC8vIEVycm9ycyB0aGF0IGluZGljYXRlIHRoZSBhY2Nlc3MgdG9rZW4gaXMgbm90IHZhbGlkXG4gICAgZXhwb3J0cy5VTkFVVEhPUklaRURfRVJST1JTID0gW1xuICAgICAgICAnTWlzc2luZyBhdXRoJyxcbiAgICAgICAgJ0ludmFsaWQgY2xpZW50IGlkJyxcbiAgICAgICAgJ05vdCBBdXRob3JpemVkJyxcbiAgICBdO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIiwiKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHZhciB2ID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzKTtcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkgbW9kdWxlLmV4cG9ydHMgPSB2O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZhY3RvcnkpO1xuICAgIH1cbn0pKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICAgIHZhciBQcm92aWRlckVycm9yQ29kZTtcbiAgICAoZnVuY3Rpb24gKFByb3ZpZGVyRXJyb3JDb2RlKSB7XG4gICAgICAgIC8vIFRocm93biB3aGVuIGFjY2Vzc2luZyBzdWJzY3JpcHRpb24gZmVhdHVyZXMgd2hlbiB0aGV5IGFyZSBkaXNhYmxlZC5cbiAgICAgICAgUHJvdmlkZXJFcnJvckNvZGVbUHJvdmlkZXJFcnJvckNvZGVbXCJTdWJzY3JpcHRpb25zVW5hdmFpbGFibGVcIl0gPSA0MDAwXSA9IFwiU3Vic2NyaXB0aW9uc1VuYXZhaWxhYmxlXCI7XG4gICAgICAgIC8vIFRocm93biB3aGVuIHJlcXVlc3QgaXMgbWlzc2luZyByZXF1aXJlZCBwYXJhbXMgb3IgZGF0YVxuICAgICAgICBQcm92aWRlckVycm9yQ29kZVtQcm92aWRlckVycm9yQ29kZVtcIkludmFsaWRSZXF1ZXN0XCJdID0gNDAwMV0gPSBcIkludmFsaWRSZXF1ZXN0XCI7XG4gICAgfSkoUHJvdmlkZXJFcnJvckNvZGUgPSBleHBvcnRzLlByb3ZpZGVyRXJyb3JDb2RlIHx8IChleHBvcnRzLlByb3ZpZGVyRXJyb3JDb2RlID0ge30pKTtcbiAgICBjbGFzcyBQcm92aWRlckVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgICAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjb2RlKSB7XG4gICAgICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9ICdQcm92aWRlckVycm9yJztcbiAgICAgICAgICAgIC8vIE1haW50YWlucyBwcm9wZXIgc3RhY2sgdHJhY2UgZm9yIHdoZXJlIG91ciBlcnJvciB3YXMgdGhyb3duIChvbmx5IGF2YWlsYWJsZSBvbiBWOClcbiAgICAgICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFByb3ZpZGVyRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgU3Vic2NyaXB0aW9uc1VuYXZhaWxhYmxlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm92aWRlckVycm9yKCdTdWJzY3JpcHRpb25zIGFyZSBkaXNhYmxlZC4gRW5hYmxlIGJsb2NrIHBvbGxpbmcgdG8gdXNlIHRoaXMgZmVhdHVyZS4nLCBQcm92aWRlckVycm9yQ29kZS5TdWJzY3JpcHRpb25zVW5hdmFpbGFibGUpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBJbnZhbGlkUmVxdWVzdChyZWFzb24pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvdmlkZXJFcnJvcihgSW52YWxpZCByZXF1ZXN0OiAke3JlYXNvbn1gLCBQcm92aWRlckVycm9yQ29kZS5JbnZhbGlkUmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXhwb3J0cy5Qcm92aWRlckVycm9yID0gUHJvdmlkZXJFcnJvcjtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXItZXJyb3IuanMubWFwIiwiKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHZhciB2ID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzKTtcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkgbW9kdWxlLmV4cG9ydHMgPSB2O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZhY3RvcnkpO1xuICAgIH1cbn0pKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYW4gZXJyb3IgdGhhdCBpcyByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAgKiBZb3UgY2FuIGFjY2VzcyB0aGUgcmVzcG9uc2UgY29kZSB2aWEgdGhlIGNvZGUgcHJvcGVydHksIGFuZCB0aGUgVVJJIGZyb20gdGhlIHJlcXVlc3RVUkkgcHJvcGVydHkuXG4gICAgICogVGhlIHJldHJpZWQgcHJvcGVydHkgd2lsbCBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGUgcmVxdWVzdCBmYWlsZWQgYWZ0ZXIgbXVsdGlwbGUgdHJpZXMuXG4gICAgICovXG4gICAgY2xhc3MgU2VydmVyRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNvZGUsIHJlcXVlc3RVUkksIHJldHJpZWQgPSBmYWxzZSkge1xuICAgICAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSAnU2VydmVyRXJyb3InO1xuICAgICAgICAgICAgLy8gTWFpbnRhaW5zIHByb3BlciBzdGFjayB0cmFjZSBmb3Igd2hlcmUgb3VyIGVycm9yIHdhcyB0aHJvd24gKG9ubHkgYXZhaWxhYmxlIG9uIFY4KVxuICAgICAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgU2VydmVyRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdFVSSSA9IHJlcXVlc3RVUkk7XG4gICAgICAgICAgICB0aGlzLnJldHJpZWQgPSByZXRyaWVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV4cG9ydHMuU2VydmVyRXJyb3IgPSBTZXJ2ZXJFcnJvcjtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VydmVyLWVycm9yLmpzLm1hcCIsIihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB2YXIgdiA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cyk7XG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiLi9iaXRza2ktZW5naW5lXCIsIFwiLi9hdXRoL2FjY2Vzcy10b2tlblwiLCBcIi4vc3VicHJvdmlkZXJzL2F1dGhlbnRpY2F0ZWQtZmV0Y2hcIiwgXCIuL25ldHdvcmtcIiwgXCIuL2Vycm9ycy9zZXJ2ZXItZXJyb3JcIiwgXCIuL2Vycm9ycy9wcm92aWRlci1lcnJvclwiXSwgZmFjdG9yeSk7XG4gICAgfVxufSkoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4gICAgdmFyIGJpdHNraV9lbmdpbmVfMSA9IHJlcXVpcmUoXCIuL2JpdHNraS1lbmdpbmVcIik7XG4gICAgZXhwb3J0cy5CaXRza2lFbmdpbmUgPSBiaXRza2lfZW5naW5lXzEuQml0c2tpRW5naW5lO1xuICAgIHZhciBhY2Nlc3NfdG9rZW5fMSA9IHJlcXVpcmUoXCIuL2F1dGgvYWNjZXNzLXRva2VuXCIpO1xuICAgIGV4cG9ydHMuQWNjZXNzVG9rZW4gPSBhY2Nlc3NfdG9rZW5fMS5BY2Nlc3NUb2tlbjtcbiAgICB2YXIgYXV0aGVudGljYXRlZF9mZXRjaF8xID0gcmVxdWlyZShcIi4vc3VicHJvdmlkZXJzL2F1dGhlbnRpY2F0ZWQtZmV0Y2hcIik7XG4gICAgZXhwb3J0cy5BdXRoZW50aWNhdGVkRmV0Y2hTdWJwcm92aWRlciA9IGF1dGhlbnRpY2F0ZWRfZmV0Y2hfMS5BdXRoZW50aWNhdGVkRmV0Y2hTdWJwcm92aWRlcjtcbiAgICB2YXIgbmV0d29ya18xID0gcmVxdWlyZShcIi4vbmV0d29ya1wiKTtcbiAgICBleHBvcnRzLk1haW5uZXQgPSBuZXR3b3JrXzEuTWFpbm5ldDtcbiAgICBleHBvcnRzLlJpbmtlYnkgPSBuZXR3b3JrXzEuUmlua2VieTtcbiAgICBleHBvcnRzLktvdmFuID0gbmV0d29ya18xLktvdmFuO1xuICAgIHZhciBzZXJ2ZXJfZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2Vycm9ycy9zZXJ2ZXItZXJyb3JcIik7XG4gICAgZXhwb3J0cy5TZXJ2ZXJFcnJvciA9IHNlcnZlcl9lcnJvcl8xLlNlcnZlckVycm9yO1xuICAgIHZhciBwcm92aWRlcl9lcnJvcl8xID0gcmVxdWlyZShcIi4vZXJyb3JzL3Byb3ZpZGVyLWVycm9yXCIpO1xuICAgIGV4cG9ydHMuUHJvdmlkZXJFcnJvciA9IHByb3ZpZGVyX2Vycm9yXzEuUHJvdmlkZXJFcnJvcjtcbiAgICBleHBvcnRzLlByb3ZpZGVyRXJyb3JDb2RlID0gcHJvdmlkZXJfZXJyb3JfMS5Qcm92aWRlckVycm9yQ29kZTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHZhciB2ID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzKTtcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkgbW9kdWxlLmV4cG9ydHMgPSB2O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZhY3RvcnkpO1xuICAgIH1cbn0pKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICAgIGV4cG9ydHMuTWFpbm5ldCA9IHtcbiAgICAgICAgY2hhaW5JZDogMSxcbiAgICAgICAgcnBjVXJsOiAnaHR0cHM6Ly9hcGkuYml0c2tpLmNvbS92MS93ZWIzL21haW5uZXQnLFxuICAgIH07XG4gICAgZXhwb3J0cy5SaW5rZWJ5ID0ge1xuICAgICAgICBjaGFpbklkOiA0LFxuICAgICAgICBycGNVcmw6ICdodHRwczovL2FwaS5iaXRza2kuY29tL3YxL3dlYjMvcmlua2VieScsXG4gICAgfTtcbiAgICBleHBvcnRzLktvdmFuID0ge1xuICAgICAgICBjaGFpbklkOiA0MixcbiAgICAgICAgcnBjVXJsOiAnaHR0cHM6Ly9hcGkuYml0c2tpLmNvbS92MS93ZWIzL2tvdmFuJyxcbiAgICB9O1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZXR3b3JrLmpzLm1hcCIsInZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB2YXIgdiA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cyk7XG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiQGJpdHNraS9wcm92aWRlci1lbmdpbmVcIiwgXCJhc3luYy9yZXRyeVwiLCBcIi4uL2NvbnN0YW50c1wiLCBcIi4uL2Vycm9ycy9zZXJ2ZXItZXJyb3JcIl0sIGZhY3RvcnkpO1xuICAgIH1cbn0pKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICAgIGNvbnN0IHByb3ZpZGVyX2VuZ2luZV8xID0gcmVxdWlyZShcIkBiaXRza2kvcHJvdmlkZXItZW5naW5lXCIpO1xuICAgIGNvbnN0IHJldHJ5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImFzeW5jL3JldHJ5XCIpKTtcbiAgICBjb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHNcIik7XG4gICAgY29uc3Qgc2VydmVyX2Vycm9yXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzL3NlcnZlci1lcnJvclwiKTtcbiAgICAvKlxuICAgICAqIFN1YnByb3ZpZGVyIHRoYXQgZmV0Y2hlcyBvdmVyIEhUVFAgYW5kIG1hbmFnZXMgYXV0aGVudGljYXRpb24gaGVhZGVyc1xuICAgICAqL1xuICAgIGNsYXNzIEF1dGhlbnRpY2F0ZWRGZXRjaFN1YnByb3ZpZGVyIGV4dGVuZHMgcHJvdmlkZXJfZW5naW5lXzEuRmV0Y2hTdWJwcm92aWRlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHJwY1VybCwgZGVidWcsIGFjY2Vzc1Rva2VuUHJvdmlkZXIsIGRlZmF1bHRIZWFkZXJzID0ge30pIHtcbiAgICAgICAgICAgIHN1cGVyKHsgcnBjVXJsIH0pO1xuICAgICAgICAgICAgdGhpcy5hdXRoZW50aWNhdGVkTWV0aG9kcyA9IGNvbnN0YW50c18xLkFVVEhFTlRJQ0FURURfTUVUSE9EUztcbiAgICAgICAgICAgIHRoaXMuYWNjZXNzVG9rZW5Qcm92aWRlciA9IGFjY2Vzc1Rva2VuUHJvdmlkZXI7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRIZWFkZXJzID0gZGVmYXVsdEhlYWRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlUmVxdWVzdChwYXlsb2FkLCBuZXh0LCBlbmQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlcXVpcmVzQXV0aGVudGljYXRpb24ocGF5bG9hZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVBdXRoZW50aWNhdGVkUmVxdWVzdChwYXlsb2FkLCBuZXh0LCBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlVW5hdXRoZW50aWNhdGVkUmVxdWVzdChwYXlsb2FkLCBuZXh0LCBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGhhbmRsZUF1dGhlbnRpY2F0ZWRSZXF1ZXN0KHBheWxvYWQsIG5leHQsIGVuZCkge1xuICAgICAgICAgICAgdGhpcy5hY2Nlc3NUb2tlblByb3ZpZGVyLmdldEFjY2Vzc1Rva2VuKCkudGhlbigoYWNjZXNzVG9rZW4pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gdGhpcy5nZW5lcmF0ZVBhcmFtZXRlcnMocGF5bG9hZCwgYWNjZXNzVG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHBhcmFtZXRlcnMsIG5leHQsIGVuZCk7XG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBlbmQoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlVW5hdXRoZW50aWNhdGVkUmVxdWVzdChwYXlsb2FkLCBuZXh0LCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSB0aGlzLmdlbmVyYXRlUGFyYW1ldGVycyhwYXlsb2FkKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHBhcmFtZXRlcnMsIG5leHQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWlyZXNBdXRoZW50aWNhdGlvbihwYXlsb2FkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdXRoZW50aWNhdGVkTWV0aG9kcy5zb21lKChtZXRob2QpID0+IG1ldGhvZCA9PT0gcGF5bG9hZC5tZXRob2QpO1xuICAgICAgICB9XG4gICAgICAgIGdlbmVyYXRlUGFyYW1ldGVycyhwYXlsb2FkLCBhY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgLy8gb3ZlcndyaXRlIGlkIHRvIG5vdCBjb25mbGljdCB3aXRoIG90aGVyIGNvbmN1cnJlbnQgdXNlcnNcbiAgICAgICAgICAgIGNvbnN0IG5ld1BheWxvYWQgPSB0aGlzLmNyZWF0ZVBheWxvYWQocGF5bG9hZCk7XG4gICAgICAgICAgICAvLyByZW1vdmUgZXh0cmEgcGFyYW1ldGVyIGZyb20gcmVxdWVzdFxuICAgICAgICAgICAgZGVsZXRlIG5ld1BheWxvYWQub3JpZ2luO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBoZWFkZXJzLCB0aGlzLmRlZmF1bHRIZWFkZXJzKTtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbkRvbWFpbiA9IHBheWxvYWQub3JpZ2luO1xuICAgICAgICAgICAgaWYgKHRoaXMub3JpZ2luSHR0cEhlYWRlcktleSAmJiBvcmlnaW5Eb21haW4pIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzW3RoaXMub3JpZ2luSHR0cEhlYWRlcktleV0gPSBvcmlnaW5Eb21haW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLkF1dGhvcml6YXRpb24gPSBgQmVhcmVyICR7YWNjZXNzVG9rZW59YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RQYXJhbWV0ZXJzID0ge1xuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KG5ld1BheWxvYWQpLFxuICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RQYXJhbWV0ZXJzO1xuICAgICAgICB9XG4gICAgICAgIHNlbmRSZXF1ZXN0KHBhcmFtZXRlcnMsIG5leHQsIGVuZCkge1xuICAgICAgICAgICAgcmV0cnlfMS5kZWZhdWx0KHtcbiAgICAgICAgICAgICAgICBlcnJvckZpbHRlcjogdGhpcy5pc0Vycm9yUmV0cmlhYmxlLFxuICAgICAgICAgICAgICAgIGludGVydmFsOiAxMDAwLFxuICAgICAgICAgICAgICAgIHRpbWVzOiA1LFxuICAgICAgICAgICAgfSwgKGNiKSA9PiB0aGlzLl9zdWJtaXRSZXF1ZXN0KHBhcmFtZXRlcnMsIGNiKSwgKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gZW5kcyBvbiByZXRyaWFibGUgZXJyb3JcbiAgICAgICAgICAgICAgICBpZiAoZXJyICYmIHRoaXMuaXNFcnJvclJldHJpYWJsZShlcnIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldHJpZXNFeGhhdXN0ZWRFcnIgPSBuZXcgc2VydmVyX2Vycm9yXzEuU2VydmVyRXJyb3IoZXJyLm1lc3NhZ2UsIDIwMCwgdGhpcy5ycGNVcmwsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW5kKHJldHJpZXNFeGhhdXN0ZWRFcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyICYmIHRoaXMuaXNVbmF1dGhvcml6ZWRFcnJvcihlcnIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFjY2Vzc1Rva2VuUHJvdmlkZXIuaW52YWxpZGF0ZVRva2VuKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW5kKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgY29udGludWUgbm9ybWFsbHlcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kKGVyciwgcmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlzRXJyb3JSZXRyaWFibGUoZXJyKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJNc2cgPSBlcnIudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHJldHVybiBjb25zdGFudHNfMS5SRVRSSUFCTEVfRVJST1JTLnNvbWUoKHBocmFzZSkgPT4gZXJyTXNnLmluY2x1ZGVzKHBocmFzZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlzVW5hdXRob3JpemVkRXJyb3IoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuVU5BVVRIT1JJWkVEX0VSUk9SUy5zb21lKChwaHJhc2UpID0+IGVyci5tZXNzYWdlLmluY2x1ZGVzKHBocmFzZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV4cG9ydHMuQXV0aGVudGljYXRlZEZldGNoU3VicHJvdmlkZXIgPSBBdXRoZW50aWNhdGVkRmV0Y2hTdWJwcm92aWRlcjtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0aGVudGljYXRlZC1mZXRjaC5qcy5tYXAiLCIoZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdmFyIHYgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMpO1xuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSBtb2R1bGUuZXhwb3J0cyA9IHY7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkBiaXRza2kvcHJvdmlkZXItZW5naW5lXCJdLCBmYWN0b3J5KTtcbiAgICB9XG59KShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgICBjb25zdCBwcm92aWRlcl9lbmdpbmVfMSA9IHJlcXVpcmUoXCJAYml0c2tpL3Byb3ZpZGVyLWVuZ2luZVwiKTtcbiAgICAvKipcbiAgICAgKiBBIHN1YnByb3ZpZGVyIHRoYXQgdHJhY2tzIGFuZCBhdXRvbWF0aWNhbGx5IGluY3JlbWVudHMgdGhlIG5vbmNlIG9uIHRoZSBjbGllbnQuXG4gICAgICogSGVhdmlseSBiYXNlZCBvbiB0aGUgcHJvdmlkZXItZW5naW5lIE5vbmNlVHJhY2tlclN1YnByb3ZpZGVyLCBidXQgbW9kaWZpZWQgZm9yXG4gICAgICogQml0c2tpJ3MgdHJhbnNhY3Rpb24gZmxvdy5cbiAgICAgKi9cbiAgICBjbGFzcyBOb25jZVRyYWNrZXJTdWJwcm92aWRlciBleHRlbmRzIHByb3ZpZGVyX2VuZ2luZV8xLlN1YnByb3ZpZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgdGhpcy5ub25jZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZVJlcXVlc3QocGF5bG9hZCwgbmV4dCwgZW5kKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHBheWxvYWQubWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZXRoX2dldFRyYW5zYWN0aW9uQ291bnQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVRyYW5zYWN0aW9uQ291bnRSZXF1ZXN0KHBheWxvYWQsIG5leHQsIGVuZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlICdldGhfc2VuZFRyYW5zYWN0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVTZW5kVHJhbnNhY3Rpb25SZXF1ZXN0KHBheWxvYWQsIG5leHQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIGNhY2hlZCByZXN1bHQgaWYgcHJlc2VudFxuICAgICAgICBoYW5kbGVUcmFuc2FjdGlvbkNvdW50UmVxdWVzdChwYXlsb2FkLCBuZXh0LCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrVGFnID0gcGF5bG9hZC5wYXJhbXMubGVuZ3RoID4gMSA/IHBheWxvYWQucGFyYW1zWzFdIDogbnVsbDtcbiAgICAgICAgICAgIC8vIE9ubHkgaGFuZGxlIHBlbmRpbmcgdGFnXG4gICAgICAgICAgICBpZiAoYmxvY2tUYWcgIT09ICdwZW5kaW5nJykge1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gcGF5bG9hZC5wYXJhbXNbMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZFJlc3VsdCA9IHRoaXMubm9uY2VDYWNoZS5nZXQoYWRkcmVzcyk7XG4gICAgICAgICAgICAvLyBSZXR1cm4gY2FjaGVkIHJlc3VsdCBpdCB3ZSBoYXZlIGl0XG4gICAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgZW5kKG51bGwsIGNhY2hlZFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmFsbHRocm91Z2ggYW5kIHBvcHVsYXRlIGNhY2hlXG4gICAgICAgICAgICBuZXh0KChlcnIsIHJlc3VsdCwgY2IpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vbmNlQ2FjaGUuc2V0KGFkZHJlc3MsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0b0hleChudW0pIHtcbiAgICAgICAgICAgIGNvbnN0IGJhc2UxNiA9IG51bS50b1N0cmluZygxNik7XG4gICAgICAgICAgICBsZXQgaGV4ID0gYmFzZTE2O1xuICAgICAgICAgICAgaWYgKGJhc2UxNi5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgaGV4ID0gJzAnICsgYmFzZTE2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICcweCcgKyBoZXg7XG4gICAgICAgIH1cbiAgICAgICAgZnJvbUhleChzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChzdHIsIDE2KTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0Tm9uY2Uobm9uY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1Ym1pdHRlZE5vbmNlID0gdGhpcy5mcm9tSGV4KG5vbmNlKTtcbiAgICAgICAgICAgIGNvbnN0IG5leHROb25jZSA9IHN1Ym1pdHRlZE5vbmNlICsgMTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvSGV4KG5leHROb25jZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW5jcmVtZW50IG5leHQgbm9uY2UgZm9yIGFkZHJlc3NcbiAgICAgICAgaGFuZGxlU2VuZFRyYW5zYWN0aW9uUmVxdWVzdChwYXlsb2FkLCBuZXh0KSB7XG4gICAgICAgICAgICAvLyBTdWJtaXQgdGhlIHJlcXVlc3QsIHRoZW4gbW9uaXRvciB0aGUgcmVzdWx0XG4gICAgICAgICAgICBuZXh0KChlcnIsIHJlc3VsdCwgY2IpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHBheWxvYWQucGFyYW1zLmxlbmd0aCA+IDAgPyBwYXlsb2FkLnBhcmFtc1swXSA6IHt9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1Ym1pdHRlZE5vbmNlID0gdHJhbnNhY3Rpb24ubm9uY2U7XG4gICAgICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHRyYW5zYWN0aW9uLmZyb207XG4gICAgICAgICAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1Ym1pdHRlZE5vbmNlICYmIGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluY3JlbWVudCBub25jZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dE5vbmNlID0gdGhpcy5uZXh0Tm9uY2Uoc3VibWl0dGVkTm9uY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub25jZUNhY2hlLnNldChhZGRyZXNzLCBuZXh0Tm9uY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgY2FjaGVkIHZhbHVlIGlmIHdlIGVuY291bnRlciBhbiBlcnJvclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vbmNlQ2FjaGUuZGVsZXRlKGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXhwb3J0cy5Ob25jZVRyYWNrZXJTdWJwcm92aWRlciA9IE5vbmNlVHJhY2tlclN1YnByb3ZpZGVyO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub25jZS10cmFja2VyLmpzLm1hcCIsIihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB2YXIgdiA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cyk7XG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiQGJpdHNraS9wcm92aWRlci1lbmdpbmVcIl0sIGZhY3RvcnkpO1xuICAgIH1cbn0pKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICAgIGNvbnN0IHByb3ZpZGVyX2VuZ2luZV8xID0gcmVxdWlyZShcIkBiaXRza2kvcHJvdmlkZXItZW5naW5lXCIpO1xuICAgIC8qKlxuICAgICAqIEEgc3VicHJvdmlkZXIgdGhhdCBhdXRvbWF0aWNhbGx5IHBvcHVsYXRlcyBtaXNzaW5nIHRyYW5zYWN0aW9uIGRldGFpbHMuXG4gICAgICogVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSBpdCBoYXMgYmVjb21lIGNvbW1vbiB0byBzdWJtaXQgdHJhbnNhY3Rpb25zIHdpdGhcbiAgICAgKiBvbmx5IHNvbWUgb2YgdGhlIHBhcmFtZXRlcnMgYW5kIHJlbHkgb24gdGhlIHByb3ZpZGVyIG9yIG5vZGUgdG8gZmlsbCBpbiB0aGUgcmVzdC5cbiAgICAgKi9cbiAgICBjbGFzcyBUcmFuc2FjdGlvblZhbGlkYXRvclN1YnByb3ZpZGVyIGV4dGVuZHMgcHJvdmlkZXJfZW5naW5lXzEuU3VicHJvdmlkZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihtaW5HYXNQcmljZSA9IDApIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICB0aGlzLm1pbkdhc1ByaWNlID0gbWluR2FzUHJpY2U7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlUmVxdWVzdChwYXlsb2FkLCBuZXh0LCBfKSB7XG4gICAgICAgICAgICAvLyBPbmx5IGhhbmRsZSB0cmFuc2FjdGlvbnNcbiAgICAgICAgICAgIGlmIChwYXlsb2FkLm1ldGhvZCA9PT0gJ2V0aF9zZW5kVHJhbnNhY3Rpb24nIHx8IHBheWxvYWQubWV0aG9kID09PSAnZXRoX3NpZ25UcmFuc2FjdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb25GaWVsZHMocGF5bG9hZCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBheWxvYWQgd2FzIG1vZGlmaWVkLiBDb250aW51ZS5cbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIH0pLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmFsbCB0aHJvdWdoIGlmIHdlIGNhbm5vdCBwb3B1bGF0ZSBmaWVsZHNcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEV4YW1pbmUgdHJhbnNhY3Rpb24gYW5kIHBvcHVsYXRlIG1pc3NpbmcgcGFyYW1zXG4gICAgICAgIGFzeW5jIHBvcHVsYXRlVHJhbnNhY3Rpb25GaWVsZHMocGF5bG9hZCkge1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gcGF5bG9hZC5wYXJhbXMgfHwgW107XG4gICAgICAgICAgICBsZXQgdHJhbnNhY3Rpb24gPSB7fTtcbiAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uID0gcGFyYW1zWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZnJvbSB3aXRoIGRlZmF1bHQgYWNjb3VudFxuICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmZyb20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50cygpO1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmZyb20gPSBhY2NvdW50c1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZ2FzUHJpY2VcbiAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi5nYXNQcmljZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLmVzdGltYXRlR2FzUHJpY2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRyYW5zYWN0aW9uLmdhc1ByaWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3Npbmcgbm9uY2VcbiAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi5ub25jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLmdldE5vbmNlKHRyYW5zYWN0aW9uLmZyb20pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2godHJhbnNhY3Rpb24ubm9uY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUG9wdWxhdGUgbWlzc2luZyBnYXNcbiAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi5nYXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5lc3RpbWF0ZUdhcyh0cmFuc2FjdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0cmFuc2FjdGlvbi5nYXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRXhlY3V0ZSBwcm9taXNlc1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHBhcmFtZXRlcnMgd2l0aCBsb2FkZWQgdmFsdWVzLiBNdXN0IGJlIHZlcnkgY2FyZWZ1bCB3aXRoIHRoZSBpbmRleGVzIGhlcmUuXG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5nYXNQcmljZSA9IHZhbHVlc1swXTtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLm5vbmNlID0gdmFsdWVzWzFdO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24uZ2FzID0gdmFsdWVzWzJdO1xuICAgICAgICAgICAgLy8gU2V0IHRoZSBwYXJhbXMgb24gdGhlIHBheWxvYWRcbiAgICAgICAgICAgIHBheWxvYWQucGFyYW1zWzBdID0gdHJhbnNhY3Rpb247XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBnZXROb25jZShhZGRyZXNzKSB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgIGlkOiAwLFxuICAgICAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ2V0aF9nZXRUcmFuc2FjdGlvbkNvdW50JyxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IFthZGRyZXNzLCAnbGF0ZXN0J10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGVyZm9ybVJlcXVlc3QocmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZ2V0QWNjb3VudHMoKSB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgIGlkOiAwLFxuICAgICAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ2V0aF9hY2NvdW50cycsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wZXJmb3JtUmVxdWVzdChyZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBlc3RpbWF0ZUdhcyh0cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICBpZDogMCxcbiAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdldGhfZXN0aW1hdGVHYXMnLFxuICAgICAgICAgICAgICAgIHBhcmFtczogW3RyYW5zYWN0aW9uXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wZXJmb3JtUmVxdWVzdChyZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBlc3RpbWF0ZUdhc1ByaWNlKCkge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICBpZDogMCxcbiAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdldGhfZ2FzUHJpY2UnLFxuICAgICAgICAgICAgICAgIHBhcmFtczogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGVyZm9ybVJlcXVlc3QocmVxdWVzdCkudGhlbigoZ2FzUHJpY2UpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZ2FzUHJpY2UgPT09ICcweDAnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgMHgke3RoaXMubWluR2FzUHJpY2UudG9TdHJpbmcoMTYpfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBnYXNQcmljZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdyYXBzIGVtaXRQYXlsb2FkIGluIGEgcHJvbWlzZVxuICAgICAgICBwZXJmb3JtUmVxdWVzdChwYXlsb2FkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKGZ1bGZpbGwsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdFBheWxvYWQocGF5bG9hZCwgKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChyZXN1bHQucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXhwb3J0cy5UcmFuc2FjdGlvblZhbGlkYXRvclN1YnByb3ZpZGVyID0gVHJhbnNhY3Rpb25WYWxpZGF0b3JTdWJwcm92aWRlcjtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNhY3Rpb24tdmFsaWRhdG9yLmpzLm1hcCIsIihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB2YXIgdiA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cyk7XG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiQGJpdHNraS9wcm92aWRlci1lbmdpbmVcIiwgXCIuLi9lcnJvcnMvcHJvdmlkZXItZXJyb3JcIiwgXCIuLi91dGlscy9wYXJzZS11dGlsc1wiXSwgZmFjdG9yeSk7XG4gICAgfVxufSkoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4gICAgY29uc3QgcHJvdmlkZXJfZW5naW5lXzEgPSByZXF1aXJlKFwiQGJpdHNraS9wcm92aWRlci1lbmdpbmVcIik7XG4gICAgY29uc3QgcHJvdmlkZXJfZXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnMvcHJvdmlkZXItZXJyb3JcIik7XG4gICAgY29uc3QgcGFyc2VfdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9wYXJzZS11dGlsc1wiKTtcbiAgICBjbGFzcyBUeXBlZERhdGFTYW5pdGl6ZXJTdWJwcm92aWRlciBleHRlbmRzIHByb3ZpZGVyX2VuZ2luZV8xLlN1YnByb3ZpZGVyIHtcbiAgICAgICAgaGFuZGxlUmVxdWVzdChwYXlsb2FkLCBuZXh0LCBlbmQpIHtcbiAgICAgICAgICAgIGlmIChwYXlsb2FkLm1ldGhvZCA9PT0gJ2V0aF9zaWduVHlwZWREYXRhJyB8fCBwYXlsb2FkLm1ldGhvZCA9PT0gJ2V0aF9zaWduVHlwZWREYXRhX3YzJykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2FuaXRpemVQYXlsb2FkKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbmQoZXJyLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBzYW5pdGl6ZVBheWxvYWQocGF5bG9hZCkge1xuICAgICAgICAgICAgY29uc3QgdHlwZWREYXRhID0gdGhpcy5leHRyYWN0VHlwZWREYXRhKHBheWxvYWQpO1xuICAgICAgICAgICAgLy8gY3JlYXRlIG1hcCBvZiB0eXBlc1xuICAgICAgICAgICAgY29uc3QgdHlwZU1hcHBpbmcgPSBjcmVhdGVUeXBlTWFwcGluZyh0eXBlZERhdGEpO1xuICAgICAgICAgICAgLy8gc2FuaXRpemUgZG9tYWluXG4gICAgICAgICAgICBzYW5pdGl6ZURvbWFpbih0eXBlZERhdGEsIHR5cGVNYXBwaW5nKTtcbiAgICAgICAgICAgIC8vIHNhbml0aXplIG1lc3NhZ2VcbiAgICAgICAgICAgIHNhbml0aXplTWVzc2FnZSh0eXBlZERhdGEsIHR5cGVNYXBwaW5nKTtcbiAgICAgICAgICAgIC8vIFJlLWFzc2lnbiB0eXBlZCBkYXRhIHRvIHBhcmFtcyBpbiBjYXNlIGl0IGhhcyBiZWVuIHBhcnNlZFxuICAgICAgICAgICAgLy8gZnJvbSBhIHN0cmluZy5cbiAgICAgICAgICAgIHBheWxvYWQucGFyYW1zWzFdID0gdHlwZWREYXRhO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdpdmVuIGEgSlNPTi1SUEMgcmVxdWVzdCwgZXh0cmFjdCB0aGUgdHlwZWQgZGF0YSBmcm9tIHRoZSBwYXJhbXNcbiAgICAgICAgZXh0cmFjdFR5cGVkRGF0YShwYXlsb2FkKSB7XG4gICAgICAgICAgICBpZiAoIXBheWxvYWQucGFyYW1zIHx8IHBheWxvYWQucGFyYW1zLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBwcm92aWRlcl9lcnJvcl8xLlByb3ZpZGVyRXJyb3IuSW52YWxpZFJlcXVlc3QoJ01pc3NpbmcgcGFyYW1zIGZvciB0eXBlZCBkYXRhJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTb21lIGltcGxlbWVudGF0aW9ucyBwYXNzIHR5cGVkIGRhdGEgYXMgYSBzdHJpbmdcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGF5bG9hZC5wYXJhbXNbMV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UocGF5bG9hZC5wYXJhbXNbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQucGFyYW1zWzFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV4cG9ydHMuVHlwZWREYXRhU2FuaXRpemVyU3VicHJvdmlkZXIgPSBUeXBlZERhdGFTYW5pdGl6ZXJTdWJwcm92aWRlcjtcbiAgICAvKipcbiAgICAgKiBTYW5pdGl6ZXMgdGhlIGBkb21haW5gIHZhbHVlcyBmcm9tIHRoZSBUeXBlZERhdGFcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eXBlZERhdGEgVHlwZWREYXRhIHBheWxvYWRcbiAgICAgKiBAcGFyYW0gdHlwZU1hcHBpbmcgYSBUeXBlTWFwcGluZyBwcmUtZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVkRGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhbml0aXplRG9tYWluKHR5cGVkRGF0YSwgdHlwZU1hcHBpbmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlZERhdGEuZG9tYWluID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgcHJvdmlkZXJfZXJyb3JfMS5Qcm92aWRlckVycm9yLkludmFsaWRSZXF1ZXN0KCdNaXNzaW5nIGRvbWFpbiBmb3IgdHlwZWQgZGF0YScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZWREYXRhLnR5cGVzLkVJUDcxMkRvbWFpbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IHByb3ZpZGVyX2Vycm9yXzEuUHJvdmlkZXJFcnJvci5JbnZhbGlkUmVxdWVzdCgnTWlzc2luZyB0eXBlIGRlZmluaXRpb24gZm9yIGRvbWFpbicpO1xuICAgICAgICB9XG4gICAgICAgIHNhbml0aXplVHlwZSgnRUlQNzEyRG9tYWluJywgdHlwZWREYXRhLmRvbWFpbiwgdHlwZU1hcHBpbmcpO1xuICAgIH1cbiAgICBleHBvcnRzLnNhbml0aXplRG9tYWluID0gc2FuaXRpemVEb21haW47XG4gICAgLyoqXG4gICAgICogU2FuaXRpemVzIHRoZSBgbWVzc2FnZWAgdmFsdWVzIGZyb20gdGhlIFR5cGVkRGF0YVxuICAgICAqXG4gICAgICogQHBhcmFtIHR5cGVkRGF0YSBUeXBlZERhdGEgcGF5bG9hZFxuICAgICAqIEBwYXJhbSB0eXBlTWFwcGluZyBhIFR5cGVNYXBwaW5nIHByZS1nZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZWREYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FuaXRpemVNZXNzYWdlKHR5cGVkRGF0YSwgdHlwZU1hcHBpbmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlZERhdGEubWVzc2FnZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IHByb3ZpZGVyX2Vycm9yXzEuUHJvdmlkZXJFcnJvci5JbnZhbGlkUmVxdWVzdCgnTWlzc2luZyBtZXNzYWdlIGluIHR5cGVkIGRhdGEnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHR5cGVkRGF0YS5wcmltYXJ5VHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IHByb3ZpZGVyX2Vycm9yXzEuUHJvdmlkZXJFcnJvci5JbnZhbGlkUmVxdWVzdCgnTWlzc2luZyBwcmltYXJ5IHR5cGUgaW4gdHlwZWQgZGF0YScpO1xuICAgICAgICB9XG4gICAgICAgIHNhbml0aXplVHlwZSh0eXBlZERhdGEucHJpbWFyeVR5cGUsIHR5cGVkRGF0YS5tZXNzYWdlLCB0eXBlTWFwcGluZyk7XG4gICAgfVxuICAgIGV4cG9ydHMuc2FuaXRpemVNZXNzYWdlID0gc2FuaXRpemVNZXNzYWdlO1xuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGV4YW1pbmVzIGVhY2ggdmFsdWUgYW5kIGRldGVybWluZXMgdHlwZSBmcm9tIHRoZSB0eXBlIG1hcHBpbmcgdG9cbiAgICAgKiBmb3JtYXQgYW5kIHNhbml0aXplIHRoZSB2YWx1ZSBpZiBuZWVkZWQuXG4gICAgICpcbiAgICAgKiBDdXJyZW50bHkgdGhpcyB3aWxsIG9ubHkgY29udmVydCBudW1iZXIgdmFsdWVzIGludG8gYSBjb25zaXN0ZW50IGhleCBmb3JtYXQsXG4gICAgICogYnV0IGluIHRoZSBmdXR1cmUgYWRkaXRpb25hbCB0cmFuc2Zvcm1hdGlvbnMgbWF5IGJlIG5lY2Vzc2FyeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eXBlTmFtZSBOYW1lIG9mIHRoZSB0eXBlIHdlIGFyZSBzdGFydGluZyBmcm9tXG4gICAgICogQHBhcmFtIHZhbHVlcyBUaGUgcm9vdCBvYmplY3QgY29udGFpbmluZyB0aGUga2V5cyBhbmQgdmFsdWVzXG4gICAgICogQHBhcmFtIHR5cGVNYXBwaW5nIFRoZSB0eXBlIG1hcHBpbmcgdGhhdCByZXByZXNlbnRzIHRoaXMgZGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhbml0aXplVHlwZSh0eXBlTmFtZSwgdmFsdWVzLCB0eXBlTWFwcGluZykge1xuICAgICAgICAvLyBGb3IgZWFjaCBrZXkgaW4gdGhlICd2YWx1ZXMnIG9iamVjdC4uLlxuICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgdHlwZSBuYW1lIGFzc29jaWF0ZWQgZnJvbSB0aGUgbWFwcGluZ1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVNYXBwaW5nW3R5cGVOYW1lXVtrZXldO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgd2UgZG9uJ3QgaGF2ZSBhIHR5cGUgZm9yIHRoaXMga2V5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0FycmF5KHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gZmluZCB0aGUgYmFzZSB0eXBlIChsZWZ0IHNpZGUgb2YgdGhlIGJyYWNrZXRzKVxuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VUeXBlID0gdHlwZS5zcGxpdCgnWycpWzBdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWVzW2tleV0ubGVuZ3RoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDb3VsZCBub3QgcGFyc2UgJHt2YWx1ZXNba2V5XX0gZm9yIHR5cGUgJHt0eXBlfS4gRXhwZWN0ZWQgYXJyYXkuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIGJhc2UgdHlwZSBpcyBhIHN0cnVjdCwgaXRlcmF0ZSB0aHJvdWdoIGVhY2ggaW5zdGFuY2Ugb2Ygc3RydWN0XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVNYXBwaW5nW2Jhc2VUeXBlXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZXNba2V5XSBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheSwgd2hlcmUgZWFjaCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIGFuIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHN0cnVjdCBuYW1lZCBiYXNlVHlwZS5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzW2tleV0uZm9yRWFjaCgoaXRlbVZhbHVlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2FuaXRpemVUeXBlKGJhc2VUeXBlLCBpdGVtVmFsdWVzLCB0eXBlTWFwcGluZyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChiYXNlVHlwZS5zdGFydHNXaXRoKCd1aW50JykgfHwgYmFzZVR5cGUuc3RhcnRzV2l0aCgnaW50JykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhbiBhcnJheSBvZiBwcmltaXRpdmUgdHlwZXMgdGhhdCBhcmUgbnVtYmVycywgd2UgbmVlZCB0byBlbmNvZGUgdGhlIG51bWJlcnMgYXMgaGV4XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG51bWJlclZhbHVlcyA9IHZhbHVlc1trZXldLm1hcCgobnVtYmVyVmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZV91dGlsc18xLmVuY29kZU51bWJlcihudW1iZXJWYWx1ZSwgYmFzZVR5cGUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzW2tleV0gPSBudW1iZXJWYWx1ZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3RoaW5nIHdpdGggcmVndWxhciBhcnJheSB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gaW50OFtdLCBldGMgc2hvdWxkIGFscmVhZHkgYmUgc3RyaW5nc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVNYXBwaW5nW3R5cGVdKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdHlwZSBuYW1lIGlzIGEgY3VzdG9tIHN0cnVjdCwgaXQgc2hvdWxkIGxpdmUgaW4gdGhlIHR5cGUgbWFwcGluZ1xuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gcmVjdXJzaXZlbHkgY2hlY2sgdGhlIGN1c3RvbSB0eXBlcyB1bnRpbCB3ZSBnZXQgdG8gcHJpbWl0aXZlIHZhbHVlc1xuICAgICAgICAgICAgICAgIHNhbml0aXplVHlwZSh0eXBlLCB2YWx1ZXNba2V5XSwgdHlwZU1hcHBpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZS5zdGFydHNXaXRoKCd1aW50JykgfHwgdHlwZS5zdGFydHNXaXRoKCdpbnQnKSkge1xuICAgICAgICAgICAgICAgIC8vIEZpbmFsbHksIGlmIHdlIGhhdmUgYSBwcmltaXRpdmUgdHlwZSB0aGF0IGlzIGEgbnVtYmVyLCB3ZSBuZWVkIHRvIGVuY29kZSB0aGUgbnVtYmVycyBhcyBoZXhcbiAgICAgICAgICAgICAgICB2YWx1ZXNba2V5XSA9IHBhcnNlX3V0aWxzXzEuZW5jb2RlTnVtYmVyKHZhbHVlc1trZXldLCB0eXBlLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGV4cG9ydHMuc2FuaXRpemVUeXBlID0gc2FuaXRpemVUeXBlO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0eXBlIG5hbWUgaW5kaWNhdGVzIHRoYXQgYW4gYXJyYXlcbiAgICAgKiBAcGFyYW0gdHlwZU5hbWUgc29saWRpdHkgdHlwZSBuYW1lXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheSh0eXBlTmFtZSkge1xuICAgICAgICBpZiAodHlwZU5hbWUuaW5jbHVkZXMoJ1snKSAmJiB0eXBlTmFtZS5pbmNsdWRlcygnXScpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcHMgdGhlIHR5cGUgZGVmaW5pdGlvbnMgZnJvbSB0aGUgdHlwZWQgZGF0YSBmb3IgZWFzeSBsb29rLXVwLlxuICAgICAqIFRvcCBsZXZlbCBrZXlzIHJlcHJlc2VudCB0aGUgc3RydWN0cyBkZWZpbmVkLCB3aGlsZSB0b3AtbGV2ZWwgdmFsdWVzXG4gICAgICogYXJlIGFuIG9iamVjdCBrZXllZCBieSBwcm9wZXJ0eSB3aXRoIHN0cmluZyB2YWx1ZXMgb2YgdGhlIHR5cGUgbmFtZS5cbiAgICAgKlxuICAgICAqIEZvciBleGFtcGxlOlxuICAgICAqIHtcbiAgICAgKiAgICBFSVA3MTJEb21haW46IHtcbiAgICAgKiAgICAgIG5hbWU6ICdzdHJpbmcnLFxuICAgICAqICAgICAgdmVyc2lvbjogJ3N0cmluZycsXG4gICAgICogICAgICBjaGFpbklkOiAndWludDI1NidcbiAgICAgKiAgICB9XG4gICAgICogfVxuICAgICAqIEBwYXJhbSB0eXBlZERhdGEgVGhlIFR5cGVkRGF0YSB0byBtYXBcbiAgICAgKiBAcmV0dXJucyB7VHlwZU1hcHBpbmd9IHRoZSBtYXBwZWQgZGF0YSBzY2hlbWFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVUeXBlTWFwcGluZyh0eXBlZERhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlZERhdGEudHlwZXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBwcm92aWRlcl9lcnJvcl8xLlByb3ZpZGVyRXJyb3IuSW52YWxpZFJlcXVlc3QoJ01pc3NpbmcgdHlwZSBkZWZpbml0aW9ucyBmb3IgdHlwZWQgZGF0YScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdvIHRocm91Z2ggZWFjaCBvZiB0aGUgdG9wIGxldmVsIGtleXMuIFRoZXNlIHJlcHJlc2VudCB0aGUgY3VzdG9tIHR5cGVzLlxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModHlwZWREYXRhLnR5cGVzKS5yZWR1Y2UoKGFjYywgY3VycmVudCkgPT4ge1xuICAgICAgICAgICAgLy8gUmVkdWNlIGludG8gYSBuZXcgc2luZ2xlIG9iamVjdFxuICAgICAgICAgICAgLy8gU2V0IGEga2V5IGZvciBlYWNoIHR5cGUsIHJlZHVjZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgdHlwZXMgdG8gYW4gb2JqZWN0XG4gICAgICAgICAgICBhY2NbY3VycmVudF0gPSB0eXBlZERhdGEudHlwZXNbY3VycmVudF0ucmVkdWNlKChhY2MyLCB0eXBlRGVmKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIGVhY2ggdHlwZSwgc2V0IHRoZSBrZXkgYXMgdGhlIHByb3BlcnR5IG5hbWUsIGFuZCB0aGUgdmFsdWUgYXMgdGhlIHR5cGUgbmFtZVxuICAgICAgICAgICAgICAgIGFjYzJbdHlwZURlZi5uYW1lXSA9IHR5cGVEZWYudHlwZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjMjtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9XG4gICAgZXhwb3J0cy5jcmVhdGVUeXBlTWFwcGluZyA9IGNyZWF0ZVR5cGVNYXBwaW5nO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlZC1kYXRhLmpzLm1hcCIsInZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB2YXIgdiA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cyk7XG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiYm4uanNcIl0sIGZhY3RvcnkpO1xuICAgIH1cbn0pKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICAgIGNvbnN0IGJuX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJuLmpzXCIpKTtcbiAgICAvKipcbiAgICAgKiBwYXJzZU51bWJlclxuICAgICAqIENvbnZlcnRzIGEgdmFsdWUgdGhhdCByZXByZXNlbnRzIGEgbnVtYmVyIGludG8gYSBoZXggdmFsdWUuXG4gICAgICogQHBhcmFtIGFyZyB7c3RyaW5nIHwgbnVtYmVyIHwgQk59IEEgbnVtYmVyIHZhbHVlIHRvIGNvbnZlcnQgdG8gaGV4LlxuICAgICAqIENhbiBiZSBhIHJlZ3VsYXIgbnVtYmVyLCBiYXNlLTEwIHN0cmluZywgYmFzZS0xNiBzdHJpbmcsIG9yIEJOIGluc3RhbmNlLlxuICAgICAqIEByZXR1cm5zIHtCTn0gQk4gaW5zdGFuY2UgcmVwcmVzZW50aW5nIHRoZSBudW1iZXJcbiAgICAgKlxuICAgICAqIChBZGFwdGVkIGZyb20gZXRoZXJldW1qcy1hYmkpXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2VOdW1iZXIoYXJnKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgYXJnO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmIChhcmcuc3Vic3RyKDAsIDIpID09PSAnMHgnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBibl9qc18xLmRlZmF1bHQoYXJnLnN1YnN0cigyKSwgMTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBibl9qc18xLmRlZmF1bHQoYXJnLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgYm5fanNfMS5kZWZhdWx0KGFyZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJnLnRvQXJyYXkpIHtcbiAgICAgICAgICAgIC8vIGFzc3VtZSB0aGlzIGlzIGEgQk4gZm9yIHRoZSBtb21lbnQsIHJlcGxhY2Ugd2l0aCBCTi5pc0JOIHNvb25cbiAgICAgICAgICAgIHJldHVybiBhcmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyZ3VtZW50IGlzIG5vdCBhIG51bWJlcicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlQml0V2lkdGgodHlwZSwgb2Zmc2V0KSB7XG4gICAgICAgIC8vIGRlZmF1bHQgdG8gMjU2IGJpdCBpZiBub3Qgc3BlY2lmaWVkXG4gICAgICAgIGxldCBzaXplID0gMjU2O1xuICAgICAgICAvLyBJZiB0eXBlIHN0cmluZyBpcyBsb25nZXIgdGhhbiBvZmZzZXQsIHBhcnNlIGJpdHMgZnJvbSB0aGUgdHlwZSBzdHJpbmdcbiAgICAgICAgaWYgKHR5cGUubGVuZ3RoID4gb2Zmc2V0KSB7XG4gICAgICAgICAgICBzaXplID0gcGFyc2VJbnQodHlwZS5zdWJzdHIob2Zmc2V0KSwgMTApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJpdCB3aWR0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgOCwgYW5kIGluIHRoZSByYW5nZSA4LTI1Ni5cbiAgICAgICAgaWYgKHNpemUgJSA4IHx8IHNpemUgPCA4IHx8IHNpemUgPiAyNTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBiaXQgd2lkdGggJHt0eXBlfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBlbmNvZGVOdW1iZXJcbiAgICAgKiBUYWtlcyBhIGRlY2ltYWwgc3RyaW5nLCBoZXggc3RyaW5nLCByZWd1bGFyIG51bWJlciwgb3IgQk4gaW5zdGFuY2UgYW5kIHJldHVybnMgYSBoZXggc3RyaW5nIGluIHRoZSBzcGVjaWZpZWQgZm9ybWF0LlxuICAgICAqIFR5cGljYWxseSB0aGVzZSBjb252ZXJzaW9ucyBhcmUgZG9uZSBpbiB3ZWIzLCBidXQgdW50aWwgd2ViMyBhZGRzIGRpcmVjdCBzdXBwb3J0LCB0aGlzIGlzIG5lY2Vzc2FyeSBmb3Igbm9ybWFsaXppbmdcbiAgICAgKiBudW1iZXJzIGV0aF9zaWduVHlwZWREYXRhIHBheWxvYWRzLlxuICAgICAqIEBwYXJhbSBudW0gVGhlIHZhbHVlIHRvIGNvbnZlcnRcbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgc29saWRpdHkgQUJJIHR5cGUgdG8gZm9ybWF0IHRoZSBkYXRhIGFzIChlZy4gdWludDI1NiwgaW50OCwgZXRjKS4gT25seSBzdXBwb3J0cyBpbnQgYW5kIHVpbnQgdmFyaWFudHMuXG4gICAgICogQHBhcmFtIGNvbXBhY3QgYm9vbGVhbiAoZGVmYXVsdCBmYWxzZSkuIFdoZXRoZXIgdG8gdXNlIGNvbXBhY3QgZW5jb2RpbmcgZm9yIHVpbnRzLCBvciBwYWQgd2l0aCB6ZXJvZXMuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gQSBoZXggc3RyaW5nIGZvcm1hdHRlZCBhcyB0aGUgc3BlY2lmaWVkIHR5cGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW5jb2RlTnVtYmVyKG51bSwgdHlwZSwgY29tcGFjdCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ3VpbnQnKSkge1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHBhcnNlQml0V2lkdGgodHlwZSwgNCk7IC8vIHN0YXJ0IGFmdGVyICd1aW50J1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gc2l6ZSAvIDQ7IC8vIGxlbmd0aCBpbiBjaGFyYWN0ZXJzIGZvciB0aGUgc3RyaW5nLiBoZXggaXMgMSBjaGFyYWN0ZXIgZm9yIDQgYml0cy5cbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlTnVtYmVyKG51bSk7XG4gICAgICAgICAgICAvLyB1aW50IGNhbiBuZXZlciBiZSBuZWdhdGl2ZVxuICAgICAgICAgICAgaWYgKHBhcnNlZC5pc05lZygpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBwbGllZCB1aW50IGlzIG5lZ2F0aXZlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRvIGhleCwgYW5kIHByZXBlbmQgMHhcbiAgICAgICAgICAgIGlmIChjb21wYWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcweCcgKyBwYXJzZWQudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICcweCcgKyBwYXJzZWQudG9TdHJpbmcoMTYsIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZS5zdGFydHNXaXRoKCdpbnQnKSkge1xuICAgICAgICAgICAgLy8gYml0IHdpZHRoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA4LCBhbmQgaW4gdGhlIHJhbmdlIDgtMjU2LlxuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHBhcnNlQml0V2lkdGgodHlwZSwgMyk7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBzaXplIC8gNDsgLy8gbGVuZ3RoIGluIGNoYXJhY3RlcnMgZm9yIHRoZSBzdHJpbmcuIGhleCBpcyAxIGNoYXJhY3RlciBmb3IgNCBiaXRzLlxuICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VOdW1iZXIobnVtKTtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gdHdvcyBjb21wbGVtZW50IGF0IHRoZSBiaXQgc2l6ZSBmcm9tIHRoZSB0eXBlLCB0aGVuIGNvbnZlcnQgdmFsdWUgdG8gaGV4XG4gICAgICAgICAgICByZXR1cm4gJzB4JyArIHBhcnNlZC50b1R3b3Moc2l6ZSkudG9TdHJpbmcoMTYsIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHlwZSBwYXNzZWQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBleHBvcnRzLmVuY29kZU51bWJlciA9IGVuY29kZU51bWJlcjtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2UtdXRpbHMuanMubWFwIiwiKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIFV0aWxzXG4gIGZ1bmN0aW9uIGFzc2VydCAodmFsLCBtc2cpIHtcbiAgICBpZiAoIXZhbCkgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xuICB9XG5cbiAgLy8gQ291bGQgdXNlIGBpbmhlcml0c2AgbW9kdWxlLCBidXQgZG9uJ3Qgd2FudCB0byBtb3ZlIGZyb20gc2luZ2xlIGZpbGVcbiAgLy8gYXJjaGl0ZWN0dXJlIHlldC5cbiAgZnVuY3Rpb24gaW5oZXJpdHMgKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGU7XG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKTtcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3I7XG4gIH1cblxuICAvLyBCTlxuXG4gIGZ1bmN0aW9uIEJOIChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIGlmIChCTi5pc0JOKG51bWJlcikpIHtcbiAgICAgIHJldHVybiBudW1iZXI7XG4gICAgfVxuXG4gICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgdGhpcy53b3JkcyA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuXG4gICAgLy8gUmVkdWN0aW9uIGNvbnRleHRcbiAgICB0aGlzLnJlZCA9IG51bGw7XG5cbiAgICBpZiAobnVtYmVyICE9PSBudWxsKSB7XG4gICAgICBpZiAoYmFzZSA9PT0gJ2xlJyB8fCBiYXNlID09PSAnYmUnKSB7XG4gICAgICAgIGVuZGlhbiA9IGJhc2U7XG4gICAgICAgIGJhc2UgPSAxMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faW5pdChudW1iZXIgfHwgMCwgYmFzZSB8fCAxMCwgZW5kaWFuIHx8ICdiZScpO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEJOO1xuICB9IGVsc2Uge1xuICAgIGV4cG9ydHMuQk4gPSBCTjtcbiAgfVxuXG4gIEJOLkJOID0gQk47XG4gIEJOLndvcmRTaXplID0gMjY7XG5cbiAgdmFyIEJ1ZmZlcjtcbiAgdHJ5IHtcbiAgICBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxuXG4gIEJOLmlzQk4gPSBmdW5jdGlvbiBpc0JOIChudW0pIHtcbiAgICBpZiAobnVtIGluc3RhbmNlb2YgQk4pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBudW0gIT09IG51bGwgJiYgdHlwZW9mIG51bSA9PT0gJ29iamVjdCcgJiZcbiAgICAgIG51bS5jb25zdHJ1Y3Rvci53b3JkU2l6ZSA9PT0gQk4ud29yZFNpemUgJiYgQXJyYXkuaXNBcnJheShudW0ud29yZHMpO1xuICB9O1xuXG4gIEJOLm1heCA9IGZ1bmN0aW9uIG1heCAobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC5jbXAocmlnaHQpID4gMCkgcmV0dXJuIGxlZnQ7XG4gICAgcmV0dXJuIHJpZ2h0O1xuICB9O1xuXG4gIEJOLm1pbiA9IGZ1bmN0aW9uIG1pbiAobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC5jbXAocmlnaHQpIDwgMCkgcmV0dXJuIGxlZnQ7XG4gICAgcmV0dXJuIHJpZ2h0O1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQgKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgaWYgKHR5cGVvZiBudW1iZXIgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5pdE51bWJlcihudW1iZXIsIGJhc2UsIGVuZGlhbik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBudW1iZXIgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5pdEFycmF5KG51bWJlciwgYmFzZSwgZW5kaWFuKTtcbiAgICB9XG5cbiAgICBpZiAoYmFzZSA9PT0gJ2hleCcpIHtcbiAgICAgIGJhc2UgPSAxNjtcbiAgICB9XG4gICAgYXNzZXJ0KGJhc2UgPT09IChiYXNlIHwgMCkgJiYgYmFzZSA+PSAyICYmIGJhc2UgPD0gMzYpO1xuXG4gICAgbnVtYmVyID0gbnVtYmVyLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxzKy9nLCAnJyk7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBpZiAobnVtYmVyWzBdID09PSAnLScpIHtcbiAgICAgIHN0YXJ0Kys7XG4gICAgfVxuXG4gICAgaWYgKGJhc2UgPT09IDE2KSB7XG4gICAgICB0aGlzLl9wYXJzZUhleChudW1iZXIsIHN0YXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcGFyc2VCYXNlKG51bWJlciwgYmFzZSwgc3RhcnQpO1xuICAgIH1cblxuICAgIGlmIChudW1iZXJbMF0gPT09ICctJykge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgfVxuXG4gICAgdGhpcy5zdHJpcCgpO1xuXG4gICAgaWYgKGVuZGlhbiAhPT0gJ2xlJykgcmV0dXJuO1xuXG4gICAgdGhpcy5faW5pdEFycmF5KHRoaXMudG9BcnJheSgpLCBiYXNlLCBlbmRpYW4pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faW5pdE51bWJlciA9IGZ1bmN0aW9uIF9pbml0TnVtYmVyIChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIG51bWJlciA9IC1udW1iZXI7XG4gICAgfVxuICAgIGlmIChudW1iZXIgPCAweDQwMDAwMDApIHtcbiAgICAgIHRoaXMud29yZHMgPSBbIG51bWJlciAmIDB4M2ZmZmZmZiBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH0gZWxzZSBpZiAobnVtYmVyIDwgMHgxMDAwMDAwMDAwMDAwMCkge1xuICAgICAgdGhpcy53b3JkcyA9IFtcbiAgICAgICAgbnVtYmVyICYgMHgzZmZmZmZmLFxuICAgICAgICAobnVtYmVyIC8gMHg0MDAwMDAwKSAmIDB4M2ZmZmZmZlxuICAgICAgXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KG51bWJlciA8IDB4MjAwMDAwMDAwMDAwMDApOyAvLyAyIF4gNTMgKHVuc2FmZSlcbiAgICAgIHRoaXMud29yZHMgPSBbXG4gICAgICAgIG51bWJlciAmIDB4M2ZmZmZmZixcbiAgICAgICAgKG51bWJlciAvIDB4NDAwMDAwMCkgJiAweDNmZmZmZmYsXG4gICAgICAgIDFcbiAgICAgIF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDM7XG4gICAgfVxuXG4gICAgaWYgKGVuZGlhbiAhPT0gJ2xlJykgcmV0dXJuO1xuXG4gICAgLy8gUmV2ZXJzZSB0aGUgYnl0ZXNcbiAgICB0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksIGJhc2UsIGVuZGlhbik7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pbml0QXJyYXkgPSBmdW5jdGlvbiBfaW5pdEFycmF5IChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIC8vIFBlcmhhcHMgYSBVaW50OEFycmF5XG4gICAgYXNzZXJ0KHR5cGVvZiBudW1iZXIubGVuZ3RoID09PSAnbnVtYmVyJyk7XG4gICAgaWYgKG51bWJlci5sZW5ndGggPD0gMCkge1xuICAgICAgdGhpcy53b3JkcyA9IFsgMCBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLmNlaWwobnVtYmVyLmxlbmd0aCAvIDMpO1xuICAgIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGosIHc7XG4gICAgdmFyIG9mZiA9IDA7XG4gICAgaWYgKGVuZGlhbiA9PT0gJ2JlJykge1xuICAgICAgZm9yIChpID0gbnVtYmVyLmxlbmd0aCAtIDEsIGogPSAwOyBpID49IDA7IGkgLT0gMykge1xuICAgICAgICB3ID0gbnVtYmVyW2ldIHwgKG51bWJlcltpIC0gMV0gPDwgOCkgfCAobnVtYmVyW2kgLSAyXSA8PCAxNik7XG4gICAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgdGhpcy53b3Jkc1tqICsgMV0gPSAodyA+Pj4gKDI2IC0gb2ZmKSkgJiAweDNmZmZmZmY7XG4gICAgICAgIG9mZiArPSAyNDtcbiAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVuZGlhbiA9PT0gJ2xlJykge1xuICAgICAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBudW1iZXIubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgdyA9IG51bWJlcltpXSB8IChudW1iZXJbaSArIDFdIDw8IDgpIHwgKG51bWJlcltpICsgMl0gPDwgMTYpO1xuICAgICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgICAgIHRoaXMud29yZHNbaiArIDFdID0gKHcgPj4+ICgyNiAtIG9mZikpICYgMHgzZmZmZmZmO1xuICAgICAgICBvZmYgKz0gMjQ7XG4gICAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgICBvZmYgLT0gMjY7XG4gICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2VIZXggKHN0ciwgc3RhcnQsIGVuZCkge1xuICAgIHZhciByID0gMDtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgZW5kKTtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKSAtIDQ4O1xuXG4gICAgICByIDw8PSA0O1xuXG4gICAgICAvLyAnYScgLSAnZidcbiAgICAgIGlmIChjID49IDQ5ICYmIGMgPD0gNTQpIHtcbiAgICAgICAgciB8PSBjIC0gNDkgKyAweGE7XG5cbiAgICAgIC8vICdBJyAtICdGJ1xuICAgICAgfSBlbHNlIGlmIChjID49IDE3ICYmIGMgPD0gMjIpIHtcbiAgICAgICAgciB8PSBjIC0gMTcgKyAweGE7XG5cbiAgICAgIC8vICcwJyAtICc5J1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgciB8PSBjICYgMHhmO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5fcGFyc2VIZXggPSBmdW5jdGlvbiBfcGFyc2VIZXggKG51bWJlciwgc3RhcnQpIHtcbiAgICAvLyBDcmVhdGUgcG9zc2libHkgYmlnZ2VyIGFycmF5IHRvIGVuc3VyZSB0aGF0IGl0IGZpdHMgdGhlIG51bWJlclxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5jZWlsKChudW1iZXIubGVuZ3RoIC0gc3RhcnQpIC8gNik7XG4gICAgdGhpcy53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gMDtcbiAgICB9XG5cbiAgICB2YXIgaiwgdztcbiAgICAvLyBTY2FuIDI0LWJpdCBjaHVua3MgYW5kIGFkZCB0aGVtIHRvIHRoZSBudW1iZXJcbiAgICB2YXIgb2ZmID0gMDtcbiAgICBmb3IgKGkgPSBudW1iZXIubGVuZ3RoIC0gNiwgaiA9IDA7IGkgPj0gc3RhcnQ7IGkgLT0gNikge1xuICAgICAgdyA9IHBhcnNlSGV4KG51bWJlciwgaSwgaSArIDYpO1xuICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuICAgICAgLy8gTk9URTogYDB4M2ZmZmZmYCBpcyBpbnRlbnRpb25hbCBoZXJlLCAyNmJpdHMgbWF4IHNoaWZ0ICsgMjRiaXQgaGV4IGxpbWJcbiAgICAgIHRoaXMud29yZHNbaiArIDFdIHw9IHcgPj4+ICgyNiAtIG9mZikgJiAweDNmZmZmZjtcbiAgICAgIG9mZiArPSAyNDtcbiAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICBqKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpICsgNiAhPT0gc3RhcnQpIHtcbiAgICAgIHcgPSBwYXJzZUhleChudW1iZXIsIHN0YXJ0LCBpICsgNik7XG4gICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgICB0aGlzLndvcmRzW2ogKyAxXSB8PSB3ID4+PiAoMjYgLSBvZmYpICYgMHgzZmZmZmY7XG4gICAgfVxuICAgIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZUJhc2UgKHN0ciwgc3RhcnQsIGVuZCwgbXVsKSB7XG4gICAgdmFyIHIgPSAwO1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBlbmQpO1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpIC0gNDg7XG5cbiAgICAgIHIgKj0gbXVsO1xuXG4gICAgICAvLyAnYSdcbiAgICAgIGlmIChjID49IDQ5KSB7XG4gICAgICAgIHIgKz0gYyAtIDQ5ICsgMHhhO1xuXG4gICAgICAvLyAnQSdcbiAgICAgIH0gZWxzZSBpZiAoYyA+PSAxNykge1xuICAgICAgICByICs9IGMgLSAxNyArIDB4YTtcblxuICAgICAgLy8gJzAnIC0gJzknXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByICs9IGM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl9wYXJzZUJhc2UgPSBmdW5jdGlvbiBfcGFyc2VCYXNlIChudW1iZXIsIGJhc2UsIHN0YXJ0KSB7XG4gICAgLy8gSW5pdGlhbGl6ZSBhcyB6ZXJvXG4gICAgdGhpcy53b3JkcyA9IFsgMCBdO1xuICAgIHRoaXMubGVuZ3RoID0gMTtcblxuICAgIC8vIEZpbmQgbGVuZ3RoIG9mIGxpbWIgaW4gYmFzZVxuICAgIGZvciAodmFyIGxpbWJMZW4gPSAwLCBsaW1iUG93ID0gMTsgbGltYlBvdyA8PSAweDNmZmZmZmY7IGxpbWJQb3cgKj0gYmFzZSkge1xuICAgICAgbGltYkxlbisrO1xuICAgIH1cbiAgICBsaW1iTGVuLS07XG4gICAgbGltYlBvdyA9IChsaW1iUG93IC8gYmFzZSkgfCAwO1xuXG4gICAgdmFyIHRvdGFsID0gbnVtYmVyLmxlbmd0aCAtIHN0YXJ0O1xuICAgIHZhciBtb2QgPSB0b3RhbCAlIGxpbWJMZW47XG4gICAgdmFyIGVuZCA9IE1hdGgubWluKHRvdGFsLCB0b3RhbCAtIG1vZCkgKyBzdGFydDtcblxuICAgIHZhciB3b3JkID0gMDtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gbGltYkxlbikge1xuICAgICAgd29yZCA9IHBhcnNlQmFzZShudW1iZXIsIGksIGkgKyBsaW1iTGVuLCBiYXNlKTtcblxuICAgICAgdGhpcy5pbXVsbihsaW1iUG93KTtcbiAgICAgIGlmICh0aGlzLndvcmRzWzBdICsgd29yZCA8IDB4NDAwMDAwMCkge1xuICAgICAgICB0aGlzLndvcmRzWzBdICs9IHdvcmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pYWRkbih3b3JkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobW9kICE9PSAwKSB7XG4gICAgICB2YXIgcG93ID0gMTtcbiAgICAgIHdvcmQgPSBwYXJzZUJhc2UobnVtYmVyLCBpLCBudW1iZXIubGVuZ3RoLCBiYXNlKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IG1vZDsgaSsrKSB7XG4gICAgICAgIHBvdyAqPSBiYXNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmltdWxuKHBvdyk7XG4gICAgICBpZiAodGhpcy53b3Jkc1swXSArIHdvcmQgPCAweDQwMDAwMDApIHtcbiAgICAgICAgdGhpcy53b3Jkc1swXSArPSB3b3JkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faWFkZG4od29yZCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAoZGVzdCkge1xuICAgIGRlc3Qud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVzdC53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV07XG4gICAgfVxuICAgIGRlc3QubGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgZGVzdC5uZWdhdGl2ZSA9IHRoaXMubmVnYXRpdmU7XG4gICAgZGVzdC5yZWQgPSB0aGlzLnJlZDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgdmFyIHIgPSBuZXcgQk4obnVsbCk7XG4gICAgdGhpcy5jb3B5KHIpO1xuICAgIHJldHVybiByO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fZXhwYW5kID0gZnVuY3Rpb24gX2V4cGFuZCAoc2l6ZSkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA8IHNpemUpIHtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGgrK10gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBSZW1vdmUgbGVhZGluZyBgMGAgZnJvbSBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnN0cmlwID0gZnVuY3Rpb24gc3RyaXAgKCkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA+IDEgJiYgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICB0aGlzLmxlbmd0aC0tO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX25vcm1TaWduID0gZnVuY3Rpb24gX25vcm1TaWduICgpIHtcbiAgICAvLyAtMCA9IDBcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLnJlZCA/ICc8Qk4tUjogJyA6ICc8Qk46ICcpICsgdGhpcy50b1N0cmluZygxNikgKyAnPic7XG4gIH07XG5cbiAgLypcblxuICB2YXIgemVyb3MgPSBbXTtcbiAgdmFyIGdyb3VwU2l6ZXMgPSBbXTtcbiAgdmFyIGdyb3VwQmFzZXMgPSBbXTtcblxuICB2YXIgcyA9ICcnO1xuICB2YXIgaSA9IC0xO1xuICB3aGlsZSAoKytpIDwgQk4ud29yZFNpemUpIHtcbiAgICB6ZXJvc1tpXSA9IHM7XG4gICAgcyArPSAnMCc7XG4gIH1cbiAgZ3JvdXBTaXplc1swXSA9IDA7XG4gIGdyb3VwU2l6ZXNbMV0gPSAwO1xuICBncm91cEJhc2VzWzBdID0gMDtcbiAgZ3JvdXBCYXNlc1sxXSA9IDA7XG4gIHZhciBiYXNlID0gMiAtIDE7XG4gIHdoaWxlICgrK2Jhc2UgPCAzNiArIDEpIHtcbiAgICB2YXIgZ3JvdXBTaXplID0gMDtcbiAgICB2YXIgZ3JvdXBCYXNlID0gMTtcbiAgICB3aGlsZSAoZ3JvdXBCYXNlIDwgKDEgPDwgQk4ud29yZFNpemUpIC8gYmFzZSkge1xuICAgICAgZ3JvdXBCYXNlICo9IGJhc2U7XG4gICAgICBncm91cFNpemUgKz0gMTtcbiAgICB9XG4gICAgZ3JvdXBTaXplc1tiYXNlXSA9IGdyb3VwU2l6ZTtcbiAgICBncm91cEJhc2VzW2Jhc2VdID0gZ3JvdXBCYXNlO1xuICB9XG5cbiAgKi9cblxuICB2YXIgemVyb3MgPSBbXG4gICAgJycsXG4gICAgJzAnLFxuICAgICcwMCcsXG4gICAgJzAwMCcsXG4gICAgJzAwMDAnLFxuICAgICcwMDAwMCcsXG4gICAgJzAwMDAwMCcsXG4gICAgJzAwMDAwMDAnLFxuICAgICcwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnXG4gIF07XG5cbiAgdmFyIGdyb3VwU2l6ZXMgPSBbXG4gICAgMCwgMCxcbiAgICAyNSwgMTYsIDEyLCAxMSwgMTAsIDksIDgsXG4gICAgOCwgNywgNywgNywgNywgNiwgNixcbiAgICA2LCA2LCA2LCA2LCA2LCA1LCA1LFxuICAgIDUsIDUsIDUsIDUsIDUsIDUsIDUsXG4gICAgNSwgNSwgNSwgNSwgNSwgNSwgNVxuICBdO1xuXG4gIHZhciBncm91cEJhc2VzID0gW1xuICAgIDAsIDAsXG4gICAgMzM1NTQ0MzIsIDQzMDQ2NzIxLCAxNjc3NzIxNiwgNDg4MjgxMjUsIDYwNDY2MTc2LCA0MDM1MzYwNywgMTY3NzcyMTYsXG4gICAgNDMwNDY3MjEsIDEwMDAwMDAwLCAxOTQ4NzE3MSwgMzU4MzE4MDgsIDYyNzQ4NTE3LCA3NTI5NTM2LCAxMTM5MDYyNSxcbiAgICAxNjc3NzIxNiwgMjQxMzc1NjksIDM0MDEyMjI0LCA0NzA0NTg4MSwgNjQwMDAwMDAsIDQwODQxMDEsIDUxNTM2MzIsXG4gICAgNjQzNjM0MywgNzk2MjYyNCwgOTc2NTYyNSwgMTE4ODEzNzYsIDE0MzQ4OTA3LCAxNzIxMDM2OCwgMjA1MTExNDksXG4gICAgMjQzMDAwMDAsIDI4NjI5MTUxLCAzMzU1NDQzMiwgMzkxMzUzOTMsIDQ1NDM1NDI0LCA1MjUyMTg3NSwgNjA0NjYxNzZcbiAgXTtcblxuICBCTi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoYmFzZSwgcGFkZGluZykge1xuICAgIGJhc2UgPSBiYXNlIHx8IDEwO1xuICAgIHBhZGRpbmcgPSBwYWRkaW5nIHwgMCB8fCAxO1xuXG4gICAgdmFyIG91dDtcbiAgICBpZiAoYmFzZSA9PT0gMTYgfHwgYmFzZSA9PT0gJ2hleCcpIHtcbiAgICAgIG91dCA9ICcnO1xuICAgICAgdmFyIG9mZiA9IDA7XG4gICAgICB2YXIgY2FycnkgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgICAgdmFyIHdvcmQgPSAoKCh3IDw8IG9mZikgfCBjYXJyeSkgJiAweGZmZmZmZikudG9TdHJpbmcoMTYpO1xuICAgICAgICBjYXJyeSA9ICh3ID4+PiAoMjQgLSBvZmYpKSAmIDB4ZmZmZmZmO1xuICAgICAgICBpZiAoY2FycnkgIT09IDAgfHwgaSAhPT0gdGhpcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgb3V0ID0gemVyb3NbNiAtIHdvcmQubGVuZ3RoXSArIHdvcmQgKyBvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ID0gd29yZCArIG91dDtcbiAgICAgICAgfVxuICAgICAgICBvZmYgKz0gMjtcbiAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgICBvdXQgPSBjYXJyeS50b1N0cmluZygxNikgKyBvdXQ7XG4gICAgICB9XG4gICAgICB3aGlsZSAob3V0Lmxlbmd0aCAlIHBhZGRpbmcgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJy0nICsgb3V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBpZiAoYmFzZSA9PT0gKGJhc2UgfCAwKSAmJiBiYXNlID49IDIgJiYgYmFzZSA8PSAzNikge1xuICAgICAgLy8gdmFyIGdyb3VwU2l6ZSA9IE1hdGguZmxvb3IoQk4ud29yZFNpemUgKiBNYXRoLkxOMiAvIE1hdGgubG9nKGJhc2UpKTtcbiAgICAgIHZhciBncm91cFNpemUgPSBncm91cFNpemVzW2Jhc2VdO1xuICAgICAgLy8gdmFyIGdyb3VwQmFzZSA9IE1hdGgucG93KGJhc2UsIGdyb3VwU2l6ZSk7XG4gICAgICB2YXIgZ3JvdXBCYXNlID0gZ3JvdXBCYXNlc1tiYXNlXTtcbiAgICAgIG91dCA9ICcnO1xuICAgICAgdmFyIGMgPSB0aGlzLmNsb25lKCk7XG4gICAgICBjLm5lZ2F0aXZlID0gMDtcbiAgICAgIHdoaWxlICghYy5pc1plcm8oKSkge1xuICAgICAgICB2YXIgciA9IGMubW9kbihncm91cEJhc2UpLnRvU3RyaW5nKGJhc2UpO1xuICAgICAgICBjID0gYy5pZGl2bihncm91cEJhc2UpO1xuXG4gICAgICAgIGlmICghYy5pc1plcm8oKSkge1xuICAgICAgICAgIG91dCA9IHplcm9zW2dyb3VwU2l6ZSAtIHIubGVuZ3RoXSArIHIgKyBvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ID0gciArIG91dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcbiAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuICAgICAgfVxuICAgICAgd2hpbGUgKG91dC5sZW5ndGggJSBwYWRkaW5nICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICcwJyArIG91dDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICctJyArIG91dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgYXNzZXJ0KGZhbHNlLCAnQmFzZSBzaG91bGQgYmUgYmV0d2VlbiAyIGFuZCAzNicpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyICgpIHtcbiAgICB2YXIgcmV0ID0gdGhpcy53b3Jkc1swXTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHJldCArPSB0aGlzLndvcmRzWzFdICogMHg0MDAwMDAwO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPT09IDMgJiYgdGhpcy53b3Jkc1syXSA9PT0gMHgwMSkge1xuICAgICAgLy8gTk9URTogYXQgdGhpcyBzdGFnZSBpdCBpcyBrbm93biB0aGF0IHRoZSB0b3AgYml0IGlzIHNldFxuICAgICAgcmV0ICs9IDB4MTAwMDAwMDAwMDAwMDAgKyAodGhpcy53b3Jkc1sxXSAqIDB4NDAwMDAwMCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGFzc2VydChmYWxzZSwgJ051bWJlciBjYW4gb25seSBzYWZlbHkgc3RvcmUgdXAgdG8gNTMgYml0cycpO1xuICAgIH1cbiAgICByZXR1cm4gKHRoaXMubmVnYXRpdmUgIT09IDApID8gLXJldCA6IHJldDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygxNik7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24gdG9CdWZmZXIgKGVuZGlhbiwgbGVuZ3RoKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnKTtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5TGlrZShCdWZmZXIsIGVuZGlhbiwgbGVuZ3RoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkgKGVuZGlhbiwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheUxpa2UoQXJyYXksIGVuZGlhbiwgbGVuZ3RoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9BcnJheUxpa2UgPSBmdW5jdGlvbiB0b0FycmF5TGlrZSAoQXJyYXlUeXBlLCBlbmRpYW4sIGxlbmd0aCkge1xuICAgIHZhciBieXRlTGVuZ3RoID0gdGhpcy5ieXRlTGVuZ3RoKCk7XG4gICAgdmFyIHJlcUxlbmd0aCA9IGxlbmd0aCB8fCBNYXRoLm1heCgxLCBieXRlTGVuZ3RoKTtcbiAgICBhc3NlcnQoYnl0ZUxlbmd0aCA8PSByZXFMZW5ndGgsICdieXRlIGFycmF5IGxvbmdlciB0aGFuIGRlc2lyZWQgbGVuZ3RoJyk7XG4gICAgYXNzZXJ0KHJlcUxlbmd0aCA+IDAsICdSZXF1ZXN0ZWQgYXJyYXkgbGVuZ3RoIDw9IDAnKTtcblxuICAgIHRoaXMuc3RyaXAoKTtcbiAgICB2YXIgbGl0dGxlRW5kaWFuID0gZW5kaWFuID09PSAnbGUnO1xuICAgIHZhciByZXMgPSBuZXcgQXJyYXlUeXBlKHJlcUxlbmd0aCk7XG5cbiAgICB2YXIgYiwgaTtcbiAgICB2YXIgcSA9IHRoaXMuY2xvbmUoKTtcbiAgICBpZiAoIWxpdHRsZUVuZGlhbikge1xuICAgICAgLy8gQXNzdW1lIGJpZy1lbmRpYW5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCByZXFMZW5ndGggLSBieXRlTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzW2ldID0gMDtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgIXEuaXNaZXJvKCk7IGkrKykge1xuICAgICAgICBiID0gcS5hbmRsbigweGZmKTtcbiAgICAgICAgcS5pdXNocm4oOCk7XG5cbiAgICAgICAgcmVzW3JlcUxlbmd0aCAtIGkgLSAxXSA9IGI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDA7ICFxLmlzWmVybygpOyBpKyspIHtcbiAgICAgICAgYiA9IHEuYW5kbG4oMHhmZik7XG4gICAgICAgIHEuaXVzaHJuKDgpO1xuXG4gICAgICAgIHJlc1tpXSA9IGI7XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBpIDwgcmVxTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzW2ldID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIGlmIChNYXRoLmNsejMyKSB7XG4gICAgQk4ucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzICh3KSB7XG4gICAgICByZXR1cm4gMzIgLSBNYXRoLmNsejMyKHcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgQk4ucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzICh3KSB7XG4gICAgICB2YXIgdCA9IHc7XG4gICAgICB2YXIgciA9IDA7XG4gICAgICBpZiAodCA+PSAweDEwMDApIHtcbiAgICAgICAgciArPSAxMztcbiAgICAgICAgdCA+Pj49IDEzO1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMHg0MCkge1xuICAgICAgICByICs9IDc7XG4gICAgICAgIHQgPj4+PSA3O1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMHg4KSB7XG4gICAgICAgIHIgKz0gNDtcbiAgICAgICAgdCA+Pj49IDQ7XG4gICAgICB9XG4gICAgICBpZiAodCA+PSAweDAyKSB7XG4gICAgICAgIHIgKz0gMjtcbiAgICAgICAgdCA+Pj49IDI7XG4gICAgICB9XG4gICAgICByZXR1cm4gciArIHQ7XG4gICAgfTtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5femVyb0JpdHMgPSBmdW5jdGlvbiBfemVyb0JpdHMgKHcpIHtcbiAgICAvLyBTaG9ydC1jdXRcbiAgICBpZiAodyA9PT0gMCkgcmV0dXJuIDI2O1xuXG4gICAgdmFyIHQgPSB3O1xuICAgIHZhciByID0gMDtcbiAgICBpZiAoKHQgJiAweDFmZmYpID09PSAwKSB7XG4gICAgICByICs9IDEzO1xuICAgICAgdCA+Pj49IDEzO1xuICAgIH1cbiAgICBpZiAoKHQgJiAweDdmKSA9PT0gMCkge1xuICAgICAgciArPSA3O1xuICAgICAgdCA+Pj49IDc7XG4gICAgfVxuICAgIGlmICgodCAmIDB4ZikgPT09IDApIHtcbiAgICAgIHIgKz0gNDtcbiAgICAgIHQgPj4+PSA0O1xuICAgIH1cbiAgICBpZiAoKHQgJiAweDMpID09PSAwKSB7XG4gICAgICByICs9IDI7XG4gICAgICB0ID4+Pj0gMjtcbiAgICB9XG4gICAgaWYgKCh0ICYgMHgxKSA9PT0gMCkge1xuICAgICAgcisrO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICAvLyBSZXR1cm4gbnVtYmVyIG9mIHVzZWQgYml0cyBpbiBhIEJOXG4gIEJOLnByb3RvdHlwZS5iaXRMZW5ndGggPSBmdW5jdGlvbiBiaXRMZW5ndGggKCkge1xuICAgIHZhciB3ID0gdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdO1xuICAgIHZhciBoaSA9IHRoaXMuX2NvdW50Qml0cyh3KTtcbiAgICByZXR1cm4gKHRoaXMubGVuZ3RoIC0gMSkgKiAyNiArIGhpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHRvQml0QXJyYXkgKG51bSkge1xuICAgIHZhciB3ID0gbmV3IEFycmF5KG51bS5iaXRMZW5ndGgoKSk7XG5cbiAgICBmb3IgKHZhciBiaXQgPSAwOyBiaXQgPCB3Lmxlbmd0aDsgYml0KyspIHtcbiAgICAgIHZhciBvZmYgPSAoYml0IC8gMjYpIHwgMDtcbiAgICAgIHZhciB3Yml0ID0gYml0ICUgMjY7XG5cbiAgICAgIHdbYml0XSA9IChudW0ud29yZHNbb2ZmXSAmICgxIDw8IHdiaXQpKSA+Pj4gd2JpdDtcbiAgICB9XG5cbiAgICByZXR1cm4gdztcbiAgfVxuXG4gIC8vIE51bWJlciBvZiB0cmFpbGluZyB6ZXJvIGJpdHNcbiAgQk4ucHJvdG90eXBlLnplcm9CaXRzID0gZnVuY3Rpb24gemVyb0JpdHMgKCkge1xuICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gMDtcblxuICAgIHZhciByID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBiID0gdGhpcy5femVyb0JpdHModGhpcy53b3Jkc1tpXSk7XG4gICAgICByICs9IGI7XG4gICAgICBpZiAoYiAhPT0gMjYpIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIGJ5dGVMZW5ndGggKCkge1xuICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5iaXRMZW5ndGgoKSAvIDgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b1R3b3MgPSBmdW5jdGlvbiB0b1R3b3MgKHdpZHRoKSB7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmFicygpLmlub3RuKHdpZHRoKS5pYWRkbigxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZnJvbVR3b3MgPSBmdW5jdGlvbiBmcm9tVHdvcyAod2lkdGgpIHtcbiAgICBpZiAodGhpcy50ZXN0bih3aWR0aCAtIDEpKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub3RuKHdpZHRoKS5pYWRkbigxKS5pbmVnKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzTmVnID0gZnVuY3Rpb24gaXNOZWcgKCkge1xuICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlICE9PSAwO1xuICB9O1xuXG4gIC8vIFJldHVybiBuZWdhdGl2ZSBjbG9uZSBvZiBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbmVnKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmluZWcgPSBmdW5jdGlvbiBpbmVnICgpIHtcbiAgICBpZiAoIXRoaXMuaXNaZXJvKCkpIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgXj0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBPciBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVvciA9IGZ1bmN0aW9uIGl1b3IgKG51bSkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA8IG51bS5sZW5ndGgpIHtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGgrK10gPSAwO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXSB8IG51bS53b3Jkc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pb3IgPSBmdW5jdGlvbiBpb3IgKG51bSkge1xuICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1b3IobnVtKTtcbiAgfTtcblxuICAvLyBPciBgbnVtYCB3aXRoIGB0aGlzYFxuICBCTi5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiBvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pb3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaW9yKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51b3IgPSBmdW5jdGlvbiB1b3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXVvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdW9yKHRoaXMpO1xuICB9O1xuXG4gIC8vIEFuZCBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVhbmQgPSBmdW5jdGlvbiBpdWFuZCAobnVtKSB7XG4gICAgLy8gYiA9IG1pbi1sZW5ndGgobnVtLCB0aGlzKVxuICAgIHZhciBiO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV0gJiBudW0ud29yZHNbaV07XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBiLmxlbmd0aDtcblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlhbmQgPSBmdW5jdGlvbiBpYW5kIChudW0pIHtcbiAgICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdWFuZChudW0pO1xuICB9O1xuXG4gIC8vIEFuZCBgbnVtYCB3aXRoIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gYW5kIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlhbmQobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaWFuZCh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudWFuZCA9IGZ1bmN0aW9uIHVhbmQgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXVhbmQobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXVhbmQodGhpcyk7XG4gIH07XG5cbiAgLy8gWG9yIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdXhvciA9IGZ1bmN0aW9uIGl1eG9yIChudW0pIHtcbiAgICAvLyBhLmxlbmd0aCA+IGIubGVuZ3RoXG4gICAgdmFyIGE7XG4gICAgdmFyIGI7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuICAgICAgYSA9IHRoaXM7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gbnVtO1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXSBeIGIud29yZHNbaV07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMgIT09IGEpIHtcbiAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IGEubGVuZ3RoO1xuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXhvciA9IGZ1bmN0aW9uIGl4b3IgKG51bSkge1xuICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1eG9yKG51bSk7XG4gIH07XG5cbiAgLy8gWG9yIGBudW1gIHdpdGggYHRoaXNgXG4gIEJOLnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbiB4b3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXhvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5peG9yKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51eG9yID0gZnVuY3Rpb24gdXhvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXhvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdXhvcih0aGlzKTtcbiAgfTtcblxuICAvLyBOb3QgYGB0aGlzYGAgd2l0aCBgYHdpZHRoYGAgYml0d2lkdGhcbiAgQk4ucHJvdG90eXBlLmlub3RuID0gZnVuY3Rpb24gaW5vdG4gKHdpZHRoKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiB3aWR0aCA9PT0gJ251bWJlcicgJiYgd2lkdGggPj0gMCk7XG5cbiAgICB2YXIgYnl0ZXNOZWVkZWQgPSBNYXRoLmNlaWwod2lkdGggLyAyNikgfCAwO1xuICAgIHZhciBiaXRzTGVmdCA9IHdpZHRoICUgMjY7XG5cbiAgICAvLyBFeHRlbmQgdGhlIGJ1ZmZlciB3aXRoIGxlYWRpbmcgemVyb2VzXG4gICAgdGhpcy5fZXhwYW5kKGJ5dGVzTmVlZGVkKTtcblxuICAgIGlmIChiaXRzTGVmdCA+IDApIHtcbiAgICAgIGJ5dGVzTmVlZGVkLS07XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGNvbXBsZXRlIHdvcmRzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlc05lZWRlZDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gfnRoaXMud29yZHNbaV0gJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHRoZSByZXNpZHVlXG4gICAgaWYgKGJpdHNMZWZ0ID4gMCkge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IH50aGlzLndvcmRzW2ldICYgKDB4M2ZmZmZmZiA+PiAoMjYgLSBiaXRzTGVmdCkpO1xuICAgIH1cblxuICAgIC8vIEFuZCByZW1vdmUgbGVhZGluZyB6ZXJvZXNcbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ub3RuID0gZnVuY3Rpb24gbm90biAod2lkdGgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlub3RuKHdpZHRoKTtcbiAgfTtcblxuICAvLyBTZXQgYGJpdGAgb2YgYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zZXRuID0gZnVuY3Rpb24gc2V0biAoYml0LCB2YWwpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicgJiYgYml0ID49IDApO1xuXG4gICAgdmFyIG9mZiA9IChiaXQgLyAyNikgfCAwO1xuICAgIHZhciB3Yml0ID0gYml0ICUgMjY7XG5cbiAgICB0aGlzLl9leHBhbmQob2ZmICsgMSk7XG5cbiAgICBpZiAodmFsKSB7XG4gICAgICB0aGlzLndvcmRzW29mZl0gPSB0aGlzLndvcmRzW29mZl0gfCAoMSA8PCB3Yml0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53b3Jkc1tvZmZdID0gdGhpcy53b3Jkc1tvZmZdICYgfigxIDw8IHdiaXQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgLy8gQWRkIGBudW1gIHRvIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaWFkZCA9IGZ1bmN0aW9uIGlhZGQgKG51bSkge1xuICAgIHZhciByO1xuXG4gICAgLy8gbmVnYXRpdmUgKyBwb3NpdGl2ZVxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICByID0gdGhpcy5pc3ViKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlIF49IDE7XG4gICAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcblxuICAgIC8vIHBvc2l0aXZlICsgbmVnYXRpdmVcbiAgICB9IGVsc2UgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgICAgciA9IHRoaXMuaXN1YihudW0pO1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiByLl9ub3JtU2lnbigpO1xuICAgIH1cblxuICAgIC8vIGEubGVuZ3RoID4gYi5sZW5ndGhcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG4gICAgICBhID0gdGhpcztcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBudW07XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyAoYi53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgIGNhcnJ5ID0gciA+Pj4gMjY7XG4gICAgfVxuICAgIGZvciAoOyBjYXJyeSAhPT0gMCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgICAgY2FycnkgPSByID4+PiAyNjtcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IGEubGVuZ3RoO1xuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aF0gPSBjYXJyeTtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgLy8gQ29weSB0aGUgcmVzdCBvZiB0aGUgd29yZHNcbiAgICB9IGVsc2UgaWYgKGEgIT09IHRoaXMpIHtcbiAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBBZGQgYG51bWAgdG8gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKG51bSkge1xuICAgIHZhciByZXM7XG4gICAgaWYgKG51bS5uZWdhdGl2ZSAhPT0gMCAmJiB0aGlzLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgICAgcmVzID0gdGhpcy5zdWIobnVtKTtcbiAgICAgIG51bS5uZWdhdGl2ZSBePSAxO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGVsc2UgaWYgKG51bS5uZWdhdGl2ZSA9PT0gMCAmJiB0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHJlcyA9IG51bS5zdWIodGhpcyk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWRkKG51bSk7XG5cbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaWFkZCh0aGlzKTtcbiAgfTtcblxuICAvLyBTdWJ0cmFjdCBgbnVtYCBmcm9tIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXN1YiA9IGZ1bmN0aW9uIGlzdWIgKG51bSkge1xuICAgIC8vIHRoaXMgLSAoLW51bSkgPSB0aGlzICsgbnVtXG4gICAgaWYgKG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcbiAgICAgIHZhciByID0gdGhpcy5pYWRkKG51bSk7XG4gICAgICBudW0ubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHIuX25vcm1TaWduKCk7XG5cbiAgICAvLyAtdGhpcyAtIG51bSA9IC0odGhpcyArIG51bSlcbiAgICB9IGVsc2UgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5pYWRkKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuICAgIH1cblxuICAgIC8vIEF0IHRoaXMgcG9pbnQgYm90aCBudW1iZXJzIGFyZSBwb3NpdGl2ZVxuICAgIHZhciBjbXAgPSB0aGlzLmNtcChudW0pO1xuXG4gICAgLy8gT3B0aW1pemF0aW9uIC0gemVyb2lmeVxuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBhID4gYlxuICAgIHZhciBhLCBiO1xuICAgIGlmIChjbXAgPiAwKSB7XG4gICAgICBhID0gdGhpcztcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBudW07XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgLSAoYi53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHIgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgZm9yICg7IGNhcnJ5ICE9PSAwICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSByID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgLy8gQ29weSByZXN0IG9mIHRoZSB3b3Jkc1xuICAgIGlmIChjYXJyeSA9PT0gMCAmJiBpIDwgYS5sZW5ndGggJiYgYSAhPT0gdGhpcykge1xuICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIGkpO1xuXG4gICAgaWYgKGEgIT09IHRoaXMpIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgLy8gU3VidHJhY3QgYG51bWAgZnJvbSBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIHN1YiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc3ViKG51bSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gc21hbGxNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICBvdXQubmVnYXRpdmUgPSBudW0ubmVnYXRpdmUgXiBzZWxmLm5lZ2F0aXZlO1xuICAgIHZhciBsZW4gPSAoc2VsZi5sZW5ndGggKyBudW0ubGVuZ3RoKSB8IDA7XG4gICAgb3V0Lmxlbmd0aCA9IGxlbjtcbiAgICBsZW4gPSAobGVuIC0gMSkgfCAwO1xuXG4gICAgLy8gUGVlbCBvbmUgaXRlcmF0aW9uIChjb21waWxlciBjYW4ndCBkbyBpdCwgYmVjYXVzZSBvZiBjb2RlIGNvbXBsZXhpdHkpXG4gICAgdmFyIGEgPSBzZWxmLndvcmRzWzBdIHwgMDtcbiAgICB2YXIgYiA9IG51bS53b3Jkc1swXSB8IDA7XG4gICAgdmFyIHIgPSBhICogYjtcblxuICAgIHZhciBsbyA9IHIgJiAweDNmZmZmZmY7XG4gICAgdmFyIGNhcnJ5ID0gKHIgLyAweDQwMDAwMDApIHwgMDtcbiAgICBvdXQud29yZHNbMF0gPSBsbztcblxuICAgIGZvciAodmFyIGsgPSAxOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgIC8vIFN1bSBhbGwgd29yZHMgd2l0aCB0aGUgc2FtZSBgaSArIGogPSBrYCBhbmQgYWNjdW11bGF0ZSBgbmNhcnJ5YCxcbiAgICAgIC8vIG5vdGUgdGhhdCBuY2FycnkgY291bGQgYmUgPj0gMHgzZmZmZmZmXG4gICAgICB2YXIgbmNhcnJ5ID0gY2FycnkgPj4+IDI2O1xuICAgICAgdmFyIHJ3b3JkID0gY2FycnkgJiAweDNmZmZmZmY7XG4gICAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIG51bS5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gc2VsZi5sZW5ndGggKyAxKTsgaiA8PSBtYXhKOyBqKyspIHtcbiAgICAgICAgdmFyIGkgPSAoayAtIGopIHwgMDtcbiAgICAgICAgYSA9IHNlbGYud29yZHNbaV0gfCAwO1xuICAgICAgICBiID0gbnVtLndvcmRzW2pdIHwgMDtcbiAgICAgICAgciA9IGEgKiBiICsgcndvcmQ7XG4gICAgICAgIG5jYXJyeSArPSAociAvIDB4NDAwMDAwMCkgfCAwO1xuICAgICAgICByd29yZCA9IHIgJiAweDNmZmZmZmY7XG4gICAgICB9XG4gICAgICBvdXQud29yZHNba10gPSByd29yZCB8IDA7XG4gICAgICBjYXJyeSA9IG5jYXJyeSB8IDA7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgb3V0LndvcmRzW2tdID0gY2FycnkgfCAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQubGVuZ3RoLS07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dC5zdHJpcCgpO1xuICB9XG5cbiAgLy8gVE9ETyhpbmR1dG55KTogaXQgbWF5IGJlIHJlYXNvbmFibGUgdG8gb21pdCBpdCBmb3IgdXNlcnMgd2hvIGRvbid0IG5lZWRcbiAgLy8gdG8gd29yayB3aXRoIDI1Ni1iaXQgbnVtYmVycywgb3RoZXJ3aXNlIGl0IGdpdmVzIDIwJSBpbXByb3ZlbWVudCBmb3IgMjU2LWJpdFxuICAvLyBtdWx0aXBsaWNhdGlvbiAobGlrZSBlbGxpcHRpYyBzZWNwMjU2azEpLlxuICB2YXIgY29tYjEwTXVsVG8gPSBmdW5jdGlvbiBjb21iMTBNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICB2YXIgYSA9IHNlbGYud29yZHM7XG4gICAgdmFyIGIgPSBudW0ud29yZHM7XG4gICAgdmFyIG8gPSBvdXQud29yZHM7XG4gICAgdmFyIGMgPSAwO1xuICAgIHZhciBsbztcbiAgICB2YXIgbWlkO1xuICAgIHZhciBoaTtcbiAgICB2YXIgYTAgPSBhWzBdIHwgMDtcbiAgICB2YXIgYWwwID0gYTAgJiAweDFmZmY7XG4gICAgdmFyIGFoMCA9IGEwID4+PiAxMztcbiAgICB2YXIgYTEgPSBhWzFdIHwgMDtcbiAgICB2YXIgYWwxID0gYTEgJiAweDFmZmY7XG4gICAgdmFyIGFoMSA9IGExID4+PiAxMztcbiAgICB2YXIgYTIgPSBhWzJdIHwgMDtcbiAgICB2YXIgYWwyID0gYTIgJiAweDFmZmY7XG4gICAgdmFyIGFoMiA9IGEyID4+PiAxMztcbiAgICB2YXIgYTMgPSBhWzNdIHwgMDtcbiAgICB2YXIgYWwzID0gYTMgJiAweDFmZmY7XG4gICAgdmFyIGFoMyA9IGEzID4+PiAxMztcbiAgICB2YXIgYTQgPSBhWzRdIHwgMDtcbiAgICB2YXIgYWw0ID0gYTQgJiAweDFmZmY7XG4gICAgdmFyIGFoNCA9IGE0ID4+PiAxMztcbiAgICB2YXIgYTUgPSBhWzVdIHwgMDtcbiAgICB2YXIgYWw1ID0gYTUgJiAweDFmZmY7XG4gICAgdmFyIGFoNSA9IGE1ID4+PiAxMztcbiAgICB2YXIgYTYgPSBhWzZdIHwgMDtcbiAgICB2YXIgYWw2ID0gYTYgJiAweDFmZmY7XG4gICAgdmFyIGFoNiA9IGE2ID4+PiAxMztcbiAgICB2YXIgYTcgPSBhWzddIHwgMDtcbiAgICB2YXIgYWw3ID0gYTcgJiAweDFmZmY7XG4gICAgdmFyIGFoNyA9IGE3ID4+PiAxMztcbiAgICB2YXIgYTggPSBhWzhdIHwgMDtcbiAgICB2YXIgYWw4ID0gYTggJiAweDFmZmY7XG4gICAgdmFyIGFoOCA9IGE4ID4+PiAxMztcbiAgICB2YXIgYTkgPSBhWzldIHwgMDtcbiAgICB2YXIgYWw5ID0gYTkgJiAweDFmZmY7XG4gICAgdmFyIGFoOSA9IGE5ID4+PiAxMztcbiAgICB2YXIgYjAgPSBiWzBdIHwgMDtcbiAgICB2YXIgYmwwID0gYjAgJiAweDFmZmY7XG4gICAgdmFyIGJoMCA9IGIwID4+PiAxMztcbiAgICB2YXIgYjEgPSBiWzFdIHwgMDtcbiAgICB2YXIgYmwxID0gYjEgJiAweDFmZmY7XG4gICAgdmFyIGJoMSA9IGIxID4+PiAxMztcbiAgICB2YXIgYjIgPSBiWzJdIHwgMDtcbiAgICB2YXIgYmwyID0gYjIgJiAweDFmZmY7XG4gICAgdmFyIGJoMiA9IGIyID4+PiAxMztcbiAgICB2YXIgYjMgPSBiWzNdIHwgMDtcbiAgICB2YXIgYmwzID0gYjMgJiAweDFmZmY7XG4gICAgdmFyIGJoMyA9IGIzID4+PiAxMztcbiAgICB2YXIgYjQgPSBiWzRdIHwgMDtcbiAgICB2YXIgYmw0ID0gYjQgJiAweDFmZmY7XG4gICAgdmFyIGJoNCA9IGI0ID4+PiAxMztcbiAgICB2YXIgYjUgPSBiWzVdIHwgMDtcbiAgICB2YXIgYmw1ID0gYjUgJiAweDFmZmY7XG4gICAgdmFyIGJoNSA9IGI1ID4+PiAxMztcbiAgICB2YXIgYjYgPSBiWzZdIHwgMDtcbiAgICB2YXIgYmw2ID0gYjYgJiAweDFmZmY7XG4gICAgdmFyIGJoNiA9IGI2ID4+PiAxMztcbiAgICB2YXIgYjcgPSBiWzddIHwgMDtcbiAgICB2YXIgYmw3ID0gYjcgJiAweDFmZmY7XG4gICAgdmFyIGJoNyA9IGI3ID4+PiAxMztcbiAgICB2YXIgYjggPSBiWzhdIHwgMDtcbiAgICB2YXIgYmw4ID0gYjggJiAweDFmZmY7XG4gICAgdmFyIGJoOCA9IGI4ID4+PiAxMztcbiAgICB2YXIgYjkgPSBiWzldIHwgMDtcbiAgICB2YXIgYmw5ID0gYjkgJiAweDFmZmY7XG4gICAgdmFyIGJoOSA9IGI5ID4+PiAxMztcblxuICAgIG91dC5uZWdhdGl2ZSA9IHNlbGYubmVnYXRpdmUgXiBudW0ubmVnYXRpdmU7XG4gICAgb3V0Lmxlbmd0aCA9IDE5O1xuICAgIC8qIGsgPSAwICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwwLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDAsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDAsIGJoMCk7XG4gICAgdmFyIHcwID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MCA+Pj4gMjYpKSB8IDA7XG4gICAgdzAgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwxLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDEsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDEsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgxKSkgfCAwO1xuICAgIHZhciB3MSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEgPj4+IDI2KSkgfCAwO1xuICAgIHcxICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMiwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwyLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgyLCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDIpKSB8IDA7XG4gICAgdmFyIHcyID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MiA+Pj4gMjYpKSB8IDA7XG4gICAgdzIgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAzICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwzLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDMsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDMsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDMpKSB8IDA7XG4gICAgdmFyIHczID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MyA+Pj4gMjYpKSB8IDA7XG4gICAgdzMgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA0ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw0LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDQsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDQsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg0KSkgfCAwO1xuICAgIHZhciB3NCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzQgPj4+IDI2KSkgfCAwO1xuICAgIHc0ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNSwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw1LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg1LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDUpKSB8IDA7XG4gICAgdmFyIHc1ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NSA+Pj4gMjYpKSB8IDA7XG4gICAgdzUgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA2ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw2LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDYsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDYsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDYpKSB8IDA7XG4gICAgdmFyIHc2ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NiA+Pj4gMjYpKSB8IDA7XG4gICAgdzYgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA3ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw3LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDcsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDcsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg3KSkgfCAwO1xuICAgIHZhciB3NyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzcgPj4+IDI2KSkgfCAwO1xuICAgIHc3ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gOCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOCwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw4LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg4LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDgpKSB8IDA7XG4gICAgdmFyIHc4ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3OCA+Pj4gMjYpKSB8IDA7XG4gICAgdzggJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA5ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDkpKSB8IDA7XG4gICAgdmFyIHc5ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3OSA+Pj4gMjYpKSB8IDA7XG4gICAgdzkgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwxKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDEpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDEpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDEpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEwID4+PiAyNikpIHwgMDtcbiAgICB3MTAgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwyKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDIpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDIpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDIpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzExID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTEgPj4+IDI2KSkgfCAwO1xuICAgIHcxMSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEyICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDMpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMyk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMykpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMyk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEyID4+PiAyNikpIHwgMDtcbiAgICB3MTIgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw0KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDQpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDQpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDQpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEzID4+PiAyNikpIHwgMDtcbiAgICB3MTMgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw1KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDUpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDUpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDUpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE0ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTQgPj4+IDI2KSkgfCAwO1xuICAgIHcxNCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE1ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDYpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNik7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNikpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNik7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE1ID4+PiAyNikpIHwgMDtcbiAgICB3MTUgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw3KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDcpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDcpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDcpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE2ID4+PiAyNikpIHwgMDtcbiAgICB3MTYgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw4KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDgpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDgpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDgpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE3ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTcgPj4+IDI2KSkgfCAwO1xuICAgIHcxNyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE4ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDkpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoOSk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsOSkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoOSk7XG4gICAgdmFyIHcxOCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE4ID4+PiAyNikpIHwgMDtcbiAgICB3MTggJj0gMHgzZmZmZmZmO1xuICAgIG9bMF0gPSB3MDtcbiAgICBvWzFdID0gdzE7XG4gICAgb1syXSA9IHcyO1xuICAgIG9bM10gPSB3MztcbiAgICBvWzRdID0gdzQ7XG4gICAgb1s1XSA9IHc1O1xuICAgIG9bNl0gPSB3NjtcbiAgICBvWzddID0gdzc7XG4gICAgb1s4XSA9IHc4O1xuICAgIG9bOV0gPSB3OTtcbiAgICBvWzEwXSA9IHcxMDtcbiAgICBvWzExXSA9IHcxMTtcbiAgICBvWzEyXSA9IHcxMjtcbiAgICBvWzEzXSA9IHcxMztcbiAgICBvWzE0XSA9IHcxNDtcbiAgICBvWzE1XSA9IHcxNTtcbiAgICBvWzE2XSA9IHcxNjtcbiAgICBvWzE3XSA9IHcxNztcbiAgICBvWzE4XSA9IHcxODtcbiAgICBpZiAoYyAhPT0gMCkge1xuICAgICAgb1sxOV0gPSBjO1xuICAgICAgb3V0Lmxlbmd0aCsrO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9O1xuXG4gIC8vIFBvbHlmaWxsIGNvbWJcbiAgaWYgKCFNYXRoLmltdWwpIHtcbiAgICBjb21iMTBNdWxUbyA9IHNtYWxsTXVsVG87XG4gIH1cblxuICBmdW5jdGlvbiBiaWdNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICBvdXQubmVnYXRpdmUgPSBudW0ubmVnYXRpdmUgXiBzZWxmLm5lZ2F0aXZlO1xuICAgIG91dC5sZW5ndGggPSBzZWxmLmxlbmd0aCArIG51bS5sZW5ndGg7XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIHZhciBobmNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IG91dC5sZW5ndGggLSAxOyBrKyspIHtcbiAgICAgIC8vIFN1bSBhbGwgd29yZHMgd2l0aCB0aGUgc2FtZSBgaSArIGogPSBrYCBhbmQgYWNjdW11bGF0ZSBgbmNhcnJ5YCxcbiAgICAgIC8vIG5vdGUgdGhhdCBuY2FycnkgY291bGQgYmUgPj0gMHgzZmZmZmZmXG4gICAgICB2YXIgbmNhcnJ5ID0gaG5jYXJyeTtcbiAgICAgIGhuY2FycnkgPSAwO1xuICAgICAgdmFyIHJ3b3JkID0gY2FycnkgJiAweDNmZmZmZmY7XG4gICAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIG51bS5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gc2VsZi5sZW5ndGggKyAxKTsgaiA8PSBtYXhKOyBqKyspIHtcbiAgICAgICAgdmFyIGkgPSBrIC0gajtcbiAgICAgICAgdmFyIGEgPSBzZWxmLndvcmRzW2ldIHwgMDtcbiAgICAgICAgdmFyIGIgPSBudW0ud29yZHNbal0gfCAwO1xuICAgICAgICB2YXIgciA9IGEgKiBiO1xuXG4gICAgICAgIHZhciBsbyA9IHIgJiAweDNmZmZmZmY7XG4gICAgICAgIG5jYXJyeSA9IChuY2FycnkgKyAoKHIgLyAweDQwMDAwMDApIHwgMCkpIHwgMDtcbiAgICAgICAgbG8gPSAobG8gKyByd29yZCkgfCAwO1xuICAgICAgICByd29yZCA9IGxvICYgMHgzZmZmZmZmO1xuICAgICAgICBuY2FycnkgPSAobmNhcnJ5ICsgKGxvID4+PiAyNikpIHwgMDtcblxuICAgICAgICBobmNhcnJ5ICs9IG5jYXJyeSA+Pj4gMjY7XG4gICAgICAgIG5jYXJyeSAmPSAweDNmZmZmZmY7XG4gICAgICB9XG4gICAgICBvdXQud29yZHNba10gPSByd29yZDtcbiAgICAgIGNhcnJ5ID0gbmNhcnJ5O1xuICAgICAgbmNhcnJ5ID0gaG5jYXJyeTtcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICBvdXQud29yZHNba10gPSBjYXJyeTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0Lmxlbmd0aC0tO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQuc3RyaXAoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGp1bWJvTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgdmFyIGZmdG0gPSBuZXcgRkZUTSgpO1xuICAgIHJldHVybiBmZnRtLm11bHAoc2VsZiwgbnVtLCBvdXQpO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLm11bFRvID0gZnVuY3Rpb24gbXVsVG8gKG51bSwgb3V0KSB7XG4gICAgdmFyIHJlcztcbiAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMTAgJiYgbnVtLmxlbmd0aCA9PT0gMTApIHtcbiAgICAgIHJlcyA9IGNvbWIxME11bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2UgaWYgKGxlbiA8IDYzKSB7XG4gICAgICByZXMgPSBzbWFsbE11bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2UgaWYgKGxlbiA8IDEwMjQpIHtcbiAgICAgIHJlcyA9IGJpZ011bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0ganVtYm9NdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBDb29sZXktVHVrZXkgYWxnb3JpdGhtIGZvciBGRlRcbiAgLy8gc2xpZ2h0bHkgcmV2aXNpdGVkIHRvIHJlbHkgb24gbG9vcGluZyBpbnN0ZWFkIG9mIHJlY3Vyc2lvblxuXG4gIGZ1bmN0aW9uIEZGVE0gKHgsIHkpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH1cblxuICBGRlRNLnByb3RvdHlwZS5tYWtlUkJUID0gZnVuY3Rpb24gbWFrZVJCVCAoTikge1xuICAgIHZhciB0ID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBsID0gQk4ucHJvdG90eXBlLl9jb3VudEJpdHMoTikgLSAxO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICB0W2ldID0gdGhpcy5yZXZCaW4oaSwgbCwgTik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBiaW5hcnktcmV2ZXJzZWQgcmVwcmVzZW50YXRpb24gb2YgYHhgXG4gIEZGVE0ucHJvdG90eXBlLnJldkJpbiA9IGZ1bmN0aW9uIHJldkJpbiAoeCwgbCwgTikge1xuICAgIGlmICh4ID09PSAwIHx8IHggPT09IE4gLSAxKSByZXR1cm4geDtcblxuICAgIHZhciByYiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJiIHw9ICh4ICYgMSkgPDwgKGwgLSBpIC0gMSk7XG4gICAgICB4ID4+PSAxO1xuICAgIH1cblxuICAgIHJldHVybiByYjtcbiAgfTtcblxuICAvLyBQZXJmb3JtcyBcInR3ZWVkbGluZ1wiIHBoYXNlLCB0aGVyZWZvcmUgJ2VtdWxhdGluZydcbiAgLy8gYmVoYXZpb3VyIG9mIHRoZSByZWN1cnNpdmUgYWxnb3JpdGhtXG4gIEZGVE0ucHJvdG90eXBlLnBlcm11dGUgPSBmdW5jdGlvbiBwZXJtdXRlIChyYnQsIHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHJ0d3NbaV0gPSByd3NbcmJ0W2ldXTtcbiAgICAgIGl0d3NbaV0gPSBpd3NbcmJ0W2ldXTtcbiAgICB9XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gdHJhbnNmb3JtIChyd3MsIGl3cywgcnR3cywgaXR3cywgTiwgcmJ0KSB7XG4gICAgdGhpcy5wZXJtdXRlKHJidCwgcndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4pO1xuXG4gICAgZm9yICh2YXIgcyA9IDE7IHMgPCBOOyBzIDw8PSAxKSB7XG4gICAgICB2YXIgbCA9IHMgPDwgMTtcblxuICAgICAgdmFyIHJ0d2RmID0gTWF0aC5jb3MoMiAqIE1hdGguUEkgLyBsKTtcbiAgICAgIHZhciBpdHdkZiA9IE1hdGguc2luKDIgKiBNYXRoLlBJIC8gbCk7XG5cbiAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgTjsgcCArPSBsKSB7XG4gICAgICAgIHZhciBydHdkZl8gPSBydHdkZjtcbiAgICAgICAgdmFyIGl0d2RmXyA9IGl0d2RmO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgczsgaisrKSB7XG4gICAgICAgICAgdmFyIHJlID0gcnR3c1twICsgal07XG4gICAgICAgICAgdmFyIGllID0gaXR3c1twICsgal07XG5cbiAgICAgICAgICB2YXIgcm8gPSBydHdzW3AgKyBqICsgc107XG4gICAgICAgICAgdmFyIGlvID0gaXR3c1twICsgaiArIHNdO1xuXG4gICAgICAgICAgdmFyIHJ4ID0gcnR3ZGZfICogcm8gLSBpdHdkZl8gKiBpbztcblxuICAgICAgICAgIGlvID0gcnR3ZGZfICogaW8gKyBpdHdkZl8gKiBybztcbiAgICAgICAgICBybyA9IHJ4O1xuXG4gICAgICAgICAgcnR3c1twICsgal0gPSByZSArIHJvO1xuICAgICAgICAgIGl0d3NbcCArIGpdID0gaWUgKyBpbztcblxuICAgICAgICAgIHJ0d3NbcCArIGogKyBzXSA9IHJlIC0gcm87XG4gICAgICAgICAgaXR3c1twICsgaiArIHNdID0gaWUgLSBpbztcblxuICAgICAgICAgIC8qIGpzaGludCBtYXhkZXB0aCA6IGZhbHNlICovXG4gICAgICAgICAgaWYgKGogIT09IGwpIHtcbiAgICAgICAgICAgIHJ4ID0gcnR3ZGYgKiBydHdkZl8gLSBpdHdkZiAqIGl0d2RmXztcblxuICAgICAgICAgICAgaXR3ZGZfID0gcnR3ZGYgKiBpdHdkZl8gKyBpdHdkZiAqIHJ0d2RmXztcbiAgICAgICAgICAgIHJ0d2RmXyA9IHJ4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5ndWVzc0xlbjEzYiA9IGZ1bmN0aW9uIGd1ZXNzTGVuMTNiIChuLCBtKSB7XG4gICAgdmFyIE4gPSBNYXRoLm1heChtLCBuKSB8IDE7XG4gICAgdmFyIG9kZCA9IE4gJiAxO1xuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKE4gPSBOIC8gMiB8IDA7IE47IE4gPSBOID4+PiAxKSB7XG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIDEgPDwgaSArIDEgKyBvZGQ7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuY29uanVnYXRlID0gZnVuY3Rpb24gY29uanVnYXRlIChyd3MsIGl3cywgTikge1xuICAgIGlmIChOIDw9IDEpIHJldHVybjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTiAvIDI7IGkrKykge1xuICAgICAgdmFyIHQgPSByd3NbaV07XG5cbiAgICAgIHJ3c1tpXSA9IHJ3c1tOIC0gaSAtIDFdO1xuICAgICAgcndzW04gLSBpIC0gMV0gPSB0O1xuXG4gICAgICB0ID0gaXdzW2ldO1xuXG4gICAgICBpd3NbaV0gPSAtaXdzW04gLSBpIC0gMV07XG4gICAgICBpd3NbTiAtIGkgLSAxXSA9IC10O1xuICAgIH1cbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5ub3JtYWxpemUxM2IgPSBmdW5jdGlvbiBub3JtYWxpemUxM2IgKHdzLCBOKSB7XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE4gLyAyOyBpKyspIHtcbiAgICAgIHZhciB3ID0gTWF0aC5yb3VuZCh3c1syICogaSArIDFdIC8gTikgKiAweDIwMDAgK1xuICAgICAgICBNYXRoLnJvdW5kKHdzWzIgKiBpXSAvIE4pICtcbiAgICAgICAgY2Fycnk7XG5cbiAgICAgIHdzW2ldID0gdyAmIDB4M2ZmZmZmZjtcblxuICAgICAgaWYgKHcgPCAweDQwMDAwMDApIHtcbiAgICAgICAgY2FycnkgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FycnkgPSB3IC8gMHg0MDAwMDAwIHwgMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gd3M7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuY29udmVydDEzYiA9IGZ1bmN0aW9uIGNvbnZlcnQxM2IgKHdzLCBsZW4sIHJ3cywgTikge1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2FycnkgPSBjYXJyeSArICh3c1tpXSB8IDApO1xuXG4gICAgICByd3NbMiAqIGldID0gY2FycnkgJiAweDFmZmY7IGNhcnJ5ID0gY2FycnkgPj4+IDEzO1xuICAgICAgcndzWzIgKiBpICsgMV0gPSBjYXJyeSAmIDB4MWZmZjsgY2FycnkgPSBjYXJyeSA+Pj4gMTM7XG4gICAgfVxuXG4gICAgLy8gUGFkIHdpdGggemVyb2VzXG4gICAgZm9yIChpID0gMiAqIGxlbjsgaSA8IE47ICsraSkge1xuICAgICAgcndzW2ldID0gMDtcbiAgICB9XG5cbiAgICBhc3NlcnQoY2FycnkgPT09IDApO1xuICAgIGFzc2VydCgoY2FycnkgJiB+MHgxZmZmKSA9PT0gMCk7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuc3R1YiA9IGZ1bmN0aW9uIHN0dWIgKE4pIHtcbiAgICB2YXIgcGggPSBuZXcgQXJyYXkoTik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHBoW2ldID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGg7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUubXVscCA9IGZ1bmN0aW9uIG11bHAgKHgsIHksIG91dCkge1xuICAgIHZhciBOID0gMiAqIHRoaXMuZ3Vlc3NMZW4xM2IoeC5sZW5ndGgsIHkubGVuZ3RoKTtcblxuICAgIHZhciByYnQgPSB0aGlzLm1ha2VSQlQoTik7XG5cbiAgICB2YXIgXyA9IHRoaXMuc3R1YihOKTtcblxuICAgIHZhciByd3MgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIHJ3c3QgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIGl3c3QgPSBuZXcgQXJyYXkoTik7XG5cbiAgICB2YXIgbnJ3cyA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgbnJ3c3QgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIG5pd3N0ID0gbmV3IEFycmF5KE4pO1xuXG4gICAgdmFyIHJtd3MgPSBvdXQud29yZHM7XG4gICAgcm13cy5sZW5ndGggPSBOO1xuXG4gICAgdGhpcy5jb252ZXJ0MTNiKHgud29yZHMsIHgubGVuZ3RoLCByd3MsIE4pO1xuICAgIHRoaXMuY29udmVydDEzYih5LndvcmRzLCB5Lmxlbmd0aCwgbnJ3cywgTik7XG5cbiAgICB0aGlzLnRyYW5zZm9ybShyd3MsIF8sIHJ3c3QsIGl3c3QsIE4sIHJidCk7XG4gICAgdGhpcy50cmFuc2Zvcm0obnJ3cywgXywgbnJ3c3QsIG5pd3N0LCBOLCByYnQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHZhciByeCA9IHJ3c3RbaV0gKiBucndzdFtpXSAtIGl3c3RbaV0gKiBuaXdzdFtpXTtcbiAgICAgIGl3c3RbaV0gPSByd3N0W2ldICogbml3c3RbaV0gKyBpd3N0W2ldICogbnJ3c3RbaV07XG4gICAgICByd3N0W2ldID0gcng7XG4gICAgfVxuXG4gICAgdGhpcy5jb25qdWdhdGUocndzdCwgaXdzdCwgTik7XG4gICAgdGhpcy50cmFuc2Zvcm0ocndzdCwgaXdzdCwgcm13cywgXywgTiwgcmJ0KTtcbiAgICB0aGlzLmNvbmp1Z2F0ZShybXdzLCBfLCBOKTtcbiAgICB0aGlzLm5vcm1hbGl6ZTEzYihybXdzLCBOKTtcblxuICAgIG91dC5uZWdhdGl2ZSA9IHgubmVnYXRpdmUgXiB5Lm5lZ2F0aXZlO1xuICAgIG91dC5sZW5ndGggPSB4Lmxlbmd0aCArIHkubGVuZ3RoO1xuICAgIHJldHVybiBvdXQuc3RyaXAoKTtcbiAgfTtcblxuICAvLyBNdWx0aXBseSBgdGhpc2AgYnkgYG51bWBcbiAgQk4ucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAobnVtKSB7XG4gICAgdmFyIG91dCA9IG5ldyBCTihudWxsKTtcbiAgICBvdXQud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoKTtcbiAgICByZXR1cm4gdGhpcy5tdWxUbyhudW0sIG91dCk7XG4gIH07XG5cbiAgLy8gTXVsdGlwbHkgZW1wbG95aW5nIEZGVFxuICBCTi5wcm90b3R5cGUubXVsZiA9IGZ1bmN0aW9uIG11bGYgKG51bSkge1xuICAgIHZhciBvdXQgPSBuZXcgQk4obnVsbCk7XG4gICAgb3V0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aCk7XG4gICAgcmV0dXJuIGp1bWJvTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICB9O1xuXG4gIC8vIEluLXBsYWNlIE11bHRpcGxpY2F0aW9uXG4gIEJOLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5tdWxUbyhudW0sIHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pbXVsbiA9IGZ1bmN0aW9uIGltdWxuIChudW0pIHtcbiAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuICAgIGFzc2VydChudW0gPCAweDQwMDAwMDApO1xuXG4gICAgLy8gQ2FycnlcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSAodGhpcy53b3Jkc1tpXSB8IDApICogbnVtO1xuICAgICAgdmFyIGxvID0gKHcgJiAweDNmZmZmZmYpICsgKGNhcnJ5ICYgMHgzZmZmZmZmKTtcbiAgICAgIGNhcnJ5ID4+PSAyNjtcbiAgICAgIGNhcnJ5ICs9ICh3IC8gMHg0MDAwMDAwKSB8IDA7XG4gICAgICAvLyBOT1RFOiBsbyBpcyAyN2JpdCBtYXhpbXVtXG4gICAgICBjYXJyeSArPSBsbyA+Pj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gbG8gJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5tdWxuID0gZnVuY3Rpb24gbXVsbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbXVsbihudW0pO1xuICB9O1xuXG4gIC8vIGB0aGlzYCAqIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24gc3FyICgpIHtcbiAgICByZXR1cm4gdGhpcy5tdWwodGhpcyk7XG4gIH07XG5cbiAgLy8gYHRoaXNgICogYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pc3FyID0gZnVuY3Rpb24gaXNxciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW11bCh0aGlzLmNsb25lKCkpO1xuICB9O1xuXG4gIC8vIE1hdGgucG93KGB0aGlzYCwgYG51bWApXG4gIEJOLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiBwb3cgKG51bSkge1xuICAgIHZhciB3ID0gdG9CaXRBcnJheShudW0pO1xuICAgIGlmICh3Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIG5ldyBCTigxKTtcblxuICAgIC8vIFNraXAgbGVhZGluZyB6ZXJvZXNcbiAgICB2YXIgcmVzID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHcubGVuZ3RoOyBpKyssIHJlcyA9IHJlcy5zcXIoKSkge1xuICAgICAgaWYgKHdbaV0gIT09IDApIGJyZWFrO1xuICAgIH1cblxuICAgIGlmICgrK2kgPCB3Lmxlbmd0aCkge1xuICAgICAgZm9yICh2YXIgcSA9IHJlcy5zcXIoKTsgaSA8IHcubGVuZ3RoOyBpKyssIHEgPSBxLnNxcigpKSB7XG4gICAgICAgIGlmICh3W2ldID09PSAwKSBjb250aW51ZTtcblxuICAgICAgICByZXMgPSByZXMubXVsKHEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gU2hpZnQtbGVmdCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVzaGxuID0gZnVuY3Rpb24gaXVzaGxuIChiaXRzKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuICAgIHZhciByID0gYml0cyAlIDI2O1xuICAgIHZhciBzID0gKGJpdHMgLSByKSAvIDI2O1xuICAgIHZhciBjYXJyeU1hc2sgPSAoMHgzZmZmZmZmID4+PiAoMjYgLSByKSkgPDwgKDI2IC0gcik7XG4gICAgdmFyIGk7XG5cbiAgICBpZiAociAhPT0gMCkge1xuICAgICAgdmFyIGNhcnJ5ID0gMDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5ld0NhcnJ5ID0gdGhpcy53b3Jkc1tpXSAmIGNhcnJ5TWFzaztcbiAgICAgICAgdmFyIGMgPSAoKHRoaXMud29yZHNbaV0gfCAwKSAtIG5ld0NhcnJ5KSA8PCByO1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYyB8IGNhcnJ5O1xuICAgICAgICBjYXJyeSA9IG5ld0NhcnJ5ID4+PiAoMjYgLSByKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhcnJ5KSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcbiAgICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocyAhPT0gMCkge1xuICAgICAgZm9yIChpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB0aGlzLndvcmRzW2kgKyBzXSA9IHRoaXMud29yZHNbaV07XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGVuZ3RoICs9IHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNobG4gPSBmdW5jdGlvbiBpc2hsbiAoYml0cykge1xuICAgIC8vIFRPRE8oaW5kdXRueSk6IGltcGxlbWVudCBtZVxuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdXNobG4oYml0cyk7XG4gIH07XG5cbiAgLy8gU2hpZnQtcmlnaHQgaW4tcGxhY2VcbiAgLy8gTk9URTogYGhpbnRgIGlzIGEgbG93ZXN0IGJpdCBiZWZvcmUgdHJhaWxpbmcgemVyb2VzXG4gIC8vIE5PVEU6IGlmIGBleHRlbmRlZGAgaXMgcHJlc2VudCAtIGl0IHdpbGwgYmUgZmlsbGVkIHdpdGggZGVzdHJveWVkIGJpdHNcbiAgQk4ucHJvdG90eXBlLml1c2hybiA9IGZ1bmN0aW9uIGl1c2hybiAoYml0cywgaGludCwgZXh0ZW5kZWQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gICAgdmFyIGg7XG4gICAgaWYgKGhpbnQpIHtcbiAgICAgIGggPSAoaGludCAtIChoaW50ICUgMjYpKSAvIDI2O1xuICAgIH0gZWxzZSB7XG4gICAgICBoID0gMDtcbiAgICB9XG5cbiAgICB2YXIgciA9IGJpdHMgJSAyNjtcbiAgICB2YXIgcyA9IE1hdGgubWluKChiaXRzIC0gcikgLyAyNiwgdGhpcy5sZW5ndGgpO1xuICAgIHZhciBtYXNrID0gMHgzZmZmZmZmIF4gKCgweDNmZmZmZmYgPj4+IHIpIDw8IHIpO1xuICAgIHZhciBtYXNrZWRXb3JkcyA9IGV4dGVuZGVkO1xuXG4gICAgaCAtPSBzO1xuICAgIGggPSBNYXRoLm1heCgwLCBoKTtcblxuICAgIC8vIEV4dGVuZGVkIG1vZGUsIGNvcHkgbWFza2VkIHBhcnRcbiAgICBpZiAobWFza2VkV29yZHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICAgIG1hc2tlZFdvcmRzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICAgIG1hc2tlZFdvcmRzLmxlbmd0aCA9IHM7XG4gICAgfVxuXG4gICAgaWYgKHMgPT09IDApIHtcbiAgICAgIC8vIE5vLW9wLCB3ZSBzaG91bGQgbm90IG1vdmUgYW55dGhpbmcgYXQgYWxsXG4gICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IHMpIHtcbiAgICAgIHRoaXMubGVuZ3RoIC09IHM7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpICsgc107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH1cblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yIChpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDAgJiYgKGNhcnJ5ICE9PSAwIHx8IGkgPj0gaCk7IGktLSkge1xuICAgICAgdmFyIHdvcmQgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAoY2FycnkgPDwgKDI2IC0gcikpIHwgKHdvcmQgPj4+IHIpO1xuICAgICAgY2FycnkgPSB3b3JkICYgbWFzaztcbiAgICB9XG5cbiAgICAvLyBQdXNoIGNhcnJpZWQgYml0cyBhcyBhIG1hc2tcbiAgICBpZiAobWFza2VkV29yZHMgJiYgY2FycnkgIT09IDApIHtcbiAgICAgIG1hc2tlZFdvcmRzLndvcmRzW21hc2tlZFdvcmRzLmxlbmd0aCsrXSA9IGNhcnJ5O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNocm4gPSBmdW5jdGlvbiBpc2hybiAoYml0cywgaGludCwgZXh0ZW5kZWQpIHtcbiAgICAvLyBUT0RPKGluZHV0bnkpOiBpbXBsZW1lbnQgbWVcbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVzaHJuKGJpdHMsIGhpbnQsIGV4dGVuZGVkKTtcbiAgfTtcblxuICAvLyBTaGlmdC1sZWZ0XG4gIEJOLnByb3RvdHlwZS5zaGxuID0gZnVuY3Rpb24gc2hsbiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXNobG4oYml0cyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVzaGxuID0gZnVuY3Rpb24gdXNobG4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLml1c2hsbihiaXRzKTtcbiAgfTtcblxuICAvLyBTaGlmdC1yaWdodFxuICBCTi5wcm90b3R5cGUuc2hybiA9IGZ1bmN0aW9uIHNocm4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzaHJuKGJpdHMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51c2hybiA9IGZ1bmN0aW9uIHVzaHJuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXNocm4oYml0cyk7XG4gIH07XG5cbiAgLy8gVGVzdCBpZiBuIGJpdCBpcyBzZXRcbiAgQk4ucHJvdG90eXBlLnRlc3RuID0gZnVuY3Rpb24gdGVzdG4gKGJpdCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyAmJiBiaXQgPj0gMCk7XG4gICAgdmFyIHIgPSBiaXQgJSAyNjtcbiAgICB2YXIgcyA9IChiaXQgLSByKSAvIDI2O1xuICAgIHZhciBxID0gMSA8PCByO1xuXG4gICAgLy8gRmFzdCBjYXNlOiBiaXQgaXMgbXVjaCBoaWdoZXIgdGhhbiBhbGwgZXhpc3Rpbmcgd29yZHNcbiAgICBpZiAodGhpcy5sZW5ndGggPD0gcykgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gQ2hlY2sgYml0IGFuZCByZXR1cm5cbiAgICB2YXIgdyA9IHRoaXMud29yZHNbc107XG5cbiAgICByZXR1cm4gISEodyAmIHEpO1xuICB9O1xuXG4gIC8vIFJldHVybiBvbmx5IGxvd2VycyBiaXRzIG9mIG51bWJlciAoaW4tcGxhY2UpXG4gIEJOLnByb3RvdHlwZS5pbWFza24gPSBmdW5jdGlvbiBpbWFza24gKGJpdHMpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gICAgdmFyIHIgPSBiaXRzICUgMjY7XG4gICAgdmFyIHMgPSAoYml0cyAtIHIpIC8gMjY7XG5cbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCwgJ2ltYXNrbiB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmUgbnVtYmVycycpO1xuXG4gICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmIChyICE9PSAwKSB7XG4gICAgICBzKys7XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5taW4ocywgdGhpcy5sZW5ndGgpO1xuXG4gICAgaWYgKHIgIT09IDApIHtcbiAgICAgIHZhciBtYXNrID0gMHgzZmZmZmZmIF4gKCgweDNmZmZmZmYgPj4+IHIpIDw8IHIpO1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdICY9IG1hc2s7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gb25seSBsb3dlcnMgYml0cyBvZiBudW1iZXJcbiAgQk4ucHJvdG90eXBlLm1hc2tuID0gZnVuY3Rpb24gbWFza24gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmltYXNrbihiaXRzKTtcbiAgfTtcblxuICAvLyBBZGQgcGxhaW4gbnVtYmVyIGBudW1gIHRvIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuaWFkZG4gPSBmdW5jdGlvbiBpYWRkbiAobnVtKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcbiAgICBpZiAobnVtIDwgMCkgcmV0dXJuIHRoaXMuaXN1Ym4oLW51bSk7XG5cbiAgICAvLyBQb3NzaWJsZSBzaWduIGNoYW5nZVxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgKHRoaXMud29yZHNbMF0gfCAwKSA8IG51bSkge1xuICAgICAgICB0aGlzLndvcmRzWzBdID0gbnVtIC0gKHRoaXMud29yZHNbMF0gfCAwKTtcbiAgICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMuaXN1Ym4obnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIHdpdGhvdXQgY2hlY2tzXG4gICAgcmV0dXJuIHRoaXMuX2lhZGRuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pYWRkbiA9IGZ1bmN0aW9uIF9pYWRkbiAobnVtKSB7XG4gICAgdGhpcy53b3Jkc1swXSArPSBudW07XG5cbiAgICAvLyBDYXJyeVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGggJiYgdGhpcy53b3Jkc1tpXSA+PSAweDQwMDAwMDA7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSAtPSAweDQwMDAwMDA7XG4gICAgICBpZiAoaSA9PT0gdGhpcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHRoaXMud29yZHNbaSArIDFdID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud29yZHNbaSArIDFdKys7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIGkgKyAxKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFN1YnRyYWN0IHBsYWluIG51bWJlciBgbnVtYCBmcm9tIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuaXN1Ym4gPSBmdW5jdGlvbiBpc3VibiAobnVtKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcbiAgICBpZiAobnVtIDwgMCkgcmV0dXJuIHRoaXMuaWFkZG4oLW51bSk7XG5cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmlhZGRuKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMud29yZHNbMF0gLT0gbnVtO1xuXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPCAwKSB7XG4gICAgICB0aGlzLndvcmRzWzBdID0gLXRoaXMud29yZHNbMF07XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2FycnlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGggJiYgdGhpcy53b3Jkc1tpXSA8IDA7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldICs9IDB4NDAwMDAwMDtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgMV0gLT0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5hZGRuID0gZnVuY3Rpb24gYWRkbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWRkbihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5zdWJuID0gZnVuY3Rpb24gc3VibiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc3VibihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pYWJzID0gZnVuY3Rpb24gaWFicyAoKSB7XG4gICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gYWJzICgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhYnMoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2lzaGxuc3VibXVsID0gZnVuY3Rpb24gX2lzaGxuc3VibXVsIChudW0sIG11bCwgc2hpZnQpIHtcbiAgICB2YXIgbGVuID0gbnVtLmxlbmd0aCArIHNoaWZ0O1xuICAgIHZhciBpO1xuXG4gICAgdGhpcy5fZXhwYW5kKGxlbik7XG5cbiAgICB2YXIgdztcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHcgPSAodGhpcy53b3Jkc1tpICsgc2hpZnRdIHwgMCkgKyBjYXJyeTtcbiAgICAgIHZhciByaWdodCA9IChudW0ud29yZHNbaV0gfCAwKSAqIG11bDtcbiAgICAgIHcgLT0gcmlnaHQgJiAweDNmZmZmZmY7XG4gICAgICBjYXJyeSA9ICh3ID4+IDI2KSAtICgocmlnaHQgLyAweDQwMDAwMDApIHwgMCk7XG4gICAgICB0aGlzLndvcmRzW2kgKyBzaGlmdF0gPSB3ICYgMHgzZmZmZmZmO1xuICAgIH1cbiAgICBmb3IgKDsgaSA8IHRoaXMubGVuZ3RoIC0gc2hpZnQ7IGkrKykge1xuICAgICAgdyA9ICh0aGlzLndvcmRzW2kgKyBzaGlmdF0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSB3ID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpICsgc2hpZnRdID0gdyAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICBpZiAoY2FycnkgPT09IDApIHJldHVybiB0aGlzLnN0cmlwKCk7XG5cbiAgICAvLyBTdWJ0cmFjdGlvbiBvdmVyZmxvd1xuICAgIGFzc2VydChjYXJyeSA9PT0gLTEpO1xuICAgIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdyA9IC0odGhpcy53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHcgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdyAmIDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fd29yZERpdiA9IGZ1bmN0aW9uIF93b3JkRGl2IChudW0sIG1vZGUpIHtcbiAgICB2YXIgc2hpZnQgPSB0aGlzLmxlbmd0aCAtIG51bS5sZW5ndGg7XG5cbiAgICB2YXIgYSA9IHRoaXMuY2xvbmUoKTtcbiAgICB2YXIgYiA9IG51bTtcblxuICAgIC8vIE5vcm1hbGl6ZVxuICAgIHZhciBiaGkgPSBiLndvcmRzW2IubGVuZ3RoIC0gMV0gfCAwO1xuICAgIHZhciBiaGlCaXRzID0gdGhpcy5fY291bnRCaXRzKGJoaSk7XG4gICAgc2hpZnQgPSAyNiAtIGJoaUJpdHM7XG4gICAgaWYgKHNoaWZ0ICE9PSAwKSB7XG4gICAgICBiID0gYi51c2hsbihzaGlmdCk7XG4gICAgICBhLml1c2hsbihzaGlmdCk7XG4gICAgICBiaGkgPSBiLndvcmRzW2IubGVuZ3RoIC0gMV0gfCAwO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgcXVvdGllbnRcbiAgICB2YXIgbSA9IGEubGVuZ3RoIC0gYi5sZW5ndGg7XG4gICAgdmFyIHE7XG5cbiAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcbiAgICAgIHEgPSBuZXcgQk4obnVsbCk7XG4gICAgICBxLmxlbmd0aCA9IG0gKyAxO1xuICAgICAgcS53b3JkcyA9IG5ldyBBcnJheShxLmxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcS53b3Jkc1tpXSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRpZmYgPSBhLmNsb25lKCkuX2lzaGxuc3VibXVsKGIsIDEsIG0pO1xuICAgIGlmIChkaWZmLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICBhID0gZGlmZjtcbiAgICAgIGlmIChxKSB7XG4gICAgICAgIHEud29yZHNbbV0gPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGogPSBtIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgIHZhciBxaiA9IChhLndvcmRzW2IubGVuZ3RoICsgal0gfCAwKSAqIDB4NDAwMDAwMCArXG4gICAgICAgIChhLndvcmRzW2IubGVuZ3RoICsgaiAtIDFdIHwgMCk7XG5cbiAgICAgIC8vIE5PVEU6IChxaiAvIGJoaSkgaXMgKDB4M2ZmZmZmZiAqIDB4NDAwMDAwMCArIDB4M2ZmZmZmZikgLyAweDIwMDAwMDAgbWF4XG4gICAgICAvLyAoMHg3ZmZmZmZmKVxuICAgICAgcWogPSBNYXRoLm1pbigocWogLyBiaGkpIHwgMCwgMHgzZmZmZmZmKTtcblxuICAgICAgYS5faXNobG5zdWJtdWwoYiwgcWosIGopO1xuICAgICAgd2hpbGUgKGEubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgcWotLTtcbiAgICAgICAgYS5uZWdhdGl2ZSA9IDA7XG4gICAgICAgIGEuX2lzaGxuc3VibXVsKGIsIDEsIGopO1xuICAgICAgICBpZiAoIWEuaXNaZXJvKCkpIHtcbiAgICAgICAgICBhLm5lZ2F0aXZlIF49IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChxKSB7XG4gICAgICAgIHEud29yZHNbal0gPSBxajtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHEpIHtcbiAgICAgIHEuc3RyaXAoKTtcbiAgICB9XG4gICAgYS5zdHJpcCgpO1xuXG4gICAgLy8gRGVub3JtYWxpemVcbiAgICBpZiAobW9kZSAhPT0gJ2RpdicgJiYgc2hpZnQgIT09IDApIHtcbiAgICAgIGEuaXVzaHJuKHNoaWZ0KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGl2OiBxIHx8IG51bGwsXG4gICAgICBtb2Q6IGFcbiAgICB9O1xuICB9O1xuXG4gIC8vIE5PVEU6IDEpIGBtb2RlYCBjYW4gYmUgc2V0IHRvIGBtb2RgIHRvIHJlcXVlc3QgbW9kIG9ubHksXG4gIC8vICAgICAgIHRvIGBkaXZgIHRvIHJlcXVlc3QgZGl2IG9ubHksIG9yIGJlIGFic2VudCB0b1xuICAvLyAgICAgICByZXF1ZXN0IGJvdGggZGl2ICYgbW9kXG4gIC8vICAgICAgIDIpIGBwb3NpdGl2ZWAgaXMgdHJ1ZSBpZiB1bnNpZ25lZCBtb2QgaXMgcmVxdWVzdGVkXG4gIEJOLnByb3RvdHlwZS5kaXZtb2QgPSBmdW5jdGlvbiBkaXZtb2QgKG51bSwgbW9kZSwgcG9zaXRpdmUpIHtcbiAgICBhc3NlcnQoIW51bS5pc1plcm8oKSk7XG5cbiAgICBpZiAodGhpcy5pc1plcm8oKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBuZXcgQk4oMCksXG4gICAgICAgIG1vZDogbmV3IEJOKDApXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBkaXYsIG1vZCwgcmVzO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgcmVzID0gdGhpcy5uZWcoKS5kaXZtb2QobnVtLCBtb2RlKTtcblxuICAgICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG4gICAgICAgIGRpdiA9IHJlcy5kaXYubmVnKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtb2RlICE9PSAnZGl2Jykge1xuICAgICAgICBtb2QgPSByZXMubW9kLm5lZygpO1xuICAgICAgICBpZiAocG9zaXRpdmUgJiYgbW9kLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgICAgbW9kLmlhZGQobnVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IGRpdixcbiAgICAgICAgbW9kOiBtb2RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICByZXMgPSB0aGlzLmRpdm1vZChudW0ubmVnKCksIG1vZGUpO1xuXG4gICAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcbiAgICAgICAgZGl2ID0gcmVzLmRpdi5uZWcoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBkaXYsXG4gICAgICAgIG1vZDogcmVzLm1vZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoKHRoaXMubmVnYXRpdmUgJiBudW0ubmVnYXRpdmUpICE9PSAwKSB7XG4gICAgICByZXMgPSB0aGlzLm5lZygpLmRpdm1vZChudW0ubmVnKCksIG1vZGUpO1xuXG4gICAgICBpZiAobW9kZSAhPT0gJ2RpdicpIHtcbiAgICAgICAgbW9kID0gcmVzLm1vZC5uZWcoKTtcbiAgICAgICAgaWYgKHBvc2l0aXZlICYmIG1vZC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICAgIG1vZC5pc3ViKG51bSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiByZXMuZGl2LFxuICAgICAgICBtb2Q6IG1vZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBCb3RoIG51bWJlcnMgYXJlIHBvc2l0aXZlIGF0IHRoaXMgcG9pbnRcblxuICAgIC8vIFN0cmlwIGJvdGggbnVtYmVycyB0byBhcHByb3hpbWF0ZSBzaGlmdCB2YWx1ZVxuICAgIGlmIChudW0ubGVuZ3RoID4gdGhpcy5sZW5ndGggfHwgdGhpcy5jbXAobnVtKSA8IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogbmV3IEJOKDApLFxuICAgICAgICBtb2Q6IHRoaXNcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gVmVyeSBzaG9ydCByZWR1Y3Rpb25cbiAgICBpZiAobnVtLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKG1vZGUgPT09ICdkaXYnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGl2OiB0aGlzLmRpdm4obnVtLndvcmRzWzBdKSxcbiAgICAgICAgICBtb2Q6IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1vZGUgPT09ICdtb2QnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGl2OiBudWxsLFxuICAgICAgICAgIG1vZDogbmV3IEJOKHRoaXMubW9kbihudW0ud29yZHNbMF0pKVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IHRoaXMuZGl2bihudW0ud29yZHNbMF0pLFxuICAgICAgICBtb2Q6IG5ldyBCTih0aGlzLm1vZG4obnVtLndvcmRzWzBdKSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3dvcmREaXYobnVtLCBtb2RlKTtcbiAgfTtcblxuICAvLyBGaW5kIGB0aGlzYCAvIGBudW1gXG4gIEJOLnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbiBkaXYgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdkaXYnLCBmYWxzZSkuZGl2O1xuICB9O1xuXG4gIC8vIEZpbmQgYHRoaXNgICUgYG51bWBcbiAgQk4ucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uIG1vZCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ21vZCcsIGZhbHNlKS5tb2Q7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVtb2QgPSBmdW5jdGlvbiB1bW9kIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnbW9kJywgdHJ1ZSkubW9kO1xuICB9O1xuXG4gIC8vIEZpbmQgUm91bmQoYHRoaXNgIC8gYG51bWApXG4gIEJOLnByb3RvdHlwZS5kaXZSb3VuZCA9IGZ1bmN0aW9uIGRpdlJvdW5kIChudW0pIHtcbiAgICB2YXIgZG0gPSB0aGlzLmRpdm1vZChudW0pO1xuXG4gICAgLy8gRmFzdCBjYXNlIC0gZXhhY3QgZGl2aXNpb25cbiAgICBpZiAoZG0ubW9kLmlzWmVybygpKSByZXR1cm4gZG0uZGl2O1xuXG4gICAgdmFyIG1vZCA9IGRtLmRpdi5uZWdhdGl2ZSAhPT0gMCA/IGRtLm1vZC5pc3ViKG51bSkgOiBkbS5tb2Q7XG5cbiAgICB2YXIgaGFsZiA9IG51bS51c2hybigxKTtcbiAgICB2YXIgcjIgPSBudW0uYW5kbG4oMSk7XG4gICAgdmFyIGNtcCA9IG1vZC5jbXAoaGFsZik7XG5cbiAgICAvLyBSb3VuZCBkb3duXG4gICAgaWYgKGNtcCA8IDAgfHwgcjIgPT09IDEgJiYgY21wID09PSAwKSByZXR1cm4gZG0uZGl2O1xuXG4gICAgLy8gUm91bmQgdXBcbiAgICByZXR1cm4gZG0uZGl2Lm5lZ2F0aXZlICE9PSAwID8gZG0uZGl2LmlzdWJuKDEpIDogZG0uZGl2LmlhZGRuKDEpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5tb2RuID0gZnVuY3Rpb24gbW9kbiAobnVtKSB7XG4gICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYpO1xuICAgIHZhciBwID0gKDEgPDwgMjYpICUgbnVtO1xuXG4gICAgdmFyIGFjYyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGFjYyA9IChwICogYWNjICsgKHRoaXMud29yZHNbaV0gfCAwKSkgJSBudW07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfTtcblxuICAvLyBJbi1wbGFjZSBkaXZpc2lvbiBieSBudW1iZXJcbiAgQk4ucHJvdG90eXBlLmlkaXZuID0gZnVuY3Rpb24gaWRpdm4gKG51bSkge1xuICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmKTtcblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciB3ID0gKHRoaXMud29yZHNbaV0gfCAwKSArIGNhcnJ5ICogMHg0MDAwMDAwO1xuICAgICAgdGhpcy53b3Jkc1tpXSA9ICh3IC8gbnVtKSB8IDA7XG4gICAgICBjYXJyeSA9IHcgJSBudW07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZGl2biA9IGZ1bmN0aW9uIGRpdm4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWRpdm4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZWdjZCA9IGZ1bmN0aW9uIGVnY2QgKHApIHtcbiAgICBhc3NlcnQocC5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgYXNzZXJ0KCFwLmlzWmVybygpKTtcblxuICAgIHZhciB4ID0gdGhpcztcbiAgICB2YXIgeSA9IHAuY2xvbmUoKTtcblxuICAgIGlmICh4Lm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB4ID0geC51bW9kKHApO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0geC5jbG9uZSgpO1xuICAgIH1cblxuICAgIC8vIEEgKiB4ICsgQiAqIHkgPSB4XG4gICAgdmFyIEEgPSBuZXcgQk4oMSk7XG4gICAgdmFyIEIgPSBuZXcgQk4oMCk7XG5cbiAgICAvLyBDICogeCArIEQgKiB5ID0geVxuICAgIHZhciBDID0gbmV3IEJOKDApO1xuICAgIHZhciBEID0gbmV3IEJOKDEpO1xuXG4gICAgdmFyIGcgPSAwO1xuXG4gICAgd2hpbGUgKHguaXNFdmVuKCkgJiYgeS5pc0V2ZW4oKSkge1xuICAgICAgeC5pdXNocm4oMSk7XG4gICAgICB5Lml1c2hybigxKTtcbiAgICAgICsrZztcbiAgICB9XG5cbiAgICB2YXIgeXAgPSB5LmNsb25lKCk7XG4gICAgdmFyIHhwID0geC5jbG9uZSgpO1xuXG4gICAgd2hpbGUgKCF4LmlzWmVybygpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaW0gPSAxOyAoeC53b3Jkc1swXSAmIGltKSA9PT0gMCAmJiBpIDwgMjY7ICsraSwgaW0gPDw9IDEpO1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIHguaXVzaHJuKGkpO1xuICAgICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICAgIGlmIChBLmlzT2RkKCkgfHwgQi5pc09kZCgpKSB7XG4gICAgICAgICAgICBBLmlhZGQoeXApO1xuICAgICAgICAgICAgQi5pc3ViKHhwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBBLml1c2hybigxKTtcbiAgICAgICAgICBCLml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqID0gMCwgam0gPSAxOyAoeS53b3Jkc1swXSAmIGptKSA9PT0gMCAmJiBqIDwgMjY7ICsraiwgam0gPDw9IDEpO1xuICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgIHkuaXVzaHJuKGopO1xuICAgICAgICB3aGlsZSAoai0tID4gMCkge1xuICAgICAgICAgIGlmIChDLmlzT2RkKCkgfHwgRC5pc09kZCgpKSB7XG4gICAgICAgICAgICBDLmlhZGQoeXApO1xuICAgICAgICAgICAgRC5pc3ViKHhwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBDLml1c2hybigxKTtcbiAgICAgICAgICBELml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoeC5jbXAoeSkgPj0gMCkge1xuICAgICAgICB4LmlzdWIoeSk7XG4gICAgICAgIEEuaXN1YihDKTtcbiAgICAgICAgQi5pc3ViKEQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeS5pc3ViKHgpO1xuICAgICAgICBDLmlzdWIoQSk7XG4gICAgICAgIEQuaXN1YihCKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYTogQyxcbiAgICAgIGI6IEQsXG4gICAgICBnY2Q6IHkuaXVzaGxuKGcpXG4gICAgfTtcbiAgfTtcblxuICAvLyBUaGlzIGlzIHJlZHVjZWQgaW5jYXJuYXRpb24gb2YgdGhlIGJpbmFyeSBFRUFcbiAgLy8gYWJvdmUsIGRlc2lnbmF0ZWQgdG8gaW52ZXJ0IG1lbWJlcnMgb2YgdGhlXG4gIC8vIF9wcmltZV8gZmllbGRzIEYocCkgYXQgYSBtYXhpbWFsIHNwZWVkXG4gIEJOLnByb3RvdHlwZS5faW52bXAgPSBmdW5jdGlvbiBfaW52bXAgKHApIHtcbiAgICBhc3NlcnQocC5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgYXNzZXJ0KCFwLmlzWmVybygpKTtcblxuICAgIHZhciBhID0gdGhpcztcbiAgICB2YXIgYiA9IHAuY2xvbmUoKTtcblxuICAgIGlmIChhLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBhID0gYS51bW9kKHApO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gYS5jbG9uZSgpO1xuICAgIH1cblxuICAgIHZhciB4MSA9IG5ldyBCTigxKTtcbiAgICB2YXIgeDIgPSBuZXcgQk4oMCk7XG5cbiAgICB2YXIgZGVsdGEgPSBiLmNsb25lKCk7XG5cbiAgICB3aGlsZSAoYS5jbXBuKDEpID4gMCAmJiBiLmNtcG4oMSkgPiAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaW0gPSAxOyAoYS53b3Jkc1swXSAmIGltKSA9PT0gMCAmJiBpIDwgMjY7ICsraSwgaW0gPDw9IDEpO1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIGEuaXVzaHJuKGkpO1xuICAgICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICAgIGlmICh4MS5pc09kZCgpKSB7XG4gICAgICAgICAgICB4MS5pYWRkKGRlbHRhKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4MS5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGptID0gMTsgKGIud29yZHNbMF0gJiBqbSkgPT09IDAgJiYgaiA8IDI2OyArK2osIGptIDw8PSAxKTtcbiAgICAgIGlmIChqID4gMCkge1xuICAgICAgICBiLml1c2hybihqKTtcbiAgICAgICAgd2hpbGUgKGotLSA+IDApIHtcbiAgICAgICAgICBpZiAoeDIuaXNPZGQoKSkge1xuICAgICAgICAgICAgeDIuaWFkZChkZWx0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeDIuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhLmNtcChiKSA+PSAwKSB7XG4gICAgICAgIGEuaXN1YihiKTtcbiAgICAgICAgeDEuaXN1Yih4Mik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiLmlzdWIoYSk7XG4gICAgICAgIHgyLmlzdWIoeDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXM7XG4gICAgaWYgKGEuY21wbigxKSA9PT0gMCkge1xuICAgICAgcmVzID0geDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IHgyO1xuICAgIH1cblxuICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcy5pYWRkKHApO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmdjZCA9IGZ1bmN0aW9uIGdjZCAobnVtKSB7XG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiBudW0uYWJzKCk7XG4gICAgaWYgKG51bS5pc1plcm8oKSkgcmV0dXJuIHRoaXMuYWJzKCk7XG5cbiAgICB2YXIgYSA9IHRoaXMuY2xvbmUoKTtcbiAgICB2YXIgYiA9IG51bS5jbG9uZSgpO1xuICAgIGEubmVnYXRpdmUgPSAwO1xuICAgIGIubmVnYXRpdmUgPSAwO1xuXG4gICAgLy8gUmVtb3ZlIGNvbW1vbiBmYWN0b3Igb2YgdHdvXG4gICAgZm9yICh2YXIgc2hpZnQgPSAwOyBhLmlzRXZlbigpICYmIGIuaXNFdmVuKCk7IHNoaWZ0KyspIHtcbiAgICAgIGEuaXVzaHJuKDEpO1xuICAgICAgYi5pdXNocm4oMSk7XG4gICAgfVxuXG4gICAgZG8ge1xuICAgICAgd2hpbGUgKGEuaXNFdmVuKCkpIHtcbiAgICAgICAgYS5pdXNocm4oMSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoYi5pc0V2ZW4oKSkge1xuICAgICAgICBiLml1c2hybigxKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHIgPSBhLmNtcChiKTtcbiAgICAgIGlmIChyIDwgMCkge1xuICAgICAgICAvLyBTd2FwIGBhYCBhbmQgYGJgIHRvIG1ha2UgYGFgIGFsd2F5cyBiaWdnZXIgdGhhbiBgYmBcbiAgICAgICAgdmFyIHQgPSBhO1xuICAgICAgICBhID0gYjtcbiAgICAgICAgYiA9IHQ7XG4gICAgICB9IGVsc2UgaWYgKHIgPT09IDAgfHwgYi5jbXBuKDEpID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBhLmlzdWIoYik7XG4gICAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgICByZXR1cm4gYi5pdXNobG4oc2hpZnQpO1xuICB9O1xuXG4gIC8vIEludmVydCBudW1iZXIgaW4gdGhlIGZpZWxkIEYobnVtKVxuICBCTi5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmVnY2QobnVtKS5hLnVtb2QobnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gaXNFdmVuICgpIHtcbiAgICByZXR1cm4gKHRoaXMud29yZHNbMF0gJiAxKSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiBpc09kZCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDE7XG4gIH07XG5cbiAgLy8gQW5kIGZpcnN0IHdvcmQgYW5kIG51bVxuICBCTi5wcm90b3R5cGUuYW5kbG4gPSBmdW5jdGlvbiBhbmRsbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMud29yZHNbMF0gJiBudW07XG4gIH07XG5cbiAgLy8gSW5jcmVtZW50IGF0IHRoZSBiaXQgcG9zaXRpb24gaW4tbGluZVxuICBCTi5wcm90b3R5cGUuYmluY24gPSBmdW5jdGlvbiBiaW5jbiAoYml0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInKTtcbiAgICB2YXIgciA9IGJpdCAlIDI2O1xuICAgIHZhciBzID0gKGJpdCAtIHIpIC8gMjY7XG4gICAgdmFyIHEgPSAxIDw8IHI7XG5cbiAgICAvLyBGYXN0IGNhc2U6IGJpdCBpcyBtdWNoIGhpZ2hlciB0aGFuIGFsbCBleGlzdGluZyB3b3Jkc1xuICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSB7XG4gICAgICB0aGlzLl9leHBhbmQocyArIDEpO1xuICAgICAgdGhpcy53b3Jkc1tzXSB8PSBxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIGJpdCBhbmQgcHJvcGFnYXRlLCBpZiBuZWVkZWRcbiAgICB2YXIgY2FycnkgPSBxO1xuICAgIGZvciAodmFyIGkgPSBzOyBjYXJyeSAhPT0gMCAmJiBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHcgKz0gY2Fycnk7XG4gICAgICBjYXJyeSA9IHcgPj4+IDI2O1xuICAgICAgdyAmPSAweDNmZmZmZmY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdztcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gaXNaZXJvICgpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuY21wbiA9IGZ1bmN0aW9uIGNtcG4gKG51bSkge1xuICAgIHZhciBuZWdhdGl2ZSA9IG51bSA8IDA7XG5cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiAhbmVnYXRpdmUpIHJldHVybiAtMTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBuZWdhdGl2ZSkgcmV0dXJuIDE7XG5cbiAgICB0aGlzLnN0cmlwKCk7XG5cbiAgICB2YXIgcmVzO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJlcyA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuZWdhdGl2ZSkge1xuICAgICAgICBudW0gPSAtbnVtO1xuICAgICAgfVxuXG4gICAgICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZiwgJ051bWJlciBpcyB0b28gYmlnJyk7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1swXSB8IDA7XG4gICAgICByZXMgPSB3ID09PSBudW0gPyAwIDogdyA8IG51bSA/IC0xIDogMTtcbiAgICB9XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHJldHVybiAtcmVzIHwgMDtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIENvbXBhcmUgdHdvIG51bWJlcnMgYW5kIHJldHVybjpcbiAgLy8gMSAtIGlmIGB0aGlzYCA+IGBudW1gXG4gIC8vIDAgLSBpZiBgdGhpc2AgPT0gYG51bWBcbiAgLy8gLTEgLSBpZiBgdGhpc2AgPCBgbnVtYFxuICBCTi5wcm90b3R5cGUuY21wID0gZnVuY3Rpb24gY21wIChudW0pIHtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHJldHVybiAtMTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBudW0ubmVnYXRpdmUgIT09IDApIHJldHVybiAxO1xuXG4gICAgdmFyIHJlcyA9IHRoaXMudWNtcChudW0pO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gLXJlcyB8IDA7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBVbnNpZ25lZCBjb21wYXJpc29uXG4gIEJOLnByb3RvdHlwZS51Y21wID0gZnVuY3Rpb24gdWNtcCAobnVtKSB7XG4gICAgLy8gQXQgdGhpcyBwb2ludCBib3RoIG51bWJlcnMgaGF2ZSB0aGUgc2FtZSBzaWduXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIDE7XG4gICAgaWYgKHRoaXMubGVuZ3RoIDwgbnVtLmxlbmd0aCkgcmV0dXJuIC0xO1xuXG4gICAgdmFyIHJlcyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBhID0gdGhpcy53b3Jkc1tpXSB8IDA7XG4gICAgICB2YXIgYiA9IG51bS53b3Jkc1tpXSB8IDA7XG5cbiAgICAgIGlmIChhID09PSBiKSBjb250aW51ZTtcbiAgICAgIGlmIChhIDwgYikge1xuICAgICAgICByZXMgPSAtMTtcbiAgICAgIH0gZWxzZSBpZiAoYSA+IGIpIHtcbiAgICAgICAgcmVzID0gMTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndG4gPSBmdW5jdGlvbiBndG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3QgPSBmdW5jdGlvbiBndCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IDE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0ZW4gPSBmdW5jdGlvbiBndGVuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPj0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3RlID0gZnVuY3Rpb24gZ3RlIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA+PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdG4gPSBmdW5jdGlvbiBsdG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gLTE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0ID0gZnVuY3Rpb24gbHQgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAtMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHRlbiA9IGZ1bmN0aW9uIGx0ZW4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA8PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdGUgPSBmdW5jdGlvbiBsdGUgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pIDw9IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmVxbiA9IGZ1bmN0aW9uIGVxbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID09PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gMDtcbiAgfTtcblxuICAvL1xuICAvLyBBIHJlZHVjZSBjb250ZXh0LCBjb3VsZCBiZSB1c2luZyBtb250Z29tZXJ5IG9yIHNvbWV0aGluZyBiZXR0ZXIsIGRlcGVuZGluZ1xuICAvLyBvbiB0aGUgYG1gIGl0c2VsZi5cbiAgLy9cbiAgQk4ucmVkID0gZnVuY3Rpb24gcmVkIChudW0pIHtcbiAgICByZXR1cm4gbmV3IFJlZChudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b1JlZCA9IGZ1bmN0aW9uIHRvUmVkIChjdHgpIHtcbiAgICBhc3NlcnQoIXRoaXMucmVkLCAnQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgICByZXR1cm4gY3R4LmNvbnZlcnRUbyh0aGlzKS5fZm9yY2VSZWQoY3R4KTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZnJvbVJlZCA9IGZ1bmN0aW9uIGZyb21SZWQgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ2Zyb21SZWQgd29ya3Mgb25seSB3aXRoIG51bWJlcnMgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuY29udmVydEZyb20odGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9mb3JjZVJlZCA9IGZ1bmN0aW9uIF9mb3JjZVJlZCAoY3R4KSB7XG4gICAgdGhpcy5yZWQgPSBjdHg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmZvcmNlUmVkID0gZnVuY3Rpb24gZm9yY2VSZWQgKGN0eCkge1xuICAgIGFzc2VydCghdGhpcy5yZWQsICdBbHJlYWR5IGEgbnVtYmVyIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG4gICAgcmV0dXJuIHRoaXMuX2ZvcmNlUmVkKGN0eCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZEFkZCA9IGZ1bmN0aW9uIHJlZEFkZCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkQWRkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5hZGQodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSUFkZCA9IGZ1bmN0aW9uIHJlZElBZGQgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElBZGQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmlhZGQodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkU3ViID0gZnVuY3Rpb24gcmVkU3ViIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnN1Yih0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJU3ViID0gZnVuY3Rpb24gcmVkSVN1YiAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSVN1YiB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaXN1Yih0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRTaGwgPSBmdW5jdGlvbiByZWRTaGwgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNobCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc2hsKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZE11bCA9IGZ1bmN0aW9uIHJlZE11bCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkyKHRoaXMsIG51bSk7XG4gICAgcmV0dXJuIHRoaXMucmVkLm11bCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJTXVsID0gZnVuY3Rpb24gcmVkSU11bCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkyKHRoaXMsIG51bSk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmltdWwodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkU3FyID0gZnVuY3Rpb24gcmVkU3FyICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnNxcih0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSVNxciA9IGZ1bmN0aW9uIHJlZElTcXIgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmlzcXIodGhpcyk7XG4gIH07XG5cbiAgLy8gU3F1YXJlIHJvb3Qgb3ZlciBwXG4gIEJOLnByb3RvdHlwZS5yZWRTcXJ0ID0gZnVuY3Rpb24gcmVkU3FydCAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3FydCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc3FydCh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSW52bSA9IGZ1bmN0aW9uIHJlZEludm0gKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZEludm0gd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmludm0odGhpcyk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG5lZ2F0aXZlIGNsb25lIG9mIGB0aGlzYCAlIGByZWQgbW9kdWxvYFxuICBCTi5wcm90b3R5cGUucmVkTmVnID0gZnVuY3Rpb24gcmVkTmVnICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWROZWcgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLm5lZyh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkUG93ID0gZnVuY3Rpb24gcmVkUG93IChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQgJiYgIW51bS5yZWQsICdyZWRQb3cobm9ybWFsTnVtKScpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5wb3codGhpcywgbnVtKTtcbiAgfTtcblxuICAvLyBQcmltZSBudW1iZXJzIHdpdGggZWZmaWNpZW50IHJlZHVjdGlvblxuICB2YXIgcHJpbWVzID0ge1xuICAgIGsyNTY6IG51bGwsXG4gICAgcDIyNDogbnVsbCxcbiAgICBwMTkyOiBudWxsLFxuICAgIHAyNTUxOTogbnVsbFxuICB9O1xuXG4gIC8vIFBzZXVkby1NZXJzZW5uZSBwcmltZVxuICBmdW5jdGlvbiBNUHJpbWUgKG5hbWUsIHApIHtcbiAgICAvLyBQID0gMiBeIE4gLSBLXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnAgPSBuZXcgQk4ocCwgMTYpO1xuICAgIHRoaXMubiA9IHRoaXMucC5iaXRMZW5ndGgoKTtcbiAgICB0aGlzLmsgPSBuZXcgQk4oMSkuaXVzaGxuKHRoaXMubikuaXN1Yih0aGlzLnApO1xuXG4gICAgdGhpcy50bXAgPSB0aGlzLl90bXAoKTtcbiAgfVxuXG4gIE1QcmltZS5wcm90b3R5cGUuX3RtcCA9IGZ1bmN0aW9uIF90bXAgKCkge1xuICAgIHZhciB0bXAgPSBuZXcgQk4obnVsbCk7XG4gICAgdG1wLndvcmRzID0gbmV3IEFycmF5KE1hdGguY2VpbCh0aGlzLm4gLyAxMykpO1xuICAgIHJldHVybiB0bXA7XG4gIH07XG5cbiAgTVByaW1lLnByb3RvdHlwZS5pcmVkdWNlID0gZnVuY3Rpb24gaXJlZHVjZSAobnVtKSB7XG4gICAgLy8gQXNzdW1lcyB0aGF0IGBudW1gIGlzIGxlc3MgdGhhbiBgUF4yYFxuICAgIC8vIG51bSA9IEhJICogKDIgXiBOIC0gSykgKyBISSAqIEsgKyBMTyA9IEhJICogSyArIExPIChtb2QgUClcbiAgICB2YXIgciA9IG51bTtcbiAgICB2YXIgcmxlbjtcblxuICAgIGRvIHtcbiAgICAgIHRoaXMuc3BsaXQociwgdGhpcy50bXApO1xuICAgICAgciA9IHRoaXMuaW11bEsocik7XG4gICAgICByID0gci5pYWRkKHRoaXMudG1wKTtcbiAgICAgIHJsZW4gPSByLmJpdExlbmd0aCgpO1xuICAgIH0gd2hpbGUgKHJsZW4gPiB0aGlzLm4pO1xuXG4gICAgdmFyIGNtcCA9IHJsZW4gPCB0aGlzLm4gPyAtMSA6IHIudWNtcCh0aGlzLnApO1xuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIHIud29yZHNbMF0gPSAwO1xuICAgICAgci5sZW5ndGggPSAxO1xuICAgIH0gZWxzZSBpZiAoY21wID4gMCkge1xuICAgICAgci5pc3ViKHRoaXMucCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIuc3RyaXAoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBNUHJpbWUucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQgKGlucHV0LCBvdXQpIHtcbiAgICBpbnB1dC5pdXNocm4odGhpcy5uLCAwLCBvdXQpO1xuICB9O1xuXG4gIE1QcmltZS5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyAobnVtKSB7XG4gICAgcmV0dXJuIG51bS5pbXVsKHRoaXMuayk7XG4gIH07XG5cbiAgZnVuY3Rpb24gSzI1NiAoKSB7XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ2syNTYnLFxuICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmYzJmJyk7XG4gIH1cbiAgaW5oZXJpdHMoSzI1NiwgTVByaW1lKTtcblxuICBLMjU2LnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0IChpbnB1dCwgb3V0cHV0KSB7XG4gICAgLy8gMjU2ID0gOSAqIDI2ICsgMjJcbiAgICB2YXIgbWFzayA9IDB4M2ZmZmZmO1xuXG4gICAgdmFyIG91dExlbiA9IE1hdGgubWluKGlucHV0Lmxlbmd0aCwgOSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRMZW47IGkrKykge1xuICAgICAgb3V0cHV0LndvcmRzW2ldID0gaW5wdXQud29yZHNbaV07XG4gICAgfVxuICAgIG91dHB1dC5sZW5ndGggPSBvdXRMZW47XG5cbiAgICBpZiAoaW5wdXQubGVuZ3RoIDw9IDkpIHtcbiAgICAgIGlucHV0LndvcmRzWzBdID0gMDtcbiAgICAgIGlucHV0Lmxlbmd0aCA9IDE7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU2hpZnQgYnkgOSBsaW1ic1xuICAgIHZhciBwcmV2ID0gaW5wdXQud29yZHNbOV07XG4gICAgb3V0cHV0LndvcmRzW291dHB1dC5sZW5ndGgrK10gPSBwcmV2ICYgbWFzaztcblxuICAgIGZvciAoaSA9IDEwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuZXh0ID0gaW5wdXQud29yZHNbaV0gfCAwO1xuICAgICAgaW5wdXQud29yZHNbaSAtIDEwXSA9ICgobmV4dCAmIG1hc2spIDw8IDQpIHwgKHByZXYgPj4+IDIyKTtcbiAgICAgIHByZXYgPSBuZXh0O1xuICAgIH1cbiAgICBwcmV2ID4+Pj0gMjI7XG4gICAgaW5wdXQud29yZHNbaSAtIDEwXSA9IHByZXY7XG4gICAgaWYgKHByZXYgPT09IDAgJiYgaW5wdXQubGVuZ3RoID4gMTApIHtcbiAgICAgIGlucHV0Lmxlbmd0aCAtPSAxMDtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5wdXQubGVuZ3RoIC09IDk7XG4gICAgfVxuICB9O1xuXG4gIEsyNTYucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuICAgIC8vIEsgPSAweDEwMDAwMDNkMSA9IFsgMHg0MCwgMHgzZDEgXVxuICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoXSA9IDA7XG4gICAgbnVtLndvcmRzW251bS5sZW5ndGggKyAxXSA9IDA7XG4gICAgbnVtLmxlbmd0aCArPSAyO1xuXG4gICAgLy8gYm91bmRlZCBhdDogMHg0MCAqIDB4M2ZmZmZmZiArIDB4M2QwID0gMHgxMDAwMDAzOTBcbiAgICB2YXIgbG8gPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdyA9IG51bS53b3Jkc1tpXSB8IDA7XG4gICAgICBsbyArPSB3ICogMHgzZDE7XG4gICAgICBudW0ud29yZHNbaV0gPSBsbyAmIDB4M2ZmZmZmZjtcbiAgICAgIGxvID0gdyAqIDB4NDAgKyAoKGxvIC8gMHg0MDAwMDAwKSB8IDApO1xuICAgIH1cblxuICAgIC8vIEZhc3QgbGVuZ3RoIHJlZHVjdGlvblxuICAgIGlmIChudW0ud29yZHNbbnVtLmxlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICBudW0ubGVuZ3RoLS07XG4gICAgICBpZiAobnVtLndvcmRzW251bS5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgICAgICBudW0ubGVuZ3RoLS07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudW07XG4gIH07XG5cbiAgZnVuY3Rpb24gUDIyNCAoKSB7XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ3AyMjQnLFxuICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAxJyk7XG4gIH1cbiAgaW5oZXJpdHMoUDIyNCwgTVByaW1lKTtcblxuICBmdW5jdGlvbiBQMTkyICgpIHtcbiAgICBNUHJpbWUuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAncDE5MicsXG4gICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmYnKTtcbiAgfVxuICBpbmhlcml0cyhQMTkyLCBNUHJpbWUpO1xuXG4gIGZ1bmN0aW9uIFAyNTUxOSAoKSB7XG4gICAgLy8gMiBeIDI1NSAtIDE5XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJzI1NTE5JyxcbiAgICAgICc3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkJyk7XG4gIH1cbiAgaW5oZXJpdHMoUDI1NTE5LCBNUHJpbWUpO1xuXG4gIFAyNTUxOS5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyAobnVtKSB7XG4gICAgLy8gSyA9IDB4MTNcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGkgPSAobnVtLndvcmRzW2ldIHwgMCkgKiAweDEzICsgY2Fycnk7XG4gICAgICB2YXIgbG8gPSBoaSAmIDB4M2ZmZmZmZjtcbiAgICAgIGhpID4+Pj0gMjY7XG5cbiAgICAgIG51bS53b3Jkc1tpXSA9IGxvO1xuICAgICAgY2FycnkgPSBoaTtcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICBudW0ud29yZHNbbnVtLmxlbmd0aCsrXSA9IGNhcnJ5O1xuICAgIH1cbiAgICByZXR1cm4gbnVtO1xuICB9O1xuXG4gIC8vIEV4cG9ydGVkIG1vc3RseSBmb3IgdGVzdGluZyBwdXJwb3NlcywgdXNlIHBsYWluIG5hbWUgaW5zdGVhZFxuICBCTi5fcHJpbWUgPSBmdW5jdGlvbiBwcmltZSAobmFtZSkge1xuICAgIC8vIENhY2hlZCB2ZXJzaW9uIG9mIHByaW1lXG4gICAgaWYgKHByaW1lc1tuYW1lXSkgcmV0dXJuIHByaW1lc1tuYW1lXTtcblxuICAgIHZhciBwcmltZTtcbiAgICBpZiAobmFtZSA9PT0gJ2syNTYnKSB7XG4gICAgICBwcmltZSA9IG5ldyBLMjU2KCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAncDIyNCcpIHtcbiAgICAgIHByaW1lID0gbmV3IFAyMjQoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMTkyJykge1xuICAgICAgcHJpbWUgPSBuZXcgUDE5MigpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AyNTUxOScpIHtcbiAgICAgIHByaW1lID0gbmV3IFAyNTUxOSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcHJpbWUgJyArIG5hbWUpO1xuICAgIH1cbiAgICBwcmltZXNbbmFtZV0gPSBwcmltZTtcblxuICAgIHJldHVybiBwcmltZTtcbiAgfTtcblxuICAvL1xuICAvLyBCYXNlIHJlZHVjdGlvbiBlbmdpbmVcbiAgLy9cbiAgZnVuY3Rpb24gUmVkIChtKSB7XG4gICAgaWYgKHR5cGVvZiBtID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIHByaW1lID0gQk4uX3ByaW1lKG0pO1xuICAgICAgdGhpcy5tID0gcHJpbWUucDtcbiAgICAgIHRoaXMucHJpbWUgPSBwcmltZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KG0uZ3RuKDEpLCAnbW9kdWx1cyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAxJyk7XG4gICAgICB0aGlzLm0gPSBtO1xuICAgICAgdGhpcy5wcmltZSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgUmVkLnByb3RvdHlwZS5fdmVyaWZ5MSA9IGZ1bmN0aW9uIF92ZXJpZnkxIChhKSB7XG4gICAgYXNzZXJ0KGEubmVnYXRpdmUgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuICAgIGFzc2VydChhLnJlZCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLl92ZXJpZnkyID0gZnVuY3Rpb24gX3ZlcmlmeTIgKGEsIGIpIHtcbiAgICBhc3NlcnQoKGEubmVnYXRpdmUgfCBiLm5lZ2F0aXZlKSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG4gICAgYXNzZXJ0KGEucmVkICYmIGEucmVkID09PSBiLnJlZCxcbiAgICAgICdyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pbW9kID0gZnVuY3Rpb24gaW1vZCAoYSkge1xuICAgIGlmICh0aGlzLnByaW1lKSByZXR1cm4gdGhpcy5wcmltZS5pcmVkdWNlKGEpLl9mb3JjZVJlZCh0aGlzKTtcbiAgICByZXR1cm4gYS51bW9kKHRoaXMubSkuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnIChhKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkpIHtcbiAgICAgIHJldHVybiBhLmNsb25lKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubS5zdWIoYSkuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLmFkZChiKTtcbiAgICBpZiAocmVzLmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcy5pc3ViKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaWFkZCA9IGZ1bmN0aW9uIGlhZGQgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuaWFkZChiKTtcbiAgICBpZiAocmVzLmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcy5pc3ViKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiBzdWIgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuc3ViKGIpO1xuICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcy5pYWRkKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaXN1YiA9IGZ1bmN0aW9uIGlzdWIgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuaXN1YihiKTtcbiAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMuaWFkZCh0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc2hsID0gZnVuY3Rpb24gc2hsIChhLCBudW0pIHtcbiAgICB0aGlzLl92ZXJpZnkxKGEpO1xuICAgIHJldHVybiB0aGlzLmltb2QoYS51c2hsbihudW0pKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGEuaW11bChiKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuICAgIHJldHVybiB0aGlzLmltb2QoYS5tdWwoYikpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaXNxciA9IGZ1bmN0aW9uIGlzcXIgKGEpIHtcbiAgICByZXR1cm4gdGhpcy5pbXVsKGEsIGEuY2xvbmUoKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zcXIgPSBmdW5jdGlvbiBzcXIgKGEpIHtcbiAgICByZXR1cm4gdGhpcy5tdWwoYSwgYSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zcXJ0ID0gZnVuY3Rpb24gc3FydCAoYSkge1xuICAgIGlmIChhLmlzWmVybygpKSByZXR1cm4gYS5jbG9uZSgpO1xuXG4gICAgdmFyIG1vZDMgPSB0aGlzLm0uYW5kbG4oMyk7XG4gICAgYXNzZXJ0KG1vZDMgJSAyID09PSAxKTtcblxuICAgIC8vIEZhc3QgY2FzZVxuICAgIGlmIChtb2QzID09PSAzKSB7XG4gICAgICB2YXIgcG93ID0gdGhpcy5tLmFkZChuZXcgQk4oMSkpLml1c2hybigyKTtcbiAgICAgIHJldHVybiB0aGlzLnBvdyhhLCBwb3cpO1xuICAgIH1cblxuICAgIC8vIFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobSAoVG90YWxseSB1bm9wdGltaXplZCBhbmQgc2xvdylcbiAgICAvL1xuICAgIC8vIEZpbmQgUSBhbmQgUywgdGhhdCBRICogMiBeIFMgPSAoUCAtIDEpXG4gICAgdmFyIHEgPSB0aGlzLm0uc3VibigxKTtcbiAgICB2YXIgcyA9IDA7XG4gICAgd2hpbGUgKCFxLmlzWmVybygpICYmIHEuYW5kbG4oMSkgPT09IDApIHtcbiAgICAgIHMrKztcbiAgICAgIHEuaXVzaHJuKDEpO1xuICAgIH1cbiAgICBhc3NlcnQoIXEuaXNaZXJvKCkpO1xuXG4gICAgdmFyIG9uZSA9IG5ldyBCTigxKS50b1JlZCh0aGlzKTtcbiAgICB2YXIgbk9uZSA9IG9uZS5yZWROZWcoKTtcblxuICAgIC8vIEZpbmQgcXVhZHJhdGljIG5vbi1yZXNpZHVlXG4gICAgLy8gTk9URTogTWF4IGlzIHN1Y2ggYmVjYXVzZSBvZiBnZW5lcmFsaXplZCBSaWVtYW5uIGh5cG90aGVzaXMuXG4gICAgdmFyIGxwb3cgPSB0aGlzLm0uc3VibigxKS5pdXNocm4oMSk7XG4gICAgdmFyIHogPSB0aGlzLm0uYml0TGVuZ3RoKCk7XG4gICAgeiA9IG5ldyBCTigyICogeiAqIHopLnRvUmVkKHRoaXMpO1xuXG4gICAgd2hpbGUgKHRoaXMucG93KHosIGxwb3cpLmNtcChuT25lKSAhPT0gMCkge1xuICAgICAgei5yZWRJQWRkKG5PbmUpO1xuICAgIH1cblxuICAgIHZhciBjID0gdGhpcy5wb3coeiwgcSk7XG4gICAgdmFyIHIgPSB0aGlzLnBvdyhhLCBxLmFkZG4oMSkuaXVzaHJuKDEpKTtcbiAgICB2YXIgdCA9IHRoaXMucG93KGEsIHEpO1xuICAgIHZhciBtID0gcztcbiAgICB3aGlsZSAodC5jbXAob25lKSAhPT0gMCkge1xuICAgICAgdmFyIHRtcCA9IHQ7XG4gICAgICBmb3IgKHZhciBpID0gMDsgdG1wLmNtcChvbmUpICE9PSAwOyBpKyspIHtcbiAgICAgICAgdG1wID0gdG1wLnJlZFNxcigpO1xuICAgICAgfVxuICAgICAgYXNzZXJ0KGkgPCBtKTtcbiAgICAgIHZhciBiID0gdGhpcy5wb3coYywgbmV3IEJOKDEpLml1c2hsbihtIC0gaSAtIDEpKTtcblxuICAgICAgciA9IHIucmVkTXVsKGIpO1xuICAgICAgYyA9IGIucmVkU3FyKCk7XG4gICAgICB0ID0gdC5yZWRNdWwoYyk7XG4gICAgICBtID0gaTtcbiAgICB9XG5cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChhKSB7XG4gICAgdmFyIGludiA9IGEuX2ludm1wKHRoaXMubSk7XG4gICAgaWYgKGludi5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgaW52Lm5lZ2F0aXZlID0gMDtcbiAgICAgIHJldHVybiB0aGlzLmltb2QoaW52KS5yZWROZWcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuaW1vZChpbnYpO1xuICAgIH1cbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIHBvdyAoYSwgbnVtKSB7XG4gICAgaWYgKG51bS5pc1plcm8oKSkgcmV0dXJuIG5ldyBCTigxKS50b1JlZCh0aGlzKTtcbiAgICBpZiAobnVtLmNtcG4oMSkgPT09IDApIHJldHVybiBhLmNsb25lKCk7XG5cbiAgICB2YXIgd2luZG93U2l6ZSA9IDQ7XG4gICAgdmFyIHduZCA9IG5ldyBBcnJheSgxIDw8IHdpbmRvd1NpemUpO1xuICAgIHduZFswXSA9IG5ldyBCTigxKS50b1JlZCh0aGlzKTtcbiAgICB3bmRbMV0gPSBhO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgd25kLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3bmRbaV0gPSB0aGlzLm11bCh3bmRbaSAtIDFdLCBhKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzID0gd25kWzBdO1xuICAgIHZhciBjdXJyZW50ID0gMDtcbiAgICB2YXIgY3VycmVudExlbiA9IDA7XG4gICAgdmFyIHN0YXJ0ID0gbnVtLmJpdExlbmd0aCgpICUgMjY7XG4gICAgaWYgKHN0YXJ0ID09PSAwKSB7XG4gICAgICBzdGFydCA9IDI2O1xuICAgIH1cblxuICAgIGZvciAoaSA9IG51bS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIHdvcmQgPSBudW0ud29yZHNbaV07XG4gICAgICBmb3IgKHZhciBqID0gc3RhcnQgLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICB2YXIgYml0ID0gKHdvcmQgPj4gaikgJiAxO1xuICAgICAgICBpZiAocmVzICE9PSB3bmRbMF0pIHtcbiAgICAgICAgICByZXMgPSB0aGlzLnNxcihyZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJpdCA9PT0gMCAmJiBjdXJyZW50ID09PSAwKSB7XG4gICAgICAgICAgY3VycmVudExlbiA9IDA7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50IDw8PSAxO1xuICAgICAgICBjdXJyZW50IHw9IGJpdDtcbiAgICAgICAgY3VycmVudExlbisrO1xuICAgICAgICBpZiAoY3VycmVudExlbiAhPT0gd2luZG93U2l6ZSAmJiAoaSAhPT0gMCB8fCBqICE9PSAwKSkgY29udGludWU7XG5cbiAgICAgICAgcmVzID0gdGhpcy5tdWwocmVzLCB3bmRbY3VycmVudF0pO1xuICAgICAgICBjdXJyZW50TGVuID0gMDtcbiAgICAgICAgY3VycmVudCA9IDA7XG4gICAgICB9XG4gICAgICBzdGFydCA9IDI2O1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5jb252ZXJ0VG8gPSBmdW5jdGlvbiBjb252ZXJ0VG8gKG51bSkge1xuICAgIHZhciByID0gbnVtLnVtb2QodGhpcy5tKTtcblxuICAgIHJldHVybiByID09PSBudW0gPyByLmNsb25lKCkgOiByO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuY29udmVydEZyb20gPSBmdW5jdGlvbiBjb252ZXJ0RnJvbSAobnVtKSB7XG4gICAgdmFyIHJlcyA9IG51bS5jbG9uZSgpO1xuICAgIHJlcy5yZWQgPSBudWxsO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy9cbiAgLy8gTW9udGdvbWVyeSBtZXRob2QgZW5naW5lXG4gIC8vXG5cbiAgQk4ubW9udCA9IGZ1bmN0aW9uIG1vbnQgKG51bSkge1xuICAgIHJldHVybiBuZXcgTW9udChudW0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIE1vbnQgKG0pIHtcbiAgICBSZWQuY2FsbCh0aGlzLCBtKTtcblxuICAgIHRoaXMuc2hpZnQgPSB0aGlzLm0uYml0TGVuZ3RoKCk7XG4gICAgaWYgKHRoaXMuc2hpZnQgJSAyNiAhPT0gMCkge1xuICAgICAgdGhpcy5zaGlmdCArPSAyNiAtICh0aGlzLnNoaWZ0ICUgMjYpO1xuICAgIH1cblxuICAgIHRoaXMuciA9IG5ldyBCTigxKS5pdXNobG4odGhpcy5zaGlmdCk7XG4gICAgdGhpcy5yMiA9IHRoaXMuaW1vZCh0aGlzLnIuc3FyKCkpO1xuICAgIHRoaXMucmludiA9IHRoaXMuci5faW52bXAodGhpcy5tKTtcblxuICAgIHRoaXMubWludiA9IHRoaXMucmludi5tdWwodGhpcy5yKS5pc3VibigxKS5kaXYodGhpcy5tKTtcbiAgICB0aGlzLm1pbnYgPSB0aGlzLm1pbnYudW1vZCh0aGlzLnIpO1xuICAgIHRoaXMubWludiA9IHRoaXMuci5zdWIodGhpcy5taW52KTtcbiAgfVxuICBpbmhlcml0cyhNb250LCBSZWQpO1xuXG4gIE1vbnQucHJvdG90eXBlLmNvbnZlcnRUbyA9IGZ1bmN0aW9uIGNvbnZlcnRUbyAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChudW0udXNobG4odGhpcy5zaGlmdCkpO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLmNvbnZlcnRGcm9tID0gZnVuY3Rpb24gY29udmVydEZyb20gKG51bSkge1xuICAgIHZhciByID0gdGhpcy5pbW9kKG51bS5tdWwodGhpcy5yaW52KSk7XG4gICAgci5yZWQgPSBudWxsO1xuICAgIHJldHVybiByO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsIChhLCBiKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkgfHwgYi5pc1plcm8oKSkge1xuICAgICAgYS53b3Jkc1swXSA9IDA7XG4gICAgICBhLmxlbmd0aCA9IDE7XG4gICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICB2YXIgdCA9IGEuaW11bChiKTtcbiAgICB2YXIgYyA9IHQubWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubWludikuaW1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm0pO1xuICAgIHZhciB1ID0gdC5pc3ViKGMpLml1c2hybih0aGlzLnNoaWZ0KTtcbiAgICB2YXIgcmVzID0gdTtcblxuICAgIGlmICh1LmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcyA9IHUuaXN1Yih0aGlzLm0pO1xuICAgIH0gZWxzZSBpZiAodS5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzID0gdS5pYWRkKHRoaXMubSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChhLCBiKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkgfHwgYi5pc1plcm8oKSkgcmV0dXJuIG5ldyBCTigwKS5fZm9yY2VSZWQodGhpcyk7XG5cbiAgICB2YXIgdCA9IGEubXVsKGIpO1xuICAgIHZhciBjID0gdC5tYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5taW52KS5pbWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubSk7XG4gICAgdmFyIHUgPSB0LmlzdWIoYykuaXVzaHJuKHRoaXMuc2hpZnQpO1xuICAgIHZhciByZXMgPSB1O1xuICAgIGlmICh1LmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcyA9IHUuaXN1Yih0aGlzLm0pO1xuICAgIH0gZWxzZSBpZiAodS5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzID0gdS5pYWRkKHRoaXMubSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0gKGEpIHtcbiAgICAvLyAoQVIpXi0xICogUl4yID0gKEFeLTEgKiBSXi0xKSAqIFJeMiA9IEFeLTEgKiBSXG4gICAgdmFyIHJlcyA9IHRoaXMuaW1vZChhLl9pbnZtcCh0aGlzLm0pLm11bCh0aGlzLnIyKSk7XG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG59KSh0eXBlb2YgbW9kdWxlID09PSAndW5kZWZpbmVkJyB8fCBtb2R1bGUsIHRoaXMpO1xuIiwiIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IG9iamVjdENyZWF0ZVBvbHlmaWxsXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IG9iamVjdEtleXNQb2x5ZmlsbFxudmFyIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCB8fCBmdW5jdGlvbkJpbmRQb2x5ZmlsbFxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcywgJ19ldmVudHMnKSkge1xuICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG52YXIgaGFzRGVmaW5lUHJvcGVydHk7XG50cnkge1xuICB2YXIgbyA9IHt9O1xuICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgJ3gnLCB7IHZhbHVlOiAwIH0pO1xuICBoYXNEZWZpbmVQcm9wZXJ0eSA9IG8ueCA9PT0gMDtcbn0gY2F0Y2ggKGVycikgeyBoYXNEZWZpbmVQcm9wZXJ0eSA9IGZhbHNlIH1cbmlmIChoYXNEZWZpbmVQcm9wZXJ0eSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgICAvLyBjaGVjayB3aGV0aGVyIHRoZSBpbnB1dCBpcyBhIHBvc2l0aXZlIG51bWJlciAod2hvc2UgdmFsdWUgaXMgemVybyBvclxuICAgICAgLy8gZ3JlYXRlciBhbmQgbm90IGEgTmFOKS5cbiAgICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IGFyZyAhPT0gYXJnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gICAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG59XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJuXCIgYXJndW1lbnQgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uICRnZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuICRnZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG4vLyBUaGVzZSBzdGFuZGFsb25lIGVtaXQqIGZ1bmN0aW9ucyBhcmUgdXNlZCB0byBvcHRpbWl6ZSBjYWxsaW5nIG9mIGV2ZW50XG4vLyBoYW5kbGVycyBmb3IgZmFzdCBjYXNlcyBiZWNhdXNlIGVtaXQoKSBpdHNlbGYgb2Z0ZW4gaGFzIGEgdmFyaWFibGUgbnVtYmVyIG9mXG4vLyBhcmd1bWVudHMgYW5kIGNhbiBiZSBkZW9wdGltaXplZCBiZWNhdXNlIG9mIHRoYXQuIFRoZXNlIGZ1bmN0aW9ucyBhbHdheXMgaGF2ZVxuLy8gdGhlIHNhbWUgbnVtYmVyIG9mIGFyZ3VtZW50cyBhbmQgdGh1cyBkbyBub3QgZ2V0IGRlb3B0aW1pemVkLCBzbyB0aGUgY29kZVxuLy8gaW5zaWRlIHRoZW0gY2FuIGV4ZWN1dGUgZmFzdGVyLlxuZnVuY3Rpb24gZW1pdE5vbmUoaGFuZGxlciwgaXNGbiwgc2VsZikge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZik7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdE9uZShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0VHdvKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEsIGFyZzIpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEsIGFyZzIpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSwgYXJnMik7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRUaHJlZShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRNYW55KGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZ3MpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5hcHBseShzZWxmLCBhcmdzKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGV2ZW50cztcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT0gbnVsbCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKVxuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKCFoYW5kbGVyKVxuICAgIHJldHVybiBmYWxzZTtcblxuICB2YXIgaXNGbiA9IHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nO1xuICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICBzd2l0Y2ggKGxlbikge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgIGNhc2UgMTpcbiAgICAgIGVtaXROb25lKGhhbmRsZXIsIGlzRm4sIHRoaXMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgICAgZW1pdE9uZShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgICAgZW1pdFR3byhoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQ6XG4gICAgICBlbWl0VGhyZWUoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSk7XG4gICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgIGRlZmF1bHQ6XG4gICAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGVtaXRNYW55KGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoIWV2ZW50cykge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKCFleGlzdGluZykge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgICBpZiAocHJlcGVuZCkge1xuICAgICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgaWYgKCFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIG0gPSAkZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgICBpZiAobSAmJiBtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtKSB7XG4gICAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyBcIicgKyBTdHJpbmcodHlwZSkgKyAnXCIgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdC4nKTtcbiAgICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSAnb2JqZWN0JyAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJyVzOiAlcycsIHcubmFtZSwgdy5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCwgYXJndW1lbnRzWzBdKTtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCwgYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0LCBhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSxcbiAgICAgICAgICAgIGFyZ3VtZW50c1syXSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBiaW5kLmNhbGwob25jZVdyYXBwZXIsIHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoIWV2ZW50cylcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAoIWxpc3QpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoIWV2ZW50cylcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmICghZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0pIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gb2JqZWN0S2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmICghZXZlbnRzKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKCFldmxpc3RlbmVyKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgPyB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3Qub3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG4vLyBBYm91dCAxLjV4IGZhc3RlciB0aGFuIHRoZSB0d28tYXJnIHZlcnNpb24gb2YgQXJyYXkjc3BsaWNlKCkuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICh2YXIgaSA9IGluZGV4LCBrID0gaSArIDEsIG4gPSBsaXN0Lmxlbmd0aDsgayA8IG47IGkgKz0gMSwgayArPSAxKVxuICAgIGxpc3RbaV0gPSBsaXN0W2tdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9iamVjdENyZWF0ZVBvbHlmaWxsKHByb3RvKSB7XG4gIHZhciBGID0gZnVuY3Rpb24oKSB7fTtcbiAgRi5wcm90b3R5cGUgPSBwcm90bztcbiAgcmV0dXJuIG5ldyBGO1xufVxuZnVuY3Rpb24gb2JqZWN0S2V5c1BvbHlmaWxsKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrIGluIG9iaikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGspKSB7XG4gICAga2V5cy5wdXNoKGspO1xuICB9XG4gIHJldHVybiBrO1xufVxuZnVuY3Rpb24gZnVuY3Rpb25CaW5kUG9seWZpbGwoY29udGV4dCkge1xuICB2YXIgZm4gPSB0aGlzO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICB9O1xufVxuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGN1c3RvbUluc3BlY3RTeW1ib2wgPVxuICAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLmZvciA9PT0gJ2Z1bmN0aW9uJylcbiAgICA/IFN5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJylcbiAgICA6IG51bGxcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG52YXIgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG4gIClcbn1cblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgdmFyIHByb3RvID0geyBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH0gfVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihwcm90bywgVWludDhBcnJheS5wcm90b3R5cGUpXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGFyciwgcHJvdG8pXG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgIT0gbnVsbCAmJlxuICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSlcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2UodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gICAgKVxuICB9XG5cbiAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgIClcbiAgfVxuXG4gIHZhciB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKClcbiAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICB2YXIgYiA9IGZyb21PYmplY3QodmFsdWUpXG4gIGlmIChiKSByZXR1cm4gYlxuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oXG4gICAgICB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoXG4gICAgKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICApXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIucHJvdG90eXBlLCBVaW50OEFycmF5LnByb3RvdHlwZSlcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIsIFVpbnQ4QXJyYXkpXG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgdmFyIGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICB9XG5cbiAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJlxuICAgIGIgIT09IEJ1ZmZlci5wcm90b3R5cGUgLy8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aClcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuICAgIClcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZilcbiAgICB9XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKVxuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5pZiAoY3VzdG9tSW5zcGVjdFN5bWJvbCkge1xuICBCdWZmZXIucHJvdG90eXBlW2N1c3RvbUluc3BlY3RTeW1ib2xdID0gQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKVxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgW3ZhbF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSBoZXhTbGljZUxvb2t1cFRhYmxlW2J1ZltpXV1cbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5ld0J1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyJylcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVc2UgYnVpbHQtaW4gd2hlbiBhdmFpbGFibGUsIG1pc3NpbmcgZnJvbSBJRTExXG4gICAgdGhpcy5jb3B5V2l0aGluKHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKVxuICB9IGVsc2UgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgJiYgY29kZSA8IDEyOCkgfHxcbiAgICAgICAgICBlbmNvZGluZyA9PT0gJ2xhdGluMScpIHtcbiAgICAgICAgLy8gRmFzdCBwYXRoOiBJZiBgdmFsYCBmaXRzIGludG8gYSBzaW5nbGUgYnl0ZSwgdXNlIHRoYXQgbnVtZXJpYyB2YWx1ZS5cbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xuICAgIHZhbCA9IE51bWJlcih2YWwpXG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbi8vIEFycmF5QnVmZmVyIG9yIFVpbnQ4QXJyYXkgb2JqZWN0cyBmcm9tIG90aGVyIGNvbnRleHRzIChpLmUuIGlmcmFtZXMpIGRvIG5vdCBwYXNzXG4vLyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIG9mIHRoYXQgdHlwZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNJbnN0YW5jZSAob2JqLCB0eXBlKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8XG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSB0eXBlLm5hbWUpXG59XG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XG4gIC8vIEZvciBJRTExIHN1cHBvcnRcbiAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cbi8vIENyZWF0ZSBsb29rdXAgdGFibGUgZm9yIGB0b1N0cmluZygnaGV4JylgXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8yMTlcbnZhciBoZXhTbGljZUxvb2t1cFRhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFscGhhYmV0ID0gJzAxMjM0NTY3ODlhYmNkZWYnXG4gIHZhciB0YWJsZSA9IG5ldyBBcnJheSgyNTYpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgIHZhciBpMTYgPSBpICogMTZcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDE2OyArK2opIHtcbiAgICAgIHRhYmxlW2kxNiArIGpdID0gYWxwaGFiZXRbaV0gKyBhbHBoYWJldFtqXVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFibGVcbn0pKClcbiIsInZhciBjbG9uZSA9IChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2luc3RhbmNlb2Yob2JqLCB0eXBlKSB7XG4gIHJldHVybiB0eXBlICE9IG51bGwgJiYgb2JqIGluc3RhbmNlb2YgdHlwZTtcbn1cblxudmFyIG5hdGl2ZU1hcDtcbnRyeSB7XG4gIG5hdGl2ZU1hcCA9IE1hcDtcbn0gY2F0Y2goXykge1xuICAvLyBtYXliZSBhIHJlZmVyZW5jZSBlcnJvciBiZWNhdXNlIG5vIGBNYXBgLiBHaXZlIGl0IGEgZHVtbXkgdmFsdWUgdGhhdCBub1xuICAvLyB2YWx1ZSB3aWxsIGV2ZXIgYmUgYW4gaW5zdGFuY2VvZi5cbiAgbmF0aXZlTWFwID0gZnVuY3Rpb24oKSB7fTtcbn1cblxudmFyIG5hdGl2ZVNldDtcbnRyeSB7XG4gIG5hdGl2ZVNldCA9IFNldDtcbn0gY2F0Y2goXykge1xuICBuYXRpdmVTZXQgPSBmdW5jdGlvbigpIHt9O1xufVxuXG52YXIgbmF0aXZlUHJvbWlzZTtcbnRyeSB7XG4gIG5hdGl2ZVByb21pc2UgPSBQcm9taXNlO1xufSBjYXRjaChfKSB7XG4gIG5hdGl2ZVByb21pc2UgPSBmdW5jdGlvbigpIHt9O1xufVxuXG4vKipcbiAqIENsb25lcyAoY29waWVzKSBhbiBPYmplY3QgdXNpbmcgZGVlcCBjb3B5aW5nLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gc3VwcG9ydHMgY2lyY3VsYXIgcmVmZXJlbmNlcyBieSBkZWZhdWx0LCBidXQgaWYgeW91IGFyZSBjZXJ0YWluXG4gKiB0aGVyZSBhcmUgbm8gY2lyY3VsYXIgcmVmZXJlbmNlcyBpbiB5b3VyIG9iamVjdCwgeW91IGNhbiBzYXZlIHNvbWUgQ1BVIHRpbWVcbiAqIGJ5IGNhbGxpbmcgY2xvbmUob2JqLCBmYWxzZSkuXG4gKlxuICogQ2F1dGlvbjogaWYgYGNpcmN1bGFyYCBpcyBmYWxzZSBhbmQgYHBhcmVudGAgY29udGFpbnMgY2lyY3VsYXIgcmVmZXJlbmNlcyxcbiAqIHlvdXIgcHJvZ3JhbSBtYXkgZW50ZXIgYW4gaW5maW5pdGUgbG9vcCBhbmQgY3Jhc2guXG4gKlxuICogQHBhcmFtIGBwYXJlbnRgIC0gdGhlIG9iamVjdCB0byBiZSBjbG9uZWRcbiAqIEBwYXJhbSBgY2lyY3VsYXJgIC0gc2V0IHRvIHRydWUgaWYgdGhlIG9iamVjdCB0byBiZSBjbG9uZWQgbWF5IGNvbnRhaW5cbiAqICAgIGNpcmN1bGFyIHJlZmVyZW5jZXMuIChvcHRpb25hbCAtIHRydWUgYnkgZGVmYXVsdClcbiAqIEBwYXJhbSBgZGVwdGhgIC0gc2V0IHRvIGEgbnVtYmVyIGlmIHRoZSBvYmplY3QgaXMgb25seSB0byBiZSBjbG9uZWQgdG9cbiAqICAgIGEgcGFydGljdWxhciBkZXB0aC4gKG9wdGlvbmFsIC0gZGVmYXVsdHMgdG8gSW5maW5pdHkpXG4gKiBAcGFyYW0gYHByb3RvdHlwZWAgLSBzZXRzIHRoZSBwcm90b3R5cGUgdG8gYmUgdXNlZCB3aGVuIGNsb25pbmcgYW4gb2JqZWN0LlxuICogICAgKG9wdGlvbmFsIC0gZGVmYXVsdHMgdG8gcGFyZW50IHByb3RvdHlwZSkuXG4gKiBAcGFyYW0gYGluY2x1ZGVOb25FbnVtZXJhYmxlYCAtIHNldCB0byB0cnVlIGlmIHRoZSBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzXG4gKiAgICBzaG91bGQgYmUgY2xvbmVkIGFzIHdlbGwuIE5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgb24gdGhlIHByb3RvdHlwZVxuICogICAgY2hhaW4gd2lsbCBiZSBpZ25vcmVkLiAob3B0aW9uYWwgLSBmYWxzZSBieSBkZWZhdWx0KVxuKi9cbmZ1bmN0aW9uIGNsb25lKHBhcmVudCwgY2lyY3VsYXIsIGRlcHRoLCBwcm90b3R5cGUsIGluY2x1ZGVOb25FbnVtZXJhYmxlKSB7XG4gIGlmICh0eXBlb2YgY2lyY3VsYXIgPT09ICdvYmplY3QnKSB7XG4gICAgZGVwdGggPSBjaXJjdWxhci5kZXB0aDtcbiAgICBwcm90b3R5cGUgPSBjaXJjdWxhci5wcm90b3R5cGU7XG4gICAgaW5jbHVkZU5vbkVudW1lcmFibGUgPSBjaXJjdWxhci5pbmNsdWRlTm9uRW51bWVyYWJsZTtcbiAgICBjaXJjdWxhciA9IGNpcmN1bGFyLmNpcmN1bGFyO1xuICB9XG4gIC8vIG1haW50YWluIHR3byBhcnJheXMgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMsIHdoZXJlIGNvcnJlc3BvbmRpbmcgcGFyZW50c1xuICAvLyBhbmQgY2hpbGRyZW4gaGF2ZSB0aGUgc2FtZSBpbmRleFxuICB2YXIgYWxsUGFyZW50cyA9IFtdO1xuICB2YXIgYWxsQ2hpbGRyZW4gPSBbXTtcblxuICB2YXIgdXNlQnVmZmVyID0gdHlwZW9mIEJ1ZmZlciAhPSAndW5kZWZpbmVkJztcblxuICBpZiAodHlwZW9mIGNpcmN1bGFyID09ICd1bmRlZmluZWQnKVxuICAgIGNpcmN1bGFyID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGRlcHRoID09ICd1bmRlZmluZWQnKVxuICAgIGRlcHRoID0gSW5maW5pdHk7XG5cbiAgLy8gcmVjdXJzZSB0aGlzIGZ1bmN0aW9uIHNvIHdlIGRvbid0IHJlc2V0IGFsbFBhcmVudHMgYW5kIGFsbENoaWxkcmVuXG4gIGZ1bmN0aW9uIF9jbG9uZShwYXJlbnQsIGRlcHRoKSB7XG4gICAgLy8gY2xvbmluZyBudWxsIGFsd2F5cyByZXR1cm5zIG51bGxcbiAgICBpZiAocGFyZW50ID09PSBudWxsKVxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBpZiAoZGVwdGggPT09IDApXG4gICAgICByZXR1cm4gcGFyZW50O1xuXG4gICAgdmFyIGNoaWxkO1xuICAgIHZhciBwcm90bztcbiAgICBpZiAodHlwZW9mIHBhcmVudCAhPSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG5cbiAgICBpZiAoX2luc3RhbmNlb2YocGFyZW50LCBuYXRpdmVNYXApKSB7XG4gICAgICBjaGlsZCA9IG5ldyBuYXRpdmVNYXAoKTtcbiAgICB9IGVsc2UgaWYgKF9pbnN0YW5jZW9mKHBhcmVudCwgbmF0aXZlU2V0KSkge1xuICAgICAgY2hpbGQgPSBuZXcgbmF0aXZlU2V0KCk7XG4gICAgfSBlbHNlIGlmIChfaW5zdGFuY2VvZihwYXJlbnQsIG5hdGl2ZVByb21pc2UpKSB7XG4gICAgICBjaGlsZCA9IG5ldyBuYXRpdmVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcGFyZW50LnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXNvbHZlKF9jbG9uZSh2YWx1ZSwgZGVwdGggLSAxKSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIHJlamVjdChfY2xvbmUoZXJyLCBkZXB0aCAtIDEpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNsb25lLl9faXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBjaGlsZCA9IFtdO1xuICAgIH0gZWxzZSBpZiAoY2xvbmUuX19pc1JlZ0V4cChwYXJlbnQpKSB7XG4gICAgICBjaGlsZCA9IG5ldyBSZWdFeHAocGFyZW50LnNvdXJjZSwgX19nZXRSZWdFeHBGbGFncyhwYXJlbnQpKTtcbiAgICAgIGlmIChwYXJlbnQubGFzdEluZGV4KSBjaGlsZC5sYXN0SW5kZXggPSBwYXJlbnQubGFzdEluZGV4O1xuICAgIH0gZWxzZSBpZiAoY2xvbmUuX19pc0RhdGUocGFyZW50KSkge1xuICAgICAgY2hpbGQgPSBuZXcgRGF0ZShwYXJlbnQuZ2V0VGltZSgpKTtcbiAgICB9IGVsc2UgaWYgKHVzZUJ1ZmZlciAmJiBCdWZmZXIuaXNCdWZmZXIocGFyZW50KSkge1xuICAgICAgaWYgKEJ1ZmZlci5hbGxvY1Vuc2FmZSkge1xuICAgICAgICAvLyBOb2RlLmpzID49IDQuNS4wXG4gICAgICAgIGNoaWxkID0gQnVmZmVyLmFsbG9jVW5zYWZlKHBhcmVudC5sZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT2xkZXIgTm9kZS5qcyB2ZXJzaW9uc1xuICAgICAgICBjaGlsZCA9IG5ldyBCdWZmZXIocGFyZW50Lmxlbmd0aCk7XG4gICAgICB9XG4gICAgICBwYXJlbnQuY29weShjaGlsZCk7XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfSBlbHNlIGlmIChfaW5zdGFuY2VvZihwYXJlbnQsIEVycm9yKSkge1xuICAgICAgY2hpbGQgPSBPYmplY3QuY3JlYXRlKHBhcmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvdG90eXBlID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHBhcmVudCk7XG4gICAgICAgIGNoaWxkID0gT2JqZWN0LmNyZWF0ZShwcm90byk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY2hpbGQgPSBPYmplY3QuY3JlYXRlKHByb3RvdHlwZSk7XG4gICAgICAgIHByb3RvID0gcHJvdG90eXBlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjaXJjdWxhcikge1xuICAgICAgdmFyIGluZGV4ID0gYWxsUGFyZW50cy5pbmRleE9mKHBhcmVudCk7XG5cbiAgICAgIGlmIChpbmRleCAhPSAtMSkge1xuICAgICAgICByZXR1cm4gYWxsQ2hpbGRyZW5baW5kZXhdO1xuICAgICAgfVxuICAgICAgYWxsUGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgICBhbGxDaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICB9XG5cbiAgICBpZiAoX2luc3RhbmNlb2YocGFyZW50LCBuYXRpdmVNYXApKSB7XG4gICAgICBwYXJlbnQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIHZhciBrZXlDaGlsZCA9IF9jbG9uZShrZXksIGRlcHRoIC0gMSk7XG4gICAgICAgIHZhciB2YWx1ZUNoaWxkID0gX2Nsb25lKHZhbHVlLCBkZXB0aCAtIDEpO1xuICAgICAgICBjaGlsZC5zZXQoa2V5Q2hpbGQsIHZhbHVlQ2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChfaW5zdGFuY2VvZihwYXJlbnQsIG5hdGl2ZVNldCkpIHtcbiAgICAgIHBhcmVudC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBlbnRyeUNoaWxkID0gX2Nsb25lKHZhbHVlLCBkZXB0aCAtIDEpO1xuICAgICAgICBjaGlsZC5hZGQoZW50cnlDaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpIGluIHBhcmVudCkge1xuICAgICAgdmFyIGF0dHJzO1xuICAgICAgaWYgKHByb3RvKSB7XG4gICAgICAgIGF0dHJzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90bywgaSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhdHRycyAmJiBhdHRycy5zZXQgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNoaWxkW2ldID0gX2Nsb25lKHBhcmVudFtpXSwgZGVwdGggLSAxKTtcbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHBhcmVudCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gRG9uJ3QgbmVlZCB0byB3b3JyeSBhYm91dCBjbG9uaW5nIGEgc3ltYm9sIGJlY2F1c2UgaXQgaXMgYSBwcmltaXRpdmUsXG4gICAgICAgIC8vIGxpa2UgYSBudW1iZXIgb3Igc3RyaW5nLlxuICAgICAgICB2YXIgc3ltYm9sID0gc3ltYm9sc1tpXTtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHBhcmVudCwgc3ltYm9sKTtcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IgJiYgIWRlc2NyaXB0b3IuZW51bWVyYWJsZSAmJiAhaW5jbHVkZU5vbkVudW1lcmFibGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZFtzeW1ib2xdID0gX2Nsb25lKHBhcmVudFtzeW1ib2xdLCBkZXB0aCAtIDEpO1xuICAgICAgICBpZiAoIWRlc2NyaXB0b3IuZW51bWVyYWJsZSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjaGlsZCwgc3ltYm9sLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluY2x1ZGVOb25FbnVtZXJhYmxlKSB7XG4gICAgICB2YXIgYWxsUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHBhcmVudCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbFByb3BlcnR5TmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3BlcnR5TmFtZSA9IGFsbFByb3BlcnR5TmFtZXNbaV07XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwYXJlbnQsIHByb3BlcnR5TmFtZSk7XG4gICAgICAgIGlmIChkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IuZW51bWVyYWJsZSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkW3Byb3BlcnR5TmFtZV0gPSBfY2xvbmUocGFyZW50W3Byb3BlcnR5TmFtZV0sIGRlcHRoIC0gMSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjaGlsZCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoaWxkO1xuICB9XG5cbiAgcmV0dXJuIF9jbG9uZShwYXJlbnQsIGRlcHRoKTtcbn1cblxuLyoqXG4gKiBTaW1wbGUgZmxhdCBjbG9uZSB1c2luZyBwcm90b3R5cGUsIGFjY2VwdHMgb25seSBvYmplY3RzLCB1c2VmdWxsIGZvciBwcm9wZXJ0eVxuICogb3ZlcnJpZGUgb24gRkxBVCBjb25maWd1cmF0aW9uIG9iamVjdCAobm8gbmVzdGVkIHByb3BzKS5cbiAqXG4gKiBVU0UgV0lUSCBDQVVUSU9OISBUaGlzIG1heSBub3QgYmVoYXZlIGFzIHlvdSB3aXNoIGlmIHlvdSBkbyBub3Qga25vdyBob3cgdGhpc1xuICogd29ya3MuXG4gKi9cbmNsb25lLmNsb25lUHJvdG90eXBlID0gZnVuY3Rpb24gY2xvbmVQcm90b3R5cGUocGFyZW50KSB7XG4gIGlmIChwYXJlbnQgPT09IG51bGwpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgdmFyIGMgPSBmdW5jdGlvbiAoKSB7fTtcbiAgYy5wcm90b3R5cGUgPSBwYXJlbnQ7XG4gIHJldHVybiBuZXcgYygpO1xufTtcblxuLy8gcHJpdmF0ZSB1dGlsaXR5IGZ1bmN0aW9uc1xuXG5mdW5jdGlvbiBfX29ialRvU3RyKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cbmNsb25lLl9fb2JqVG9TdHIgPSBfX29ialRvU3RyO1xuXG5mdW5jdGlvbiBfX2lzRGF0ZShvKSB7XG4gIHJldHVybiB0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiYgX19vYmpUb1N0cihvKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuY2xvbmUuX19pc0RhdGUgPSBfX2lzRGF0ZTtcblxuZnVuY3Rpb24gX19pc0FycmF5KG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiBfX29ialRvU3RyKG8pID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuY2xvbmUuX19pc0FycmF5ID0gX19pc0FycmF5O1xuXG5mdW5jdGlvbiBfX2lzUmVnRXhwKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiBfX29ialRvU3RyKG8pID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmNsb25lLl9faXNSZWdFeHAgPSBfX2lzUmVnRXhwO1xuXG5mdW5jdGlvbiBfX2dldFJlZ0V4cEZsYWdzKHJlKSB7XG4gIHZhciBmbGFncyA9ICcnO1xuICBpZiAocmUuZ2xvYmFsKSBmbGFncyArPSAnZyc7XG4gIGlmIChyZS5pZ25vcmVDYXNlKSBmbGFncyArPSAnaSc7XG4gIGlmIChyZS5tdWx0aWxpbmUpIGZsYWdzICs9ICdtJztcbiAgcmV0dXJuIGZsYWdzO1xufVxuY2xvbmUuX19nZXRSZWdFeHBGbGFncyA9IF9fZ2V0UmVnRXhwRmxhZ3M7XG5cbnJldHVybiBjbG9uZTtcbn0pKCk7XG5cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGNsb25lO1xufVxuIiwidmFyIF9fcm9vdF9fID0gKGZ1bmN0aW9uIChyb290KSB7XG5mdW5jdGlvbiBGKCkgeyB0aGlzLmZldGNoID0gZmFsc2U7IH1cbkYucHJvdG90eXBlID0gcm9vdDtcbnJldHVybiBuZXcgRigpO1xufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMpO1xuKGZ1bmN0aW9uKHNlbGYpIHtcblxuKGZ1bmN0aW9uKHNlbGYpIHtcblxuICBpZiAoc2VsZi5mZXRjaCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHN1cHBvcnQgPSB7XG4gICAgc2VhcmNoUGFyYW1zOiAnVVJMU2VhcmNoUGFyYW1zJyBpbiBzZWxmLFxuICAgIGl0ZXJhYmxlOiAnU3ltYm9sJyBpbiBzZWxmICYmICdpdGVyYXRvcicgaW4gU3ltYm9sLFxuICAgIGJsb2I6ICdGaWxlUmVhZGVyJyBpbiBzZWxmICYmICdCbG9iJyBpbiBzZWxmICYmIChmdW5jdGlvbigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBCbG9iKCk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSkoKSxcbiAgICBmb3JtRGF0YTogJ0Zvcm1EYXRhJyBpbiBzZWxmLFxuICAgIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIHNlbGZcbiAgfTtcblxuICBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlcikge1xuICAgIHZhciB2aWV3Q2xhc3NlcyA9IFtcbiAgICAgICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgICAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBGbG9hdDY0QXJyYXldJ1xuICAgIF07XG5cbiAgICB2YXIgaXNEYXRhVmlldyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiBEYXRhVmlldy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihvYmopXG4gICAgfTtcblxuICAgIHZhciBpc0FycmF5QnVmZmVyVmlldyA9IEFycmF5QnVmZmVyLmlzVmlldyB8fCBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdmlld0NsYXNzZXMuaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkgPiAtMVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVOYW1lKG5hbWUpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBuYW1lID0gU3RyaW5nKG5hbWUpO1xuICAgIH1cbiAgICBpZiAoL1teYS16MC05XFwtIyQlJicqKy5cXF5fYHx+XS9pLnRlc3QobmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyIGluIGhlYWRlciBmaWVsZCBuYW1lJylcbiAgICB9XG4gICAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKVxuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8vIEJ1aWxkIGEgZGVzdHJ1Y3RpdmUgaXRlcmF0b3IgZm9yIHRoZSB2YWx1ZSBsaXN0XG4gIGZ1bmN0aW9uIGl0ZXJhdG9yRm9yKGl0ZW1zKSB7XG4gICAgdmFyIGl0ZXJhdG9yID0ge1xuICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGl0ZW1zLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiB7ZG9uZTogdmFsdWUgPT09IHVuZGVmaW5lZCwgdmFsdWU6IHZhbHVlfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICAgICAgaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZXJhdG9yXG4gIH1cblxuICBmdW5jdGlvbiBIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICB0aGlzLm1hcCA9IHt9O1xuXG4gICAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKGhlYWRlclswXSwgaGVhZGVyWzFdKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoaGVhZGVycykge1xuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIGhlYWRlcnNbbmFtZV0pO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICB2YWx1ZSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLm1hcFtuYW1lXTtcbiAgICB0aGlzLm1hcFtuYW1lXSA9IG9sZFZhbHVlID8gb2xkVmFsdWUrJywnK3ZhbHVlIDogdmFsdWU7XG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGVbJ2RlbGV0ZSddID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgbmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSk7XG4gICAgcmV0dXJuIHRoaXMuaGFzKG5hbWUpID8gdGhpcy5tYXBbbmFtZV0gOiBudWxsXG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShub3JtYWxpemVOYW1lKG5hbWUpKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV0gPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSk7XG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLm1hcCkge1xuICAgICAgaWYgKHRoaXMubWFwLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdGhpcy5tYXBbbmFtZV0sIG5hbWUsIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7IGl0ZW1zLnB1c2gobmFtZSk7IH0pO1xuICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHsgaXRlbXMucHVzaCh2YWx1ZSk7IH0pO1xuICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7IGl0ZW1zLnB1c2goW25hbWUsIHZhbHVlXSk7IH0pO1xuICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgfTtcblxuICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICAgIEhlYWRlcnMucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBIZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzO1xuICB9XG5cbiAgZnVuY3Rpb24gY29uc3VtZWQoYm9keSkge1xuICAgIGlmIChib2R5LmJvZHlVc2VkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJykpXG4gICAgfVxuICAgIGJvZHkuYm9keVVzZWQgPSB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlsZVJlYWRlclJlYWR5KHJlYWRlcikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzb2x2ZShyZWFkZXIucmVzdWx0KTtcbiAgICAgIH07XG4gICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QocmVhZGVyLmVycm9yKTtcbiAgICAgIH07XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNBcnJheUJ1ZmZlcihibG9iKSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKTtcbiAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYik7XG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNUZXh0KGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpO1xuICAgIHJlYWRlci5yZWFkQXNUZXh0KGJsb2IpO1xuICAgIHJldHVybiBwcm9taXNlXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQXJyYXlCdWZmZXJBc1RleHQoYnVmKSB7XG4gICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYpO1xuICAgIHZhciBjaGFycyA9IG5ldyBBcnJheSh2aWV3Lmxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoYXJzW2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZSh2aWV3W2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpXG4gIH1cblxuICBmdW5jdGlvbiBidWZmZXJDbG9uZShidWYpIHtcbiAgICBpZiAoYnVmLnNsaWNlKSB7XG4gICAgICByZXR1cm4gYnVmLnNsaWNlKDApXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmLmJ5dGVMZW5ndGgpO1xuICAgICAgdmlldy5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmKSk7XG4gICAgICByZXR1cm4gdmlldy5idWZmZXJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBCb2R5KCkge1xuICAgIHRoaXMuYm9keVVzZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuX2luaXRCb2R5ID0gZnVuY3Rpb24oYm9keSkge1xuICAgICAgdGhpcy5fYm9keUluaXQgPSBib2R5O1xuICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gJyc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYmxvYiAmJiBCbG9iLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlCbG9iID0gYm9keTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5mb3JtRGF0YSAmJiBGb3JtRGF0YS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5Rm9ybURhdGEgPSBib2R5O1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LnNlYXJjaFBhcmFtcyAmJiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5LnRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgc3VwcG9ydC5ibG9iICYmIGlzRGF0YVZpZXcoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keS5idWZmZXIpO1xuICAgICAgICAvLyBJRSAxMC0xMSBjYW4ndCBoYW5kbGUgYSBEYXRhVmlldyBib2R5LlxuICAgICAgICB0aGlzLl9ib2R5SW5pdCA9IG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiAoQXJyYXlCdWZmZXIucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkgfHwgaXNBcnJheUJ1ZmZlclZpZXcoYm9keSkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCBCb2R5SW5pdCB0eXBlJylcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlCbG9iICYmIHRoaXMuX2JvZHlCbG9iLnR5cGUpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCB0aGlzLl9ib2R5QmxvYi50eXBlKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LnNlYXJjaFBhcmFtcyAmJiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgICB0aGlzLmJsb2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcyk7XG4gICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QmxvYilcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKSlcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgYmxvYicpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keVRleHRdKSlcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnN1bWVkKHRoaXMpIHx8IFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYmxvYigpLnRoZW4ocmVhZEJsb2JBc0FycmF5QnVmZmVyKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMudGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcyk7XG4gICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICByZXR1cm4gcmVhZEJsb2JBc1RleHQodGhpcy5fYm9keUJsb2IpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlYWRBcnJheUJ1ZmZlckFzVGV4dCh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIHRleHQnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5VGV4dClcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHN1cHBvcnQuZm9ybURhdGEpIHtcbiAgICAgIHRoaXMuZm9ybURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oZGVjb2RlKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLmpzb24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKEpTT04ucGFyc2UpXG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBIVFRQIG1ldGhvZHMgd2hvc2UgY2FwaXRhbGl6YXRpb24gc2hvdWxkIGJlIG5vcm1hbGl6ZWRcbiAgdmFyIG1ldGhvZHMgPSBbJ0RFTEVURScsICdHRVQnLCAnSEVBRCcsICdPUFRJT05TJywgJ1BPU1QnLCAnUFVUJ107XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplTWV0aG9kKG1ldGhvZCkge1xuICAgIHZhciB1cGNhc2VkID0gbWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gICAgcmV0dXJuIChtZXRob2RzLmluZGV4T2YodXBjYXNlZCkgPiAtMSkgPyB1cGNhc2VkIDogbWV0aG9kXG4gIH1cblxuICBmdW5jdGlvbiBSZXF1ZXN0KGlucHV0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGJvZHkgPSBvcHRpb25zLmJvZHk7XG5cbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBSZXF1ZXN0KSB7XG4gICAgICBpZiAoaW5wdXQuYm9keVVzZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJylcbiAgICAgIH1cbiAgICAgIHRoaXMudXJsID0gaW5wdXQudXJsO1xuICAgICAgdGhpcy5jcmVkZW50aWFscyA9IGlucHV0LmNyZWRlbnRpYWxzO1xuICAgICAgaWYgKCFvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5wdXQuaGVhZGVycyk7XG4gICAgICB9XG4gICAgICB0aGlzLm1ldGhvZCA9IGlucHV0Lm1ldGhvZDtcbiAgICAgIHRoaXMubW9kZSA9IGlucHV0Lm1vZGU7XG4gICAgICBpZiAoIWJvZHkgJiYgaW5wdXQuX2JvZHlJbml0ICE9IG51bGwpIHtcbiAgICAgICAgYm9keSA9IGlucHV0Ll9ib2R5SW5pdDtcbiAgICAgICAgaW5wdXQuYm9keVVzZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVybCA9IFN0cmluZyhpbnB1dCk7XG4gICAgfVxuXG4gICAgdGhpcy5jcmVkZW50aWFscyA9IG9wdGlvbnMuY3JlZGVudGlhbHMgfHwgdGhpcy5jcmVkZW50aWFscyB8fCAnb21pdCc7XG4gICAgaWYgKG9wdGlvbnMuaGVhZGVycyB8fCAhdGhpcy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpO1xuICAgIH1cbiAgICB0aGlzLm1ldGhvZCA9IG5vcm1hbGl6ZU1ldGhvZChvcHRpb25zLm1ldGhvZCB8fCB0aGlzLm1ldGhvZCB8fCAnR0VUJyk7XG4gICAgdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlIHx8IHRoaXMubW9kZSB8fCBudWxsO1xuICAgIHRoaXMucmVmZXJyZXIgPSBudWxsO1xuXG4gICAgaWYgKCh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5tZXRob2QgPT09ICdIRUFEJykgJiYgYm9keSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9keSBub3QgYWxsb3dlZCBmb3IgR0VUIG9yIEhFQUQgcmVxdWVzdHMnKVxuICAgIH1cbiAgICB0aGlzLl9pbml0Qm9keShib2R5KTtcbiAgfVxuXG4gIFJlcXVlc3QucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBSZXF1ZXN0KHRoaXMsIHsgYm9keTogdGhpcy5fYm9keUluaXQgfSlcbiAgfTtcblxuICBmdW5jdGlvbiBkZWNvZGUoYm9keSkge1xuICAgIHZhciBmb3JtID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgYm9keS50cmltKCkuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICBpZiAoYnl0ZXMpIHtcbiAgICAgICAgdmFyIHNwbGl0ID0gYnl0ZXMuc3BsaXQoJz0nKTtcbiAgICAgICAgdmFyIG5hbWUgPSBzcGxpdC5zaGlmdCgpLnJlcGxhY2UoL1xcKy9nLCAnICcpO1xuICAgICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCc9JykucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gICAgICAgIGZvcm0uYXBwZW5kKGRlY29kZVVSSUNvbXBvbmVudChuYW1lKSwgZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZvcm1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSB7XG4gICAgdmFyIGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgIC8vIFJlcGxhY2UgaW5zdGFuY2VzIG9mIFxcclxcbiBhbmQgXFxuIGZvbGxvd2VkIGJ5IGF0IGxlYXN0IG9uZSBzcGFjZSBvciBob3Jpem9udGFsIHRhYiB3aXRoIGEgc3BhY2VcbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMCNzZWN0aW9uLTMuMlxuICAgIHZhciBwcmVQcm9jZXNzZWRIZWFkZXJzID0gcmF3SGVhZGVycy5yZXBsYWNlKC9cXHI/XFxuW1xcdCBdKy9nLCAnICcpO1xuICAgIHByZVByb2Nlc3NlZEhlYWRlcnMuc3BsaXQoL1xccj9cXG4vKS5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHZhciBwYXJ0cyA9IGxpbmUuc3BsaXQoJzonKTtcbiAgICAgIHZhciBrZXkgPSBwYXJ0cy5zaGlmdCgpLnRyaW0oKTtcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcGFydHMuam9pbignOicpLnRyaW0oKTtcbiAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGhlYWRlcnNcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXF1ZXN0LnByb3RvdHlwZSk7XG5cbiAgZnVuY3Rpb24gUmVzcG9uc2UoYm9keUluaXQsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLnR5cGUgPSAnZGVmYXVsdCc7XG4gICAgdGhpcy5zdGF0dXMgPSBvcHRpb25zLnN0YXR1cyA9PT0gdW5kZWZpbmVkID8gMjAwIDogb3B0aW9ucy5zdGF0dXM7XG4gICAgdGhpcy5vayA9IHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8IDMwMDtcbiAgICB0aGlzLnN0YXR1c1RleHQgPSAnc3RhdHVzVGV4dCcgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc3RhdHVzVGV4dCA6ICdPSyc7XG4gICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKTtcbiAgICB0aGlzLnVybCA9IG9wdGlvbnMudXJsIHx8ICcnO1xuICAgIHRoaXMuX2luaXRCb2R5KGJvZHlJbml0KTtcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXNwb25zZS5wcm90b3R5cGUpO1xuXG4gIFJlc3BvbnNlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UodGhpcy5fYm9keUluaXQsIHtcbiAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICBzdGF0dXNUZXh0OiB0aGlzLnN0YXR1c1RleHQsXG4gICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyh0aGlzLmhlYWRlcnMpLFxuICAgICAgdXJsOiB0aGlzLnVybFxuICAgIH0pXG4gIH07XG5cbiAgUmVzcG9uc2UuZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogMCwgc3RhdHVzVGV4dDogJyd9KTtcbiAgICByZXNwb25zZS50eXBlID0gJ2Vycm9yJztcbiAgICByZXR1cm4gcmVzcG9uc2VcbiAgfTtcblxuICB2YXIgcmVkaXJlY3RTdGF0dXNlcyA9IFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF07XG5cbiAgUmVzcG9uc2UucmVkaXJlY3QgPSBmdW5jdGlvbih1cmwsIHN0YXR1cykge1xuICAgIGlmIChyZWRpcmVjdFN0YXR1c2VzLmluZGV4T2Yoc3RhdHVzKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHN0YXR1cyBjb2RlJylcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IHN0YXR1cywgaGVhZGVyczoge2xvY2F0aW9uOiB1cmx9fSlcbiAgfTtcblxuICBzZWxmLkhlYWRlcnMgPSBIZWFkZXJzO1xuICBzZWxmLlJlcXVlc3QgPSBSZXF1ZXN0O1xuICBzZWxmLlJlc3BvbnNlID0gUmVzcG9uc2U7XG5cbiAgc2VsZi5mZXRjaCA9IGZ1bmN0aW9uKGlucHV0LCBpbml0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgUmVxdWVzdChpbnB1dCwgaW5pdCk7XG4gICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgc3RhdHVzOiB4aHIuc3RhdHVzLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgIGhlYWRlcnM6IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgfHwgJycpXG4gICAgICAgIH07XG4gICAgICAgIG9wdGlvbnMudXJsID0gJ3Jlc3BvbnNlVVJMJyBpbiB4aHIgPyB4aHIucmVzcG9uc2VVUkwgOiBvcHRpb25zLmhlYWRlcnMuZ2V0KCdYLVJlcXVlc3QtVVJMJyk7XG4gICAgICAgIHZhciBib2R5ID0gJ3Jlc3BvbnNlJyBpbiB4aHIgPyB4aHIucmVzcG9uc2UgOiB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICByZXNvbHZlKG5ldyBSZXNwb25zZShib2R5LCBvcHRpb25zKSk7XG4gICAgICB9O1xuXG4gICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSk7XG4gICAgICB9O1xuXG4gICAgICB4aHIub3BlbihyZXF1ZXN0Lm1ldGhvZCwgcmVxdWVzdC51cmwsIHRydWUpO1xuXG4gICAgICBpZiAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ2luY2x1ZGUnKSB7XG4gICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnb21pdCcpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoJ3Jlc3BvbnNlVHlwZScgaW4geGhyICYmIHN1cHBvcnQuYmxvYikge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2Jsb2InO1xuICAgICAgfVxuXG4gICAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSk7XG4gICAgICB9KTtcblxuICAgICAgeGhyLnNlbmQodHlwZW9mIHJlcXVlc3QuX2JvZHlJbml0ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiByZXF1ZXN0Ll9ib2R5SW5pdCk7XG4gICAgfSlcbiAgfTtcbiAgc2VsZi5mZXRjaC5wb2x5ZmlsbCA9IHRydWU7XG59KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcyk7XG59KS5jYWxsKF9fcm9vdF9fLCB2b2lkKDApKTtcbnZhciBmZXRjaCA9IF9fcm9vdF9fLmZldGNoO1xudmFyIFJlc3BvbnNlID0gZmV0Y2guUmVzcG9uc2UgPSBfX3Jvb3RfXy5SZXNwb25zZTtcbnZhciBSZXF1ZXN0ID0gZmV0Y2guUmVxdWVzdCA9IF9fcm9vdF9fLlJlcXVlc3Q7XG52YXIgSGVhZGVycyA9IGZldGNoLkhlYWRlcnMgPSBfX3Jvb3RfXy5IZWFkZXJzO1xuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5tb2R1bGUuZXhwb3J0cyA9IGZldGNoO1xuLy8gTmVlZGVkIGZvciBUeXBlU2NyaXB0IGNvbnN1bWVycyB3aXRob3V0IGVzTW9kdWxlSW50ZXJvcC5cbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBmZXRjaDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgcHJvY2Vzc0ZuID0gKGZuLCBvcHRzKSA9PiBmdW5jdGlvbiAoKSB7XG5cdGNvbnN0IFAgPSBvcHRzLnByb21pc2VNb2R1bGU7XG5cdGNvbnN0IGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG5cblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuXHR9XG5cblx0cmV0dXJuIG5ldyBQKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRpZiAob3B0cy5lcnJvckZpcnN0KSB7XG5cdFx0XHRhcmdzLnB1c2goZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XG5cdFx0XHRcdGlmIChvcHRzLm11bHRpQXJncykge1xuXHRcdFx0XHRcdGNvbnN0IHJlc3VsdHMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdHJlc3VsdHNbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0XHRcdHJlc3VsdHMudW5zaGlmdChlcnIpO1xuXHRcdFx0XHRcdFx0cmVqZWN0KHJlc3VsdHMpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdHMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChlcnIpIHtcblx0XHRcdFx0XHRyZWplY3QoZXJyKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhcmdzLnB1c2goZnVuY3Rpb24gKHJlc3VsdCkge1xuXHRcdFx0XHRpZiAob3B0cy5tdWx0aUFyZ3MpIHtcblx0XHRcdFx0XHRjb25zdCByZXN1bHRzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcblxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRzW2ldID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJlc29sdmUocmVzdWx0cyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzb2x2ZShyZXN1bHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRmbi5hcHBseSh0aGlzLCBhcmdzKTtcblx0fSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IChvYmosIG9wdHMpID0+IHtcblx0b3B0cyA9IE9iamVjdC5hc3NpZ24oe1xuXHRcdGV4Y2x1ZGU6IFsvLisoU3luY3xTdHJlYW0pJC9dLFxuXHRcdGVycm9yRmlyc3Q6IHRydWUsXG5cdFx0cHJvbWlzZU1vZHVsZTogUHJvbWlzZVxuXHR9LCBvcHRzKTtcblxuXHRjb25zdCBmaWx0ZXIgPSBrZXkgPT4ge1xuXHRcdGNvbnN0IG1hdGNoID0gcGF0dGVybiA9PiB0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycgPyBrZXkgPT09IHBhdHRlcm4gOiBwYXR0ZXJuLnRlc3Qoa2V5KTtcblx0XHRyZXR1cm4gb3B0cy5pbmNsdWRlID8gb3B0cy5pbmNsdWRlLnNvbWUobWF0Y2gpIDogIW9wdHMuZXhjbHVkZS5zb21lKG1hdGNoKTtcblx0fTtcblxuXHRsZXQgcmV0O1xuXHRpZiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHJldCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmIChvcHRzLmV4Y2x1ZGVNYWluKSB7XG5cdFx0XHRcdHJldHVybiBvYmouYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHByb2Nlc3NGbihvYmosIG9wdHMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRyZXQgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopKTtcblx0fVxuXG5cdGZvciAoY29uc3Qga2V5IGluIG9iaikgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGd1YXJkLWZvci1pblxuXHRcdGNvbnN0IHggPSBvYmpba2V5XTtcblx0XHRyZXRba2V5XSA9IHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nICYmIGZpbHRlcihrZXkpID8gcHJvY2Vzc0ZuKHgsIG9wdHMpIDogeDtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuIiwiY29uc3QgRXRoUXVlcnkgPSByZXF1aXJlKCdldGgtcXVlcnknKVxuY29uc3QgcGlmeSA9IHJlcXVpcmUoJ3BpZnknKVxuY29uc3QgU2FmZUV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ3NhZmUtZXZlbnQtZW1pdHRlcicpXG5cbmNvbnN0IHNlYyA9IDEwMDBcblxuY29uc3QgY2FsY3VsYXRlU3VtID0gKGFjY3VtdWxhdG9yLCBjdXJyZW50VmFsdWUpID0+IGFjY3VtdWxhdG9yICsgY3VycmVudFZhbHVlXG5jb25zdCBibG9ja1RyYWNrZXJFdmVudHMgPSBbJ3N5bmMnLCAnbGF0ZXN0J11cblxuY2xhc3MgQmFzZUJsb2NrVHJhY2tlciBleHRlbmRzIFNhZmVFdmVudEVtaXR0ZXIge1xuXG4gIC8vXG4gIC8vIHB1YmxpY1xuICAvL1xuXG4gIGNvbnN0cnVjdG9yIChvcHRzID0ge30pIHtcbiAgICBzdXBlcigpXG4gICAgLy8gY29uZmlnXG4gICAgdGhpcy5fYmxvY2tSZXNldER1cmF0aW9uID0gb3B0cy5ibG9ja1Jlc2V0RHVyYXRpb24gfHwgMjAgKiBzZWNcbiAgICAvLyBzdGF0ZVxuICAgIHRoaXMuX2Jsb2NrUmVzZXRUaW1lb3V0XG4gICAgdGhpcy5fY3VycmVudEJsb2NrID0gbnVsbFxuICAgIHRoaXMuX2lzUnVubmluZyA9IGZhbHNlXG4gICAgLy8gYmluZCBmdW5jdGlvbnMgZm9yIGludGVybmFsIHVzZVxuICAgIHRoaXMuX29uTmV3TGlzdGVuZXIgPSB0aGlzLl9vbk5ld0xpc3RlbmVyLmJpbmQodGhpcylcbiAgICB0aGlzLl9vblJlbW92ZUxpc3RlbmVyID0gdGhpcy5fb25SZW1vdmVMaXN0ZW5lci5iaW5kKHRoaXMpXG4gICAgdGhpcy5fcmVzZXRDdXJyZW50QmxvY2sgPSB0aGlzLl9yZXNldEN1cnJlbnRCbG9jay5iaW5kKHRoaXMpXG4gICAgLy8gbGlzdGVuIGZvciBoYW5kbGVyIGNoYW5nZXNcbiAgICB0aGlzLl9zZXR1cEludGVybmFsRXZlbnRzKClcbiAgfVxuXG4gIGlzUnVubmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzUnVubmluZ1xuICB9XG5cbiAgZ2V0Q3VycmVudEJsb2NrICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudEJsb2NrXG4gIH1cblxuICBhc3luYyBnZXRMYXRlc3RCbG9jayAoKSB7XG4gICAgLy8gcmV0dXJuIGlmIGF2YWlsYWJsZVxuICAgIGlmICh0aGlzLl9jdXJyZW50QmxvY2spIHJldHVybiB0aGlzLl9jdXJyZW50QmxvY2tcbiAgICAvLyB3YWl0IGZvciBhIG5ldyBsYXRlc3QgYmxvY2tcbiAgICBjb25zdCBsYXRlc3RCbG9jayA9IGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gdGhpcy5vbmNlKCdsYXRlc3QnLCByZXNvbHZlKSlcbiAgICAvLyByZXR1cm4gbmV3bHkgc2V0IGN1cnJlbnQgYmxvY2tcbiAgICByZXR1cm4gbGF0ZXN0QmxvY2tcbiAgfVxuXG4gIC8vIGRvbnQgYWxsb3cgbW9kdWxlIGNvbnN1bWVyIHRvIHJlbW92ZSBvdXIgaW50ZXJuYWwgZXZlbnQgbGlzdGVuZXJzXG4gIHJlbW92ZUFsbExpc3RlbmVycyAoZXZlbnROYW1lKSB7XG4gICAgLy8gcGVyZm9ybSBkZWZhdWx0IGJlaGF2aW9yLCBwcmVzZXJ2ZSBmbiBhcml0eVxuICAgIGlmIChldmVudE5hbWUpIHtcbiAgICAgIHN1cGVyLnJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLnJlbW92ZUFsbExpc3RlbmVycygpXG4gICAgfVxuICAgIC8vIHJlLWFkZCBpbnRlcm5hbCBldmVudHNcbiAgICB0aGlzLl9zZXR1cEludGVybmFsRXZlbnRzKClcbiAgICAvLyB0cmlnZ2VyIHN0b3AgY2hlY2sganVzdCBpbiBjYXNlXG4gICAgdGhpcy5fb25SZW1vdmVMaXN0ZW5lcigpXG4gIH1cblxuICAvL1xuICAvLyB0byBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzc1xuICAvL1xuXG4gIF9zdGFydCAoKSB7XG4gICAgLy8gZGVmYXVsdCBiZWhhdmlvciBpcyBub29wXG4gIH1cblxuICBfZW5kICgpIHtcbiAgICAvLyBkZWZhdWx0IGJlaGF2aW9yIGlzIG5vb3BcbiAgfVxuXG4gIC8vXG4gIC8vIHByaXZhdGVcbiAgLy9cblxuICBfc2V0dXBJbnRlcm5hbEV2ZW50cyAoKSB7XG4gICAgLy8gZmlyc3QgcmVtb3ZlIGxpc3RlbmVycyBmb3IgaWRlbXBvdGVuY2VcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCduZXdMaXN0ZW5lcicsIHRoaXMuX29uTmV3TGlzdGVuZXIpXG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigncmVtb3ZlTGlzdGVuZXInLCB0aGlzLl9vblJlbW92ZUxpc3RlbmVyKVxuICAgIC8vIHRoZW4gYWRkIHRoZW1cbiAgICB0aGlzLm9uKCduZXdMaXN0ZW5lcicsIHRoaXMuX29uTmV3TGlzdGVuZXIpXG4gICAgdGhpcy5vbigncmVtb3ZlTGlzdGVuZXInLCB0aGlzLl9vblJlbW92ZUxpc3RlbmVyKVxuICB9XG5cbiAgX29uTmV3TGlzdGVuZXIgKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgIC8vIGBuZXdMaXN0ZW5lcmAgaXMgY2FsbGVkICpiZWZvcmUqIHRoZSBsaXN0ZW5lciBpcyBhZGRlZFxuICAgIGlmICghYmxvY2tUcmFja2VyRXZlbnRzLmluY2x1ZGVzKGV2ZW50TmFtZSkpIHJldHVyblxuICAgIHRoaXMuX21heWJlU3RhcnQoKVxuICB9XG5cbiAgX29uUmVtb3ZlTGlzdGVuZXIgKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgIC8vIGByZW1vdmVMaXN0ZW5lcmAgaXMgY2FsbGVkICphZnRlciogdGhlIGxpc3RlbmVyIGlzIHJlbW92ZWRcbiAgICBpZiAodGhpcy5fZ2V0QmxvY2tUcmFja2VyRXZlbnRDb3VudCgpID4gMCkgcmV0dXJuXG4gICAgdGhpcy5fbWF5YmVFbmQoKVxuICB9XG5cbiAgX21heWJlU3RhcnQgKCkge1xuICAgIGlmICh0aGlzLl9pc1J1bm5pbmcpIHJldHVyblxuICAgIHRoaXMuX2lzUnVubmluZyA9IHRydWVcbiAgICAvLyBjYW5jZWwgc2V0dGluZyBsYXRlc3QgYmxvY2sgdG8gc3RhbGVcbiAgICB0aGlzLl9jYW5jZWxCbG9ja1Jlc2V0VGltZW91dCgpXG4gICAgdGhpcy5fc3RhcnQoKVxuICB9XG5cbiAgX21heWJlRW5kICgpIHtcbiAgICBpZiAoIXRoaXMuX2lzUnVubmluZykgcmV0dXJuXG4gICAgdGhpcy5faXNSdW5uaW5nID0gZmFsc2VcbiAgICB0aGlzLl9zZXR1cEJsb2NrUmVzZXRUaW1lb3V0KClcbiAgICB0aGlzLl9lbmQoKVxuICB9XG5cbiAgX2dldEJsb2NrVHJhY2tlckV2ZW50Q291bnQgKCkge1xuICAgIHJldHVybiBibG9ja1RyYWNrZXJFdmVudHNcbiAgICAgIC5tYXAoZXZlbnROYW1lID0+IHRoaXMubGlzdGVuZXJDb3VudChldmVudE5hbWUpKVxuICAgICAgLnJlZHVjZShjYWxjdWxhdGVTdW0pXG4gIH1cblxuICBfbmV3UG90ZW50aWFsTGF0ZXN0IChuZXdCbG9jaykge1xuICAgIGNvbnN0IGN1cnJlbnRCbG9jayA9IHRoaXMuX2N1cnJlbnRCbG9ja1xuICAgIC8vIG9ubHkgdXBkYXRlIGlmIGJsb2sgbnVtYmVyIGlzIGhpZ2hlclxuICAgIGlmIChjdXJyZW50QmxvY2sgJiYgKGhleFRvSW50KG5ld0Jsb2NrKSA8PSBoZXhUb0ludChjdXJyZW50QmxvY2spKSkgcmV0dXJuXG4gICAgdGhpcy5fc2V0Q3VycmVudEJsb2NrKG5ld0Jsb2NrKVxuICB9XG5cbiAgX3NldEN1cnJlbnRCbG9jayAobmV3QmxvY2spIHtcbiAgICBjb25zdCBvbGRCbG9jayA9IHRoaXMuX2N1cnJlbnRCbG9ja1xuICAgIHRoaXMuX2N1cnJlbnRCbG9jayA9IG5ld0Jsb2NrXG4gICAgdGhpcy5lbWl0KCdsYXRlc3QnLCBuZXdCbG9jaylcbiAgICB0aGlzLmVtaXQoJ3N5bmMnLCB7IG9sZEJsb2NrLCBuZXdCbG9jayB9KVxuICB9XG5cbiAgX3NldHVwQmxvY2tSZXNldFRpbWVvdXQgKCkge1xuICAgIC8vIGNsZWFyIGFueSBleGlzdGluZyB0aW1lb3V0XG4gICAgdGhpcy5fY2FuY2VsQmxvY2tSZXNldFRpbWVvdXQoKVxuICAgIC8vIGNsZWFyIGxhdGVzdCBibG9jayB3aGVuIHN0YWxlXG4gICAgdGhpcy5fYmxvY2tSZXNldFRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuX3Jlc2V0Q3VycmVudEJsb2NrLCB0aGlzLl9ibG9ja1Jlc2V0RHVyYXRpb24pXG4gICAgLy8gbm9kZWpzIC0gZG9udCBob2xkIHByb2Nlc3Mgb3BlblxuICAgIGlmICh0aGlzLl9ibG9ja1Jlc2V0VGltZW91dC51bnJlZikge1xuICAgICAgdGhpcy5fYmxvY2tSZXNldFRpbWVvdXQudW5yZWYoKVxuICAgIH1cbiAgfVxuXG4gIF9jYW5jZWxCbG9ja1Jlc2V0VGltZW91dCAoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX2Jsb2NrUmVzZXRUaW1lb3V0KVxuICB9XG5cbiAgX3Jlc2V0Q3VycmVudEJsb2NrICgpIHtcbiAgICB0aGlzLl9jdXJyZW50QmxvY2sgPSBudWxsXG4gIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VCbG9ja1RyYWNrZXJcblxuZnVuY3Rpb24gaGV4VG9JbnQoaGV4SW50KSB7XG4gIHJldHVybiBOdW1iZXIucGFyc2VJbnQoaGV4SW50LCAxNilcbn1cbiIsImNvbnN0IHBpZnkgPSByZXF1aXJlKCdwaWZ5JylcbmNvbnN0IEJhc2VCbG9ja1RyYWNrZXIgPSByZXF1aXJlKCcuL2Jhc2UnKVxuXG5jb25zdCBzZWMgPSAxMDAwXG5cbmNsYXNzIFBvbGxpbmdCbG9ja1RyYWNrZXIgZXh0ZW5kcyBCYXNlQmxvY2tUcmFja2VyIHtcblxuICBjb25zdHJ1Y3RvciAob3B0cyA9IHt9KSB7XG4gICAgLy8gcGFyc2UgKyB2YWxpZGF0ZSBhcmdzXG4gICAgaWYgKCFvcHRzLnByb3ZpZGVyKSB0aHJvdyBuZXcgRXJyb3IoJ1BvbGxpbmdCbG9ja1RyYWNrZXIgLSBubyBwcm92aWRlciBzcGVjaWZpZWQuJylcbiAgICBjb25zdCBwb2xsaW5nSW50ZXJ2YWwgPSBvcHRzLnBvbGxpbmdJbnRlcnZhbCB8fCAyMCAqIHNlY1xuICAgIGNvbnN0IHJldHJ5VGltZW91dCA9IG9wdHMucmV0cnlUaW1lb3V0IHx8IHBvbGxpbmdJbnRlcnZhbCAvIDEwXG4gICAgY29uc3Qga2VlcEV2ZW50TG9vcEFjdGl2ZSA9IG9wdHMua2VlcEV2ZW50TG9vcEFjdGl2ZSAhPT0gdW5kZWZpbmVkID8gb3B0cy5rZWVwRXZlbnRMb29wQWN0aXZlIDogdHJ1ZVxuICAgIGNvbnN0IHNldFNraXBDYWNoZUZsYWcgPSBvcHRzLnNldFNraXBDYWNoZUZsYWcgfHwgZmFsc2VcbiAgICAvLyBCYXNlQmxvY2tUcmFja2VyIGNvbnN0cnVjdG9yXG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbih7XG4gICAgICBibG9ja1Jlc2V0RHVyYXRpb246IHBvbGxpbmdJbnRlcnZhbCxcbiAgICB9LCBvcHRzKSlcbiAgICAvLyBjb25maWdcbiAgICB0aGlzLl9wcm92aWRlciA9IG9wdHMucHJvdmlkZXJcbiAgICB0aGlzLl9wb2xsaW5nSW50ZXJ2YWwgPSBwb2xsaW5nSW50ZXJ2YWxcbiAgICB0aGlzLl9yZXRyeVRpbWVvdXQgPSByZXRyeVRpbWVvdXRcbiAgICB0aGlzLl9rZWVwRXZlbnRMb29wQWN0aXZlID0ga2VlcEV2ZW50TG9vcEFjdGl2ZVxuICAgIHRoaXMuX3NldFNraXBDYWNoZUZsYWcgPSBzZXRTa2lwQ2FjaGVGbGFnXG4gIH1cblxuICAvL1xuICAvLyBwdWJsaWNcbiAgLy9cblxuICAvLyB0cmlnZ2VyIGJsb2NrIHBvbGxpbmdcbiAgYXN5bmMgY2hlY2tGb3JMYXRlc3RCbG9jayAoKSB7XG4gICAgYXdhaXQgdGhpcy5fdXBkYXRlTGF0ZXN0QmxvY2soKVxuICAgIHJldHVybiBhd2FpdCB0aGlzLmdldExhdGVzdEJsb2NrKClcbiAgfVxuXG4gIC8vXG4gIC8vIHByaXZhdGVcbiAgLy9cblxuICBfc3RhcnQgKCkge1xuICAgIHRoaXMuX3BlcmZvcm1TeW5jKCkuY2F0Y2goZXJyID0+IHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpKVxuICB9XG5cbiAgYXN5bmMgX3BlcmZvcm1TeW5jICgpIHtcbiAgICB3aGlsZSAodGhpcy5faXNSdW5uaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVMYXRlc3RCbG9jaygpXG4gICAgICAgIGF3YWl0IHRpbWVvdXQodGhpcy5fcG9sbGluZ0ludGVydmFsLCAhdGhpcy5fa2VlcEV2ZW50TG9vcEFjdGl2ZSlcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBuZXdFcnIgPSBuZXcgRXJyb3IoYFBvbGxpbmdCbG9ja1RyYWNrZXIgLSBlbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSBhdHRlbXB0aW5nIHRvIHVwZGF0ZSBsYXRlc3QgYmxvY2s6XFxuJHtlcnIuc3RhY2t9YClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3RXJyKVxuICAgICAgICB9IGNhdGNoIChlbWl0RXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihuZXdFcnIpXG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGltZW91dCh0aGlzLl9yZXRyeVRpbWVvdXQsICF0aGlzLl9rZWVwRXZlbnRMb29wQWN0aXZlKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIF91cGRhdGVMYXRlc3RCbG9jayAoKSB7XG4gICAgLy8gZmV0Y2ggKyBzZXQgbGF0ZXN0IGJsb2NrXG4gICAgY29uc3QgbGF0ZXN0QmxvY2sgPSBhd2FpdCB0aGlzLl9mZXRjaExhdGVzdEJsb2NrKClcbiAgICB0aGlzLl9uZXdQb3RlbnRpYWxMYXRlc3QobGF0ZXN0QmxvY2spXG4gIH1cblxuICBhc3luYyBfZmV0Y2hMYXRlc3RCbG9jayAoKSB7XG4gICAgY29uc3QgcmVxID0geyBqc29ucnBjOiBcIjIuMFwiLCBpZDogMSwgbWV0aG9kOiAnZXRoX2Jsb2NrTnVtYmVyJywgcGFyYW1zOiBbXSB9XG4gICAgaWYgKHRoaXMuX3NldFNraXBDYWNoZUZsYWcpIHJlcS5za2lwQ2FjaGUgPSB0cnVlXG4gICAgY29uc3QgcmVzID0gYXdhaXQgcGlmeSgoY2IpID0+IHRoaXMuX3Byb3ZpZGVyLnNlbmRBc3luYyhyZXEsIGNiKSkoKVxuICAgIGlmIChyZXMuZXJyb3IpIHRocm93IG5ldyBFcnJvcihgUG9sbGluZ0Jsb2NrVHJhY2tlciAtIGVuY291bnRlcmVkIGVycm9yIGZldGNoaW5nIGJsb2NrOlxcbiR7cmVzLmVycm9yfWApXG4gICAgcmV0dXJuIHJlcy5yZXN1bHRcbiAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gUG9sbGluZ0Jsb2NrVHJhY2tlclxuXG5mdW5jdGlvbiB0aW1lb3V0IChkdXJhdGlvbiwgdW5yZWYpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIGNvbnN0IHRpbW91dFJlZiA9IHNldFRpbWVvdXQocmVzb2x2ZSwgZHVyYXRpb24pXG4gICAgLy8gZG9uJ3Qga2VlcCBwcm9jZXNzIG9wZW5cbiAgICBpZiAodGltb3V0UmVmLnVucmVmICYmIHVucmVmKSB7XG4gICAgICB0aW1vdXRSZWYudW5yZWYoKVxuICAgIH1cbiAgfSlcbn1cbiIsImNvbnN0IGV4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcbmNvbnN0IGNyZWF0ZVJhbmRvbUlkID0gcmVxdWlyZSgnanNvbi1ycGMtcmFuZG9tLWlkJykoKVxuXG5tb2R1bGUuZXhwb3J0cyA9IEV0aFF1ZXJ5XG5cblxuZnVuY3Rpb24gRXRoUXVlcnkocHJvdmlkZXIpe1xuICBjb25zdCBzZWxmID0gdGhpc1xuICBzZWxmLmN1cnJlbnRQcm92aWRlciA9IHByb3ZpZGVyXG59XG5cbi8vXG4vLyBiYXNlIHF1ZXJpZXNcbi8vXG5cbi8vIGRlZmF1bHQgYmxvY2tcbkV0aFF1ZXJ5LnByb3RvdHlwZS5nZXRCYWxhbmNlID0gICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRm5XaXRoRGVmYXVsdEJsb2NrRm9yKDIsICdldGhfZ2V0QmFsYW5jZScpXG5FdGhRdWVyeS5wcm90b3R5cGUuZ2V0Q29kZSA9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUZuV2l0aERlZmF1bHRCbG9ja0ZvcigyLCAnZXRoX2dldENvZGUnKVxuRXRoUXVlcnkucHJvdG90eXBlLmdldFRyYW5zYWN0aW9uQ291bnQgPSAgICAgICAgICAgICAgICAgZ2VuZXJhdGVGbldpdGhEZWZhdWx0QmxvY2tGb3IoMiwgJ2V0aF9nZXRUcmFuc2FjdGlvbkNvdW50JylcbkV0aFF1ZXJ5LnByb3RvdHlwZS5nZXRTdG9yYWdlQXQgPSAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRm5XaXRoRGVmYXVsdEJsb2NrRm9yKDMsICdldGhfZ2V0U3RvcmFnZUF0JylcbkV0aFF1ZXJ5LnByb3RvdHlwZS5jYWxsID0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRm5XaXRoRGVmYXVsdEJsb2NrRm9yKDIsICdldGhfY2FsbCcpXG4vLyBzdGFuZGFyZFxuRXRoUXVlcnkucHJvdG90eXBlLnByb3RvY29sVmVyc2lvbiA9ICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVGbkZvcignZXRoX3Byb3RvY29sVmVyc2lvbicpXG5FdGhRdWVyeS5wcm90b3R5cGUuc3luY2luZyA9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUZuRm9yKCdldGhfc3luY2luZycpXG5FdGhRdWVyeS5wcm90b3R5cGUuY29pbmJhc2UgPSAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUZuRm9yKCdldGhfY29pbmJhc2UnKVxuRXRoUXVlcnkucHJvdG90eXBlLm1pbmluZyA9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVGbkZvcignZXRoX21pbmluZycpXG5FdGhRdWVyeS5wcm90b3R5cGUuaGFzaHJhdGUgPSAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUZuRm9yKCdldGhfaGFzaHJhdGUnKVxuRXRoUXVlcnkucHJvdG90eXBlLmdhc1ByaWNlID0gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVGbkZvcignZXRoX2dhc1ByaWNlJylcbkV0aFF1ZXJ5LnByb3RvdHlwZS5hY2NvdW50cyA9ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRm5Gb3IoJ2V0aF9hY2NvdW50cycpXG5FdGhRdWVyeS5wcm90b3R5cGUuYmxvY2tOdW1iZXIgPSAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUZuRm9yKCdldGhfYmxvY2tOdW1iZXInKVxuRXRoUXVlcnkucHJvdG90eXBlLmdldEJsb2NrVHJhbnNhY3Rpb25Db3VudEJ5SGFzaCA9ICAgICAgZ2VuZXJhdGVGbkZvcignZXRoX2dldEJsb2NrVHJhbnNhY3Rpb25Db3VudEJ5SGFzaCcpXG5FdGhRdWVyeS5wcm90b3R5cGUuZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50QnlOdW1iZXIgPSAgICBnZW5lcmF0ZUZuRm9yKCdldGhfZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50QnlOdW1iZXInKVxuRXRoUXVlcnkucHJvdG90eXBlLmdldFVuY2xlQ291bnRCeUJsb2NrSGFzaCA9ICAgICAgICAgICAgZ2VuZXJhdGVGbkZvcignZXRoX2dldFVuY2xlQ291bnRCeUJsb2NrSGFzaCcpXG5FdGhRdWVyeS5wcm90b3R5cGUuZ2V0VW5jbGVDb3VudEJ5QmxvY2tOdW1iZXIgPSAgICAgICAgICBnZW5lcmF0ZUZuRm9yKCdldGhfZ2V0VW5jbGVDb3VudEJ5QmxvY2tOdW1iZXInKVxuRXRoUXVlcnkucHJvdG90eXBlLnNpZ24gPSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVGbkZvcignZXRoX3NpZ24nKVxuRXRoUXVlcnkucHJvdG90eXBlLnNlbmRUcmFuc2FjdGlvbiA9ICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVGbkZvcignZXRoX3NlbmRUcmFuc2FjdGlvbicpXG5FdGhRdWVyeS5wcm90b3R5cGUuc2VuZFJhd1RyYW5zYWN0aW9uID0gICAgICAgICAgICAgICAgICBnZW5lcmF0ZUZuRm9yKCdldGhfc2VuZFJhd1RyYW5zYWN0aW9uJylcbkV0aFF1ZXJ5LnByb3RvdHlwZS5lc3RpbWF0ZUdhcyA9ICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRm5Gb3IoJ2V0aF9lc3RpbWF0ZUdhcycpXG5FdGhRdWVyeS5wcm90b3R5cGUuZ2V0QmxvY2tCeUhhc2ggPSAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUZuRm9yKCdldGhfZ2V0QmxvY2tCeUhhc2gnKVxuRXRoUXVlcnkucHJvdG90eXBlLmdldEJsb2NrQnlOdW1iZXIgPSAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVGbkZvcignZXRoX2dldEJsb2NrQnlOdW1iZXInKVxuRXRoUXVlcnkucHJvdG90eXBlLmdldFRyYW5zYWN0aW9uQnlIYXNoID0gICAgICAgICAgICAgICAgZ2VuZXJhdGVGbkZvcignZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoJylcbkV0aFF1ZXJ5LnByb3RvdHlwZS5nZXRUcmFuc2FjdGlvbkJ5QmxvY2tIYXNoQW5kSW5kZXggPSAgIGdlbmVyYXRlRm5Gb3IoJ2V0aF9nZXRUcmFuc2FjdGlvbkJ5QmxvY2tIYXNoQW5kSW5kZXgnKVxuRXRoUXVlcnkucHJvdG90eXBlLmdldFRyYW5zYWN0aW9uQnlCbG9ja051bWJlckFuZEluZGV4ID0gZ2VuZXJhdGVGbkZvcignZXRoX2dldFRyYW5zYWN0aW9uQnlCbG9ja051bWJlckFuZEluZGV4JylcbkV0aFF1ZXJ5LnByb3RvdHlwZS5nZXRUcmFuc2FjdGlvblJlY2VpcHQgPSAgICAgICAgICAgICAgIGdlbmVyYXRlRm5Gb3IoJ2V0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHQnKVxuRXRoUXVlcnkucHJvdG90eXBlLmdldFVuY2xlQnlCbG9ja0hhc2hBbmRJbmRleCA9ICAgICAgICAgZ2VuZXJhdGVGbkZvcignZXRoX2dldFVuY2xlQnlCbG9ja0hhc2hBbmRJbmRleCcpXG5FdGhRdWVyeS5wcm90b3R5cGUuZ2V0VW5jbGVCeUJsb2NrTnVtYmVyQW5kSW5kZXggPSAgICAgICBnZW5lcmF0ZUZuRm9yKCdldGhfZ2V0VW5jbGVCeUJsb2NrTnVtYmVyQW5kSW5kZXgnKVxuRXRoUXVlcnkucHJvdG90eXBlLmdldENvbXBpbGVycyA9ICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVGbkZvcignZXRoX2dldENvbXBpbGVycycpXG5FdGhRdWVyeS5wcm90b3R5cGUuY29tcGlsZUxMTCA9ICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUZuRm9yKCdldGhfY29tcGlsZUxMTCcpXG5FdGhRdWVyeS5wcm90b3R5cGUuY29tcGlsZVNvbGlkaXR5ID0gICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUZuRm9yKCdldGhfY29tcGlsZVNvbGlkaXR5JylcbkV0aFF1ZXJ5LnByb3RvdHlwZS5jb21waWxlU2VycGVudCA9ICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRm5Gb3IoJ2V0aF9jb21waWxlU2VycGVudCcpXG5FdGhRdWVyeS5wcm90b3R5cGUubmV3RmlsdGVyID0gICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUZuRm9yKCdldGhfbmV3RmlsdGVyJylcbkV0aFF1ZXJ5LnByb3RvdHlwZS5uZXdCbG9ja0ZpbHRlciA9ICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRm5Gb3IoJ2V0aF9uZXdCbG9ja0ZpbHRlcicpXG5FdGhRdWVyeS5wcm90b3R5cGUubmV3UGVuZGluZ1RyYW5zYWN0aW9uRmlsdGVyID0gICAgICAgICBnZW5lcmF0ZUZuRm9yKCdldGhfbmV3UGVuZGluZ1RyYW5zYWN0aW9uRmlsdGVyJylcbkV0aFF1ZXJ5LnByb3RvdHlwZS51bmluc3RhbGxGaWx0ZXIgPSAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRm5Gb3IoJ2V0aF91bmluc3RhbGxGaWx0ZXInKVxuRXRoUXVlcnkucHJvdG90eXBlLmdldEZpbHRlckNoYW5nZXMgPSAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVGbkZvcignZXRoX2dldEZpbHRlckNoYW5nZXMnKVxuRXRoUXVlcnkucHJvdG90eXBlLmdldEZpbHRlckxvZ3MgPSAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVGbkZvcignZXRoX2dldEZpbHRlckxvZ3MnKVxuRXRoUXVlcnkucHJvdG90eXBlLmdldExvZ3MgPSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVGbkZvcignZXRoX2dldExvZ3MnKVxuRXRoUXVlcnkucHJvdG90eXBlLmdldFdvcmsgPSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVGbkZvcignZXRoX2dldFdvcmsnKVxuRXRoUXVlcnkucHJvdG90eXBlLnN1Ym1pdFdvcmsgPSAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVGbkZvcignZXRoX3N1Ym1pdFdvcmsnKVxuRXRoUXVlcnkucHJvdG90eXBlLnN1Ym1pdEhhc2hyYXRlID0gICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVGbkZvcignZXRoX3N1Ym1pdEhhc2hyYXRlJylcblxuLy8gbmV0d29yayBsZXZlbFxuXG5FdGhRdWVyeS5wcm90b3R5cGUuc2VuZEFzeW5jID0gZnVuY3Rpb24ob3B0cywgY2Ipe1xuICBjb25zdCBzZWxmID0gdGhpc1xuICBzZWxmLmN1cnJlbnRQcm92aWRlci5zZW5kQXN5bmMoY3JlYXRlUGF5bG9hZChvcHRzKSwgZnVuY3Rpb24oZXJyLCByZXNwb25zZSl7XG4gICAgaWYgKCFlcnIgJiYgcmVzcG9uc2UuZXJyb3IpIGVyciA9IG5ldyBFcnJvcignRXRoUXVlcnkgLSBSUEMgRXJyb3IgLSAnK3Jlc3BvbnNlLmVycm9yLm1lc3NhZ2UpXG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBjYihudWxsLCByZXNwb25zZS5yZXN1bHQpXG4gIH0pXG59XG5cbi8vIHV0aWxcblxuZnVuY3Rpb24gZ2VuZXJhdGVGbkZvcihtZXRob2ROYW1lKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICAgIHZhciBjYiA9IGFyZ3MucG9wKClcbiAgICBzZWxmLnNlbmRBc3luYyh7XG4gICAgICBtZXRob2Q6IG1ldGhvZE5hbWUsXG4gICAgICBwYXJhbXM6IGFyZ3MsXG4gICAgfSwgY2IpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVGbldpdGhEZWZhdWx0QmxvY2tGb3IoYXJnQ291bnQsIG1ldGhvZE5hbWUpe1xuICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICBjb25zdCBzZWxmID0gdGhpc1xuICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gICAgdmFyIGNiID0gYXJncy5wb3AoKVxuICAgIC8vIHNldCBvcHRpb25hbCBkZWZhdWx0IGJsb2NrIHBhcmFtXG4gICAgaWYgKGFyZ3MubGVuZ3RoIDwgYXJnQ291bnQpIGFyZ3MucHVzaCgnbGF0ZXN0JylcbiAgICBzZWxmLnNlbmRBc3luYyh7XG4gICAgICBtZXRob2Q6IG1ldGhvZE5hbWUsXG4gICAgICBwYXJhbXM6IGFyZ3MsXG4gICAgfSwgY2IpXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlUGF5bG9hZChkYXRhKXtcbiAgcmV0dXJuIGV4dGVuZCh7XG4gICAgLy8gZGVmYXVsdHNcbiAgICBpZDogY3JlYXRlUmFuZG9tSWQoKSxcbiAgICBqc29ucnBjOiAnMi4wJyxcbiAgICBwYXJhbXM6IFtdLFxuICAgIC8vIHVzZXItc3BlY2lmaWVkXG4gIH0sIGRhdGEpXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0hleFByZWZpeGVkID0gcmVxdWlyZSgnaXMtaGV4LXByZWZpeGVkJyk7XG52YXIgc3RyaXBIZXhQcmVmaXggPSByZXF1aXJlKCdzdHJpcC1oZXgtcHJlZml4Jyk7XG5cbi8qKlxuICogUGFkcyBhIGBTdHJpbmdgIHRvIGhhdmUgYW4gZXZlbiBsZW5ndGhcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQHJldHVybiB7U3RyaW5nfSBvdXRwdXRcbiAqL1xuZnVuY3Rpb24gcGFkVG9FdmVuKHZhbHVlKSB7XG4gIHZhciBhID0gdmFsdWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICBpZiAodHlwZW9mIGEgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gd2hpbGUgcGFkZGluZyB0byBldmVuLCB2YWx1ZSBtdXN0IGJlIHN0cmluZywgaXMgY3VycmVudGx5ICcgKyB0eXBlb2YgYSArICcsIHdoaWxlIHBhZFRvRXZlbi4nKTtcbiAgfVxuXG4gIGlmIChhLmxlbmd0aCAlIDIpIHtcbiAgICBhID0gJzAnICsgYTtcbiAgfVxuXG4gIHJldHVybiBhO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgYE51bWJlcmAgaW50byBhIGhleCBgU3RyaW5nYFxuICogQHBhcmFtIHtOdW1iZXJ9IGlcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaW50VG9IZXgoaSkge1xuICB2YXIgaGV4ID0gaS50b1N0cmluZygxNik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICByZXR1cm4gJzB4JyArIGhleDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBgTnVtYmVyYCB0byBhIGBCdWZmZXJgXG4gKiBAcGFyYW0ge051bWJlcn0gaVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5mdW5jdGlvbiBpbnRUb0J1ZmZlcihpKSB7XG4gIHZhciBoZXggPSBpbnRUb0hleChpKTtcblxuICByZXR1cm4gbmV3IEJ1ZmZlcihwYWRUb0V2ZW4oaGV4LnNsaWNlKDIpKSwgJ2hleCcpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgYmluYXJ5IHNpemUgb2YgYSBzdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gZ2V0QmluYXJ5U2l6ZShzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gd2hpbGUgZ2V0dGluZyBiaW5hcnkgc2l6ZSwgbWV0aG9kIGdldEJpbmFyeVNpemUgcmVxdWlyZXMgaW5wdXQgXFwnc3RyXFwnIHRvIGJlIHR5cGUgU3RyaW5nLCBnb3QgXFwnJyArIHR5cGVvZiBzdHIgKyAnXFwnLicpO1xuICB9XG5cbiAgcmV0dXJuIEJ1ZmZlci5ieXRlTGVuZ3RoKHN0ciwgJ3V0ZjgnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIFRSVUUgaWYgdGhlIGZpcnN0IHNwZWNpZmllZCBhcnJheSBjb250YWlucyBhbGwgZWxlbWVudHNcbiAqIGZyb20gdGhlIHNlY29uZCBvbmUuIEZBTFNFIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge2FycmF5fSBzdXBlcnNldFxuICogQHBhcmFtIHthcnJheX0gc3Vic2V0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGFycmF5Q29udGFpbnNBcnJheShzdXBlcnNldCwgc3Vic2V0LCBzb21lKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHN1cGVyc2V0KSAhPT0gdHJ1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIG1ldGhvZCBhcnJheUNvbnRhaW5zQXJyYXkgcmVxdWlyZXMgaW5wdXQgXFwnc3VwZXJzZXRcXCcgdG8gYmUgYW4gYXJyYXkgZ290IHR5cGUgXFwnJyArIHR5cGVvZiBzdXBlcnNldCArICdcXCcnKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShzdWJzZXQpICE9PSB0cnVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gbWV0aG9kIGFycmF5Q29udGFpbnNBcnJheSByZXF1aXJlcyBpbnB1dCBcXCdzdWJzZXRcXCcgdG8gYmUgYW4gYXJyYXkgZ290IHR5cGUgXFwnJyArIHR5cGVvZiBzdWJzZXQgKyAnXFwnJyk7XG4gIH1cblxuICByZXR1cm4gc3Vic2V0W0Jvb2xlYW4oc29tZSkgJiYgJ3NvbWUnIHx8ICdldmVyeSddKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBzdXBlcnNldC5pbmRleE9mKHZhbHVlKSA+PSAwO1xuICB9KTtcbn1cblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCB1dGY4IGZyb20gaXQncyBoZXggcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAbWV0aG9kIHRvVXRmOFxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBpbiBoZXhcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGFzY2lpIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBoZXggdmFsdWVcbiAqL1xuZnVuY3Rpb24gdG9VdGY4KGhleCkge1xuICB2YXIgYnVmZmVyVmFsdWUgPSBuZXcgQnVmZmVyKHBhZFRvRXZlbihzdHJpcEhleFByZWZpeChoZXgpLnJlcGxhY2UoL14wK3wwKyQvZywgJycpKSwgJ2hleCcpO1xuXG4gIHJldHVybiBidWZmZXJWYWx1ZS50b1N0cmluZygndXRmOCcpO1xufVxuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGFzY2lpIGZyb20gaXQncyBoZXggcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAbWV0aG9kIHRvQXNjaWlcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgaW4gaGV4XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBhc2NpaSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgaGV4IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRvQXNjaWkoaGV4KSB7XG4gIHZhciBzdHIgPSAnJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICB2YXIgaSA9IDAsXG4gICAgICBsID0gaGV4Lmxlbmd0aDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGlmIChoZXguc3Vic3RyaW5nKDAsIDIpID09PSAnMHgnKSB7XG4gICAgaSA9IDI7XG4gIH1cblxuICBmb3IgKDsgaSA8IGw7IGkgKz0gMikge1xuICAgIHZhciBjb2RlID0gcGFyc2VJbnQoaGV4LnN1YnN0cihpLCAyKSwgMTYpO1xuICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBoZXggcmVwcmVzZW50YXRpb24gKHByZWZpeGVkIGJ5IDB4KSBvZiB1dGY4IHN0cmluZ1xuICpcbiAqIEBtZXRob2QgZnJvbVV0ZjhcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25hbCBwYWRkaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBoZXggcmVwcmVzZW50YXRpb24gb2YgaW5wdXQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGZyb21VdGY4KHN0cmluZ1ZhbHVlKSB7XG4gIHZhciBzdHIgPSBuZXcgQnVmZmVyKHN0cmluZ1ZhbHVlLCAndXRmOCcpO1xuXG4gIHJldHVybiAnMHgnICsgcGFkVG9FdmVuKHN0ci50b1N0cmluZygnaGV4JykpLnJlcGxhY2UoL14wK3wwKyQvZywgJycpO1xufVxuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGhleCByZXByZXNlbnRhdGlvbiAocHJlZml4ZWQgYnkgMHgpIG9mIGFzY2lpIHN0cmluZ1xuICpcbiAqIEBtZXRob2QgZnJvbUFzY2lpXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9uYWwgcGFkZGluZ1xuICogQHJldHVybnMge1N0cmluZ30gaGV4IHJlcHJlc2VudGF0aW9uIG9mIGlucHV0IHN0cmluZ1xuICovXG5mdW5jdGlvbiBmcm9tQXNjaWkoc3RyaW5nVmFsdWUpIHtcbiAgdmFyIGhleCA9ICcnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgdmFyIGNvZGUgPSBzdHJpbmdWYWx1ZS5jaGFyQ29kZUF0KGkpO1xuICAgIHZhciBuID0gY29kZS50b1N0cmluZygxNik7XG4gICAgaGV4ICs9IG4ubGVuZ3RoIDwgMiA/ICcwJyArIG4gOiBuO1xuICB9XG5cbiAgcmV0dXJuICcweCcgKyBoZXg7XG59XG5cbi8qKlxuICogZ2V0S2V5cyhbe2E6IDEsIGI6IDJ9LCB7YTogMywgYjogNH1dLCAnYScpID0+IFsxLCAzXVxuICpcbiAqIEBtZXRob2QgZ2V0S2V5cyBnZXQgc3BlY2lmaWMga2V5IGZyb20gaW5uZXIgb2JqZWN0IGFycmF5IG9mIG9iamVjdHNcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXNcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxsb3dFbXB0eVxuICogQHJldHVybnMge0FycmF5fSBvdXRwdXQganVzdCBhIHNpbXBsZSBhcnJheSBvZiBvdXRwdXQga2V5c1xuICovXG5mdW5jdGlvbiBnZXRLZXlzKHBhcmFtcywga2V5LCBhbGxvd0VtcHR5KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShwYXJhbXMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gbWV0aG9kIGdldEtleXMgZXhwZWN0aW5nIHR5cGUgQXJyYXkgYXMgXFwncGFyYW1zXFwnIGlucHV0LCBnb3QgXFwnJyArIHR5cGVvZiBwYXJhbXMgKyAnXFwnJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gbWV0aG9kIGdldEtleXMgZXhwZWN0aW5nIHR5cGUgU3RyaW5nIGZvciBpbnB1dCBcXCdrZXlcXCcgZ290IFxcJycgKyB0eXBlb2Yga2V5ICsgJ1xcJy4nKTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBbXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIHZhciB2YWx1ZSA9IHBhcmFtc1tpXVtrZXldOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgaWYgKGFsbG93RW1wdHkgJiYgIXZhbHVlKSB7XG4gICAgICB2YWx1ZSA9ICcnO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFiaScpO1xuICAgIH1cbiAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIElzIHRoZSBzdHJpbmcgYSBoZXggc3RyaW5nLlxuICpcbiAqIEBtZXRob2QgY2hlY2sgaWYgc3RyaW5nIGlzIGhleCBzdHJpbmcgb2Ygc3BlY2lmaWMgbGVuZ3RoXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGhcbiAqIEByZXR1cm5zIHtCb29sZWFufSBvdXRwdXQgdGhlIHN0cmluZyBpcyBhIGhleCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gaXNIZXhTdHJpbmcodmFsdWUsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCAhdmFsdWUubWF0Y2goL14weFswLTlBLUZhLWZdKiQvKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChsZW5ndGggJiYgdmFsdWUubGVuZ3RoICE9PSAyICsgMiAqIGxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXJyYXlDb250YWluc0FycmF5OiBhcnJheUNvbnRhaW5zQXJyYXksXG4gIGludFRvQnVmZmVyOiBpbnRUb0J1ZmZlcixcbiAgZ2V0QmluYXJ5U2l6ZTogZ2V0QmluYXJ5U2l6ZSxcbiAgaXNIZXhQcmVmaXhlZDogaXNIZXhQcmVmaXhlZCxcbiAgc3RyaXBIZXhQcmVmaXg6IHN0cmlwSGV4UHJlZml4LFxuICBwYWRUb0V2ZW46IHBhZFRvRXZlbixcbiAgaW50VG9IZXg6IGludFRvSGV4LFxuICBmcm9tQXNjaWk6IGZyb21Bc2NpaSxcbiAgZnJvbVV0Zjg6IGZyb21VdGY4LFxuICB0b0FzY2lpOiB0b0FzY2lpLFxuICB0b1V0Zjg6IHRvVXRmOCxcbiAgZ2V0S2V5czogZ2V0S2V5cyxcbiAgaXNIZXhTdHJpbmc6IGlzSGV4U3RyaW5nXG59OyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgIH1cbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICB9XG59KTtcblxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiAkZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiAkZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gJGdldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIFJlZmxlY3RBcHBseSh0aGlzLmxpc3RlbmVyLCB0aGlzLnRhcmdldCwgYXJncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/XG4gICAgdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKVxuICAgIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh4KSB7XG5cdHJldHVybiB0b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcbiIsIi8qKlxuICogUmV0dXJucyBhIGBCb29sZWFuYCBvbiB3aGV0aGVyIG9yIG5vdCB0aGUgYSBgU3RyaW5nYCBzdGFydHMgd2l0aCAnMHgnXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIHRoZSBzdHJpbmcgaW5wdXQgdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGEgYm9vbGVhbiBpZiBpdCBpcyBvciBpcyBub3QgaGV4IHByZWZpeGVkXG4gKiBAdGhyb3dzIGlmIHRoZSBzdHIgaW5wdXQgaXMgbm90IGEgc3RyaW5nXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNIZXhQcmVmaXhlZChzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiW2lzLWhleC1wcmVmaXhlZF0gdmFsdWUgbXVzdCBiZSB0eXBlICdzdHJpbmcnLCBpcyBjdXJyZW50bHkgdHlwZSBcIiArICh0eXBlb2Ygc3RyKSArIFwiLCB3aGlsZSBjaGVja2luZyBpc0hleFByZWZpeGVkLlwiKTtcbiAgfVxuXG4gIHJldHVybiBzdHIuc2xpY2UoMCwgMikgPT09ICcweCc7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2Vycm9ycycpOyIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbnZhciBKc29uUnBjRXJyb3IgPSBmdW5jdGlvbihtZXNzYWdlLCBjb2RlLCBkYXRhKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBKc29uUnBjRXJyb3IpKSB7XG4gICAgcmV0dXJuIG5ldyBKc29uUnBjRXJyb3IobWVzc2FnZSwgY29kZSwgZGF0YSk7XG4gIH1cblxuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB0aGlzLmNvZGUgPSBjb2RlO1xuXG4gIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICB9XG59O1xuXG5pbmhlcml0cyhKc29uUnBjRXJyb3IsIEVycm9yKTtcblxudmFyIFBhcnNlRXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhcnNlRXJyb3IpKSB7XG4gICAgcmV0dXJuIG5ldyBQYXJzZUVycm9yKCk7XG4gIH1cblxuICBKc29uUnBjRXJyb3IuY2FsbCh0aGlzLCAnUGFyc2UgZXJyb3InLCAtMzI3MDApO1xufTtcblxuaW5oZXJpdHMoUGFyc2VFcnJvciwgSnNvblJwY0Vycm9yKTtcblxudmFyIEludmFsaWRSZXF1ZXN0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJbnZhbGlkUmVxdWVzdCkpIHtcbiAgICByZXR1cm4gbmV3IEludmFsaWRSZXF1ZXN0KCk7XG4gIH1cblxuICBKc29uUnBjRXJyb3IuY2FsbCh0aGlzLCAnSW52YWxpZCBSZXF1ZXN0JywgLTMyNjAwKTtcbn07XG5cbmluaGVyaXRzKEludmFsaWRSZXF1ZXN0LCBKc29uUnBjRXJyb3IpO1xuXG52YXIgTWV0aG9kTm90Rm91bmQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1ldGhvZE5vdEZvdW5kKSkge1xuICAgIHJldHVybiBuZXcgTWV0aG9kTm90Rm91bmQoKTtcbiAgfVxuXG4gIEpzb25ScGNFcnJvci5jYWxsKHRoaXMsICdNZXRob2Qgbm90IGZvdW5kJywgLTMyNjAxKTtcbn07XG5cbmluaGVyaXRzKE1ldGhvZE5vdEZvdW5kLCBKc29uUnBjRXJyb3IpO1xuXG52YXIgSW52YWxpZFBhcmFtcyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSW52YWxpZFBhcmFtcykpIHtcbiAgICByZXR1cm4gbmV3IEludmFsaWRQYXJhbXMoKTtcbiAgfVxuXG4gIEpzb25ScGNFcnJvci5jYWxsKHRoaXMsICdJbnZhbGlkIHBhcmFtcycsIC0zMjYwMik7XG59O1xuXG5pbmhlcml0cyhJbnZhbGlkUGFyYW1zLCBKc29uUnBjRXJyb3IpO1xuXG52YXIgSW50ZXJuYWxFcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICB2YXIgbWVzc2FnZTtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSW50ZXJuYWxFcnJvcikpIHtcbiAgICByZXR1cm4gbmV3IEludGVybmFsRXJyb3IoZXJyKTtcbiAgfVxuXG4gIGlmIChlcnIgJiYgZXJyLm1lc3NhZ2UpIHtcbiAgICBtZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gIH0gZWxzZSB7XG4gICAgbWVzc2FnZSA9ICdJbnRlcm5hbCBlcnJvcic7XG4gIH1cblxuICBKc29uUnBjRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlLCAtMzI2MDMpO1xufTtcblxuaW5oZXJpdHMoSW50ZXJuYWxFcnJvciwgSnNvblJwY0Vycm9yKTtcblxudmFyIFNlcnZlckVycm9yID0gZnVuY3Rpb24oY29kZSkge1xuICBpZiAoY29kZSA8IC0zMjA5OSB8fCBjb2RlID4gLTMyMDAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGVycm9yIGNvZGUnKTtcbiAgfVxuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTZXJ2ZXJFcnJvcikpIHtcbiAgICByZXR1cm4gbmV3IFNlcnZlckVycm9yKGNvZGUpO1xuICB9XG5cbiAgSnNvblJwY0Vycm9yLmNhbGwodGhpcywgJ1NlcnZlciBlcnJvcicsIGNvZGUpO1xufTtcblxuaW5oZXJpdHMoU2VydmVyRXJyb3IsIEpzb25ScGNFcnJvcik7XG5cbkpzb25ScGNFcnJvci5QYXJzZUVycm9yID0gUGFyc2VFcnJvcjtcbkpzb25ScGNFcnJvci5JbnZhbGlkUmVxdWVzdCA9IEludmFsaWRSZXF1ZXN0O1xuSnNvblJwY0Vycm9yLk1ldGhvZE5vdEZvdW5kID0gTWV0aG9kTm90Rm91bmQ7XG5Kc29uUnBjRXJyb3IuSW52YWxpZFBhcmFtcyA9IEludmFsaWRQYXJhbXM7XG5Kc29uUnBjRXJyb3IuSW50ZXJuYWxFcnJvciA9IEludGVybmFsRXJyb3I7XG5Kc29uUnBjRXJyb3IuU2VydmVyRXJyb3IgPSBTZXJ2ZXJFcnJvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBKc29uUnBjRXJyb3I7XG5cblxuIiwibW9kdWxlLmV4cG9ydHMgPSBJZEl0ZXJhdG9yXG5cbmZ1bmN0aW9uIElkSXRlcmF0b3Iob3B0cyl7XG4gIG9wdHMgPSBvcHRzIHx8IHt9XG4gIHZhciBtYXggPSBvcHRzLm1heCB8fCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuICB2YXIgaWRDb3VudGVyID0gdHlwZW9mIG9wdHMuc3RhcnQgIT09ICd1bmRlZmluZWQnID8gb3B0cy5zdGFydCA6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG1heClcblxuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlUmFuZG9tSWQgKCkge1xuICAgIGlkQ291bnRlciA9IGlkQ291bnRlciAlIG1heFxuICAgIHJldHVybiBpZENvdW50ZXIrK1xuICB9XG5cbn0iLCJ2YXIganNvbiA9IHR5cGVvZiBKU09OICE9PSAndW5kZWZpbmVkJyA/IEpTT04gOiByZXF1aXJlKCdqc29uaWZ5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwgb3B0cykge1xuICAgIGlmICghb3B0cykgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykgb3B0cyA9IHsgY21wOiBvcHRzIH07XG4gICAgdmFyIHNwYWNlID0gb3B0cy5zcGFjZSB8fCAnJztcbiAgICBpZiAodHlwZW9mIHNwYWNlID09PSAnbnVtYmVyJykgc3BhY2UgPSBBcnJheShzcGFjZSsxKS5qb2luKCcgJyk7XG4gICAgdmFyIGN5Y2xlcyA9ICh0eXBlb2Ygb3B0cy5jeWNsZXMgPT09ICdib29sZWFuJykgPyBvcHRzLmN5Y2xlcyA6IGZhbHNlO1xuICAgIHZhciByZXBsYWNlciA9IG9wdHMucmVwbGFjZXIgfHwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG5cbiAgICB2YXIgY21wID0gb3B0cy5jbXAgJiYgKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFvYmogPSB7IGtleTogYSwgdmFsdWU6IG5vZGVbYV0gfTtcbiAgICAgICAgICAgICAgICB2YXIgYm9iaiA9IHsga2V5OiBiLCB2YWx1ZTogbm9kZVtiXSB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBmKGFvYmosIGJvYmopO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9KShvcHRzLmNtcCk7XG5cbiAgICB2YXIgc2VlbiA9IFtdO1xuICAgIHJldHVybiAoZnVuY3Rpb24gc3RyaW5naWZ5IChwYXJlbnQsIGtleSwgbm9kZSwgbGV2ZWwpIHtcbiAgICAgICAgdmFyIGluZGVudCA9IHNwYWNlID8gKCdcXG4nICsgbmV3IEFycmF5KGxldmVsICsgMSkuam9pbihzcGFjZSkpIDogJyc7XG4gICAgICAgIHZhciBjb2xvblNlcGFyYXRvciA9IHNwYWNlID8gJzogJyA6ICc6JztcblxuICAgICAgICBpZiAobm9kZSAmJiBub2RlLnRvSlNPTiAmJiB0eXBlb2Ygbm9kZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnRvSlNPTigpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IHJlcGxhY2VyLmNhbGwocGFyZW50LCBrZXksIG5vZGUpO1xuXG4gICAgICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8IG5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBqc29uLnN0cmluZ2lmeShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBzdHJpbmdpZnkobm9kZSwgaSwgbm9kZVtpXSwgbGV2ZWwrMSkgfHwganNvbi5zdHJpbmdpZnkobnVsbCk7XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goaW5kZW50ICsgc3BhY2UgKyBpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnWycgKyBvdXQuam9pbignLCcpICsgaW5kZW50ICsgJ10nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNlZW4uaW5kZXhPZihub2RlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3ljbGVzKSByZXR1cm4ganNvbi5zdHJpbmdpZnkoJ19fY3ljbGVfXycpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvbnZlcnRpbmcgY2lyY3VsYXIgc3RydWN0dXJlIHRvIEpTT04nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Ugc2Vlbi5wdXNoKG5vZGUpO1xuXG4gICAgICAgICAgICB2YXIga2V5cyA9IG9iamVjdEtleXMobm9kZSkuc29ydChjbXAgJiYgY21wKG5vZGUpKTtcbiAgICAgICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHN0cmluZ2lmeShub2RlLCBrZXksIG5vZGVba2V5XSwgbGV2ZWwrMSk7XG5cbiAgICAgICAgICAgICAgICBpZighdmFsdWUpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgdmFyIGtleVZhbHVlID0ganNvbi5zdHJpbmdpZnkoa2V5KVxuICAgICAgICAgICAgICAgICAgICArIGNvbG9uU2VwYXJhdG9yXG4gICAgICAgICAgICAgICAgICAgICsgdmFsdWU7XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKGluZGVudCArIHNwYWNlICsga2V5VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2Vlbi5zcGxpY2Uoc2Vlbi5pbmRleE9mKG5vZGUpLCAxKTtcbiAgICAgICAgICAgIHJldHVybiAneycgKyBvdXQuam9pbignLCcpICsgaW5kZW50ICsgJ30nO1xuICAgICAgICB9XG4gICAgfSkoeyAnJzogb2JqIH0sICcnLCBvYmosIDApO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHt9LnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSB8fCBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlIH07XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChoYXMuY2FsbChvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbn07XG4iLCJleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9saWIvcGFyc2UnKTtcbmV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9saWIvc3RyaW5naWZ5Jyk7XG4iLCJ2YXIgYXQsIC8vIFRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBjaGFyYWN0ZXJcbiAgICBjaCwgLy8gVGhlIGN1cnJlbnQgY2hhcmFjdGVyXG4gICAgZXNjYXBlZSA9IHtcbiAgICAgICAgJ1wiJzogICdcIicsXG4gICAgICAgICdcXFxcJzogJ1xcXFwnLFxuICAgICAgICAnLyc6ICAnLycsXG4gICAgICAgIGI6ICAgICdcXGInLFxuICAgICAgICBmOiAgICAnXFxmJyxcbiAgICAgICAgbjogICAgJ1xcbicsXG4gICAgICAgIHI6ICAgICdcXHInLFxuICAgICAgICB0OiAgICAnXFx0J1xuICAgIH0sXG4gICAgdGV4dCxcblxuICAgIGVycm9yID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgLy8gQ2FsbCBlcnJvciB3aGVuIHNvbWV0aGluZyBpcyB3cm9uZy5cbiAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgbmFtZTogICAgJ1N5bnRheEVycm9yJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IG0sXG4gICAgICAgICAgICBhdDogICAgICBhdCxcbiAgICAgICAgICAgIHRleHQ6ICAgIHRleHRcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIFxuICAgIG5leHQgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICAvLyBJZiBhIGMgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLCB2ZXJpZnkgdGhhdCBpdCBtYXRjaGVzIHRoZSBjdXJyZW50IGNoYXJhY3Rlci5cbiAgICAgICAgaWYgKGMgJiYgYyAhPT0gY2gpIHtcbiAgICAgICAgICAgIGVycm9yKFwiRXhwZWN0ZWQgJ1wiICsgYyArIFwiJyBpbnN0ZWFkIG9mICdcIiArIGNoICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBHZXQgdGhlIG5leHQgY2hhcmFjdGVyLiBXaGVuIHRoZXJlIGFyZSBubyBtb3JlIGNoYXJhY3RlcnMsXG4gICAgICAgIC8vIHJldHVybiB0aGUgZW1wdHkgc3RyaW5nLlxuICAgICAgICBcbiAgICAgICAgY2ggPSB0ZXh0LmNoYXJBdChhdCk7XG4gICAgICAgIGF0ICs9IDE7XG4gICAgICAgIHJldHVybiBjaDtcbiAgICB9LFxuICAgIFxuICAgIG51bWJlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUGFyc2UgYSBudW1iZXIgdmFsdWUuXG4gICAgICAgIHZhciBudW1iZXIsXG4gICAgICAgICAgICBzdHJpbmcgPSAnJztcbiAgICAgICAgXG4gICAgICAgIGlmIChjaCA9PT0gJy0nKSB7XG4gICAgICAgICAgICBzdHJpbmcgPSAnLSc7XG4gICAgICAgICAgICBuZXh0KCctJyk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGNoID49ICcwJyAmJiBjaCA8PSAnOScpIHtcbiAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ggPT09ICcuJykge1xuICAgICAgICAgICAgc3RyaW5nICs9ICcuJztcbiAgICAgICAgICAgIHdoaWxlIChuZXh0KCkgJiYgY2ggPj0gJzAnICYmIGNoIDw9ICc5Jykge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ggPT09ICdlJyB8fCBjaCA9PT0gJ0UnKSB7XG4gICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJysnKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBudW1iZXIgPSArc3RyaW5nO1xuICAgICAgICBpZiAoIWlzRmluaXRlKG51bWJlcikpIHtcbiAgICAgICAgICAgIGVycm9yKFwiQmFkIG51bWJlclwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIHN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUGFyc2UgYSBzdHJpbmcgdmFsdWUuXG4gICAgICAgIHZhciBoZXgsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgc3RyaW5nID0gJycsXG4gICAgICAgICAgICB1ZmZmZjtcbiAgICAgICAgXG4gICAgICAgIC8vIFdoZW4gcGFyc2luZyBmb3Igc3RyaW5nIHZhbHVlcywgd2UgbXVzdCBsb29rIGZvciBcIiBhbmQgXFwgY2hhcmFjdGVycy5cbiAgICAgICAgaWYgKGNoID09PSAnXCInKSB7XG4gICAgICAgICAgICB3aGlsZSAobmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd1Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdWZmZmYgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhleCA9IHBhcnNlSW50KG5leHQoKSwgMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNGaW5pdGUoaGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdWZmZmYgPSB1ZmZmZiAqIDE2ICsgaGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodWZmZmYpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlc2NhcGVlW2NoXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBlc2NhcGVlW2NoXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlcnJvcihcIkJhZCBzdHJpbmdcIik7XG4gICAgfSxcblxuICAgIHdoaXRlID0gZnVuY3Rpb24gKCkge1xuXG4vLyBTa2lwIHdoaXRlc3BhY2UuXG5cbiAgICAgICAgd2hpbGUgKGNoICYmIGNoIDw9ICcgJykge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHdvcmQgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIHRydWUsIGZhbHNlLCBvciBudWxsLlxuXG4gICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICBuZXh0KCd0Jyk7XG4gICAgICAgICAgICBuZXh0KCdyJyk7XG4gICAgICAgICAgICBuZXh0KCd1Jyk7XG4gICAgICAgICAgICBuZXh0KCdlJyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICBuZXh0KCdmJyk7XG4gICAgICAgICAgICBuZXh0KCdhJyk7XG4gICAgICAgICAgICBuZXh0KCdsJyk7XG4gICAgICAgICAgICBuZXh0KCdzJyk7XG4gICAgICAgICAgICBuZXh0KCdlJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgbmV4dCgnbicpO1xuICAgICAgICAgICAgbmV4dCgndScpO1xuICAgICAgICAgICAgbmV4dCgnbCcpO1xuICAgICAgICAgICAgbmV4dCgnbCcpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IoXCJVbmV4cGVjdGVkICdcIiArIGNoICsgXCInXCIpO1xuICAgIH0sXG5cbiAgICB2YWx1ZSwgIC8vIFBsYWNlIGhvbGRlciBmb3IgdGhlIHZhbHVlIGZ1bmN0aW9uLlxuXG4gICAgYXJyYXkgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIFBhcnNlIGFuIGFycmF5IHZhbHVlLlxuXG4gICAgICAgIHZhciBhcnJheSA9IFtdO1xuXG4gICAgICAgIGlmIChjaCA9PT0gJ1snKSB7XG4gICAgICAgICAgICBuZXh0KCdbJyk7XG4gICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCddJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5OyAgIC8vIGVtcHR5IGFycmF5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY2gpIHtcbiAgICAgICAgICAgICAgICBhcnJheS5wdXNoKHZhbHVlKCkpO1xuICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnXScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHQoJywnKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVycm9yKFwiQmFkIGFycmF5XCIpO1xuICAgIH0sXG5cbiAgICBvYmplY3QgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIFBhcnNlIGFuIG9iamVjdCB2YWx1ZS5cblxuICAgICAgICB2YXIga2V5LFxuICAgICAgICAgICAgb2JqZWN0ID0ge307XG5cbiAgICAgICAgaWYgKGNoID09PSAneycpIHtcbiAgICAgICAgICAgIG5leHQoJ3snKTtcbiAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICd9Jykge1xuICAgICAgICAgICAgICAgIG5leHQoJ30nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0OyAgIC8vIGVtcHR5IG9iamVjdFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNoKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICBuZXh0KCc6Jyk7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcignRHVwbGljYXRlIGtleSBcIicgKyBrZXkgKyAnXCInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZSgpO1xuICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnfScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0KCcsJyk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlcnJvcihcIkJhZCBvYmplY3RcIik7XG4gICAgfTtcblxudmFsdWUgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIFBhcnNlIGEgSlNPTiB2YWx1ZS4gSXQgY291bGQgYmUgYW4gb2JqZWN0LCBhbiBhcnJheSwgYSBzdHJpbmcsIGEgbnVtYmVyLFxuLy8gb3IgYSB3b3JkLlxuXG4gICAgd2hpdGUoKTtcbiAgICBzd2l0Y2ggKGNoKSB7XG4gICAgY2FzZSAneyc6XG4gICAgICAgIHJldHVybiBvYmplY3QoKTtcbiAgICBjYXNlICdbJzpcbiAgICAgICAgcmV0dXJuIGFycmF5KCk7XG4gICAgY2FzZSAnXCInOlxuICAgICAgICByZXR1cm4gc3RyaW5nKCk7XG4gICAgY2FzZSAnLSc6XG4gICAgICAgIHJldHVybiBudW1iZXIoKTtcbiAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gY2ggPj0gJzAnICYmIGNoIDw9ICc5JyA/IG51bWJlcigpIDogd29yZCgpO1xuICAgIH1cbn07XG5cbi8vIFJldHVybiB0aGUganNvbl9wYXJzZSBmdW5jdGlvbi4gSXQgd2lsbCBoYXZlIGFjY2VzcyB0byBhbGwgb2YgdGhlIGFib3ZlXG4vLyBmdW5jdGlvbnMgYW5kIHZhcmlhYmxlcy5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc291cmNlLCByZXZpdmVyKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBcbiAgICB0ZXh0ID0gc291cmNlO1xuICAgIGF0ID0gMDtcbiAgICBjaCA9ICcgJztcbiAgICByZXN1bHQgPSB2YWx1ZSgpO1xuICAgIHdoaXRlKCk7XG4gICAgaWYgKGNoKSB7XG4gICAgICAgIGVycm9yKFwiU3ludGF4IGVycm9yXCIpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGlzIGEgcmV2aXZlciBmdW5jdGlvbiwgd2UgcmVjdXJzaXZlbHkgd2FsayB0aGUgbmV3IHN0cnVjdHVyZSxcbiAgICAvLyBwYXNzaW5nIGVhY2ggbmFtZS92YWx1ZSBwYWlyIHRvIHRoZSByZXZpdmVyIGZ1bmN0aW9uIGZvciBwb3NzaWJsZVxuICAgIC8vIHRyYW5zZm9ybWF0aW9uLCBzdGFydGluZyB3aXRoIGEgdGVtcG9yYXJ5IHJvb3Qgb2JqZWN0IHRoYXQgaG9sZHMgdGhlIHJlc3VsdFxuICAgIC8vIGluIGFuIGVtcHR5IGtleS4gSWYgdGhlcmUgaXMgbm90IGEgcmV2aXZlciBmdW5jdGlvbiwgd2Ugc2ltcGx5IHJldHVybiB0aGVcbiAgICAvLyByZXN1bHQuXG5cbiAgICByZXR1cm4gdHlwZW9mIHJldml2ZXIgPT09ICdmdW5jdGlvbicgPyAoZnVuY3Rpb24gd2Fsayhob2xkZXIsIGtleSkge1xuICAgICAgICB2YXIgaywgdiwgdmFsdWUgPSBob2xkZXJba2V5XTtcbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGZvciAoayBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGspKSB7XG4gICAgICAgICAgICAgICAgICAgIHYgPSB3YWxrKHZhbHVlLCBrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVba10gPSB2O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHZhbHVlW2tdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXZpdmVyLmNhbGwoaG9sZGVyLCBrZXksIHZhbHVlKTtcbiAgICB9KHsnJzogcmVzdWx0fSwgJycpKSA6IHJlc3VsdDtcbn07XG4iLCJ2YXIgY3ggPSAvW1xcdTAwMDBcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZyxcbiAgICBlc2NhcGFibGUgPSAvW1xcXFxcXFwiXFx4MDAtXFx4MWZcXHg3Zi1cXHg5ZlxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nLFxuICAgIGdhcCxcbiAgICBpbmRlbnQsXG4gICAgbWV0YSA9IHsgICAgLy8gdGFibGUgb2YgY2hhcmFjdGVyIHN1YnN0aXR1dGlvbnNcbiAgICAgICAgJ1xcYic6ICdcXFxcYicsXG4gICAgICAgICdcXHQnOiAnXFxcXHQnLFxuICAgICAgICAnXFxuJzogJ1xcXFxuJyxcbiAgICAgICAgJ1xcZic6ICdcXFxcZicsXG4gICAgICAgICdcXHInOiAnXFxcXHInLFxuICAgICAgICAnXCInIDogJ1xcXFxcIicsXG4gICAgICAgICdcXFxcJzogJ1xcXFxcXFxcJ1xuICAgIH0sXG4gICAgcmVwO1xuXG5mdW5jdGlvbiBxdW90ZShzdHJpbmcpIHtcbiAgICAvLyBJZiB0aGUgc3RyaW5nIGNvbnRhaW5zIG5vIGNvbnRyb2wgY2hhcmFjdGVycywgbm8gcXVvdGUgY2hhcmFjdGVycywgYW5kIG5vXG4gICAgLy8gYmFja3NsYXNoIGNoYXJhY3RlcnMsIHRoZW4gd2UgY2FuIHNhZmVseSBzbGFwIHNvbWUgcXVvdGVzIGFyb3VuZCBpdC5cbiAgICAvLyBPdGhlcndpc2Ugd2UgbXVzdCBhbHNvIHJlcGxhY2UgdGhlIG9mZmVuZGluZyBjaGFyYWN0ZXJzIHdpdGggc2FmZSBlc2NhcGVcbiAgICAvLyBzZXF1ZW5jZXMuXG4gICAgXG4gICAgZXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG4gICAgcmV0dXJuIGVzY2FwYWJsZS50ZXN0KHN0cmluZykgPyAnXCInICsgc3RyaW5nLnJlcGxhY2UoZXNjYXBhYmxlLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgYyA9IG1ldGFbYV07XG4gICAgICAgIHJldHVybiB0eXBlb2YgYyA9PT0gJ3N0cmluZycgPyBjIDpcbiAgICAgICAgICAgICdcXFxcdScgKyAoJzAwMDAnICsgYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgIH0pICsgJ1wiJyA6ICdcIicgKyBzdHJpbmcgKyAnXCInO1xufVxuXG5mdW5jdGlvbiBzdHIoa2V5LCBob2xkZXIpIHtcbiAgICAvLyBQcm9kdWNlIGEgc3RyaW5nIGZyb20gaG9sZGVyW2tleV0uXG4gICAgdmFyIGksICAgICAgICAgIC8vIFRoZSBsb29wIGNvdW50ZXIuXG4gICAgICAgIGssICAgICAgICAgIC8vIFRoZSBtZW1iZXIga2V5LlxuICAgICAgICB2LCAgICAgICAgICAvLyBUaGUgbWVtYmVyIHZhbHVlLlxuICAgICAgICBsZW5ndGgsXG4gICAgICAgIG1pbmQgPSBnYXAsXG4gICAgICAgIHBhcnRpYWwsXG4gICAgICAgIHZhbHVlID0gaG9sZGVyW2tleV07XG4gICAgXG4gICAgLy8gSWYgdGhlIHZhbHVlIGhhcyBhIHRvSlNPTiBtZXRob2QsIGNhbGwgaXQgdG8gb2J0YWluIGEgcmVwbGFjZW1lbnQgdmFsdWUuXG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04oa2V5KTtcbiAgICB9XG4gICAgXG4gICAgLy8gSWYgd2Ugd2VyZSBjYWxsZWQgd2l0aCBhIHJlcGxhY2VyIGZ1bmN0aW9uLCB0aGVuIGNhbGwgdGhlIHJlcGxhY2VyIHRvXG4gICAgLy8gb2J0YWluIGEgcmVwbGFjZW1lbnQgdmFsdWUuXG4gICAgaWYgKHR5cGVvZiByZXAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsdWUgPSByZXAuY2FsbChob2xkZXIsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICBcbiAgICAvLyBXaGF0IGhhcHBlbnMgbmV4dCBkZXBlbmRzIG9uIHRoZSB2YWx1ZSdzIHR5cGUuXG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIHJldHVybiBxdW90ZSh2YWx1ZSk7XG4gICAgICAgIFxuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgLy8gSlNPTiBudW1iZXJzIG11c3QgYmUgZmluaXRlLiBFbmNvZGUgbm9uLWZpbml0ZSBudW1iZXJzIGFzIG51bGwuXG4gICAgICAgICAgICByZXR1cm4gaXNGaW5pdGUodmFsdWUpID8gU3RyaW5nKHZhbHVlKSA6ICdudWxsJztcbiAgICAgICAgXG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICBjYXNlICdudWxsJzpcbiAgICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBhIGJvb2xlYW4gb3IgbnVsbCwgY29udmVydCBpdCB0byBhIHN0cmluZy4gTm90ZTpcbiAgICAgICAgICAgIC8vIHR5cGVvZiBudWxsIGRvZXMgbm90IHByb2R1Y2UgJ251bGwnLiBUaGUgY2FzZSBpcyBpbmNsdWRlZCBoZXJlIGluXG4gICAgICAgICAgICAvLyB0aGUgcmVtb3RlIGNoYW5jZSB0aGF0IHRoaXMgZ2V0cyBmaXhlZCBzb21lZGF5LlxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgIGlmICghdmFsdWUpIHJldHVybiAnbnVsbCc7XG4gICAgICAgICAgICBnYXAgKz0gaW5kZW50O1xuICAgICAgICAgICAgcGFydGlhbCA9IFtdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBBcnJheS5pc0FycmF5XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseSh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpYWxbaV0gPSBzdHIoaSwgdmFsdWUpIHx8ICdudWxsJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gSm9pbiBhbGwgb2YgdGhlIGVsZW1lbnRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsIGFuZFxuICAgICAgICAgICAgICAgIC8vIHdyYXAgdGhlbSBpbiBicmFja2V0cy5cbiAgICAgICAgICAgICAgICB2ID0gcGFydGlhbC5sZW5ndGggPT09IDAgPyAnW10nIDogZ2FwID9cbiAgICAgICAgICAgICAgICAgICAgJ1tcXG4nICsgZ2FwICsgcGFydGlhbC5qb2luKCcsXFxuJyArIGdhcCkgKyAnXFxuJyArIG1pbmQgKyAnXScgOlxuICAgICAgICAgICAgICAgICAgICAnWycgKyBwYXJ0aWFsLmpvaW4oJywnKSArICddJztcbiAgICAgICAgICAgICAgICBnYXAgPSBtaW5kO1xuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBJZiB0aGUgcmVwbGFjZXIgaXMgYW4gYXJyYXksIHVzZSBpdCB0byBzZWxlY3QgdGhlIG1lbWJlcnMgdG8gYmVcbiAgICAgICAgICAgIC8vIHN0cmluZ2lmaWVkLlxuICAgICAgICAgICAgaWYgKHJlcCAmJiB0eXBlb2YgcmVwID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHJlcC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGsgPSByZXBbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBzdHIoaywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsLnB1c2gocXVvdGUoaykgKyAoZ2FwID8gJzogJyA6ICc6JykgKyB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgaXRlcmF0ZSB0aHJvdWdoIGFsbCBvZiB0aGUga2V5cyBpbiB0aGUgb2JqZWN0LlxuICAgICAgICAgICAgICAgIGZvciAoayBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHN0cihrLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWwucHVzaChxdW90ZShrKSArIChnYXAgPyAnOiAnIDogJzonKSArIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgIC8vIEpvaW4gYWxsIG9mIHRoZSBtZW1iZXIgdGV4dHMgdG9nZXRoZXIsIHNlcGFyYXRlZCB3aXRoIGNvbW1hcyxcbiAgICAgICAgLy8gYW5kIHdyYXAgdGhlbSBpbiBicmFjZXMuXG5cbiAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwID8gJ3t9JyA6IGdhcCA/XG4gICAgICAgICAgICAne1xcbicgKyBnYXAgKyBwYXJ0aWFsLmpvaW4oJyxcXG4nICsgZ2FwKSArICdcXG4nICsgbWluZCArICd9JyA6XG4gICAgICAgICAgICAneycgKyBwYXJ0aWFsLmpvaW4oJywnKSArICd9JztcbiAgICAgICAgZ2FwID0gbWluZDtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlKSB7XG4gICAgdmFyIGk7XG4gICAgZ2FwID0gJyc7XG4gICAgaW5kZW50ID0gJyc7XG4gICAgXG4gICAgLy8gSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIG51bWJlciwgbWFrZSBhbiBpbmRlbnQgc3RyaW5nIGNvbnRhaW5pbmcgdGhhdFxuICAgIC8vIG1hbnkgc3BhY2VzLlxuICAgIGlmICh0eXBlb2Ygc3BhY2UgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzcGFjZTsgaSArPSAxKSB7XG4gICAgICAgICAgICBpbmRlbnQgKz0gJyAnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmcsIGl0IHdpbGwgYmUgdXNlZCBhcyB0aGUgaW5kZW50IHN0cmluZy5cbiAgICBlbHNlIGlmICh0eXBlb2Ygc3BhY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGluZGVudCA9IHNwYWNlO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGlzIGEgcmVwbGFjZXIsIGl0IG11c3QgYmUgYSBmdW5jdGlvbiBvciBhbiBhcnJheS5cbiAgICAvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yLlxuICAgIHJlcCA9IHJlcGxhY2VyO1xuICAgIGlmIChyZXBsYWNlciAmJiB0eXBlb2YgcmVwbGFjZXIgIT09ICdmdW5jdGlvbidcbiAgICAmJiAodHlwZW9mIHJlcGxhY2VyICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgcmVwbGFjZXIubGVuZ3RoICE9PSAnbnVtYmVyJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdKU09OLnN0cmluZ2lmeScpO1xuICAgIH1cbiAgICBcbiAgICAvLyBNYWtlIGEgZmFrZSByb290IG9iamVjdCBjb250YWluaW5nIG91ciB2YWx1ZSB1bmRlciB0aGUga2V5IG9mICcnLlxuICAgIC8vIFJldHVybiB0aGUgcmVzdWx0IG9mIHN0cmluZ2lmeWluZyB0aGUgdmFsdWUuXG4gICAgcmV0dXJuIHN0cignJywgeycnOiB2YWx1ZX0pO1xufTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaXNGbiA9IHJlcXVpcmUoJ2lzLWZuJyk7XG52YXIgc2V0SW1tZWRpYXRlID0gcmVxdWlyZSgnc2V0LWltbWVkaWF0ZS1zaGltJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHByb21pc2UpIHtcblx0aWYgKCFpc0ZuKHByb21pc2UudGhlbikpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIHByb21pc2UnKTtcblx0fVxuXG5cdHJldHVybiBmdW5jdGlvbiAoY2IpIHtcblx0XHRwcm9taXNlLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcblx0XHRcdHNldEltbWVkaWF0ZShjYiwgbnVsbCwgZGF0YSk7XG5cdFx0fSwgZnVuY3Rpb24gKGVycikge1xuXHRcdFx0c2V0SW1tZWRpYXRlKGNiLCBlcnIpO1xuXHRcdH0pO1xuXHR9O1xufTtcbiIsImNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJylcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cy8nKVxuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFIuYXBwbHlcbiAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTYWZlRXZlbnRFbWl0dGVyXG5cblxuZnVuY3Rpb24gU2FmZUV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcylcbn1cblxudXRpbC5pbmhlcml0cyhTYWZlRXZlbnRFbWl0dGVyLCBFdmVudEVtaXR0ZXIpXG5cblNhZmVFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAodHlwZSkge1xuICAvLyBjb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vR296YWxhL2V2ZW50cy9ibG9iL21hc3Rlci9ldmVudHMuanNcbiAgLy8gbW9kaWZpZWQgbGluZXMgYXJlIGNvbW1lbnRlZCB3aXRoIFwiZWRpdGVkOlwiXG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBlZGl0ZWQ6IHVzaW5nIHNhZmVBcHBseVxuICAgIHNhZmVBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgLy8gZWRpdGVkOiB1c2luZyBzYWZlQXBwbHlcbiAgICAgIHNhZmVBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHNhZmVBcHBseShoYW5kbGVyLCBjb250ZXh0LCBhcmdzKSB7XG4gIHRyeSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIGNvbnRleHQsIGFyZ3MpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIHRocm93IGVycm9yIGFmdGVyIHRpbWVvdXQgc28gYXMgbm90IHRvIGludGVydXB0IHRoZSBzdGFja1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicgPyBzZXRJbW1lZGlhdGUgOlxuXHRmdW5jdGlvbiBzZXRJbW1lZGlhdGUoKSB7XG5cdFx0dmFyIGFyZ3MgPSBbXS5zbGljZS5hcHBseShhcmd1bWVudHMpO1xuXHRcdGFyZ3Muc3BsaWNlKDEsIDAsIDApO1xuXHRcdHNldFRpbWVvdXQuYXBwbHkobnVsbCwgYXJncyk7XG5cdH07XG4iLCJ2YXIgaXNIZXhQcmVmaXhlZCA9IHJlcXVpcmUoJ2lzLWhleC1wcmVmaXhlZCcpO1xuXG4vKipcbiAqIFJlbW92ZXMgJzB4JyBmcm9tIGEgZ2l2ZW4gYFN0cmluZ2AgaXMgcHJlc2VudFxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHZhbHVlXG4gKiBAcmV0dXJuIHtTdHJpbmd8T3B0aW9uYWx9IGEgc3RyaW5nIGJ5IHBhc3MgaWYgbmVjZXNzYXJ5XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3RyaXBIZXhQcmVmaXgoc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICByZXR1cm4gaXNIZXhQcmVmaXhlZChzdHIpID8gc3RyLnNsaWNlKDIpIDogc3RyO1xufVxuIiwidmFyIG5leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy9icm93c2VyLmpzJykubmV4dFRpY2s7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaW1tZWRpYXRlSWRzID0ge307XG52YXIgbmV4dEltbWVkaWF0ZUlkID0gMDtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHsgdGltZW91dC5jbG9zZSgpOyB9O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIFRoYXQncyBub3QgaG93IG5vZGUuanMgaW1wbGVtZW50cyBpdCBidXQgdGhlIGV4cG9zZWQgYXBpIGlzIHRoZSBzYW1lLlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBmdW5jdGlvbihmbikge1xuICB2YXIgaWQgPSBuZXh0SW1tZWRpYXRlSWQrKztcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGZhbHNlIDogc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIGltbWVkaWF0ZUlkc1tpZF0gPSB0cnVlO1xuXG4gIG5leHRUaWNrKGZ1bmN0aW9uIG9uTmV4dFRpY2soKSB7XG4gICAgaWYgKGltbWVkaWF0ZUlkc1tpZF0pIHtcbiAgICAgIC8vIGZuLmNhbGwoKSBpcyBmYXN0ZXIgc28gd2Ugb3B0aW1pemUgZm9yIHRoZSBjb21tb24gdXNlLWNhc2VcbiAgICAgIC8vIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vY2FsbC1hcHBseS1zZWd1XG4gICAgICBpZiAoYXJncykge1xuICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZuLmNhbGwobnVsbCk7XG4gICAgICB9XG4gICAgICAvLyBQcmV2ZW50IGlkcyBmcm9tIGxlYWtpbmdcbiAgICAgIGV4cG9ydHMuY2xlYXJJbW1lZGlhdGUoaWQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGlkO1xufTtcblxuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9IHR5cGVvZiBjbGVhckltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gY2xlYXJJbW1lZGlhdGUgOiBmdW5jdGlvbihpZCkge1xuICBkZWxldGUgaW1tZWRpYXRlSWRzW2lkXTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG4vKipcbiAqIENvbnZlcnQgYXJyYXkgb2YgMTYgYnl0ZSB2YWx1ZXMgdG8gVVVJRCBzdHJpbmcgZm9ybWF0IG9mIHRoZSBmb3JtOlxuICogWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXG4gKi9cbnZhciBieXRlVG9IZXggPSBbXTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXhbaV0gPSAoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpO1xufVxuXG5mdW5jdGlvbiBieXRlc1RvVXVpZChidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IG9mZnNldCB8fCAwO1xuICB2YXIgYnRoID0gYnl0ZVRvSGV4OyAvLyBqb2luIHVzZWQgdG8gZml4IG1lbW9yeSBpc3N1ZSBjYXVzZWQgYnkgY29uY2F0ZW5hdGlvbjogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzE3NSNjNFxuXG4gIHJldHVybiBbYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLCBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJywgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLCBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dXS5qb2luKCcnKTtcbn1cblxudmFyIF9kZWZhdWx0ID0gYnl0ZXNUb1V1aWQ7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidjFcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3YuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2M1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdjIuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2NFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdjMuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2NVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdjQuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfdiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdjEuanNcIikpO1xuXG52YXIgX3YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92My5qc1wiKSk7XG5cbnZhciBfdjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3Y0LmpzXCIpKTtcblxudmFyIF92NCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdjUuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG4vKlxuICogQnJvd3Nlci1jb21wYXRpYmxlIEphdmFTY3JpcHQgTUQ1XG4gKlxuICogTW9kaWZpY2F0aW9uIG9mIEphdmFTY3JpcHQgTUQ1XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYmx1ZWltcC9KYXZhU2NyaXB0LU1ENVxuICpcbiAqIENvcHlyaWdodCAyMDExLCBTZWJhc3RpYW4gVHNjaGFuXG4gKiBodHRwczovL2JsdWVpbXAubmV0XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqXG4gKiBCYXNlZCBvblxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBSU0EgRGF0YSBTZWN1cml0eSwgSW5jLiBNRDUgTWVzc2FnZVxuICogRGlnZXN0IEFsZ29yaXRobSwgYXMgZGVmaW5lZCBpbiBSRkMgMTMyMS5cbiAqIFZlcnNpb24gMi4yIENvcHlyaWdodCAoQykgUGF1bCBKb2huc3RvbiAxOTk5IC0gMjAwOVxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlXG4gKiBTZWUgaHR0cDovL3BhamhvbWUub3JnLnVrL2NyeXB0L21kNSBmb3IgbW9yZSBpbmZvLlxuICovXG5mdW5jdGlvbiBtZDUoYnl0ZXMpIHtcbiAgaWYgKHR5cGVvZiBieXRlcyA9PSAnc3RyaW5nJykge1xuICAgIHZhciBtc2cgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoYnl0ZXMpKTsgLy8gVVRGOCBlc2NhcGVcblxuICAgIGJ5dGVzID0gbmV3IEFycmF5KG1zZy5sZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspIGJ5dGVzW2ldID0gbXNnLmNoYXJDb2RlQXQoaSk7XG4gIH1cblxuICByZXR1cm4gbWQ1VG9IZXhFbmNvZGVkQXJyYXkod29yZHNUb01kNShieXRlc1RvV29yZHMoYnl0ZXMpLCBieXRlcy5sZW5ndGggKiA4KSk7XG59XG4vKlxuICogQ29udmVydCBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzIHRvIGFuIGFycmF5IG9mIGJ5dGVzXG4gKi9cblxuXG5mdW5jdGlvbiBtZDVUb0hleEVuY29kZWRBcnJheShpbnB1dCkge1xuICB2YXIgaTtcbiAgdmFyIHg7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgdmFyIGxlbmd0aDMyID0gaW5wdXQubGVuZ3RoICogMzI7XG4gIHZhciBoZXhUYWIgPSAnMDEyMzQ1Njc4OWFiY2RlZic7XG4gIHZhciBoZXg7XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDMyOyBpICs9IDgpIHtcbiAgICB4ID0gaW5wdXRbaSA+PiA1XSA+Pj4gaSAlIDMyICYgMHhmZjtcbiAgICBoZXggPSBwYXJzZUludChoZXhUYWIuY2hhckF0KHggPj4+IDQgJiAweDBmKSArIGhleFRhYi5jaGFyQXQoeCAmIDB4MGYpLCAxNik7XG4gICAgb3V0cHV0LnB1c2goaGV4KTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG4vKlxuICogQ2FsY3VsYXRlIHRoZSBNRDUgb2YgYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3JkcywgYW5kIGEgYml0IGxlbmd0aC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHdvcmRzVG9NZDUoeCwgbGVuKSB7XG4gIC8qIGFwcGVuZCBwYWRkaW5nICovXG4gIHhbbGVuID4+IDVdIHw9IDB4ODAgPDwgbGVuICUgMzI7XG4gIHhbKGxlbiArIDY0ID4+PiA5IDw8IDQpICsgMTRdID0gbGVuO1xuICB2YXIgaTtcbiAgdmFyIG9sZGE7XG4gIHZhciBvbGRiO1xuICB2YXIgb2xkYztcbiAgdmFyIG9sZGQ7XG4gIHZhciBhID0gMTczMjU4NDE5MztcbiAgdmFyIGIgPSAtMjcxNzMzODc5O1xuICB2YXIgYyA9IC0xNzMyNTg0MTk0O1xuICB2YXIgZCA9IDI3MTczMzg3ODtcblxuICBmb3IgKGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICBvbGRhID0gYTtcbiAgICBvbGRiID0gYjtcbiAgICBvbGRjID0gYztcbiAgICBvbGRkID0gZDtcbiAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpXSwgNywgLTY4MDg3NjkzNik7XG4gICAgZCA9IG1kNWZmKGQsIGEsIGIsIGMsIHhbaSArIDFdLCAxMiwgLTM4OTU2NDU4Nik7XG4gICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDJdLCAxNywgNjA2MTA1ODE5KTtcbiAgICBiID0gbWQ1ZmYoYiwgYywgZCwgYSwgeFtpICsgM10sIDIyLCAtMTA0NDUyNTMzMCk7XG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaSArIDRdLCA3LCAtMTc2NDE4ODk3KTtcbiAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgNV0sIDEyLCAxMjAwMDgwNDI2KTtcbiAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgNl0sIDE3LCAtMTQ3MzIzMTM0MSk7XG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDddLCAyMiwgLTQ1NzA1OTgzKTtcbiAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpICsgOF0sIDcsIDE3NzAwMzU0MTYpO1xuICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyA5XSwgMTIsIC0xOTU4NDE0NDE3KTtcbiAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgMTBdLCAxNywgLTQyMDYzKTtcbiAgICBiID0gbWQ1ZmYoYiwgYywgZCwgYSwgeFtpICsgMTFdLCAyMiwgLTE5OTA0MDQxNjIpO1xuICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2kgKyAxMl0sIDcsIDE4MDQ2MDM2ODIpO1xuICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyAxM10sIDEyLCAtNDAzNDExMDEpO1xuICAgIGMgPSBtZDVmZihjLCBkLCBhLCBiLCB4W2kgKyAxNF0sIDE3LCAtMTUwMjAwMjI5MCk7XG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDE1XSwgMjIsIDEyMzY1MzUzMjkpO1xuICAgIGEgPSBtZDVnZyhhLCBiLCBjLCBkLCB4W2kgKyAxXSwgNSwgLTE2NTc5NjUxMCk7XG4gICAgZCA9IG1kNWdnKGQsIGEsIGIsIGMsIHhbaSArIDZdLCA5LCAtMTA2OTUwMTYzMik7XG4gICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDExXSwgMTQsIDY0MzcxNzcxMyk7XG4gICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaV0sIDIwLCAtMzczODk3MzAyKTtcbiAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgNV0sIDUsIC03MDE1NTg2OTEpO1xuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyAxMF0sIDksIDM4MDE2MDgzKTtcbiAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgMTVdLCAxNCwgLTY2MDQ3ODMzNSk7XG4gICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaSArIDRdLCAyMCwgLTQwNTUzNzg0OCk7XG4gICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDldLCA1LCA1Njg0NDY0MzgpO1xuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyAxNF0sIDksIC0xMDE5ODAzNjkwKTtcbiAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgM10sIDE0LCAtMTg3MzYzOTYxKTtcbiAgICBiID0gbWQ1Z2coYiwgYywgZCwgYSwgeFtpICsgOF0sIDIwLCAxMTYzNTMxNTAxKTtcbiAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgMTNdLCA1LCAtMTQ0NDY4MTQ2Nyk7XG4gICAgZCA9IG1kNWdnKGQsIGEsIGIsIGMsIHhbaSArIDJdLCA5LCAtNTE0MDM3ODQpO1xuICAgIGMgPSBtZDVnZyhjLCBkLCBhLCBiLCB4W2kgKyA3XSwgMTQsIDE3MzUzMjg0NzMpO1xuICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2kgKyAxMl0sIDIwLCAtMTkyNjYwNzczNCk7XG4gICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDVdLCA0LCAtMzc4NTU4KTtcbiAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpICsgOF0sIDExLCAtMjAyMjU3NDQ2Myk7XG4gICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDExXSwgMTYsIDE4MzkwMzA1NjIpO1xuICAgIGIgPSBtZDVoaChiLCBjLCBkLCBhLCB4W2kgKyAxNF0sIDIzLCAtMzUzMDk1NTYpO1xuICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyAxXSwgNCwgLTE1MzA5OTIwNjApO1xuICAgIGQgPSBtZDVoaChkLCBhLCBiLCBjLCB4W2kgKyA0XSwgMTEsIDEyNzI4OTMzNTMpO1xuICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyA3XSwgMTYsIC0xNTU0OTc2MzIpO1xuICAgIGIgPSBtZDVoaChiLCBjLCBkLCBhLCB4W2kgKyAxMF0sIDIzLCAtMTA5NDczMDY0MCk7XG4gICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDEzXSwgNCwgNjgxMjc5MTc0KTtcbiAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpXSwgMTEsIC0zNTg1MzcyMjIpO1xuICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyAzXSwgMTYsIC03MjI1MjE5NzkpO1xuICAgIGIgPSBtZDVoaChiLCBjLCBkLCBhLCB4W2kgKyA2XSwgMjMsIDc2MDI5MTg5KTtcbiAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgOV0sIDQsIC02NDAzNjQ0ODcpO1xuICAgIGQgPSBtZDVoaChkLCBhLCBiLCBjLCB4W2kgKyAxMl0sIDExLCAtNDIxODE1ODM1KTtcbiAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgMTVdLCAxNiwgNTMwNzQyNTIwKTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgMl0sIDIzLCAtOTk1MzM4NjUxKTtcbiAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpXSwgNiwgLTE5ODYzMDg0NCk7XG4gICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDddLCAxMCwgMTEyNjg5MTQxNSk7XG4gICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDE0XSwgMTUsIC0xNDE2MzU0OTA1KTtcbiAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgNV0sIDIxLCAtNTc0MzQwNTUpO1xuICAgIGEgPSBtZDVpaShhLCBiLCBjLCBkLCB4W2kgKyAxMl0sIDYsIDE3MDA0ODU1NzEpO1xuICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyAzXSwgMTAsIC0xODk0OTg2NjA2KTtcbiAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgMTBdLCAxNSwgLTEwNTE1MjMpO1xuICAgIGIgPSBtZDVpaShiLCBjLCBkLCBhLCB4W2kgKyAxXSwgMjEsIC0yMDU0OTIyNzk5KTtcbiAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpICsgOF0sIDYsIDE4NzMzMTMzNTkpO1xuICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyAxNV0sIDEwLCAtMzA2MTE3NDQpO1xuICAgIGMgPSBtZDVpaShjLCBkLCBhLCBiLCB4W2kgKyA2XSwgMTUsIC0xNTYwMTk4MzgwKTtcbiAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgMTNdLCAyMSwgMTMwOTE1MTY0OSk7XG4gICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaSArIDRdLCA2LCAtMTQ1NTIzMDcwKTtcbiAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgMTFdLCAxMCwgLTExMjAyMTAzNzkpO1xuICAgIGMgPSBtZDVpaShjLCBkLCBhLCBiLCB4W2kgKyAyXSwgMTUsIDcxODc4NzI1OSk7XG4gICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDldLCAyMSwgLTM0MzQ4NTU1MSk7XG4gICAgYSA9IHNhZmVBZGQoYSwgb2xkYSk7XG4gICAgYiA9IHNhZmVBZGQoYiwgb2xkYik7XG4gICAgYyA9IHNhZmVBZGQoYywgb2xkYyk7XG4gICAgZCA9IHNhZmVBZGQoZCwgb2xkZCk7XG4gIH1cblxuICByZXR1cm4gW2EsIGIsIGMsIGRdO1xufVxuLypcbiAqIENvbnZlcnQgYW4gYXJyYXkgYnl0ZXMgdG8gYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3Jkc1xuICogQ2hhcmFjdGVycyA+MjU1IGhhdmUgdGhlaXIgaGlnaC1ieXRlIHNpbGVudGx5IGlnbm9yZWQuXG4gKi9cblxuXG5mdW5jdGlvbiBieXRlc1RvV29yZHMoaW5wdXQpIHtcbiAgdmFyIGk7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgb3V0cHV0WyhpbnB1dC5sZW5ndGggPj4gMikgLSAxXSA9IHVuZGVmaW5lZDtcblxuICBmb3IgKGkgPSAwOyBpIDwgb3V0cHV0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgb3V0cHV0W2ldID0gMDtcbiAgfVxuXG4gIHZhciBsZW5ndGg4ID0gaW5wdXQubGVuZ3RoICogODtcblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoODsgaSArPSA4KSB7XG4gICAgb3V0cHV0W2kgPj4gNV0gfD0gKGlucHV0W2kgLyA4XSAmIDB4ZmYpIDw8IGkgJSAzMjtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG4vKlxuICogQWRkIGludGVnZXJzLCB3cmFwcGluZyBhdCAyXjMyLiBUaGlzIHVzZXMgMTYtYml0IG9wZXJhdGlvbnMgaW50ZXJuYWxseVxuICogdG8gd29yayBhcm91bmQgYnVncyBpbiBzb21lIEpTIGludGVycHJldGVycy5cbiAqL1xuXG5cbmZ1bmN0aW9uIHNhZmVBZGQoeCwgeSkge1xuICB2YXIgbHN3ID0gKHggJiAweGZmZmYpICsgKHkgJiAweGZmZmYpO1xuICB2YXIgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XG4gIHJldHVybiBtc3cgPDwgMTYgfCBsc3cgJiAweGZmZmY7XG59XG4vKlxuICogQml0d2lzZSByb3RhdGUgYSAzMi1iaXQgbnVtYmVyIHRvIHRoZSBsZWZ0LlxuICovXG5cblxuZnVuY3Rpb24gYml0Um90YXRlTGVmdChudW0sIGNudCkge1xuICByZXR1cm4gbnVtIDw8IGNudCB8IG51bSA+Pj4gMzIgLSBjbnQ7XG59XG4vKlxuICogVGhlc2UgZnVuY3Rpb25zIGltcGxlbWVudCB0aGUgZm91ciBiYXNpYyBvcGVyYXRpb25zIHRoZSBhbGdvcml0aG0gdXNlcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIG1kNWNtbihxLCBhLCBiLCB4LCBzLCB0KSB7XG4gIHJldHVybiBzYWZlQWRkKGJpdFJvdGF0ZUxlZnQoc2FmZUFkZChzYWZlQWRkKGEsIHEpLCBzYWZlQWRkKHgsIHQpKSwgcyksIGIpO1xufVxuXG5mdW5jdGlvbiBtZDVmZihhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYiAmIGMgfCB+YiAmIGQsIGEsIGIsIHgsIHMsIHQpO1xufVxuXG5mdW5jdGlvbiBtZDVnZyhhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYiAmIGQgfCBjICYgfmQsIGEsIGIsIHgsIHMsIHQpO1xufVxuXG5mdW5jdGlvbiBtZDVoaChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYiBeIGMgXiBkLCBhLCBiLCB4LCBzLCB0KTtcbn1cblxuZnVuY3Rpb24gbWQ1aWkoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICByZXR1cm4gbWQ1Y21uKGMgXiAoYiB8IH5kKSwgYSwgYiwgeCwgcywgdCk7XG59XG5cbnZhciBfZGVmYXVsdCA9IG1kNTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBybmc7XG4vLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiBJbiB0aGUgYnJvd3NlciB3ZSB0aGVyZWZvcmVcbi8vIHJlcXVpcmUgdGhlIGNyeXB0byBBUEkgYW5kIGRvIG5vdCBzdXBwb3J0IGJ1aWx0LWluIGZhbGxiYWNrIHRvIGxvd2VyIHF1YWxpdHkgcmFuZG9tIG51bWJlclxuLy8gZ2VuZXJhdG9ycyAobGlrZSBNYXRoLnJhbmRvbSgpKS5cbi8vIGdldFJhbmRvbVZhbHVlcyBuZWVkcyB0byBiZSBpbnZva2VkIGluIGEgY29udGV4dCB3aGVyZSBcInRoaXNcIiBpcyBhIENyeXB0byBpbXBsZW1lbnRhdGlvbi4gQWxzbyxcbi8vIGZpbmQgdGhlIGNvbXBsZXRlIGltcGxlbWVudGF0aW9uIG9mIGNyeXB0byAobXNDcnlwdG8pIG9uIElFMTEuXG52YXIgZ2V0UmFuZG9tVmFsdWVzID0gdHlwZW9mIGNyeXB0byAhPSAndW5kZWZpbmVkJyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChjcnlwdG8pIHx8IHR5cGVvZiBtc0NyeXB0byAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09ICdmdW5jdGlvbicgJiYgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQobXNDcnlwdG8pO1xudmFyIHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbmZ1bmN0aW9uIHJuZygpIHtcbiAgaWYgKCFnZXRSYW5kb21WYWx1ZXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMoKSBub3Qgc3VwcG9ydGVkLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkI2dldHJhbmRvbXZhbHVlcy1ub3Qtc3VwcG9ydGVkJyk7XG4gIH1cblxuICByZXR1cm4gZ2V0UmFuZG9tVmFsdWVzKHJuZHM4KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbi8vIEFkYXB0ZWQgZnJvbSBDaHJpcyBWZW5lc3MnIFNIQTEgY29kZSBhdFxuLy8gaHR0cDovL3d3dy5tb3ZhYmxlLXR5cGUuY28udWsvc2NyaXB0cy9zaGExLmh0bWxcbmZ1bmN0aW9uIGYocywgeCwgeSwgeikge1xuICBzd2l0Y2ggKHMpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4geCAmIHkgXiB+eCAmIHo7XG5cbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4geCBeIHkgXiB6O1xuXG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIHggJiB5IF4geCAmIHogXiB5ICYgejtcblxuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiB4IF4geSBeIHo7XG4gIH1cbn1cblxuZnVuY3Rpb24gUk9UTCh4LCBuKSB7XG4gIHJldHVybiB4IDw8IG4gfCB4ID4+PiAzMiAtIG47XG59XG5cbmZ1bmN0aW9uIHNoYTEoYnl0ZXMpIHtcbiAgdmFyIEsgPSBbMHg1YTgyNzk5OSwgMHg2ZWQ5ZWJhMSwgMHg4ZjFiYmNkYywgMHhjYTYyYzFkNl07XG4gIHZhciBIID0gWzB4Njc0NTIzMDEsIDB4ZWZjZGFiODksIDB4OThiYWRjZmUsIDB4MTAzMjU0NzYsIDB4YzNkMmUxZjBdO1xuXG4gIGlmICh0eXBlb2YgYnl0ZXMgPT0gJ3N0cmluZycpIHtcbiAgICB2YXIgbXNnID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGJ5dGVzKSk7IC8vIFVURjggZXNjYXBlXG5cbiAgICBieXRlcyA9IG5ldyBBcnJheShtc2cubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKSBieXRlc1tpXSA9IG1zZy5jaGFyQ29kZUF0KGkpO1xuICB9XG5cbiAgYnl0ZXMucHVzaCgweDgwKTtcbiAgdmFyIGwgPSBieXRlcy5sZW5ndGggLyA0ICsgMjtcbiAgdmFyIE4gPSBNYXRoLmNlaWwobCAvIDE2KTtcbiAgdmFyIE0gPSBuZXcgQXJyYXkoTik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICBNW2ldID0gbmV3IEFycmF5KDE2KTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgMTY7IGorKykge1xuICAgICAgTVtpXVtqXSA9IGJ5dGVzW2kgKiA2NCArIGogKiA0XSA8PCAyNCB8IGJ5dGVzW2kgKiA2NCArIGogKiA0ICsgMV0gPDwgMTYgfCBieXRlc1tpICogNjQgKyBqICogNCArIDJdIDw8IDggfCBieXRlc1tpICogNjQgKyBqICogNCArIDNdO1xuICAgIH1cbiAgfVxuXG4gIE1bTiAtIDFdWzE0XSA9IChieXRlcy5sZW5ndGggLSAxKSAqIDggLyBNYXRoLnBvdygyLCAzMik7XG4gIE1bTiAtIDFdWzE0XSA9IE1hdGguZmxvb3IoTVtOIC0gMV1bMTRdKTtcbiAgTVtOIC0gMV1bMTVdID0gKGJ5dGVzLmxlbmd0aCAtIDEpICogOCAmIDB4ZmZmZmZmZmY7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICB2YXIgVyA9IG5ldyBBcnJheSg4MCk7XG5cbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IDE2OyB0KyspIFdbdF0gPSBNW2ldW3RdO1xuXG4gICAgZm9yICh2YXIgdCA9IDE2OyB0IDwgODA7IHQrKykge1xuICAgICAgV1t0XSA9IFJPVEwoV1t0IC0gM10gXiBXW3QgLSA4XSBeIFdbdCAtIDE0XSBeIFdbdCAtIDE2XSwgMSk7XG4gICAgfVxuXG4gICAgdmFyIGEgPSBIWzBdO1xuICAgIHZhciBiID0gSFsxXTtcbiAgICB2YXIgYyA9IEhbMl07XG4gICAgdmFyIGQgPSBIWzNdO1xuICAgIHZhciBlID0gSFs0XTtcblxuICAgIGZvciAodmFyIHQgPSAwOyB0IDwgODA7IHQrKykge1xuICAgICAgdmFyIHMgPSBNYXRoLmZsb29yKHQgLyAyMCk7XG4gICAgICB2YXIgVCA9IFJPVEwoYSwgNSkgKyBmKHMsIGIsIGMsIGQpICsgZSArIEtbc10gKyBXW3RdID4+PiAwO1xuICAgICAgZSA9IGQ7XG4gICAgICBkID0gYztcbiAgICAgIGMgPSBST1RMKGIsIDMwKSA+Pj4gMDtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IFQ7XG4gICAgfVxuXG4gICAgSFswXSA9IEhbMF0gKyBhID4+PiAwO1xuICAgIEhbMV0gPSBIWzFdICsgYiA+Pj4gMDtcbiAgICBIWzJdID0gSFsyXSArIGMgPj4+IDA7XG4gICAgSFszXSA9IEhbM10gKyBkID4+PiAwO1xuICAgIEhbNF0gPSBIWzRdICsgZSA+Pj4gMDtcbiAgfVxuXG4gIHJldHVybiBbSFswXSA+PiAyNCAmIDB4ZmYsIEhbMF0gPj4gMTYgJiAweGZmLCBIWzBdID4+IDggJiAweGZmLCBIWzBdICYgMHhmZiwgSFsxXSA+PiAyNCAmIDB4ZmYsIEhbMV0gPj4gMTYgJiAweGZmLCBIWzFdID4+IDggJiAweGZmLCBIWzFdICYgMHhmZiwgSFsyXSA+PiAyNCAmIDB4ZmYsIEhbMl0gPj4gMTYgJiAweGZmLCBIWzJdID4+IDggJiAweGZmLCBIWzJdICYgMHhmZiwgSFszXSA+PiAyNCAmIDB4ZmYsIEhbM10gPj4gMTYgJiAweGZmLCBIWzNdID4+IDggJiAweGZmLCBIWzNdICYgMHhmZiwgSFs0XSA+PiAyNCAmIDB4ZmYsIEhbNF0gPj4gMTYgJiAweGZmLCBIWzRdID4+IDggJiAweGZmLCBIWzRdICYgMHhmZl07XG59XG5cbnZhciBfZGVmYXVsdCA9IHNoYTE7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3JuZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcm5nLmpzXCIpKTtcblxudmFyIF9ieXRlc1RvVXVpZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vYnl0ZXNUb1V1aWQuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyAqKmB2MSgpYCAtIEdlbmVyYXRlIHRpbWUtYmFzZWQgVVVJRCoqXG4vL1xuLy8gSW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL0xpb3NLL1VVSUQuanNcbi8vIGFuZCBodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvdXVpZC5odG1sXG52YXIgX25vZGVJZDtcblxudmFyIF9jbG9ja3NlcTsgLy8gUHJldmlvdXMgdXVpZCBjcmVhdGlvbiB0aW1lXG5cblxudmFyIF9sYXN0TVNlY3MgPSAwO1xudmFyIF9sYXN0TlNlY3MgPSAwOyAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkIGZvciBBUEkgZGV0YWlsc1xuXG5mdW5jdGlvbiB2MShvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcbiAgdmFyIGIgPSBidWYgfHwgW107XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgbm9kZSA9IG9wdGlvbnMubm9kZSB8fCBfbm9kZUlkO1xuICB2YXIgY2xvY2tzZXEgPSBvcHRpb25zLmNsb2Nrc2VxICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsb2Nrc2VxIDogX2Nsb2Nrc2VxOyAvLyBub2RlIGFuZCBjbG9ja3NlcSBuZWVkIHRvIGJlIGluaXRpYWxpemVkIHRvIHJhbmRvbSB2YWx1ZXMgaWYgdGhleSdyZSBub3RcbiAgLy8gc3BlY2lmaWVkLiAgV2UgZG8gdGhpcyBsYXppbHkgdG8gbWluaW1pemUgaXNzdWVzIHJlbGF0ZWQgdG8gaW5zdWZmaWNpZW50XG4gIC8vIHN5c3RlbSBlbnRyb3B5LiAgU2VlICMxODlcblxuICBpZiAobm9kZSA9PSBudWxsIHx8IGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICB2YXIgc2VlZEJ5dGVzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IF9ybmcuZGVmYXVsdCkoKTtcblxuICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjUsIGNyZWF0ZSBhbmQgNDgtYml0IG5vZGUgaWQsICg0NyByYW5kb20gYml0cyArIG11bHRpY2FzdCBiaXQgPSAxKVxuICAgICAgbm9kZSA9IF9ub2RlSWQgPSBbc2VlZEJ5dGVzWzBdIHwgMHgwMSwgc2VlZEJ5dGVzWzFdLCBzZWVkQnl0ZXNbMl0sIHNlZWRCeXRlc1szXSwgc2VlZEJ5dGVzWzRdLCBzZWVkQnl0ZXNbNV1dO1xuICAgIH1cblxuICAgIGlmIChjbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgICAvLyBQZXIgNC4yLjIsIHJhbmRvbWl6ZSAoMTQgYml0KSBjbG9ja3NlcVxuICAgICAgY2xvY2tzZXEgPSBfY2xvY2tzZXEgPSAoc2VlZEJ5dGVzWzZdIDw8IDggfCBzZWVkQnl0ZXNbN10pICYgMHgzZmZmO1xuICAgIH1cbiAgfSAvLyBVVUlEIHRpbWVzdGFtcHMgYXJlIDEwMCBuYW5vLXNlY29uZCB1bml0cyBzaW5jZSB0aGUgR3JlZ29yaWFuIGVwb2NoLFxuICAvLyAoMTU4Mi0xMC0xNSAwMDowMCkuICBKU051bWJlcnMgYXJlbid0IHByZWNpc2UgZW5vdWdoIGZvciB0aGlzLCBzb1xuICAvLyB0aW1lIGlzIGhhbmRsZWQgaW50ZXJuYWxseSBhcyAnbXNlY3MnIChpbnRlZ2VyIG1pbGxpc2Vjb25kcykgYW5kICduc2VjcydcbiAgLy8gKDEwMC1uYW5vc2Vjb25kcyBvZmZzZXQgZnJvbSBtc2Vjcykgc2luY2UgdW5peCBlcG9jaCwgMTk3MC0wMS0wMSAwMDowMC5cblxuXG4gIHZhciBtc2VjcyA9IG9wdGlvbnMubXNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubXNlY3MgOiBuZXcgRGF0ZSgpLmdldFRpbWUoKTsgLy8gUGVyIDQuMi4xLjIsIHVzZSBjb3VudCBvZiB1dWlkJ3MgZ2VuZXJhdGVkIGR1cmluZyB0aGUgY3VycmVudCBjbG9ja1xuICAvLyBjeWNsZSB0byBzaW11bGF0ZSBoaWdoZXIgcmVzb2x1dGlvbiBjbG9ja1xuXG4gIHZhciBuc2VjcyA9IG9wdGlvbnMubnNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubnNlY3MgOiBfbGFzdE5TZWNzICsgMTsgLy8gVGltZSBzaW5jZSBsYXN0IHV1aWQgY3JlYXRpb24gKGluIG1zZWNzKVxuXG4gIHZhciBkdCA9IG1zZWNzIC0gX2xhc3RNU2VjcyArIChuc2VjcyAtIF9sYXN0TlNlY3MpIC8gMTAwMDA7IC8vIFBlciA0LjIuMS4yLCBCdW1wIGNsb2Nrc2VxIG9uIGNsb2NrIHJlZ3Jlc3Npb25cblxuICBpZiAoZHQgPCAwICYmIG9wdGlvbnMuY2xvY2tzZXEgPT09IHVuZGVmaW5lZCkge1xuICAgIGNsb2Nrc2VxID0gY2xvY2tzZXEgKyAxICYgMHgzZmZmO1xuICB9IC8vIFJlc2V0IG5zZWNzIGlmIGNsb2NrIHJlZ3Jlc3NlcyAobmV3IGNsb2Nrc2VxKSBvciB3ZSd2ZSBtb3ZlZCBvbnRvIGEgbmV3XG4gIC8vIHRpbWUgaW50ZXJ2YWxcblxuXG4gIGlmICgoZHQgPCAwIHx8IG1zZWNzID4gX2xhc3RNU2VjcykgJiYgb3B0aW9ucy5uc2VjcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbnNlY3MgPSAwO1xuICB9IC8vIFBlciA0LjIuMS4yIFRocm93IGVycm9yIGlmIHRvbyBtYW55IHV1aWRzIGFyZSByZXF1ZXN0ZWRcblxuXG4gIGlmIChuc2VjcyA+PSAxMDAwMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInV1aWQudjEoKTogQ2FuJ3QgY3JlYXRlIG1vcmUgdGhhbiAxME0gdXVpZHMvc2VjXCIpO1xuICB9XG5cbiAgX2xhc3RNU2VjcyA9IG1zZWNzO1xuICBfbGFzdE5TZWNzID0gbnNlY3M7XG4gIF9jbG9ja3NlcSA9IGNsb2Nrc2VxOyAvLyBQZXIgNC4xLjQgLSBDb252ZXJ0IGZyb20gdW5peCBlcG9jaCB0byBHcmVnb3JpYW4gZXBvY2hcblxuICBtc2VjcyArPSAxMjIxOTI5MjgwMDAwMDsgLy8gYHRpbWVfbG93YFxuXG4gIHZhciB0bCA9ICgobXNlY3MgJiAweGZmZmZmZmYpICogMTAwMDAgKyBuc2VjcykgJSAweDEwMDAwMDAwMDtcbiAgYltpKytdID0gdGwgPj4+IDI0ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDE2ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDggJiAweGZmO1xuICBiW2krK10gPSB0bCAmIDB4ZmY7IC8vIGB0aW1lX21pZGBcblxuICB2YXIgdG1oID0gbXNlY3MgLyAweDEwMDAwMDAwMCAqIDEwMDAwICYgMHhmZmZmZmZmO1xuICBiW2krK10gPSB0bWggPj4+IDggJiAweGZmO1xuICBiW2krK10gPSB0bWggJiAweGZmOyAvLyBgdGltZV9oaWdoX2FuZF92ZXJzaW9uYFxuXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMjQgJiAweGYgfCAweDEwOyAvLyBpbmNsdWRlIHZlcnNpb25cblxuICBiW2krK10gPSB0bWggPj4+IDE2ICYgMHhmZjsgLy8gYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgIChQZXIgNC4yLjIgLSBpbmNsdWRlIHZhcmlhbnQpXG5cbiAgYltpKytdID0gY2xvY2tzZXEgPj4+IDggfCAweDgwOyAvLyBgY2xvY2tfc2VxX2xvd2BcblxuICBiW2krK10gPSBjbG9ja3NlcSAmIDB4ZmY7IC8vIGBub2RlYFxuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwgNjsgKytuKSB7XG4gICAgYltpICsgbl0gPSBub2RlW25dO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZiA/IGJ1ZiA6ICgwLCBfYnl0ZXNUb1V1aWQuZGVmYXVsdCkoYik7XG59XG5cbnZhciBfZGVmYXVsdCA9IHYxO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF92ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92MzUuanNcIikpO1xuXG52YXIgX21kID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9tZDUuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5jb25zdCB2MyA9ICgwLCBfdi5kZWZhdWx0KSgndjMnLCAweDMwLCBfbWQuZGVmYXVsdCk7XG52YXIgX2RlZmF1bHQgPSB2MztcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcbmV4cG9ydHMuVVJMID0gZXhwb3J0cy5ETlMgPSB2b2lkIDA7XG5cbnZhciBfYnl0ZXNUb1V1aWQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2J5dGVzVG9VdWlkLmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gdXVpZFRvQnl0ZXModXVpZCkge1xuICAvLyBOb3RlOiBXZSBhc3N1bWUgd2UncmUgYmVpbmcgcGFzc2VkIGEgdmFsaWQgdXVpZCBzdHJpbmdcbiAgdmFyIGJ5dGVzID0gW107XG4gIHV1aWQucmVwbGFjZSgvW2EtZkEtRjAtOV17Mn0vZywgZnVuY3Rpb24gKGhleCkge1xuICAgIGJ5dGVzLnB1c2gocGFyc2VJbnQoaGV4LCAxNikpO1xuICB9KTtcbiAgcmV0dXJuIGJ5dGVzO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdUb0J5dGVzKHN0cikge1xuICBzdHIgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7IC8vIFVURjggZXNjYXBlXG5cbiAgdmFyIGJ5dGVzID0gbmV3IEFycmF5KHN0ci5sZW5ndGgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgYnl0ZXNbaV0gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgfVxuXG4gIHJldHVybiBieXRlcztcbn1cblxuY29uc3QgRE5TID0gJzZiYTdiODEwLTlkYWQtMTFkMS04MGI0LTAwYzA0ZmQ0MzBjOCc7XG5leHBvcnRzLkROUyA9IEROUztcbmNvbnN0IFVSTCA9ICc2YmE3YjgxMS05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzgnO1xuZXhwb3J0cy5VUkwgPSBVUkw7XG5cbmZ1bmN0aW9uIF9kZWZhdWx0KG5hbWUsIHZlcnNpb24sIGhhc2hmdW5jKSB7XG4gIHZhciBnZW5lcmF0ZVVVSUQgPSBmdW5jdGlvbiAodmFsdWUsIG5hbWVzcGFjZSwgYnVmLCBvZmZzZXQpIHtcbiAgICB2YXIgb2ZmID0gYnVmICYmIG9mZnNldCB8fCAwO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHZhbHVlID0gc3RyaW5nVG9CeXRlcyh2YWx1ZSk7XG4gICAgaWYgKHR5cGVvZiBuYW1lc3BhY2UgPT0gJ3N0cmluZycpIG5hbWVzcGFjZSA9IHV1aWRUb0J5dGVzKG5hbWVzcGFjZSk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkgdGhyb3cgVHlwZUVycm9yKCd2YWx1ZSBtdXN0IGJlIGFuIGFycmF5IG9mIGJ5dGVzJyk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG5hbWVzcGFjZSkgfHwgbmFtZXNwYWNlLmxlbmd0aCAhPT0gMTYpIHRocm93IFR5cGVFcnJvcignbmFtZXNwYWNlIG11c3QgYmUgdXVpZCBzdHJpbmcgb3IgYW4gQXJyYXkgb2YgMTYgYnl0ZSB2YWx1ZXMnKTsgLy8gUGVyIDQuM1xuXG4gICAgdmFyIGJ5dGVzID0gaGFzaGZ1bmMobmFtZXNwYWNlLmNvbmNhdCh2YWx1ZSkpO1xuICAgIGJ5dGVzWzZdID0gYnl0ZXNbNl0gJiAweDBmIHwgdmVyc2lvbjtcbiAgICBieXRlc1s4XSA9IGJ5dGVzWzhdICYgMHgzZiB8IDB4ODA7XG5cbiAgICBpZiAoYnVmKSB7XG4gICAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCAxNjsgKytpZHgpIHtcbiAgICAgICAgYnVmW29mZiArIGlkeF0gPSBieXRlc1tpZHhdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBidWYgfHwgKDAsIF9ieXRlc1RvVXVpZC5kZWZhdWx0KShieXRlcyk7XG4gIH07IC8vIEZ1bmN0aW9uI25hbWUgaXMgbm90IHNldHRhYmxlIG9uIHNvbWUgcGxhdGZvcm1zICgjMjcwKVxuXG5cbiAgdHJ5IHtcbiAgICBnZW5lcmF0ZVVVSUQubmFtZSA9IG5hbWU7XG4gIH0gY2F0Y2ggKGVycikge30gLy8gRm9yIENvbW1vbkpTIGRlZmF1bHQgZXhwb3J0IHN1cHBvcnRcblxuXG4gIGdlbmVyYXRlVVVJRC5ETlMgPSBETlM7XG4gIGdlbmVyYXRlVVVJRC5VUkwgPSBVUkw7XG4gIHJldHVybiBnZW5lcmF0ZVVVSUQ7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfcm5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9ybmcuanNcIikpO1xuXG52YXIgX2J5dGVzVG9VdWlkID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9ieXRlc1RvVXVpZC5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PSAnc3RyaW5nJykge1xuICAgIGJ1ZiA9IG9wdGlvbnMgPT09ICdiaW5hcnknID8gbmV3IEFycmF5KDE2KSA6IG51bGw7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBfcm5nLmRlZmF1bHQpKCk7IC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcblxuXG4gIHJuZHNbNl0gPSBybmRzWzZdICYgMHgwZiB8IDB4NDA7XG4gIHJuZHNbOF0gPSBybmRzWzhdICYgMHgzZiB8IDB4ODA7IC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuXG4gIGlmIChidWYpIHtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgMTY7ICsraWkpIHtcbiAgICAgIGJ1ZltpICsgaWldID0gcm5kc1tpaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZiB8fCAoMCwgX2J5dGVzVG9VdWlkLmRlZmF1bHQpKHJuZHMpO1xufVxuXG52YXIgX2RlZmF1bHQgPSB2NDtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfdiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdjM1LmpzXCIpKTtcblxudmFyIF9zaGEgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3NoYTEuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5jb25zdCB2NSA9ICgwLCBfdi5kZWZhdWx0KSgndjUnLCAweDUwLCBfc2hhLmRlZmF1bHQpO1xudmFyIF9kZWZhdWx0ID0gdjU7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0OyIsIm1vZHVsZS5leHBvcnRzID0gZXh0ZW5kXG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGV4dGVuZCgpIHtcbiAgICB2YXIgdGFyZ2V0ID0ge31cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV1cblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0XG59XG4iXX0=
